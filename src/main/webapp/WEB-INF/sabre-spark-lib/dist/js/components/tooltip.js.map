{"version":3,"sources":["js/dist/components/node_modules/browser-pack/_prelude.js","js/dist/components/js/dist/components/base.js","js/dist/components/js/dist/components/tooltip.js","js/dist/components/js/dist/helpers/dom/add-class.js","js/dist/components/js/dist/helpers/dom/has-class.js","js/dist/components/js/dist/helpers/dom/make-element.js","js/dist/components/js/dist/helpers/dom/offset.js","js/dist/components/js/dist/helpers/dom/parse-attribute.js","js/dist/components/js/dist/helpers/dom/remove-class.js","js/dist/components/js/dist/helpers/dom/toggle-class.js","js/dist/components/js/dist/helpers/position/affix.js","js/dist/components/js/dist/helpers/position/box-position.js","js/dist/components/js/dist/helpers/traversal/has-parent.js","js/dist/components/js/dist/helpers/util/debounce.js","js/dist/components/js/dist/helpers/util/each.js","js/dist/components/js/dist/helpers/util/trim.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"tooltip.js","sourcesContent":["(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _each = require('../helpers/util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * # Base Component\n                                                                                                                                                           * The base class for Spark JS components. This class should never be\n                                                                                                                                                           * instantiated directly.\n                                                                                                                                                           *\n                                                                                                                                                           * @param {Element} el\n                                                                                                                                                           * @param {Object} params\n                                                                                                                                                           *\n                                                                                                                                                           * @module components/base.js\n                                                                                                                                                           */\n\nvar noop = function noop() {};\n\nvar Base = function () {\n\n  /**\n   * Set parameters and cache elements.\n   */\n  function Base(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Base);\n\n    if (params.elRequired && !el) {\n      return;\n    }\n\n    this.setParams(this.defaults || {}, true);\n    this.setParams(params);\n    (this._cacheElements || noop).call(this, el, params);\n    (this._parseParams || noop).call(this);\n  }\n\n  /**\n   * Remove the component from the DOM and prepare for garbage collection by dereferencing values.\n   * @param {Boolean} leaveElement Leave the element intact.\n   */\n\n\n  Base.prototype.remove = function remove(leaveElement) {\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    if (!leaveElement && this.el && this.el.parentNode) {\n      this.el.parentNode.removeChild(this.el);\n    }\n\n    this.unsetParams(this.defaults);\n\n    return this;\n  };\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   * @param {Object} params Optional\n   */\n\n\n  Base.prototype.update = function update(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    (this._cacheElements || noop).call(this, el || this.el, params);\n    (this._parseParams || noop).call(this);\n\n    if (this._addEventListeners) {\n      this._addEventListeners();\n    }\n\n    return this;\n  };\n\n  /**\n   * Set a hash of parameters if they're whitelisted or we're told to force the set.\n   * This is used to set initial values as well as set passed parameters.\n   * @param {Object} params\n   * @param {Boolean} force Force setting even if the param is not whitelisted.\n   */\n\n\n  Base.prototype.setParams = function setParams(params, force) {\n    var _this = this;\n\n    (0, _each2.default)(params, function (k, v) {\n      if (_this._whitelistedParams.indexOf(k) !== -1 || force) {\n        _this[k] = v;\n      }\n    });\n\n    return this;\n  };\n\n  /**\n   * Unset all parameters.\n   * @param {Array|Object} keys\n   * @param {Object} scope The object to unset the params from. Defaults to `this`.\n   */\n\n\n  Base.prototype.unsetParams = function unsetParams(keys, scope) {\n\n    keys = keys instanceof Array ? keys : Object.keys(keys);\n    scope = scope || this;\n    (0, _each2.default)(keys, function (k) {\n      delete scope[k];\n    });\n\n    return this;\n  };\n\n  return Base;\n}();\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nBase.prototype._whitelistedParams = [];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nBase.prototype.defaults = {};\n\nexports.default = Base;\nmodule.exports = exports['default'];\n//# sourceMappingURL=base.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _base = require('./base');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _addClass = require('../helpers/dom/add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _removeClass = require('../helpers/dom/remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nvar _hasClass = require('../helpers/dom/has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _toggleClass = require('../helpers/dom/toggle-class');\n\nvar _toggleClass2 = _interopRequireDefault(_toggleClass);\n\nvar _hasParent = require('../helpers/traversal/has-parent');\n\nvar _hasParent2 = _interopRequireDefault(_hasParent);\n\nvar _parseAttribute = require('../helpers/dom/parse-attribute');\n\nvar _affix = require('../helpers/position/affix');\n\nvar _affix2 = _interopRequireDefault(_affix);\n\nvar _makeElement = require('../helpers/dom/make-element');\n\nvar _makeElement2 = _interopRequireDefault(_makeElement);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * # Tooltip\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Show and hide a tooltip.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @example\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * new Tooltip(el, {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   // Optional. Default anchoring of the content's x and y-axis relative to the button.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   anchorX: 'center', // 'left', 'center', 'right'\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   anchorY: 'center' // 'top', 'middle', 'bottom'\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * });\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module components/popover.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\nvar Tooltip = function (_BaseComponent) {\n  _inherits(Tooltip, _BaseComponent);\n\n  function Tooltip(el) {\n    var _this;\n\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Tooltip);\n\n    params.elRequired = true;\n\n    if (!(_this = _possibleConstructorReturn(this, _BaseComponent.call(this, el, params)), _this)) {\n      return _possibleConstructorReturn(_this);\n    }\n\n    _this._bindEventListenerCallbacks();\n    _this._addEventListeners();\n    return _possibleConstructorReturn(_this);\n  }\n\n  /**\n   * Open.\n   */\n\n\n  Tooltip.prototype.open = function open() {\n\n    if (this.affix) return this;\n\n    this.affix = new _affix2.default({\n      el: this.contentEl,\n      targetEl: this.toggleEl,\n      caretEl: this.caretEl,\n      anchorX: this.anchorX,\n      anchorY: this.anchorY\n    });\n\n    (0, _addClass2.default)(this.contentEl, 'active');\n\n    this.isActive = true;\n    this.toggleEl.setAttribute('aria-expanded', 'true');\n\n    return this;\n  };\n\n  /**\n   * Close.\n   */\n\n\n  Tooltip.prototype.close = function close() {\n\n    if (!this.affix) return this;\n\n    (0, _removeClass2.default)(this.contentEl, 'active');\n    this.el.appendChild(this.contentEl);\n\n    this.affix.remove({ keepEl: true });\n    this.affix = null;\n\n    this.isActive = false;\n    this.toggleEl.setAttribute('aria-expanded', 'false');\n\n    return this;\n  };\n\n  /**\n   * Toggle the open state.\n   */\n\n\n  Tooltip.prototype.toggle = function toggle() {\n    return this[this.isActive ? 'close' : 'open']();\n  };\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   */\n\n\n  Tooltip.prototype.update = function update(el) {\n\n    if (this.affix) this.affix.update();\n\n    this._removeEventListeners();\n    this._cacheElements(el || this.el);\n    this._addEventListeners();\n\n    return this;\n  };\n\n  /**\n   * Close on remove.\n   * @param {Boolean} leaveElement\n   */\n\n\n  Tooltip.prototype.remove = function remove(leaveElement) {\n    this.close();\n    (0, _removeClass2.default)(this.el, 'tooltip-initialized');\n    return _BaseComponent.prototype.remove.call(this, leaveElement);\n  };\n\n  /**\n   * Store a reference to the tabs list, each tab and each panel.\n   * Set which tab is active, or use the first.\n   * @param {Element} el\n   */\n\n\n  Tooltip.prototype._cacheElements = function _cacheElements(el) {\n\n    this.el = el;\n    this.toggleEl = this.el.querySelector('.spark-tooltip__toggle, [data-role=\"toggle\"]') || this.el;\n    this.contentEl = this.contentEl || this.el.querySelector('[class*=\"spark-tooltip__content--\"]') || this._createContentEl();\n    this.caretEl = this.el.querySelector('.spark-tooltip__caret') || this._createCaretEl();\n    this.isActive = (0, _hasClass2.default)(this.toggleEl, 'tooltip-active');\n\n    (0, _addClass2.default)(this.el, 'tooltip-initialized');\n  };\n\n  /**\n   * Parse config values from the element.\n   */\n\n\n  Tooltip.prototype._parseParams = function _parseParams() {\n\n    this.anchorY = this.anchorY !== null ? this.anchorY : (0, _parseAttribute.string)(this.el, 'data-anchor-y', null);\n    this.anchorX = this.anchorX !== null ? this.anchorX : (0, _parseAttribute.string)(this.el, 'data-anchor-x', null);\n\n    // No anchors defined\n    if (!this.anchorY && !this.anchorX) {\n\n      // Left\n      if ((0, _hasClass2.default)(this.contentEl, 'spark-tooltip__content--left')) {\n        this.anchorY = 'middle';\n        this.anchorX = 'left';\n      }\n      // Right\n      else if ((0, _hasClass2.default)(this.contentEl, 'spark-tooltip__content--right')) {\n          this.anchorY = 'middle';\n          this.anchorX = 'right';\n        }\n        // Top\n        else if ((0, _hasClass2.default)(this.contentEl, 'spark-tooltip__content--top')) {\n            this.anchorY = 'top';\n            this.anchorX = 'center';\n          }\n          // Bottom\n          else if ((0, _hasClass2.default)(this.contentEl, 'spark-tooltip__content--bottom')) {\n              this.anchorY = 'bottom';\n              this.anchorX = 'center';\n            }\n    }\n  };\n\n  /**\n   * Update classes for the open or close state.\n   */\n\n\n  Tooltip.prototype._updateAttributes = function _updateAttributes() {\n    (0, _toggleClass2.default)(this.el, 'tooltip-active', this.isActive);\n    (0, _toggleClass2.default)(this.contentEl, 'tooltip-active', this.isActive);\n    (0, _toggleClass2.default)(this.toggleEl, 'active', this.isActive);\n  };\n\n  /**\n   * Create bound versions of event listener callbacks and store them.\n   * Otherwise we can't unbind from these events later because the\n   * function signatures won't match.\n   */\n\n\n  Tooltip.prototype._bindEventListenerCallbacks = function _bindEventListenerCallbacks() {\n    this._onMouseoverBound = this._onMouseover.bind(this);\n    this._onMouseoutBound = this._onMouseout.bind(this);\n    this._onWindowMouseoverBound = this._onWindowMouseover.bind(this);\n    this._onFocusBound = this._onFocus.bind(this);\n    this._onBlurBound = this._onBlur.bind(this);\n  };\n\n  /**\n   * Add event listeners for DOM events.\n   */\n\n\n  Tooltip.prototype._addEventListeners = function _addEventListeners() {\n    this.toggleEl.addEventListener('mouseover', this._onMouseoverBound);\n    this.toggleEl.addEventListener('mouseout', this._onMouseoutBound);\n    this.toggleEl.addEventListener('focus', this._onFocusBound);\n    this.toggleEl.addEventListener('blur', this._onBlurBound);\n  };\n\n  /**\n   * Remove event listeners for DOM events..\n   */\n\n\n  Tooltip.prototype._removeEventListeners = function _removeEventListeners() {\n    this.toggleEl.removeEventListener('mouseover', this._onMouseoverBound);\n    this.toggleEl.removeEventListener('mouseout', this._onMouseoutBound);\n    this.toggleEl.removeEventListener('focus', this._onFocusBound);\n    this.toggleEl.removeEventListener('blur', this._onBlurBound);\n  };\n\n  /**\n   * Add window listeners.\n   */\n\n\n  Tooltip.prototype._addWindowEventListeners = function _addWindowEventListeners() {\n    window.addEventListener('mouseover', this._onWindowMouseoverBound);\n  };\n\n  /**\n   * Remove window listeners.\n   */\n\n\n  Tooltip.prototype._removeWindowEventListeners = function _removeWindowEventListeners() {\n    window.removeEventListener('mouseover', this._onWindowMouseoverBound);\n  };\n\n  /**\n   * Create a content element.\n   * @return {Element}\n   */\n\n\n  Tooltip.prototype._createContentEl = function _createContentEl() {\n    return (0, _makeElement2.default)('<div class=\"spark-tooltip__content\"></div>');\n  };\n\n  /**\n   * Create the caret element.\n   * @return {Element}\n   */\n\n\n  Tooltip.prototype._createCaretEl = function _createCaretEl() {\n    return (0, _makeElement2.default)('<div class=\"spark-tooltip__caret\"></div>');\n  };\n\n  /**\n   * Open the tooltip on mouseover.\n   */\n\n\n  Tooltip.prototype._onMouseover = function _onMouseover() {\n    this._addWindowEventListeners();\n    this.open();\n  };\n\n  /**\n   * Close the tooltip on mouseout.\n   */\n\n\n  Tooltip.prototype._onMouseout = function _onMouseout() {\n    this._removeWindowEventListeners();\n    this.close();\n  };\n\n  /**\n   * Open the tooltip on focus.\n   */\n\n\n  Tooltip.prototype._onFocus = function _onFocus() {\n    this._addWindowEventListeners();\n    this.open();\n  };\n\n  /**\n   * Close the tooltip on blur.\n   */\n\n\n  Tooltip.prototype._onBlur = function _onBlur() {\n    this._removeWindowEventListeners();\n    this.close();\n  };\n\n  /**\n   * Close the tooltip if we mouse over another element.\n   * @param {Object} e\n   */\n\n\n  Tooltip.prototype._onWindowMouseover = function _onWindowMouseover(e) {\n    if (e.target === this.el || (0, _hasParent2.default)(e.target, this.el)) return;\n    this._onMouseout();\n  };\n\n  return Tooltip;\n}(_base2.default);\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nTooltip.prototype._whitelistedParams = ['anchorY', 'anchorX', 'contentEl', 'toggleEl'];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nTooltip.prototype.defaults = {\n  el: null,\n  toggleEl: null,\n  contentEl: null,\n  caretEl: null,\n  isActive: false,\n  affix: null,\n  anchorY: null,\n  anchorX: null,\n  _onMouseoverBound: null,\n  _onMouseoutBound: null,\n  _onFocusBound: null,\n  _onBlurBound: null,\n  _onWindowMouseoverBound: null\n};\n\nexports.default = Tooltip;\nmodule.exports = exports['default'];\n//# sourceMappingURL=tooltip.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * # Add Class\n * Add a class on an element.\n *\n * @param {Element|Array} el An element or array of elements to update.\n * @param {String} name\n * @return {Element}\n *\n * @module helpers/dom/add-class.js\n */\n\nvar ws = /\\s+/;\nvar cleanup = /\\s{2,}/g;\n\nfunction addClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) {\n      el.classList.add(name[0]);\n    }\n    return el;\n  }\n\n  var toAdd = [];\n  var i = 0;\n  var l = name.length;\n  var item = void 0;\n  var clsName = typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '';\n\n  // see if we have anything to add\n  for (; i < l; i++) {\n    item = name[i];\n    if (item && !(0, _hasClass2.default)(clsName, item)) {\n      toAdd.push(item);\n    }\n  }\n\n  if (toAdd.length) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = addClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=add-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * # Has Class\n * See if an element has a class.\n *\n * @param {Element|String} el\n * @param {String} name\n * @return {Boolean}\n *\n * @module helpers/dom/has-class.js\n */\nfunction hasClass(el, name) {\n  var cName = ((typeof el === 'undefined' ? 'undefined' : _typeof(el)) === 'object' ? el.className || el.getAttribute && el.getAttribute('class') || '' : el || '').replace(/[\\t\\r\\n\\f]/g, ' ');\n  return (' ' + cName + ' ').indexOf(' ' + name + ' ') !== -1;\n}\n\nexports.default = hasClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=has-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (html) {\n\n  if (!html) {\n    throw new Error('Cannot create element with no HTML!');\n  }\n\n  var el = document.createElement('div');\n  el.innerHTML = html;\n  var el2 = el.children[0];\n  el2.parentNode.removeChild(el2);\n  return el2;\n};\n\nmodule.exports = exports['default']; /**\n                                      * # Make Element\n                                      * Make en element using a string of HTML.\n                                      *\n                                      * @example\n                                      * makeElement('<div></div>');\n                                      *\n                                      * @module helpers/make-element.js\n                                      *\n                                      * @param {String} html\n                                      * @return {Element}\n                                      */\n//# sourceMappingURL=make-element.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Offset Position\n * Get the offset position of the element.\n *\n * @param {Element} el\n * @param {Boolean} viewPortOffset The offset relative to the viewport, not page.\n * @return {Object}\n *\n * @module helpers/dom/offset.js\n */\nfunction offset(el, viewPortOffset) {\n\n  var rect = {\n    top: 0,\n    left: 0\n  };\n\n  // Native implementation\n  if (el.getBoundingClientRect) {\n\n    var bounding = el.getBoundingClientRect();\n    rect.left = bounding.left;\n    rect.top = bounding.top;\n\n    if (!viewPortOffset) {\n      rect.left += typeof window.scrollX !== 'undefined' ? window.scrollX : window.pageXOffset;\n      rect.top += typeof window.scrollY !== 'undefined' ? window.scrollY : window.pageYOffset;\n    }\n  } else {\n    var x = 0,\n        y = 0;\n    do {\n      x += el.offsetLeft - (!viewPortOffset ? el.scrollLeft : 0);\n      y += el.offsetTop - (!viewPortOffset ? el.scrollTop : 0);\n    } while (el = el.offsetParent);\n\n    rect.left = x;\n    rect.top = y;\n  }\n\n  return rect;\n}\n\nexports.default = offset;\nmodule.exports = exports['default'];\n//# sourceMappingURL=offset.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Parse DOM attributes\n * Given an element and an attribute name, parse that attribute\n * if it exists or return a default.\n *\n * @module helpers/dom/parse-attribute.js\n */\n\n/**\n * Get the boolean value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction boolean(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return val === 'true' || val === '' ? true : false;\n}\n\n/**\n * Get the numeric value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction number(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return parseInt(val, 10);\n}\n\n/**\n * Get the boolean value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction string(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return val;\n}\n\nexports.boolean = boolean;\nexports.number = number;\nexports.string = string;\n//# sourceMappingURL=parse-attribute.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ws = /\\s+/; /**\n                 * # Remove Class\n                 * Remove a class on an element.\n                 *\n                 * @param {Element|Array} el An element or array of elements to update.\n                 * @param {String} name\n                 * @return {Element}\n                 *\n                 * @module helpers/dom/remove-class.js\n                 */\n\nvar cleanup = /\\s{2,}/g;\n\nfunction removeClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) el.classList.remove(name[0]);\n    return el;\n  }\n\n  // store two copies\n  var clsName = ' ' + (typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '') + ' ';\n  var result = clsName;\n  var current = void 0;\n  var start = void 0;\n  for (var i = 0, l = name.length; i < l; i++) {\n    current = name[i];\n    start = current ? result.indexOf(' ' + current + ' ') : -1;\n    if (start !== -1) {\n      start += 1;\n      result = result.slice(0, start) + result.slice(start + current.length);\n    }\n  }\n\n  // only write if modified\n  if (clsName !== result) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)(result.replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)(result.replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = removeClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=remove-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _addClass = require('./add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _removeClass = require('./remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toggleClass(el, name, enable) {\n\n  if (!el) {\n    return;\n  }\n\n  // If we're passed an array, toggle the class on each.\n  if (el instanceof NodeList || el instanceof Array) {\n\n    for (var i = 0, len = el.length; i < len; i++) {\n      toggleClass(el[i], name, enable);\n    }\n\n    return;\n  }\n\n  var action = void 0;\n  if (enable !== undefined) {\n    enable = typeof enable === 'function' ? enable.call(null, el) : enable;\n    action = enable ? 'add' : 'remove';\n  } else {\n    action = (0, _hasClass2.default)(el, name) ? 'remove' : 'add';\n  }\n\n  return (action === 'add' ? _addClass2.default : _removeClass2.default)(el, name);\n} /**\n   * # Toggle Class\n   * Toggle a class on an element given a condition.\n   *\n   * @param {Element|Array} el An element or array of elements to update.\n   * @param {String} name\n   * @param {Boolean} enable\n   * @return {Element}\n   *\n   * @module  helpers/dom/toggle-class.js\n   */\n\nexports.default = toggleClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=toggle-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _offset2 = require('../dom/offset');\n\nvar _offset3 = _interopRequireDefault(_offset2);\n\nvar _boxPosition = require('./box-position');\n\nvar _boxPosition2 = _interopRequireDefault(_boxPosition);\n\nvar _debounce = require('../util/debounce');\n\nvar _debounce2 = _interopRequireDefault(_debounce);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * # Affix\n                                                                                                                                                           * Affix one element to another.\n                                                                                                                                                           *\n                                                                                                                                                           * @example\n                                                                                                                                                           * new Affix({\n                                                                                                                                                           *   el: el,\n                                                                                                                                                           *   targetEl: el2,\n                                                                                                                                                           *   caretEl: el3,\n                                                                                                                                                           *   anchorY: 'top', // 'middle', 'bottom'\n                                                                                                                                                           *   anchorX: 'left', // 'center', 'right'\n                                                                                                                                                           * })\n                                                                                                                                                           *\n                                                                                                                                                           * @module helpers/position/affix.js\n                                                                                                                                                           */\n\nvar Affix = function () {\n\n  /**\n   * Store the reference elements and position.\n   * @param  {Object} params\n   */\n  function Affix() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Affix);\n\n    this.el = params.el;\n    this.targetEl = params.targetEl;\n    this.caretEl = params.caretEl;\n    this.anchorY = params.anchorY || 'top';\n    this.anchorX = params.anchorX || 'center';\n    this.isFixed = params.isFixed || false;\n\n    this._addEventListeners();\n    this._insertEl();\n    this._setPosition();\n    this._updateDebounced = (0, _debounce2.default)(this.update.bind(this), 500);\n  }\n\n  /**\n   * Stop listening and clean up event listeners\n   * @param {Object} params Optional\n   * @return {Object} this\n   */\n\n\n  Affix.prototype.remove = function remove() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!params.keepEl) this._removeEl();\n    this._removeEventListeners();\n    return this;\n  };\n\n  /**\n   * Update the position.\n   * @return {Object} this\n   */\n\n\n  Affix.prototype.update = function update() {\n    this._setPosition();\n    return this;\n  };\n\n  /**\n   * Listen for window resizes to update the position.\n   */\n\n\n  Affix.prototype._addEventListeners = function _addEventListeners() {\n    this._onResizeBound = this._onResize.bind(this);\n    this._onScrollBound = this._onScroll.bind(this);\n    window.addEventListener('resize', this._onResizeBound);\n    window.addEventListener('scroll', this._onScrollBound);\n  };\n\n  /**\n   * Remove event listeners\n   */\n\n\n  Affix.prototype._removeEventListeners = function _removeEventListeners() {\n    window.removeEventListener('resize', this._onResizeBound);\n    window.removeEventListener('scroll', this._onScrollBound);\n  };\n\n  /**\n   * Insert the element into the DOM.\n   */\n\n\n  Affix.prototype._insertEl = function _insertEl() {\n    this.el.setAttribute('data-affixed', '');\n    this._getRootEl().appendChild(this.el);\n  };\n\n  /**\n   * Remove the element from the DOM.\n   */\n\n\n  Affix.prototype._removeEl = function _removeEl() {\n    this.el.parentNode.removeChild(this.el);\n    this.el.removeAttribute('data-affixed');\n  };\n\n  /**\n   * Set the position of the target element.\n   */\n\n\n  Affix.prototype._setPosition = function _setPosition() {\n\n    // Fixed position\n    this.el.style.setProperty('position', this.isFixed ? 'fixed' : 'absolute', 'important');\n\n    // Target element properties\n\n    var _offset = (0, _offset3.default)(this.targetEl, this.isFixed),\n        targetTop = _offset.top,\n        targetLeft = _offset.left;\n\n    var targetWidth = this.targetEl.offsetWidth;\n    var targetHeight = this.targetEl.offsetHeight;\n\n    // Element to affix properties\n    var elWidth = this.el.offsetWidth;\n    var elHeight = this.el.offsetHeight;\n\n    // Maxes\n    var docHeight = document.documentElement.offsetHeight;\n    var docWidth = document.documentElement.offsetWidth;\n\n    // Get the values\n\n    var _calculatePosition2 = this._calculatePosition({\n      anchorX: this.anchorX,\n      anchorY: this.anchorY,\n      targetTop: targetTop,\n      targetLeft: targetLeft,\n      elHeight: elHeight,\n      elWidth: elWidth,\n      targetHeight: targetHeight,\n      targetWidth: targetWidth,\n      minX: 0,\n      minY: 0,\n      maxX: docWidth - elWidth,\n      maxY: Math.max(docHeight - elHeight, 0)\n    }),\n        elTop = _calculatePosition2.elTop,\n        elLeft = _calculatePosition2.elLeft;\n\n    // Position the caret\n\n\n    var _positionCaret2 = this._positionCaret({\n      elLeft: elLeft,\n      elTop: elTop,\n      elWidth: elWidth,\n      elHeight: elHeight,\n      targetHeight: targetHeight,\n      targetWidth: targetWidth,\n      targetLeft: targetLeft,\n      targetTop: targetTop\n    }),\n        extraLeft = _positionCaret2.extraLeft,\n        extraTop = _positionCaret2.extraTop;\n\n    // Set the position\n\n\n    this.el.style.left = elLeft + extraLeft + 'px';\n    this.el.style.top = elTop + extraTop + 'px';\n  };\n\n  /**\n   * Get the proper top position for an anchor direction.\n   * @param  {Object} p\n   * @return {Object}\n   */\n\n\n  Affix.prototype._calculatePosition = function _calculatePosition(p) {\n\n    // Keep track of what we're trying to do here, so on subsequent, nested calls to this\n    // method we can see what has already been tried.\n    p.previousAttempts = (p.previousAttempts || 0) + 1;\n    p.previousChecks = p.previousChecks || [];\n\n    var finalCheck = p.previousAttempts > 3;\n    var top = void 0;\n    var left = void 0;\n\n    // Y-axis check\n    switch (p.anchorY) {\n      case 'bottom':\n        top = p.targetTop + p.targetHeight;\n        break;\n      case 'middle':\n        top = p.targetTop - (p.elHeight - p.targetHeight) / 2;\n        break;\n      default:\n        top = p.targetTop - p.elHeight;\n        break;\n    }\n\n    // Under min\n    if (top < p.minY) {\n\n      if (!finalCheck && p.previousChecks.indexOf('overY') === -1) {\n        p.previousChecks.push('underY');\n        p.anchorY = this._getNewAnchorY(true, p.anchorY, p.anchorX);\n        return this._calculatePosition(p);\n      } else {\n        top = p.minY;\n      }\n    }\n\n    // Don't check for being too tall because causing a vertical scroll\n    // bar down is okay and this saves us from some real positioning hell.\n    /*if (top > p.maxY) {\n       if (!finalCheck && p.previousChecks.indexOf('underY') === -1) {\n        p.previousChecks.push('overY');\n        p.anchorY = this._getNewAnchorY(false, p.anchorY, p.anchorX);\n        return this._calculatePosition(p);\n      }\n      // On a final check, bottom wins because at least we can scroll\n      else if (!(finalCheck && p.anchorY === 'bottom')) {\n        top = p.maxY;\n      }\n    }*/\n\n    // X-axis check\n    switch (p.anchorX) {\n      case 'right':\n        left = p.targetLeft + (p.anchorY !== 'middle' && !p.isOverlapping ? 0 : p.targetWidth);\n        break;\n      case 'center':\n        left = p.targetLeft - (p.elWidth - p.targetWidth) / 2;\n        break;\n      default:\n        left = p.targetLeft - p.elWidth + (p.anchorY !== 'middle' ? p.targetWidth : 0);\n        break;\n    }\n\n    // Under min\n    if (left < p.minX) {\n\n      if (!finalCheck && p.previousChecks.indexOf('overX') === -1) {\n        p.previousChecks.push('underX');\n        p.anchorX = this._getNewAnchorX(true, p.anchorX, p.anchorY);\n        return this._calculatePosition(p);\n      } else {\n        left = p.minX;\n      }\n    }\n\n    // Over max\n    if (left > p.maxX) {\n\n      if (!finalCheck && p.previousChecks.indexOf('underX') === -1) {\n        p.previousChecks.push('overX');\n        p.anchorX = this._getNewAnchorX(false, p.anchorX, p.anchorY);\n        return this._calculatePosition(p);\n      } else {\n        left = p.maxX;\n      }\n    }\n\n    // One element is covering another. Try to fix that, but bail out after four tries.\n    if ((0, _boxPosition2.default)({ width: p.elWidth, height: p.elHeight, left: left, top: top }, { width: p.targetWidth, height: p.targetHeight, left: p.targetLeft, top: p.targetTop }) === 'overlap') {\n\n      p.isOverlapping = true;\n\n      // Try Y\n      if (p.repositionY !== false) {\n\n        // Will start undefined, then true, then false. This limits us to entering\n        // this loop twice, once to try moving in each direction.\n        p.repositionY = !p.repositionY;\n\n        // First try to put above, then try to put below.\n        p.anchorY = this._getNewAnchorY(p.repositionY, 'middle', p.anchorX);\n\n        // Give us one more shot at positioning\n        p.previousAttempts--;\n\n        return this._calculatePosition(p);\n      }\n      // Try X\n      else if (p.repositionX !== false) {\n\n          // Will start undefined, then true, then false. This limits us to entering\n          // this loop twice, once to try moving in each direction.\n          p.repositionX = !p.repositionX;\n\n          // First try to put above, then try to put below.\n          p.anchorX = this._getNewAnchorX(p.repositionX, 'center', p.anchorY);\n\n          // Give us one more shot at positioning\n          p.previousAttempts--;\n\n          return this._calculatePosition(p);\n        }\n    }\n\n    return { elTop: top, elLeft: left, anchorX: p.anchorX, anchorY: p.anchorY };\n  };\n\n  /**\n   * Determine the new y-axis anchor\n   * @param  {Boolean} underMin Under the min?\n   * @param  {String} anchorY\n   * @param  {String} anchorX\n   * @return {String}\n   */\n\n\n  Affix.prototype._getNewAnchorY = function _getNewAnchorY(underMin, anchorY, anchorX) {\n\n    // If the x-axis is anchored in the center, skip\n    // trying to anchor to the middle because then we'd\n    // be overlaying the button.\n    if (anchorX === 'center' || anchorY === 'middle') {\n      return underMin ? 'bottom' : 'top';\n    } else {\n      return 'middle';\n    }\n  };\n\n  /**\n   * Determine the new y-axis anchor\n   * @param  {Boolean} underMin Under the min?\n   * @param  {String} anchorY\n   * @param  {String} anchorX\n   * @return {String}\n   */\n\n\n  Affix.prototype._getNewAnchorX = function _getNewAnchorX(underMin, anchorX, anchorY) {\n\n    // If the y-axis is anchored in the center, skip\n    // trying to anchor to the middle because then we'd\n    // be overlaying the button.\n    if (anchorY === 'middle' || anchorX === 'center') {\n      return underMin ? 'left' : 'right';\n    } else {\n      return 'center';\n    }\n  };\n\n  /**\n   * Set the position of the caret.\n   * @param {Object} p\n   * @return {Object}\n   */\n\n\n  Affix.prototype._positionCaret = function _positionCaret() {\n    var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n    if (!this.caretEl) return;\n\n    var caretPosition = (0, _boxPosition2.default)({ width: p.elWidth, height: p.elHeight, left: p.elLeft, top: p.elTop }, { width: p.targetWidth, height: p.targetHeight, left: p.targetLeft, top: p.targetTop });\n\n    var caretDimensions = this.caretEl.getBoundingClientRect();\n    var caretWidth = caretDimensions.width;\n    var caretHeight = caretDimensions.height;\n    var left = Math.min(p.elWidth, Math.max(0, p.targetLeft - p.elLeft + p.targetWidth / 2));\n    var top = Math.min(p.elHeight, Math.max(0, p.targetTop - p.elTop + p.targetHeight / 2));\n\n    this.caretEl.style.left = Math.round(left) + 'px';\n    this.caretEl.style.top = Math.round(top) + 'px';\n\n    var extraLeft = 0;\n    var extraTop = 0;\n\n    this.caretEl.setAttribute('data-position', caretPosition);\n\n    switch (caretPosition) {\n      case 'above':\n        extraTop = -caretWidth / 2;\n        break;\n      case 'below':\n        extraTop = caretWidth / 2;\n        break;\n      case 'left':\n        extraLeft = -caretHeight / 2;\n        break;\n      default:\n        extraLeft = caretHeight / 2;\n        break;\n    }\n\n    return {\n      extraLeft: extraLeft,\n      extraTop: extraTop\n    };\n  };\n\n  /**\n   * Get the root element. Want to check if there's a top-level form for working\n   * with ASP .NET pages.\n   */\n\n\n  Affix.prototype._getRootEl = function _getRootEl() {\n    var form = document.querySelector('body > form');\n    return form && form.getAttribute('data-affixed') === null ? form : document.body;\n  };\n\n  /**\n   * On resize, update the position.\n   */\n\n\n  Affix.prototype._onResize = function _onResize() {\n    this.update();\n  };\n\n  /**\n   * When the window scrolls, ensure the proper position of the popover.\n   */\n\n\n  Affix.prototype._onScroll = function _onScroll() {\n    this._updateDebounced();\n  };\n\n  return Affix;\n}();\n\nexports.default = Affix;\nmodule.exports = exports['default'];\n//# sourceMappingURL=affix.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (a, b) {\n\n  var aXSpan = a.left + a.width;\n  var aYSpan = a.top + a.height;\n  var bXSpan = b.left + b.width;\n  var bYSpan = b.top + b.height;\n\n  if (aXSpan <= b.left) return 'left'; // a is fully left of b\n  if (a.left >= bXSpan) return 'right'; // a is fully right of b\n  if (aYSpan <= b.top) return 'above'; // a is fully above b\n  if (a.top >= bYSpan) return 'below'; // a is fully below b\n\n  return 'overlap'; // boxes overlap\n};\n\nmodule.exports = exports['default']; /**\n                                      * # Box Position\n                                      * How is one element positioned relative to another?\n                                      *\n                                      * @example\n                                      * boxPosition(\n                                      * {width: 100, height: 300, left: 0, top: 0},\n                                      * {width: 200, height: 50, left: 100, top: 40}\n                                      * )\n                                      *\n                                      * @module helpers/position/box-position.js\n                                      *\n                                      * @param {Object} a\n                                      * @param {Object} b\n                                      * @return {String}\n                                      */\n//# sourceMappingURL=box-position.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Has Parent\n * See if an element has another element for a parent.\n *\n * @param {Element} child\n * @param {Element} possibleParent\n * @return {Boolean}\n *\n * @module helpers/traversal/has-parent.js\n */\nfunction hasParent(child, possibleParent) {\n\n  var parent = child.parentNode;\n\n  while (parent) {\n\n    if (parent === possibleParent) {\n      return true;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return false;\n}\n\nexports.default = hasParent;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=has-parent.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Debounce\n * Debounce a function call\n *\n * @param {Function} func\n * @param {Integer} delay\n *\n * @module helpers/util/debounce.js\n */\nfunction debounce(func, delay) {\n\n  var timer = void 0;\n\n  return function () {\n    var args = arguments;\n    if (timer) window.clearTimeout(timer);\n    timer = window.setTimeout(function () {\n      func.apply(this, args);\n    }, delay);\n  };\n}\n\nexports.default = debounce;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=debounce.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Each\n * Apply a callback function to a list of any kind: Array, NodeList, HTMLCollection or Object.\n *\n * @param {Array|NodeList|HTMLCollection|Object} list\n * @param {Function} cb\n *\n * @example\n * each([], callback);\n * each(el.children, callback);\n * each(el.childNodes, callback);\n * each({}, callback);\n *\n * @module helpers/util/each.js\n */\nfunction each(list, cb) {\n\n  if (!list) {\n    return;\n  }\n\n  if (typeof cb !== 'function') {\n    throw new Error('Cannot invoke `each` without a callback!');\n  }\n\n  var i = 0;\n  var len = list.length;\n\n  // Object\n  if (len === undefined) {\n    for (i in list) {\n      if (i !== 'prototype' && list.hasOwnProperty(i)) {\n        cb(i, list[i]);\n      }\n    }\n  }\n  // Array-like\n  else {\n      for (; i < len; i++) {\n        cb(list[i]);\n      }\n    }\n}\n\nexports.default = each;\nmodule.exports = exports['default'];\n//# sourceMappingURL=each.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Trim\n * Trim whitespace on a string.\n *\n * @param {String} str\n *\n * @module helpers/util/trim.js\n */\n\nvar trimRE = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\nfunction trim(str) {\n  return str.replace(trimRE, '');\n}\n\nexports.default = trim;\nmodule.exports = exports['default'];\n//# sourceMappingURL=trim.js.map\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9kaXN0L2NvbXBvbmVudHMvYmFzZS5qcyIsImpzL2Rpc3QvY29tcG9uZW50cy90b29sdGlwLmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS9hZGQtY2xhc3MuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL2hhcy1jbGFzcy5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vbWFrZS1lbGVtZW50LmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS9vZmZzZXQuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL3BhcnNlLWF0dHJpYnV0ZS5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vcmVtb3ZlLWNsYXNzLmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS90b2dnbGUtY2xhc3MuanMiLCJqcy9kaXN0L2hlbHBlcnMvcG9zaXRpb24vYWZmaXguanMiLCJqcy9kaXN0L2hlbHBlcnMvcG9zaXRpb24vYm94LXBvc2l0aW9uLmpzIiwianMvZGlzdC9oZWxwZXJzL3RyYXZlcnNhbC9oYXMtcGFyZW50LmpzIiwianMvZGlzdC9oZWxwZXJzL3V0aWwvZGVib3VuY2UuanMiLCJqcy9kaXN0L2hlbHBlcnMvdXRpbC9lYWNoLmpzIiwianMvZGlzdC9oZWxwZXJzL3V0aWwvdHJpbS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc31yZXR1cm4gZX0pKCkiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZWFjaCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdXRpbC9lYWNoJyk7XG5cbnZhciBfZWFjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIyBCYXNlIENvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoZSBiYXNlIGNsYXNzIGZvciBTcGFyayBKUyBjb21wb25lbnRzLiBUaGlzIGNsYXNzIHNob3VsZCBuZXZlciBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGluc3RhbnRpYXRlZCBkaXJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIGNvbXBvbmVudHMvYmFzZS5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIEJhc2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIFNldCBwYXJhbWV0ZXJzIGFuZCBjYWNoZSBlbGVtZW50cy5cbiAgICovXG4gIGZ1bmN0aW9uIEJhc2UoZWwpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlKTtcblxuICAgIGlmIChwYXJhbXMuZWxSZXF1aXJlZCAmJiAhZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldFBhcmFtcyh0aGlzLmRlZmF1bHRzIHx8IHt9LCB0cnVlKTtcbiAgICB0aGlzLnNldFBhcmFtcyhwYXJhbXMpO1xuICAgICh0aGlzLl9jYWNoZUVsZW1lbnRzIHx8IG5vb3ApLmNhbGwodGhpcywgZWwsIHBhcmFtcyk7XG4gICAgKHRoaXMuX3BhcnNlUGFyYW1zIHx8IG5vb3ApLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBjb21wb25lbnQgZnJvbSB0aGUgRE9NIGFuZCBwcmVwYXJlIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24gYnkgZGVyZWZlcmVuY2luZyB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbGVhdmVFbGVtZW50IExlYXZlIHRoZSBlbGVtZW50IGludGFjdC5cbiAgICovXG5cblxuICBCYXNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUobGVhdmVFbGVtZW50KSB7XG5cbiAgICBpZiAodGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgaWYgKCFsZWF2ZUVsZW1lbnQgJiYgdGhpcy5lbCAmJiB0aGlzLmVsLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgICB9XG5cbiAgICB0aGlzLnVuc2V0UGFyYW1zKHRoaXMuZGVmYXVsdHMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY29tcG9uZW50IHRvIHVzZSBhIG5ldyBlbGVtZW50IG9yIHJlcGFyc2UgZnJvbVxuICAgKiB0aGUgZXhpc3RpbmcgZWxlbWVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBPcHRpb25hbFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIE9wdGlvbmFsXG4gICAqL1xuXG5cbiAgQmFzZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGVsKSB7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cblxuICAgIGlmICh0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycykge1xuICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICAodGhpcy5fY2FjaGVFbGVtZW50cyB8fCBub29wKS5jYWxsKHRoaXMsIGVsIHx8IHRoaXMuZWwsIHBhcmFtcyk7XG4gICAgKHRoaXMuX3BhcnNlUGFyYW1zIHx8IG5vb3ApLmNhbGwodGhpcyk7XG5cbiAgICBpZiAodGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIGhhc2ggb2YgcGFyYW1ldGVycyBpZiB0aGV5J3JlIHdoaXRlbGlzdGVkIG9yIHdlJ3JlIHRvbGQgdG8gZm9yY2UgdGhlIHNldC5cbiAgICogVGhpcyBpcyB1c2VkIHRvIHNldCBpbml0aWFsIHZhbHVlcyBhcyB3ZWxsIGFzIHNldCBwYXNzZWQgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlIEZvcmNlIHNldHRpbmcgZXZlbiBpZiB0aGUgcGFyYW0gaXMgbm90IHdoaXRlbGlzdGVkLlxuICAgKi9cblxuXG4gIEJhc2UucHJvdG90eXBlLnNldFBhcmFtcyA9IGZ1bmN0aW9uIHNldFBhcmFtcyhwYXJhbXMsIGZvcmNlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICgwLCBfZWFjaDIuZGVmYXVsdCkocGFyYW1zLCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgaWYgKF90aGlzLl93aGl0ZWxpc3RlZFBhcmFtcy5pbmRleE9mKGspICE9PSAtMSB8fCBmb3JjZSkge1xuICAgICAgICBfdGhpc1trXSA9IHY7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVW5zZXQgYWxsIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSBUaGUgb2JqZWN0IHRvIHVuc2V0IHRoZSBwYXJhbXMgZnJvbS4gRGVmYXVsdHMgdG8gYHRoaXNgLlxuICAgKi9cblxuXG4gIEJhc2UucHJvdG90eXBlLnVuc2V0UGFyYW1zID0gZnVuY3Rpb24gdW5zZXRQYXJhbXMoa2V5cywgc2NvcGUpIHtcblxuICAgIGtleXMgPSBrZXlzIGluc3RhbmNlb2YgQXJyYXkgPyBrZXlzIDogT2JqZWN0LmtleXMoa2V5cyk7XG4gICAgc2NvcGUgPSBzY29wZSB8fCB0aGlzO1xuICAgICgwLCBfZWFjaDIuZGVmYXVsdCkoa2V5cywgZnVuY3Rpb24gKGspIHtcbiAgICAgIGRlbGV0ZSBzY29wZVtrXTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBCYXNlO1xufSgpO1xuXG4vKipcbiAqIFdoaXRlbGlzdGVkIHBhcmFtZXRlcnMgd2hpY2ggY2FuIGJlIHNldCBvbiBjb25zdHJ1Y3Rpb24uXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cblxuXG5CYXNlLnByb3RvdHlwZS5fd2hpdGVsaXN0ZWRQYXJhbXMgPSBbXTtcblxuLyoqXG4gKiBEZWZhdWx0IHZhbHVlcyBmb3IgaW50ZXJuYWwgcHJvcGVydGllcyB3ZSB3aWxsIGJlIHNldHRpbmcuXG4gKiBUaGVzZSBhcmUgc2V0IG9uIGVhY2ggY29uc3RydWN0aW9uIHNvIHdlIGRvbid0IGxlYWsgcHJvcGVydGllc1xuICogaW50byB0aGUgcHJvdG90eXBlIGNoYWluLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuQmFzZS5wcm90b3R5cGUuZGVmYXVsdHMgPSB7fTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQmFzZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9iYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5cbnZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcblxudmFyIF9hZGRDbGFzcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL2FkZC1jbGFzcycpO1xuXG52YXIgX2FkZENsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FkZENsYXNzKTtcblxudmFyIF9yZW1vdmVDbGFzcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL3JlbW92ZS1jbGFzcycpO1xuXG52YXIgX3JlbW92ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlbW92ZUNsYXNzKTtcblxudmFyIF9oYXNDbGFzcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL2hhcy1jbGFzcycpO1xuXG52YXIgX2hhc0NsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhc0NsYXNzKTtcblxudmFyIF90b2dnbGVDbGFzcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL3RvZ2dsZS1jbGFzcycpO1xuXG52YXIgX3RvZ2dsZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvZ2dsZUNsYXNzKTtcblxudmFyIF9oYXNQYXJlbnQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RyYXZlcnNhbC9oYXMtcGFyZW50Jyk7XG5cbnZhciBfaGFzUGFyZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhc1BhcmVudCk7XG5cbnZhciBfcGFyc2VBdHRyaWJ1dGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbS9wYXJzZS1hdHRyaWJ1dGUnKTtcblxudmFyIF9hZmZpeCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcG9zaXRpb24vYWZmaXgnKTtcblxudmFyIF9hZmZpeDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hZmZpeCk7XG5cbnZhciBfbWFrZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbS9tYWtlLWVsZW1lbnQnKTtcblxudmFyIF9tYWtlRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYWtlRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAjIFRvb2x0aXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNob3cgYW5kIGhpZGUgYSB0b29sdGlwLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBuZXcgVG9vbHRpcChlbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAvLyBPcHRpb25hbC4gRGVmYXVsdCBhbmNob3Jpbmcgb2YgdGhlIGNvbnRlbnQncyB4IGFuZCB5LWF4aXMgcmVsYXRpdmUgdG8gdGhlIGJ1dHRvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgYW5jaG9yWDogJ2NlbnRlcicsIC8vICdsZWZ0JywgJ2NlbnRlcicsICdyaWdodCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgYW5jaG9yWTogJ2NlbnRlcicgLy8gJ3RvcCcsICdtaWRkbGUnLCAnYm90dG9tJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBjb21wb25lbnRzL3BvcG92ZXIuanNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5cbnZhciBUb29sdGlwID0gZnVuY3Rpb24gKF9CYXNlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhUb29sdGlwLCBfQmFzZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVG9vbHRpcChlbCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRvb2x0aXApO1xuXG4gICAgcGFyYW1zLmVsUmVxdWlyZWQgPSB0cnVlO1xuXG4gICAgaWYgKCEoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQmFzZUNvbXBvbmVudC5jYWxsKHRoaXMsIGVsLCBwYXJhbXMpKSwgX3RoaXMpKSB7XG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMpO1xuICAgIH1cblxuICAgIF90aGlzLl9iaW5kRXZlbnRMaXN0ZW5lckNhbGxiYWNrcygpO1xuICAgIF90aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogT3Blbi5cbiAgICovXG5cblxuICBUb29sdGlwLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gb3BlbigpIHtcblxuICAgIGlmICh0aGlzLmFmZml4KSByZXR1cm4gdGhpcztcblxuICAgIHRoaXMuYWZmaXggPSBuZXcgX2FmZml4Mi5kZWZhdWx0KHtcbiAgICAgIGVsOiB0aGlzLmNvbnRlbnRFbCxcbiAgICAgIHRhcmdldEVsOiB0aGlzLnRvZ2dsZUVsLFxuICAgICAgY2FyZXRFbDogdGhpcy5jYXJldEVsLFxuICAgICAgYW5jaG9yWDogdGhpcy5hbmNob3JYLFxuICAgICAgYW5jaG9yWTogdGhpcy5hbmNob3JZXG4gICAgfSk7XG5cbiAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLmNvbnRlbnRFbCwgJ2FjdGl2ZScpO1xuXG4gICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy50b2dnbGVFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsb3NlLlxuICAgKi9cblxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UoKSB7XG5cbiAgICBpZiAoIXRoaXMuYWZmaXgpIHJldHVybiB0aGlzO1xuXG4gICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkodGhpcy5jb250ZW50RWwsICdhY3RpdmUnKTtcbiAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMuY29udGVudEVsKTtcblxuICAgIHRoaXMuYWZmaXgucmVtb3ZlKHsga2VlcEVsOiB0cnVlIH0pO1xuICAgIHRoaXMuYWZmaXggPSBudWxsO1xuXG4gICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMudG9nZ2xlRWwuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVG9nZ2xlIHRoZSBvcGVuIHN0YXRlLlxuICAgKi9cblxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICByZXR1cm4gdGhpc1t0aGlzLmlzQWN0aXZlID8gJ2Nsb3NlJyA6ICdvcGVuJ10oKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjb21wb25lbnQgdG8gdXNlIGEgbmV3IGVsZW1lbnQgb3IgcmVwYXJzZSBmcm9tXG4gICAqIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIE9wdGlvbmFsXG4gICAqL1xuXG5cbiAgVG9vbHRpcC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGVsKSB7XG5cbiAgICBpZiAodGhpcy5hZmZpeCkgdGhpcy5hZmZpeC51cGRhdGUoKTtcblxuICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fY2FjaGVFbGVtZW50cyhlbCB8fCB0aGlzLmVsKTtcbiAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsb3NlIG9uIHJlbW92ZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBsZWF2ZUVsZW1lbnRcbiAgICovXG5cblxuICBUb29sdGlwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUobGVhdmVFbGVtZW50KSB7XG4gICAgdGhpcy5jbG9zZSgpO1xuICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKHRoaXMuZWwsICd0b29sdGlwLWluaXRpYWxpemVkJyk7XG4gICAgcmV0dXJuIF9CYXNlQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLCBsZWF2ZUVsZW1lbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgdGFicyBsaXN0LCBlYWNoIHRhYiBhbmQgZWFjaCBwYW5lbC5cbiAgICogU2V0IHdoaWNoIHRhYiBpcyBhY3RpdmUsIG9yIHVzZSB0aGUgZmlyc3QuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICovXG5cblxuICBUb29sdGlwLnByb3RvdHlwZS5fY2FjaGVFbGVtZW50cyA9IGZ1bmN0aW9uIF9jYWNoZUVsZW1lbnRzKGVsKSB7XG5cbiAgICB0aGlzLmVsID0gZWw7XG4gICAgdGhpcy50b2dnbGVFbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnNwYXJrLXRvb2x0aXBfX3RvZ2dsZSwgW2RhdGEtcm9sZT1cInRvZ2dsZVwiXScpIHx8IHRoaXMuZWw7XG4gICAgdGhpcy5jb250ZW50RWwgPSB0aGlzLmNvbnRlbnRFbCB8fCB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ1tjbGFzcyo9XCJzcGFyay10b29sdGlwX19jb250ZW50LS1cIl0nKSB8fCB0aGlzLl9jcmVhdGVDb250ZW50RWwoKTtcbiAgICB0aGlzLmNhcmV0RWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay10b29sdGlwX19jYXJldCcpIHx8IHRoaXMuX2NyZWF0ZUNhcmV0RWwoKTtcbiAgICB0aGlzLmlzQWN0aXZlID0gKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkodGhpcy50b2dnbGVFbCwgJ3Rvb2x0aXAtYWN0aXZlJyk7XG5cbiAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLmVsLCAndG9vbHRpcC1pbml0aWFsaXplZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBjb25maWcgdmFsdWVzIGZyb20gdGhlIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuX3BhcnNlUGFyYW1zID0gZnVuY3Rpb24gX3BhcnNlUGFyYW1zKCkge1xuXG4gICAgdGhpcy5hbmNob3JZID0gdGhpcy5hbmNob3JZICE9PSBudWxsID8gdGhpcy5hbmNob3JZIDogKDAsIF9wYXJzZUF0dHJpYnV0ZS5zdHJpbmcpKHRoaXMuZWwsICdkYXRhLWFuY2hvci15JywgbnVsbCk7XG4gICAgdGhpcy5hbmNob3JYID0gdGhpcy5hbmNob3JYICE9PSBudWxsID8gdGhpcy5hbmNob3JYIDogKDAsIF9wYXJzZUF0dHJpYnV0ZS5zdHJpbmcpKHRoaXMuZWwsICdkYXRhLWFuY2hvci14JywgbnVsbCk7XG5cbiAgICAvLyBObyBhbmNob3JzIGRlZmluZWRcbiAgICBpZiAoIXRoaXMuYW5jaG9yWSAmJiAhdGhpcy5hbmNob3JYKSB7XG5cbiAgICAgIC8vIExlZnRcbiAgICAgIGlmICgoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KSh0aGlzLmNvbnRlbnRFbCwgJ3NwYXJrLXRvb2x0aXBfX2NvbnRlbnQtLWxlZnQnKSkge1xuICAgICAgICB0aGlzLmFuY2hvclkgPSAnbWlkZGxlJztcbiAgICAgICAgdGhpcy5hbmNob3JYID0gJ2xlZnQnO1xuICAgICAgfVxuICAgICAgLy8gUmlnaHRcbiAgICAgIGVsc2UgaWYgKCgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKHRoaXMuY29udGVudEVsLCAnc3BhcmstdG9vbHRpcF9fY29udGVudC0tcmlnaHQnKSkge1xuICAgICAgICAgIHRoaXMuYW5jaG9yWSA9ICdtaWRkbGUnO1xuICAgICAgICAgIHRoaXMuYW5jaG9yWCA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVG9wXG4gICAgICAgIGVsc2UgaWYgKCgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKHRoaXMuY29udGVudEVsLCAnc3BhcmstdG9vbHRpcF9fY29udGVudC0tdG9wJykpIHtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yWSA9ICd0b3AnO1xuICAgICAgICAgICAgdGhpcy5hbmNob3JYID0gJ2NlbnRlcic7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEJvdHRvbVxuICAgICAgICAgIGVsc2UgaWYgKCgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKHRoaXMuY29udGVudEVsLCAnc3BhcmstdG9vbHRpcF9fY29udGVudC0tYm90dG9tJykpIHtcbiAgICAgICAgICAgICAgdGhpcy5hbmNob3JZID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgIHRoaXMuYW5jaG9yWCA9ICdjZW50ZXInO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGNsYXNzZXMgZm9yIHRoZSBvcGVuIG9yIGNsb3NlIHN0YXRlLlxuICAgKi9cblxuXG4gIFRvb2x0aXAucHJvdG90eXBlLl91cGRhdGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gX3VwZGF0ZUF0dHJpYnV0ZXMoKSB7XG4gICAgKDAsIF90b2dnbGVDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ3Rvb2x0aXAtYWN0aXZlJywgdGhpcy5pc0FjdGl2ZSk7XG4gICAgKDAsIF90b2dnbGVDbGFzczIuZGVmYXVsdCkodGhpcy5jb250ZW50RWwsICd0b29sdGlwLWFjdGl2ZScsIHRoaXMuaXNBY3RpdmUpO1xuICAgICgwLCBfdG9nZ2xlQ2xhc3MyLmRlZmF1bHQpKHRoaXMudG9nZ2xlRWwsICdhY3RpdmUnLCB0aGlzLmlzQWN0aXZlKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGJvdW5kIHZlcnNpb25zIG9mIGV2ZW50IGxpc3RlbmVyIGNhbGxiYWNrcyBhbmQgc3RvcmUgdGhlbS5cbiAgICogT3RoZXJ3aXNlIHdlIGNhbid0IHVuYmluZCBmcm9tIHRoZXNlIGV2ZW50cyBsYXRlciBiZWNhdXNlIHRoZVxuICAgKiBmdW5jdGlvbiBzaWduYXR1cmVzIHdvbid0IG1hdGNoLlxuICAgKi9cblxuXG4gIFRvb2x0aXAucHJvdG90eXBlLl9iaW5kRXZlbnRMaXN0ZW5lckNhbGxiYWNrcyA9IGZ1bmN0aW9uIF9iaW5kRXZlbnRMaXN0ZW5lckNhbGxiYWNrcygpIHtcbiAgICB0aGlzLl9vbk1vdXNlb3ZlckJvdW5kID0gdGhpcy5fb25Nb3VzZW92ZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbk1vdXNlb3V0Qm91bmQgPSB0aGlzLl9vbk1vdXNlb3V0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25XaW5kb3dNb3VzZW92ZXJCb3VuZCA9IHRoaXMuX29uV2luZG93TW91c2VvdmVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Gb2N1c0JvdW5kID0gdGhpcy5fb25Gb2N1cy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQmx1ckJvdW5kID0gdGhpcy5fb25CbHVyLmJpbmQodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBldmVudCBsaXN0ZW5lcnMgZm9yIERPTSBldmVudHMuXG4gICAqL1xuXG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMudG9nZ2xlRWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5fb25Nb3VzZW92ZXJCb3VuZCk7XG4gICAgdGhpcy50b2dnbGVFbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMuX29uTW91c2VvdXRCb3VuZCk7XG4gICAgdGhpcy50b2dnbGVFbC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX29uRm9jdXNCb3VuZCk7XG4gICAgdGhpcy50b2dnbGVFbC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fb25CbHVyQm91bmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGZvciBET00gZXZlbnRzLi5cbiAgICovXG5cblxuICBUb29sdGlwLnByb3RvdHlwZS5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy50b2dnbGVFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLl9vbk1vdXNlb3ZlckJvdW5kKTtcbiAgICB0aGlzLnRvZ2dsZUVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5fb25Nb3VzZW91dEJvdW5kKTtcbiAgICB0aGlzLnRvZ2dsZUVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fb25Gb2N1c0JvdW5kKTtcbiAgICB0aGlzLnRvZ2dsZUVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9vbkJsdXJCb3VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB3aW5kb3cgbGlzdGVuZXJzLlxuICAgKi9cblxuXG4gIFRvb2x0aXAucHJvdG90eXBlLl9hZGRXaW5kb3dFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIF9hZGRXaW5kb3dFdmVudExpc3RlbmVycygpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5fb25XaW5kb3dNb3VzZW92ZXJCb3VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB3aW5kb3cgbGlzdGVuZXJzLlxuICAgKi9cblxuXG4gIFRvb2x0aXAucHJvdG90eXBlLl9yZW1vdmVXaW5kb3dFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZW1vdmVXaW5kb3dFdmVudExpc3RlbmVycygpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5fb25XaW5kb3dNb3VzZW92ZXJCb3VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNvbnRlbnQgZWxlbWVudC5cbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG5cblxuICBUb29sdGlwLnByb3RvdHlwZS5fY3JlYXRlQ29udGVudEVsID0gZnVuY3Rpb24gX2NyZWF0ZUNvbnRlbnRFbCgpIHtcbiAgICByZXR1cm4gKDAsIF9tYWtlRWxlbWVudDIuZGVmYXVsdCkoJzxkaXYgY2xhc3M9XCJzcGFyay10b29sdGlwX19jb250ZW50XCI+PC9kaXY+Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgY2FyZXQgZWxlbWVudC5cbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG5cblxuICBUb29sdGlwLnByb3RvdHlwZS5fY3JlYXRlQ2FyZXRFbCA9IGZ1bmN0aW9uIF9jcmVhdGVDYXJldEVsKCkge1xuICAgIHJldHVybiAoMCwgX21ha2VFbGVtZW50Mi5kZWZhdWx0KSgnPGRpdiBjbGFzcz1cInNwYXJrLXRvb2x0aXBfX2NhcmV0XCI+PC9kaXY+Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE9wZW4gdGhlIHRvb2x0aXAgb24gbW91c2VvdmVyLlxuICAgKi9cblxuXG4gIFRvb2x0aXAucHJvdG90eXBlLl9vbk1vdXNlb3ZlciA9IGZ1bmN0aW9uIF9vbk1vdXNlb3ZlcigpIHtcbiAgICB0aGlzLl9hZGRXaW5kb3dFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMub3BlbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgdG9vbHRpcCBvbiBtb3VzZW91dC5cbiAgICovXG5cblxuICBUb29sdGlwLnByb3RvdHlwZS5fb25Nb3VzZW91dCA9IGZ1bmN0aW9uIF9vbk1vdXNlb3V0KCkge1xuICAgIHRoaXMuX3JlbW92ZVdpbmRvd0V2ZW50TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5jbG9zZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBPcGVuIHRoZSB0b29sdGlwIG9uIGZvY3VzLlxuICAgKi9cblxuXG4gIFRvb2x0aXAucHJvdG90eXBlLl9vbkZvY3VzID0gZnVuY3Rpb24gX29uRm9jdXMoKSB7XG4gICAgdGhpcy5fYWRkV2luZG93RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLm9wZW4oKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xvc2UgdGhlIHRvb2x0aXAgb24gYmx1ci5cbiAgICovXG5cblxuICBUb29sdGlwLnByb3RvdHlwZS5fb25CbHVyID0gZnVuY3Rpb24gX29uQmx1cigpIHtcbiAgICB0aGlzLl9yZW1vdmVXaW5kb3dFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xvc2UgdGhlIHRvb2x0aXAgaWYgd2UgbW91c2Ugb3ZlciBhbm90aGVyIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuX29uV2luZG93TW91c2VvdmVyID0gZnVuY3Rpb24gX29uV2luZG93TW91c2VvdmVyKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IHRoaXMuZWwgfHwgKDAsIF9oYXNQYXJlbnQyLmRlZmF1bHQpKGUudGFyZ2V0LCB0aGlzLmVsKSkgcmV0dXJuO1xuICAgIHRoaXMuX29uTW91c2VvdXQoKTtcbiAgfTtcblxuICByZXR1cm4gVG9vbHRpcDtcbn0oX2Jhc2UyLmRlZmF1bHQpO1xuXG4vKipcbiAqIFdoaXRlbGlzdGVkIHBhcmFtZXRlcnMgd2hpY2ggY2FuIGJlIHNldCBvbiBjb25zdHJ1Y3Rpb24uXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cblxuXG5Ub29sdGlwLnByb3RvdHlwZS5fd2hpdGVsaXN0ZWRQYXJhbXMgPSBbJ2FuY2hvclknLCAnYW5jaG9yWCcsICdjb250ZW50RWwnLCAndG9nZ2xlRWwnXTtcblxuLyoqXG4gKiBEZWZhdWx0IHZhbHVlcyBmb3IgaW50ZXJuYWwgcHJvcGVydGllcyB3ZSB3aWxsIGJlIHNldHRpbmcuXG4gKiBUaGVzZSBhcmUgc2V0IG9uIGVhY2ggY29uc3RydWN0aW9uIHNvIHdlIGRvbid0IGxlYWsgcHJvcGVydGllc1xuICogaW50byB0aGUgcHJvdG90eXBlIGNoYWluLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuVG9vbHRpcC5wcm90b3R5cGUuZGVmYXVsdHMgPSB7XG4gIGVsOiBudWxsLFxuICB0b2dnbGVFbDogbnVsbCxcbiAgY29udGVudEVsOiBudWxsLFxuICBjYXJldEVsOiBudWxsLFxuICBpc0FjdGl2ZTogZmFsc2UsXG4gIGFmZml4OiBudWxsLFxuICBhbmNob3JZOiBudWxsLFxuICBhbmNob3JYOiBudWxsLFxuICBfb25Nb3VzZW92ZXJCb3VuZDogbnVsbCxcbiAgX29uTW91c2VvdXRCb3VuZDogbnVsbCxcbiAgX29uRm9jdXNCb3VuZDogbnVsbCxcbiAgX29uQmx1ckJvdW5kOiBudWxsLFxuICBfb25XaW5kb3dNb3VzZW92ZXJCb3VuZDogbnVsbFxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVG9vbHRpcDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9vbHRpcC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90cmltID0gcmVxdWlyZSgnLi4vdXRpbC90cmltJyk7XG5cbnZhciBfdHJpbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmltKTtcblxudmFyIF9oYXNDbGFzcyA9IHJlcXVpcmUoJy4vaGFzLWNsYXNzJyk7XG5cbnZhciBfaGFzQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzQ2xhc3MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqICMgQWRkIENsYXNzXG4gKiBBZGQgYSBjbGFzcyBvbiBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxBcnJheX0gZWwgQW4gZWxlbWVudCBvciBhcnJheSBvZiBlbGVtZW50cyB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7RWxlbWVudH1cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZG9tL2FkZC1jbGFzcy5qc1xuICovXG5cbnZhciB3cyA9IC9cXHMrLztcbnZhciBjbGVhbnVwID0gL1xcc3syLH0vZztcblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIG5hbWUpIHtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gKDAsIF90cmltMi5kZWZhdWx0KShuYW1lKS5zcGxpdCh3cyk7XG4gIH0gZWxzZSB7XG4gICAgbmFtZSA9IG5hbWUgaW5zdGFuY2VvZiBBcnJheSA/IG5hbWUgOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB9XG5cbiAgLy8gb3B0aW1pemUgZm9yIGJlc3QsIG1vc3QgY29tbW9uIGNhc2VcbiAgaWYgKG5hbWUubGVuZ3RoID09PSAxICYmIGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChuYW1lWzBdKSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKG5hbWVbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICB2YXIgdG9BZGQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IG5hbWUubGVuZ3RoO1xuICB2YXIgaXRlbSA9IHZvaWQgMDtcbiAgdmFyIGNsc05hbWUgPSB0eXBlb2YgZWwuY2xhc3NOYW1lID09PSAnc3RyaW5nJyA/IGVsLmNsYXNzTmFtZSA6IGVsLmdldEF0dHJpYnV0ZSA/IGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSA6ICcnO1xuXG4gIC8vIHNlZSBpZiB3ZSBoYXZlIGFueXRoaW5nIHRvIGFkZFxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGl0ZW0gPSBuYW1lW2ldO1xuICAgIGlmIChpdGVtICYmICEoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KShjbHNOYW1lLCBpdGVtKSkge1xuICAgICAgdG9BZGQucHVzaChpdGVtKTtcbiAgICB9XG4gIH1cblxuICBpZiAodG9BZGQubGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBlbC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbC5jbGFzc05hbWUgPSAoMCwgX3RyaW0yLmRlZmF1bHQpKChjbHNOYW1lICsgJyAnICsgdG9BZGQuam9pbignICcpKS5yZXBsYWNlKGNsZWFudXAsICcgJykpO1xuICAgIH0gZWxzZSBpZiAoZWwuc2V0QXR0cmlidXRlKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKDAsIF90cmltMi5kZWZhdWx0KSgoY2xzTmFtZSArICcgJyArIHRvQWRkLmpvaW4oJyAnKSkucmVwbGFjZShjbGVhbnVwLCAnICcpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBhZGRDbGFzcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkLWNsYXNzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbi8qKlxuICogIyBIYXMgQ2xhc3NcbiAqIFNlZSBpZiBhbiBlbGVtZW50IGhhcyBhIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZG9tL2hhcy1jbGFzcy5qc1xuICovXG5mdW5jdGlvbiBoYXNDbGFzcyhlbCwgbmFtZSkge1xuICB2YXIgY05hbWUgPSAoKHR5cGVvZiBlbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZWwpKSA9PT0gJ29iamVjdCcgPyBlbC5jbGFzc05hbWUgfHwgZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJyA6IGVsIHx8ICcnKS5yZXBsYWNlKC9bXFx0XFxyXFxuXFxmXS9nLCAnICcpO1xuICByZXR1cm4gKCcgJyArIGNOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIG5hbWUgKyAnICcpICE9PSAtMTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gaGFzQ2xhc3M7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhcy1jbGFzcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGh0bWwpIHtcblxuICBpZiAoIWh0bWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgZWxlbWVudCB3aXRoIG5vIEhUTUwhJyk7XG4gIH1cblxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZWwuaW5uZXJIVE1MID0gaHRtbDtcbiAgdmFyIGVsMiA9IGVsLmNoaWxkcmVuWzBdO1xuICBlbDIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbDIpO1xuICByZXR1cm4gZWwyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICMgTWFrZSBFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTWFrZSBlbiBlbGVtZW50IHVzaW5nIGEgc3RyaW5nIG9mIEhUTUwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG1ha2VFbGVtZW50KCc8ZGl2PjwvZGl2PicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBoZWxwZXJzL21ha2UtZWxlbWVudC5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1lbGVtZW50LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIE9mZnNldCBQb3NpdGlvblxuICogR2V0IHRoZSBvZmZzZXQgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtCb29sZWFufSB2aWV3UG9ydE9mZnNldCBUaGUgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCwgbm90IHBhZ2UuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL2RvbS9vZmZzZXQuanNcbiAqL1xuZnVuY3Rpb24gb2Zmc2V0KGVsLCB2aWV3UG9ydE9mZnNldCkge1xuXG4gIHZhciByZWN0ID0ge1xuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG5cbiAgLy8gTmF0aXZlIGltcGxlbWVudGF0aW9uXG4gIGlmIChlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcblxuICAgIHZhciBib3VuZGluZyA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJlY3QubGVmdCA9IGJvdW5kaW5nLmxlZnQ7XG4gICAgcmVjdC50b3AgPSBib3VuZGluZy50b3A7XG5cbiAgICBpZiAoIXZpZXdQb3J0T2Zmc2V0KSB7XG4gICAgICByZWN0LmxlZnQgKz0gdHlwZW9mIHdpbmRvdy5zY3JvbGxYICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5zY3JvbGxYIDogd2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgICAgcmVjdC50b3AgKz0gdHlwZW9mIHdpbmRvdy5zY3JvbGxZICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5zY3JvbGxZIDogd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgeCA9IDAsXG4gICAgICAgIHkgPSAwO1xuICAgIGRvIHtcbiAgICAgIHggKz0gZWwub2Zmc2V0TGVmdCAtICghdmlld1BvcnRPZmZzZXQgPyBlbC5zY3JvbGxMZWZ0IDogMCk7XG4gICAgICB5ICs9IGVsLm9mZnNldFRvcCAtICghdmlld1BvcnRPZmZzZXQgPyBlbC5zY3JvbGxUb3AgOiAwKTtcbiAgICB9IHdoaWxlIChlbCA9IGVsLm9mZnNldFBhcmVudCk7XG5cbiAgICByZWN0LmxlZnQgPSB4O1xuICAgIHJlY3QudG9wID0geTtcbiAgfVxuXG4gIHJldHVybiByZWN0O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBvZmZzZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9mZnNldC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBQYXJzZSBET00gYXR0cmlidXRlc1xuICogR2l2ZW4gYW4gZWxlbWVudCBhbmQgYW4gYXR0cmlidXRlIG5hbWUsIHBhcnNlIHRoYXQgYXR0cmlidXRlXG4gKiBpZiBpdCBleGlzdHMgb3IgcmV0dXJuIGEgZGVmYXVsdC5cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZG9tL3BhcnNlLWF0dHJpYnV0ZS5qc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSBib29sZWFuIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxuICogZmFsbGluZyBiYWNrIHRvIHRoZSBkZWZhdWx0IHZhbHVlLlxuICogQHBhcmFtICB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gZGVmXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBib29sZWFuKGVsLCBuYW1lLCBkZWYpIHtcbiAgdmFyIHZhbCA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuIGRlZjtcbiAgcmV0dXJuIHZhbCA9PT0gJ3RydWUnIHx8IHZhbCA9PT0gJycgPyB0cnVlIDogZmFsc2U7XG59XG5cbi8qKlxuICogR2V0IHRoZSBudW1lcmljIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxuICogZmFsbGluZyBiYWNrIHRvIHRoZSBkZWZhdWx0IHZhbHVlLlxuICogQHBhcmFtICB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gZGVmXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBudW1iZXIoZWwsIG5hbWUsIGRlZikge1xuICB2YXIgdmFsID0gZWwuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gZGVmO1xuICByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBib29sZWFuIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxuICogZmFsbGluZyBiYWNrIHRvIHRoZSBkZWZhdWx0IHZhbHVlLlxuICogQHBhcmFtICB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gZGVmXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBzdHJpbmcoZWwsIG5hbWUsIGRlZikge1xuICB2YXIgdmFsID0gZWwuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gZGVmO1xuICByZXR1cm4gdmFsO1xufVxuXG5leHBvcnRzLmJvb2xlYW4gPSBib29sZWFuO1xuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLWF0dHJpYnV0ZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90cmltID0gcmVxdWlyZSgnLi4vdXRpbC90cmltJyk7XG5cbnZhciBfdHJpbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmltKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHdzID0gL1xccysvOyAvKipcbiAgICAgICAgICAgICAgICAgKiAjIFJlbW92ZSBDbGFzc1xuICAgICAgICAgICAgICAgICAqIFJlbW92ZSBhIGNsYXNzIG9uIGFuIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXl9IGVsIEFuIGVsZW1lbnQgb3IgYXJyYXkgb2YgZWxlbWVudHMgdG8gdXBkYXRlLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgaGVscGVycy9kb20vcmVtb3ZlLWNsYXNzLmpzXG4gICAgICAgICAgICAgICAgICovXG5cbnZhciBjbGVhbnVwID0gL1xcc3syLH0vZztcblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIG5hbWUpIHtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gKDAsIF90cmltMi5kZWZhdWx0KShuYW1lKS5zcGxpdCh3cyk7XG4gIH0gZWxzZSB7XG4gICAgbmFtZSA9IG5hbWUgaW5zdGFuY2VvZiBBcnJheSA/IG5hbWUgOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB9XG5cbiAgLy8gb3B0aW1pemUgZm9yIGJlc3QsIG1vc3QgY29tbW9uIGNhc2VcbiAgaWYgKG5hbWUubGVuZ3RoID09PSAxICYmIGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChuYW1lWzBdKSBlbC5jbGFzc0xpc3QucmVtb3ZlKG5hbWVbMF0pO1xuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIC8vIHN0b3JlIHR3byBjb3BpZXNcbiAgdmFyIGNsc05hbWUgPSAnICcgKyAodHlwZW9mIGVsLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycgPyBlbC5jbGFzc05hbWUgOiBlbC5nZXRBdHRyaWJ1dGUgPyBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgOiAnJykgKyAnICc7XG4gIHZhciByZXN1bHQgPSBjbHNOYW1lO1xuICB2YXIgY3VycmVudCA9IHZvaWQgMDtcbiAgdmFyIHN0YXJ0ID0gdm9pZCAwO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IG5hbWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY3VycmVudCA9IG5hbWVbaV07XG4gICAgc3RhcnQgPSBjdXJyZW50ID8gcmVzdWx0LmluZGV4T2YoJyAnICsgY3VycmVudCArICcgJykgOiAtMTtcbiAgICBpZiAoc3RhcnQgIT09IC0xKSB7XG4gICAgICBzdGFydCArPSAxO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIHN0YXJ0KSArIHJlc3VsdC5zbGljZShzdGFydCArIGN1cnJlbnQubGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICAvLyBvbmx5IHdyaXRlIGlmIG1vZGlmaWVkXG4gIGlmIChjbHNOYW1lICE9PSByZXN1bHQpIHtcbiAgICBpZiAodHlwZW9mIGVsLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVsLmNsYXNzTmFtZSA9ICgwLCBfdHJpbTIuZGVmYXVsdCkocmVzdWx0LnJlcGxhY2UoY2xlYW51cCwgJyAnKSk7XG4gICAgfSBlbHNlIGlmIChlbC5zZXRBdHRyaWJ1dGUpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoMCwgX3RyaW0yLmRlZmF1bHQpKHJlc3VsdC5yZXBsYWNlKGNsZWFudXAsICcgJykpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWw7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHJlbW92ZUNsYXNzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmUtY2xhc3MuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfaGFzQ2xhc3MgPSByZXF1aXJlKCcuL2hhcy1jbGFzcycpO1xuXG52YXIgX2hhc0NsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhc0NsYXNzKTtcblxudmFyIF9hZGRDbGFzcyA9IHJlcXVpcmUoJy4vYWRkLWNsYXNzJyk7XG5cbnZhciBfYWRkQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWRkQ2xhc3MpO1xuXG52YXIgX3JlbW92ZUNsYXNzID0gcmVxdWlyZSgnLi9yZW1vdmUtY2xhc3MnKTtcblxudmFyIF9yZW1vdmVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZW1vdmVDbGFzcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsLCBuYW1lLCBlbmFibGUpIHtcblxuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgd2UncmUgcGFzc2VkIGFuIGFycmF5LCB0b2dnbGUgdGhlIGNsYXNzIG9uIGVhY2guXG4gIGlmIChlbCBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IGVsIGluc3RhbmNlb2YgQXJyYXkpIHtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdG9nZ2xlQ2xhc3MoZWxbaV0sIG5hbWUsIGVuYWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGFjdGlvbiA9IHZvaWQgMDtcbiAgaWYgKGVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5hYmxlID0gdHlwZW9mIGVuYWJsZSA9PT0gJ2Z1bmN0aW9uJyA/IGVuYWJsZS5jYWxsKG51bGwsIGVsKSA6IGVuYWJsZTtcbiAgICBhY3Rpb24gPSBlbmFibGUgPyAnYWRkJyA6ICdyZW1vdmUnO1xuICB9IGVsc2Uge1xuICAgIGFjdGlvbiA9ICgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKGVsLCBuYW1lKSA/ICdyZW1vdmUnIDogJ2FkZCc7XG4gIH1cblxuICByZXR1cm4gKGFjdGlvbiA9PT0gJ2FkZCcgPyBfYWRkQ2xhc3MyLmRlZmF1bHQgOiBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKGVsLCBuYW1lKTtcbn0gLyoqXG4gICAqICMgVG9nZ2xlIENsYXNzXG4gICAqIFRvZ2dsZSBhIGNsYXNzIG9uIGFuIGVsZW1lbnQgZ2l2ZW4gYSBjb25kaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxBcnJheX0gZWwgQW4gZWxlbWVudCBvciBhcnJheSBvZiBlbGVtZW50cyB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqXG4gICAqIEBtb2R1bGUgIGhlbHBlcnMvZG9tL3RvZ2dsZS1jbGFzcy5qc1xuICAgKi9cblxuZXhwb3J0cy5kZWZhdWx0ID0gdG9nZ2xlQ2xhc3M7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvZ2dsZS1jbGFzcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9vZmZzZXQyID0gcmVxdWlyZSgnLi4vZG9tL29mZnNldCcpO1xuXG52YXIgX29mZnNldDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vZmZzZXQyKTtcblxudmFyIF9ib3hQb3NpdGlvbiA9IHJlcXVpcmUoJy4vYm94LXBvc2l0aW9uJyk7XG5cbnZhciBfYm94UG9zaXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYm94UG9zaXRpb24pO1xuXG52YXIgX2RlYm91bmNlID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJvdW5jZScpO1xuXG52YXIgX2RlYm91bmNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlYm91bmNlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIyBBZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEFmZml4IG9uZSBlbGVtZW50IHRvIGFub3RoZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG5ldyBBZmZpeCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICBlbDogZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICB0YXJnZXRFbDogZWwyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgY2FyZXRFbDogZWwzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgYW5jaG9yWTogJ3RvcCcsIC8vICdtaWRkbGUnLCAnYm90dG9tJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgYW5jaG9yWDogJ2xlZnQnLCAvLyAnY2VudGVyJywgJ3JpZ2h0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIGhlbHBlcnMvcG9zaXRpb24vYWZmaXguanNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxudmFyIEFmZml4ID0gZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBTdG9yZSB0aGUgcmVmZXJlbmNlIGVsZW1lbnRzIGFuZCBwb3NpdGlvbi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBwYXJhbXNcbiAgICovXG4gIGZ1bmN0aW9uIEFmZml4KCkge1xuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFmZml4KTtcblxuICAgIHRoaXMuZWwgPSBwYXJhbXMuZWw7XG4gICAgdGhpcy50YXJnZXRFbCA9IHBhcmFtcy50YXJnZXRFbDtcbiAgICB0aGlzLmNhcmV0RWwgPSBwYXJhbXMuY2FyZXRFbDtcbiAgICB0aGlzLmFuY2hvclkgPSBwYXJhbXMuYW5jaG9yWSB8fCAndG9wJztcbiAgICB0aGlzLmFuY2hvclggPSBwYXJhbXMuYW5jaG9yWCB8fCAnY2VudGVyJztcbiAgICB0aGlzLmlzRml4ZWQgPSBwYXJhbXMuaXNGaXhlZCB8fCBmYWxzZTtcblxuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5faW5zZXJ0RWwoKTtcbiAgICB0aGlzLl9zZXRQb3NpdGlvbigpO1xuICAgIHRoaXMuX3VwZGF0ZURlYm91bmNlZCA9ICgwLCBfZGVib3VuY2UyLmRlZmF1bHQpKHRoaXMudXBkYXRlLmJpbmQodGhpcyksIDUwMCk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBsaXN0ZW5pbmcgYW5kIGNsZWFuIHVwIGV2ZW50IGxpc3RlbmVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIE9wdGlvbmFsXG4gICAqIEByZXR1cm4ge09iamVjdH0gdGhpc1xuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBpZiAoIXBhcmFtcy5rZWVwRWwpIHRoaXMuX3JlbW92ZUVsKCk7XG4gICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBwb3NpdGlvbi5cbiAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzXG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9zZXRQb3NpdGlvbigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMaXN0ZW4gZm9yIHdpbmRvdyByZXNpemVzIHRvIHVwZGF0ZSB0aGUgcG9zaXRpb24uXG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9vblJlc2l6ZUJvdW5kID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblNjcm9sbEJvdW5kID0gdGhpcy5fb25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemVCb3VuZCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsQm91bmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9yZW1vdmVFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemVCb3VuZCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsQm91bmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnNlcnQgdGhlIGVsZW1lbnQgaW50byB0aGUgRE9NLlxuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5faW5zZXJ0RWwgPSBmdW5jdGlvbiBfaW5zZXJ0RWwoKSB7XG4gICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYWZmaXhlZCcsICcnKTtcbiAgICB0aGlzLl9nZXRSb290RWwoKS5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gdGhlIERPTS5cbiAgICovXG5cblxuICBBZmZpeC5wcm90b3R5cGUuX3JlbW92ZUVsID0gZnVuY3Rpb24gX3JlbW92ZUVsKCkge1xuICAgIHRoaXMuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1hZmZpeGVkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBlbGVtZW50LlxuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5fc2V0UG9zaXRpb24gPSBmdW5jdGlvbiBfc2V0UG9zaXRpb24oKSB7XG5cbiAgICAvLyBGaXhlZCBwb3NpdGlvblxuICAgIHRoaXMuZWwuc3R5bGUuc2V0UHJvcGVydHkoJ3Bvc2l0aW9uJywgdGhpcy5pc0ZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZScsICdpbXBvcnRhbnQnKTtcblxuICAgIC8vIFRhcmdldCBlbGVtZW50IHByb3BlcnRpZXNcblxuICAgIHZhciBfb2Zmc2V0ID0gKDAsIF9vZmZzZXQzLmRlZmF1bHQpKHRoaXMudGFyZ2V0RWwsIHRoaXMuaXNGaXhlZCksXG4gICAgICAgIHRhcmdldFRvcCA9IF9vZmZzZXQudG9wLFxuICAgICAgICB0YXJnZXRMZWZ0ID0gX29mZnNldC5sZWZ0O1xuXG4gICAgdmFyIHRhcmdldFdpZHRoID0gdGhpcy50YXJnZXRFbC5vZmZzZXRXaWR0aDtcbiAgICB2YXIgdGFyZ2V0SGVpZ2h0ID0gdGhpcy50YXJnZXRFbC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAvLyBFbGVtZW50IHRvIGFmZml4IHByb3BlcnRpZXNcbiAgICB2YXIgZWxXaWR0aCA9IHRoaXMuZWwub2Zmc2V0V2lkdGg7XG4gICAgdmFyIGVsSGVpZ2h0ID0gdGhpcy5lbC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAvLyBNYXhlc1xuICAgIHZhciBkb2NIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIHZhciBkb2NXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRXaWR0aDtcblxuICAgIC8vIEdldCB0aGUgdmFsdWVzXG5cbiAgICB2YXIgX2NhbGN1bGF0ZVBvc2l0aW9uMiA9IHRoaXMuX2NhbGN1bGF0ZVBvc2l0aW9uKHtcbiAgICAgIGFuY2hvclg6IHRoaXMuYW5jaG9yWCxcbiAgICAgIGFuY2hvclk6IHRoaXMuYW5jaG9yWSxcbiAgICAgIHRhcmdldFRvcDogdGFyZ2V0VG9wLFxuICAgICAgdGFyZ2V0TGVmdDogdGFyZ2V0TGVmdCxcbiAgICAgIGVsSGVpZ2h0OiBlbEhlaWdodCxcbiAgICAgIGVsV2lkdGg6IGVsV2lkdGgsXG4gICAgICB0YXJnZXRIZWlnaHQ6IHRhcmdldEhlaWdodCxcbiAgICAgIHRhcmdldFdpZHRoOiB0YXJnZXRXaWR0aCxcbiAgICAgIG1pblg6IDAsXG4gICAgICBtaW5ZOiAwLFxuICAgICAgbWF4WDogZG9jV2lkdGggLSBlbFdpZHRoLFxuICAgICAgbWF4WTogTWF0aC5tYXgoZG9jSGVpZ2h0IC0gZWxIZWlnaHQsIDApXG4gICAgfSksXG4gICAgICAgIGVsVG9wID0gX2NhbGN1bGF0ZVBvc2l0aW9uMi5lbFRvcCxcbiAgICAgICAgZWxMZWZ0ID0gX2NhbGN1bGF0ZVBvc2l0aW9uMi5lbExlZnQ7XG5cbiAgICAvLyBQb3NpdGlvbiB0aGUgY2FyZXRcblxuXG4gICAgdmFyIF9wb3NpdGlvbkNhcmV0MiA9IHRoaXMuX3Bvc2l0aW9uQ2FyZXQoe1xuICAgICAgZWxMZWZ0OiBlbExlZnQsXG4gICAgICBlbFRvcDogZWxUb3AsXG4gICAgICBlbFdpZHRoOiBlbFdpZHRoLFxuICAgICAgZWxIZWlnaHQ6IGVsSGVpZ2h0LFxuICAgICAgdGFyZ2V0SGVpZ2h0OiB0YXJnZXRIZWlnaHQsXG4gICAgICB0YXJnZXRXaWR0aDogdGFyZ2V0V2lkdGgsXG4gICAgICB0YXJnZXRMZWZ0OiB0YXJnZXRMZWZ0LFxuICAgICAgdGFyZ2V0VG9wOiB0YXJnZXRUb3BcbiAgICB9KSxcbiAgICAgICAgZXh0cmFMZWZ0ID0gX3Bvc2l0aW9uQ2FyZXQyLmV4dHJhTGVmdCxcbiAgICAgICAgZXh0cmFUb3AgPSBfcG9zaXRpb25DYXJldDIuZXh0cmFUb3A7XG5cbiAgICAvLyBTZXQgdGhlIHBvc2l0aW9uXG5cblxuICAgIHRoaXMuZWwuc3R5bGUubGVmdCA9IGVsTGVmdCArIGV4dHJhTGVmdCArICdweCc7XG4gICAgdGhpcy5lbC5zdHlsZS50b3AgPSBlbFRvcCArIGV4dHJhVG9wICsgJ3B4JztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBwcm9wZXIgdG9wIHBvc2l0aW9uIGZvciBhbiBhbmNob3IgZGlyZWN0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHBcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5fY2FsY3VsYXRlUG9zaXRpb24gPSBmdW5jdGlvbiBfY2FsY3VsYXRlUG9zaXRpb24ocCkge1xuXG4gICAgLy8gS2VlcCB0cmFjayBvZiB3aGF0IHdlJ3JlIHRyeWluZyB0byBkbyBoZXJlLCBzbyBvbiBzdWJzZXF1ZW50LCBuZXN0ZWQgY2FsbHMgdG8gdGhpc1xuICAgIC8vIG1ldGhvZCB3ZSBjYW4gc2VlIHdoYXQgaGFzIGFscmVhZHkgYmVlbiB0cmllZC5cbiAgICBwLnByZXZpb3VzQXR0ZW1wdHMgPSAocC5wcmV2aW91c0F0dGVtcHRzIHx8IDApICsgMTtcbiAgICBwLnByZXZpb3VzQ2hlY2tzID0gcC5wcmV2aW91c0NoZWNrcyB8fCBbXTtcblxuICAgIHZhciBmaW5hbENoZWNrID0gcC5wcmV2aW91c0F0dGVtcHRzID4gMztcbiAgICB2YXIgdG9wID0gdm9pZCAwO1xuICAgIHZhciBsZWZ0ID0gdm9pZCAwO1xuXG4gICAgLy8gWS1heGlzIGNoZWNrXG4gICAgc3dpdGNoIChwLmFuY2hvclkpIHtcbiAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIHRvcCA9IHAudGFyZ2V0VG9wICsgcC50YXJnZXRIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgdG9wID0gcC50YXJnZXRUb3AgLSAocC5lbEhlaWdodCAtIHAudGFyZ2V0SGVpZ2h0KSAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdG9wID0gcC50YXJnZXRUb3AgLSBwLmVsSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBVbmRlciBtaW5cbiAgICBpZiAodG9wIDwgcC5taW5ZKSB7XG5cbiAgICAgIGlmICghZmluYWxDaGVjayAmJiBwLnByZXZpb3VzQ2hlY2tzLmluZGV4T2YoJ292ZXJZJykgPT09IC0xKSB7XG4gICAgICAgIHAucHJldmlvdXNDaGVja3MucHVzaCgndW5kZXJZJyk7XG4gICAgICAgIHAuYW5jaG9yWSA9IHRoaXMuX2dldE5ld0FuY2hvclkodHJ1ZSwgcC5hbmNob3JZLCBwLmFuY2hvclgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlUG9zaXRpb24ocCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3AgPSBwLm1pblk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgY2hlY2sgZm9yIGJlaW5nIHRvbyB0YWxsIGJlY2F1c2UgY2F1c2luZyBhIHZlcnRpY2FsIHNjcm9sbFxuICAgIC8vIGJhciBkb3duIGlzIG9rYXkgYW5kIHRoaXMgc2F2ZXMgdXMgZnJvbSBzb21lIHJlYWwgcG9zaXRpb25pbmcgaGVsbC5cbiAgICAvKmlmICh0b3AgPiBwLm1heFkpIHtcbiAgICAgICBpZiAoIWZpbmFsQ2hlY2sgJiYgcC5wcmV2aW91c0NoZWNrcy5pbmRleE9mKCd1bmRlclknKSA9PT0gLTEpIHtcbiAgICAgICAgcC5wcmV2aW91c0NoZWNrcy5wdXNoKCdvdmVyWScpO1xuICAgICAgICBwLmFuY2hvclkgPSB0aGlzLl9nZXROZXdBbmNob3JZKGZhbHNlLCBwLmFuY2hvclksIHAuYW5jaG9yWCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVQb3NpdGlvbihwKTtcbiAgICAgIH1cbiAgICAgIC8vIE9uIGEgZmluYWwgY2hlY2ssIGJvdHRvbSB3aW5zIGJlY2F1c2UgYXQgbGVhc3Qgd2UgY2FuIHNjcm9sbFxuICAgICAgZWxzZSBpZiAoIShmaW5hbENoZWNrICYmIHAuYW5jaG9yWSA9PT0gJ2JvdHRvbScpKSB7XG4gICAgICAgIHRvcCA9IHAubWF4WTtcbiAgICAgIH1cbiAgICB9Ki9cblxuICAgIC8vIFgtYXhpcyBjaGVja1xuICAgIHN3aXRjaCAocC5hbmNob3JYKSB7XG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGxlZnQgPSBwLnRhcmdldExlZnQgKyAocC5hbmNob3JZICE9PSAnbWlkZGxlJyAmJiAhcC5pc092ZXJsYXBwaW5nID8gMCA6IHAudGFyZ2V0V2lkdGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIGxlZnQgPSBwLnRhcmdldExlZnQgLSAocC5lbFdpZHRoIC0gcC50YXJnZXRXaWR0aCkgLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlZnQgPSBwLnRhcmdldExlZnQgLSBwLmVsV2lkdGggKyAocC5hbmNob3JZICE9PSAnbWlkZGxlJyA/IHAudGFyZ2V0V2lkdGggOiAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gVW5kZXIgbWluXG4gICAgaWYgKGxlZnQgPCBwLm1pblgpIHtcblxuICAgICAgaWYgKCFmaW5hbENoZWNrICYmIHAucHJldmlvdXNDaGVja3MuaW5kZXhPZignb3ZlclgnKSA9PT0gLTEpIHtcbiAgICAgICAgcC5wcmV2aW91c0NoZWNrcy5wdXNoKCd1bmRlclgnKTtcbiAgICAgICAgcC5hbmNob3JYID0gdGhpcy5fZ2V0TmV3QW5jaG9yWCh0cnVlLCBwLmFuY2hvclgsIHAuYW5jaG9yWSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVQb3NpdGlvbihwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnQgPSBwLm1pblg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3ZlciBtYXhcbiAgICBpZiAobGVmdCA+IHAubWF4WCkge1xuXG4gICAgICBpZiAoIWZpbmFsQ2hlY2sgJiYgcC5wcmV2aW91c0NoZWNrcy5pbmRleE9mKCd1bmRlclgnKSA9PT0gLTEpIHtcbiAgICAgICAgcC5wcmV2aW91c0NoZWNrcy5wdXNoKCdvdmVyWCcpO1xuICAgICAgICBwLmFuY2hvclggPSB0aGlzLl9nZXROZXdBbmNob3JYKGZhbHNlLCBwLmFuY2hvclgsIHAuYW5jaG9yWSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVQb3NpdGlvbihwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnQgPSBwLm1heFg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT25lIGVsZW1lbnQgaXMgY292ZXJpbmcgYW5vdGhlci4gVHJ5IHRvIGZpeCB0aGF0LCBidXQgYmFpbCBvdXQgYWZ0ZXIgZm91ciB0cmllcy5cbiAgICBpZiAoKDAsIF9ib3hQb3NpdGlvbjIuZGVmYXVsdCkoeyB3aWR0aDogcC5lbFdpZHRoLCBoZWlnaHQ6IHAuZWxIZWlnaHQsIGxlZnQ6IGxlZnQsIHRvcDogdG9wIH0sIHsgd2lkdGg6IHAudGFyZ2V0V2lkdGgsIGhlaWdodDogcC50YXJnZXRIZWlnaHQsIGxlZnQ6IHAudGFyZ2V0TGVmdCwgdG9wOiBwLnRhcmdldFRvcCB9KSA9PT0gJ292ZXJsYXAnKSB7XG5cbiAgICAgIHAuaXNPdmVybGFwcGluZyA9IHRydWU7XG5cbiAgICAgIC8vIFRyeSBZXG4gICAgICBpZiAocC5yZXBvc2l0aW9uWSAhPT0gZmFsc2UpIHtcblxuICAgICAgICAvLyBXaWxsIHN0YXJ0IHVuZGVmaW5lZCwgdGhlbiB0cnVlLCB0aGVuIGZhbHNlLiBUaGlzIGxpbWl0cyB1cyB0byBlbnRlcmluZ1xuICAgICAgICAvLyB0aGlzIGxvb3AgdHdpY2UsIG9uY2UgdG8gdHJ5IG1vdmluZyBpbiBlYWNoIGRpcmVjdGlvbi5cbiAgICAgICAgcC5yZXBvc2l0aW9uWSA9ICFwLnJlcG9zaXRpb25ZO1xuXG4gICAgICAgIC8vIEZpcnN0IHRyeSB0byBwdXQgYWJvdmUsIHRoZW4gdHJ5IHRvIHB1dCBiZWxvdy5cbiAgICAgICAgcC5hbmNob3JZID0gdGhpcy5fZ2V0TmV3QW5jaG9yWShwLnJlcG9zaXRpb25ZLCAnbWlkZGxlJywgcC5hbmNob3JYKTtcblxuICAgICAgICAvLyBHaXZlIHVzIG9uZSBtb3JlIHNob3QgYXQgcG9zaXRpb25pbmdcbiAgICAgICAgcC5wcmV2aW91c0F0dGVtcHRzLS07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZVBvc2l0aW9uKHApO1xuICAgICAgfVxuICAgICAgLy8gVHJ5IFhcbiAgICAgIGVsc2UgaWYgKHAucmVwb3NpdGlvblggIT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAvLyBXaWxsIHN0YXJ0IHVuZGVmaW5lZCwgdGhlbiB0cnVlLCB0aGVuIGZhbHNlLiBUaGlzIGxpbWl0cyB1cyB0byBlbnRlcmluZ1xuICAgICAgICAgIC8vIHRoaXMgbG9vcCB0d2ljZSwgb25jZSB0byB0cnkgbW92aW5nIGluIGVhY2ggZGlyZWN0aW9uLlxuICAgICAgICAgIHAucmVwb3NpdGlvblggPSAhcC5yZXBvc2l0aW9uWDtcblxuICAgICAgICAgIC8vIEZpcnN0IHRyeSB0byBwdXQgYWJvdmUsIHRoZW4gdHJ5IHRvIHB1dCBiZWxvdy5cbiAgICAgICAgICBwLmFuY2hvclggPSB0aGlzLl9nZXROZXdBbmNob3JYKHAucmVwb3NpdGlvblgsICdjZW50ZXInLCBwLmFuY2hvclkpO1xuXG4gICAgICAgICAgLy8gR2l2ZSB1cyBvbmUgbW9yZSBzaG90IGF0IHBvc2l0aW9uaW5nXG4gICAgICAgICAgcC5wcmV2aW91c0F0dGVtcHRzLS07XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlUG9zaXRpb24ocCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBlbFRvcDogdG9wLCBlbExlZnQ6IGxlZnQsIGFuY2hvclg6IHAuYW5jaG9yWCwgYW5jaG9yWTogcC5hbmNob3JZIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgbmV3IHktYXhpcyBhbmNob3JcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gdW5kZXJNaW4gVW5kZXIgdGhlIG1pbj9cbiAgICogQHBhcmFtICB7U3RyaW5nfSBhbmNob3JZXG4gICAqIEBwYXJhbSAge1N0cmluZ30gYW5jaG9yWFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9nZXROZXdBbmNob3JZID0gZnVuY3Rpb24gX2dldE5ld0FuY2hvclkodW5kZXJNaW4sIGFuY2hvclksIGFuY2hvclgpIHtcblxuICAgIC8vIElmIHRoZSB4LWF4aXMgaXMgYW5jaG9yZWQgaW4gdGhlIGNlbnRlciwgc2tpcFxuICAgIC8vIHRyeWluZyB0byBhbmNob3IgdG8gdGhlIG1pZGRsZSBiZWNhdXNlIHRoZW4gd2UnZFxuICAgIC8vIGJlIG92ZXJsYXlpbmcgdGhlIGJ1dHRvbi5cbiAgICBpZiAoYW5jaG9yWCA9PT0gJ2NlbnRlcicgfHwgYW5jaG9yWSA9PT0gJ21pZGRsZScpIHtcbiAgICAgIHJldHVybiB1bmRlck1pbiA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnbWlkZGxlJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgbmV3IHktYXhpcyBhbmNob3JcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gdW5kZXJNaW4gVW5kZXIgdGhlIG1pbj9cbiAgICogQHBhcmFtICB7U3RyaW5nfSBhbmNob3JZXG4gICAqIEBwYXJhbSAge1N0cmluZ30gYW5jaG9yWFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9nZXROZXdBbmNob3JYID0gZnVuY3Rpb24gX2dldE5ld0FuY2hvclgodW5kZXJNaW4sIGFuY2hvclgsIGFuY2hvclkpIHtcblxuICAgIC8vIElmIHRoZSB5LWF4aXMgaXMgYW5jaG9yZWQgaW4gdGhlIGNlbnRlciwgc2tpcFxuICAgIC8vIHRyeWluZyB0byBhbmNob3IgdG8gdGhlIG1pZGRsZSBiZWNhdXNlIHRoZW4gd2UnZFxuICAgIC8vIGJlIG92ZXJsYXlpbmcgdGhlIGJ1dHRvbi5cbiAgICBpZiAoYW5jaG9yWSA9PT0gJ21pZGRsZScgfHwgYW5jaG9yWCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHJldHVybiB1bmRlck1pbiA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnY2VudGVyJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIGNhcmV0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gcFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9wb3NpdGlvbkNhcmV0ID0gZnVuY3Rpb24gX3Bvc2l0aW9uQ2FyZXQoKSB7XG4gICAgdmFyIHAgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG5cbiAgICBpZiAoIXRoaXMuY2FyZXRFbCkgcmV0dXJuO1xuXG4gICAgdmFyIGNhcmV0UG9zaXRpb24gPSAoMCwgX2JveFBvc2l0aW9uMi5kZWZhdWx0KSh7IHdpZHRoOiBwLmVsV2lkdGgsIGhlaWdodDogcC5lbEhlaWdodCwgbGVmdDogcC5lbExlZnQsIHRvcDogcC5lbFRvcCB9LCB7IHdpZHRoOiBwLnRhcmdldFdpZHRoLCBoZWlnaHQ6IHAudGFyZ2V0SGVpZ2h0LCBsZWZ0OiBwLnRhcmdldExlZnQsIHRvcDogcC50YXJnZXRUb3AgfSk7XG5cbiAgICB2YXIgY2FyZXREaW1lbnNpb25zID0gdGhpcy5jYXJldEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBjYXJldFdpZHRoID0gY2FyZXREaW1lbnNpb25zLndpZHRoO1xuICAgIHZhciBjYXJldEhlaWdodCA9IGNhcmV0RGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgdmFyIGxlZnQgPSBNYXRoLm1pbihwLmVsV2lkdGgsIE1hdGgubWF4KDAsIHAudGFyZ2V0TGVmdCAtIHAuZWxMZWZ0ICsgcC50YXJnZXRXaWR0aCAvIDIpKTtcbiAgICB2YXIgdG9wID0gTWF0aC5taW4ocC5lbEhlaWdodCwgTWF0aC5tYXgoMCwgcC50YXJnZXRUb3AgLSBwLmVsVG9wICsgcC50YXJnZXRIZWlnaHQgLyAyKSk7XG5cbiAgICB0aGlzLmNhcmV0RWwuc3R5bGUubGVmdCA9IE1hdGgucm91bmQobGVmdCkgKyAncHgnO1xuICAgIHRoaXMuY2FyZXRFbC5zdHlsZS50b3AgPSBNYXRoLnJvdW5kKHRvcCkgKyAncHgnO1xuXG4gICAgdmFyIGV4dHJhTGVmdCA9IDA7XG4gICAgdmFyIGV4dHJhVG9wID0gMDtcblxuICAgIHRoaXMuY2FyZXRFbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcG9zaXRpb24nLCBjYXJldFBvc2l0aW9uKTtcblxuICAgIHN3aXRjaCAoY2FyZXRQb3NpdGlvbikge1xuICAgICAgY2FzZSAnYWJvdmUnOlxuICAgICAgICBleHRyYVRvcCA9IC1jYXJldFdpZHRoIC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdiZWxvdyc6XG4gICAgICAgIGV4dHJhVG9wID0gY2FyZXRXaWR0aCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGV4dHJhTGVmdCA9IC1jYXJldEhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZXh0cmFMZWZ0ID0gY2FyZXRIZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXh0cmFMZWZ0OiBleHRyYUxlZnQsXG4gICAgICBleHRyYVRvcDogZXh0cmFUb3BcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJvb3QgZWxlbWVudC4gV2FudCB0byBjaGVjayBpZiB0aGVyZSdzIGEgdG9wLWxldmVsIGZvcm0gZm9yIHdvcmtpbmdcbiAgICogd2l0aCBBU1AgLk5FVCBwYWdlcy5cbiAgICovXG5cblxuICBBZmZpeC5wcm90b3R5cGUuX2dldFJvb3RFbCA9IGZ1bmN0aW9uIF9nZXRSb290RWwoKSB7XG4gICAgdmFyIGZvcm0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5ID4gZm9ybScpO1xuICAgIHJldHVybiBmb3JtICYmIGZvcm0uZ2V0QXR0cmlidXRlKCdkYXRhLWFmZml4ZWQnKSA9PT0gbnVsbCA/IGZvcm0gOiBkb2N1bWVudC5ib2R5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBPbiByZXNpemUsIHVwZGF0ZSB0aGUgcG9zaXRpb24uXG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9vblJlc2l6ZSA9IGZ1bmN0aW9uIF9vblJlc2l6ZSgpIHtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSB3aW5kb3cgc2Nyb2xscywgZW5zdXJlIHRoZSBwcm9wZXIgcG9zaXRpb24gb2YgdGhlIHBvcG92ZXIuXG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9vblNjcm9sbCA9IGZ1bmN0aW9uIF9vblNjcm9sbCgpIHtcbiAgICB0aGlzLl91cGRhdGVEZWJvdW5jZWQoKTtcbiAgfTtcblxuICByZXR1cm4gQWZmaXg7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEFmZml4O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZmZpeC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGEsIGIpIHtcblxuICB2YXIgYVhTcGFuID0gYS5sZWZ0ICsgYS53aWR0aDtcbiAgdmFyIGFZU3BhbiA9IGEudG9wICsgYS5oZWlnaHQ7XG4gIHZhciBiWFNwYW4gPSBiLmxlZnQgKyBiLndpZHRoO1xuICB2YXIgYllTcGFuID0gYi50b3AgKyBiLmhlaWdodDtcblxuICBpZiAoYVhTcGFuIDw9IGIubGVmdCkgcmV0dXJuICdsZWZ0JzsgLy8gYSBpcyBmdWxseSBsZWZ0IG9mIGJcbiAgaWYgKGEubGVmdCA+PSBiWFNwYW4pIHJldHVybiAncmlnaHQnOyAvLyBhIGlzIGZ1bGx5IHJpZ2h0IG9mIGJcbiAgaWYgKGFZU3BhbiA8PSBiLnRvcCkgcmV0dXJuICdhYm92ZSc7IC8vIGEgaXMgZnVsbHkgYWJvdmUgYlxuICBpZiAoYS50b3AgPj0gYllTcGFuKSByZXR1cm4gJ2JlbG93JzsgLy8gYSBpcyBmdWxseSBiZWxvdyBiXG5cbiAgcmV0dXJuICdvdmVybGFwJzsgLy8gYm94ZXMgb3ZlcmxhcFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICMgQm94IFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogSG93IGlzIG9uZSBlbGVtZW50IHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gYW5vdGhlcj9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogYm94UG9zaXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICoge3dpZHRoOiAxMDAsIGhlaWdodDogMzAwLCBsZWZ0OiAwLCB0b3A6IDB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHt3aWR0aDogMjAwLCBoZWlnaHQ6IDUwLCBsZWZ0OiAxMDAsIHRvcDogNDB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBoZWxwZXJzL3Bvc2l0aW9uL2JveC1wb3NpdGlvbi5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJveC1wb3NpdGlvbi5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIEhhcyBQYXJlbnRcbiAqIFNlZSBpZiBhbiBlbGVtZW50IGhhcyBhbm90aGVyIGVsZW1lbnQgZm9yIGEgcGFyZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gY2hpbGRcbiAqIEBwYXJhbSB7RWxlbWVudH0gcG9zc2libGVQYXJlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL3RyYXZlcnNhbC9oYXMtcGFyZW50LmpzXG4gKi9cbmZ1bmN0aW9uIGhhc1BhcmVudChjaGlsZCwgcG9zc2libGVQYXJlbnQpIHtcblxuICB2YXIgcGFyZW50ID0gY2hpbGQucGFyZW50Tm9kZTtcblxuICB3aGlsZSAocGFyZW50KSB7XG5cbiAgICBpZiAocGFyZW50ID09PSBwb3NzaWJsZVBhcmVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGhhc1BhcmVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXMtcGFyZW50LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgRGVib3VuY2VcbiAqIERlYm91bmNlIGEgZnVuY3Rpb24gY2FsbFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAqIEBwYXJhbSB7SW50ZWdlcn0gZGVsYXlcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdXRpbC9kZWJvdW5jZS5qc1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCBkZWxheSkge1xuXG4gIHZhciB0aW1lciA9IHZvaWQgMDtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIGlmICh0aW1lcikgd2luZG93LmNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgdGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0sIGRlbGF5KTtcbiAgfTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZGVib3VuY2U7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVib3VuY2UuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgRWFjaFxuICogQXBwbHkgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBhIGxpc3Qgb2YgYW55IGtpbmQ6IEFycmF5LCBOb2RlTGlzdCwgSFRNTENvbGxlY3Rpb24gb3IgT2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8Tm9kZUxpc3R8SFRNTENvbGxlY3Rpb258T2JqZWN0fSBsaXN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICpcbiAqIEBleGFtcGxlXG4gKiBlYWNoKFtdLCBjYWxsYmFjayk7XG4gKiBlYWNoKGVsLmNoaWxkcmVuLCBjYWxsYmFjayk7XG4gKiBlYWNoKGVsLmNoaWxkTm9kZXMsIGNhbGxiYWNrKTtcbiAqIGVhY2goe30sIGNhbGxiYWNrKTtcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdXRpbC9lYWNoLmpzXG4gKi9cbmZ1bmN0aW9uIGVhY2gobGlzdCwgY2IpIHtcblxuICBpZiAoIWxpc3QpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52b2tlIGBlYWNoYCB3aXRob3V0IGEgY2FsbGJhY2shJyk7XG4gIH1cblxuICB2YXIgaSA9IDA7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcblxuICAvLyBPYmplY3RcbiAgaWYgKGxlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChpIGluIGxpc3QpIHtcbiAgICAgIGlmIChpICE9PSAncHJvdG90eXBlJyAmJiBsaXN0Lmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGNiKGksIGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBBcnJheS1saWtlXG4gIGVsc2Uge1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjYihsaXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGVhY2g7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVhY2guanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgVHJpbVxuICogVHJpbSB3aGl0ZXNwYWNlIG9uIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdXRpbC90cmltLmpzXG4gKi9cblxudmFyIHRyaW1SRSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHRyaW1SRSwgJycpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0cmltO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmltLmpzLm1hcFxuIl19"}