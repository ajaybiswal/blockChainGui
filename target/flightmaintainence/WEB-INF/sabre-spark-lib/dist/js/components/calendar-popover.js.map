{"version":3,"sources":["js/dist/components/node_modules/browser-pack/_prelude.js","js/dist/components/js/dist/components/base.js","js/dist/components/js/dist/components/calendar-popover.js","js/dist/components/js/dist/components/popover.js","js/dist/components/js/dist/helpers/animation/request.js","js/dist/components/js/dist/helpers/animation/scroll-to.js","js/dist/components/js/dist/helpers/animation/tween.js","js/dist/components/js/dist/helpers/date/date.js","js/dist/components/js/dist/helpers/date/parse-format.js","js/dist/components/js/dist/helpers/dom/add-class.js","js/dist/components/js/dist/helpers/dom/breakpoint.js","js/dist/components/js/dist/helpers/dom/has-class.js","js/dist/components/js/dist/helpers/dom/offset.js","js/dist/components/js/dist/helpers/dom/parse-attribute.js","js/dist/components/js/dist/helpers/dom/remove-class.js","js/dist/components/js/dist/helpers/dom/toggle-class.js","js/dist/components/js/dist/helpers/dom/trigger-event.js","js/dist/components/js/dist/helpers/form/build-select.js","js/dist/components/js/dist/helpers/manipulation/append-children.js","js/dist/components/js/dist/helpers/position/affix.js","js/dist/components/js/dist/helpers/position/box-position.js","js/dist/components/js/dist/helpers/traversal/get-parent.js","js/dist/components/js/dist/helpers/traversal/get-sibling-after.js","js/dist/components/js/dist/helpers/traversal/get-sibling-before.js","js/dist/components/js/dist/helpers/traversal/has-parent.js","js/dist/components/js/dist/helpers/traversal/matches.js","js/dist/components/js/dist/helpers/util/debounce.js","js/dist/components/js/dist/helpers/util/each.js","js/dist/components/js/dist/helpers/util/pad.js","js/dist/components/js/dist/helpers/util/range.js","js/dist/components/js/dist/helpers/util/trim.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzmEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1kBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"calendar-popover.js","sourcesContent":["(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _each = require('../helpers/util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * # Base Component\n                                                                                                                                                           * The base class for Spark JS components. This class should never be\n                                                                                                                                                           * instantiated directly.\n                                                                                                                                                           *\n                                                                                                                                                           * @param {Element} el\n                                                                                                                                                           * @param {Object} params\n                                                                                                                                                           *\n                                                                                                                                                           * @module components/base.js\n                                                                                                                                                           */\n\nvar noop = function noop() {};\n\nvar Base = function () {\n\n  /**\n   * Set parameters and cache elements.\n   */\n  function Base(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Base);\n\n    if (params.elRequired && !el) {\n      return;\n    }\n\n    this.setParams(this.defaults || {}, true);\n    this.setParams(params);\n    (this._cacheElements || noop).call(this, el, params);\n    (this._parseParams || noop).call(this);\n  }\n\n  /**\n   * Remove the component from the DOM and prepare for garbage collection by dereferencing values.\n   * @param {Boolean} leaveElement Leave the element intact.\n   */\n\n\n  Base.prototype.remove = function remove(leaveElement) {\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    if (!leaveElement && this.el && this.el.parentNode) {\n      this.el.parentNode.removeChild(this.el);\n    }\n\n    this.unsetParams(this.defaults);\n\n    return this;\n  };\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   * @param {Object} params Optional\n   */\n\n\n  Base.prototype.update = function update(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    (this._cacheElements || noop).call(this, el || this.el, params);\n    (this._parseParams || noop).call(this);\n\n    if (this._addEventListeners) {\n      this._addEventListeners();\n    }\n\n    return this;\n  };\n\n  /**\n   * Set a hash of parameters if they're whitelisted or we're told to force the set.\n   * This is used to set initial values as well as set passed parameters.\n   * @param {Object} params\n   * @param {Boolean} force Force setting even if the param is not whitelisted.\n   */\n\n\n  Base.prototype.setParams = function setParams(params, force) {\n    var _this = this;\n\n    (0, _each2.default)(params, function (k, v) {\n      if (_this._whitelistedParams.indexOf(k) !== -1 || force) {\n        _this[k] = v;\n      }\n    });\n\n    return this;\n  };\n\n  /**\n   * Unset all parameters.\n   * @param {Array|Object} keys\n   * @param {Object} scope The object to unset the params from. Defaults to `this`.\n   */\n\n\n  Base.prototype.unsetParams = function unsetParams(keys, scope) {\n\n    keys = keys instanceof Array ? keys : Object.keys(keys);\n    scope = scope || this;\n    (0, _each2.default)(keys, function (k) {\n      delete scope[k];\n    });\n\n    return this;\n  };\n\n  return Base;\n}();\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nBase.prototype._whitelistedParams = [];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nBase.prototype.defaults = {};\n\nexports.default = Base;\nmodule.exports = exports['default'];\n//# sourceMappingURL=base.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _base = require('./base');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _popover = require('./popover');\n\nvar _popover2 = _interopRequireDefault(_popover);\n\nvar _parseFormat = require('../helpers/date/parse-format');\n\nvar _parseFormat2 = _interopRequireDefault(_parseFormat);\n\nvar _date = require('../helpers/date/date');\n\nvar _date2 = _interopRequireDefault(_date);\n\nvar _buildSelect = require('../helpers/form/build-select');\n\nvar _buildSelect2 = _interopRequireDefault(_buildSelect);\n\nvar _addClass = require('../helpers/dom/add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _removeClass = require('../helpers/dom/remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nvar _hasClass = require('../helpers/dom/has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _appendChildren = require('../helpers/manipulation/append-children');\n\nvar _appendChildren2 = _interopRequireDefault(_appendChildren);\n\nvar _getParent = require('../helpers/traversal/get-parent');\n\nvar _getParent2 = _interopRequireDefault(_getParent);\n\nvar _triggerEvent = require('../helpers/dom/trigger-event');\n\nvar _triggerEvent2 = _interopRequireDefault(_triggerEvent);\n\nvar _breakpoint = require('../helpers/dom/breakpoint');\n\nvar _scrollTo = require('../helpers/animation/scroll-to');\n\nvar _scrollTo2 = _interopRequireDefault(_scrollTo);\n\nvar _getSiblingBefore = require('../helpers/traversal/get-sibling-before');\n\nvar _getSiblingBefore2 = _interopRequireDefault(_getSiblingBefore);\n\nvar _getSiblingAfter = require('../helpers/traversal/get-sibling-after');\n\nvar _getSiblingAfter2 = _interopRequireDefault(_getSiblingAfter);\n\nvar _range = require('../helpers/util/range');\n\nvar _range2 = _interopRequireDefault(_range);\n\nvar _parseAttribute = require('../helpers/dom/parse-attribute');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * # Calendar Popover\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Create a calendar from which dates can be selected.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @example\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * new CalendarPopover(el);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module components/calendar-popover.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\nvar noop = function noop() {};\nvar domDateFormat = 'YYYY-MM-DD';\nvar parsedDomFormat = (0, _parseFormat2.default)(domDateFormat);\n\nfunction createDefaultElement() {\n  var el = document.createElement('span');\n  el.className = 'spark-input spark-date';\n  el.innerHTML = '<input class=\"spark-input__field\" type=\"date\"><span class=\"spark-label\"></span>';\n  return el;\n}\n\n/**\n * Parse the proper params for initialization\n * @param  {Element} el\n * @param  {Object} params\n * @return {Objec}\n */\nfunction parseInitParams(el, params) {\n\n  // If the first element is an array or array-like (NodeList),\n  // we will be working with a range.\n  if (el && el.hasOwnProperty('length')) {\n    params.els = el;\n  }\n  // If the first argument is a plain object, create a default element\n  // since the user MUST provide additional params but the element\n  // is optional. Doing it this way to keep the arity the same\n  // as other components.\n  else if (!(el instanceof HTMLElement)) {\n      params = el || {};\n      params.els = [createDefaultElement()];\n    }\n    // A single element is passed.\n    else {\n        params.els = [el];\n      }\n\n  params.visibleCounts = params.visibleCounts || (params.visibleCount ? [params.visibleCount] : null);\n  params.mins = params.mins || (params.min ? [params.min] : []);\n  params.maxes = params.maxes || (params.max ? [params.max] : []);\n  params.values = params.values || (params.value ? [params.value] : []);\n\n  return params;\n}\n\nvar CalendarPopover = function (_BaseComponent) {\n  _inherits(CalendarPopover, _BaseComponent);\n\n  /**\n   * Calendar Popover constructor\n   * @param {Element} el Optional\n   * @param {Object} params Optional\n   */\n  function CalendarPopover(el) {\n    var _this;\n\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, CalendarPopover);\n\n    params = parseInitParams(el, params);\n\n    if (!(_this = _possibleConstructorReturn(this, _BaseComponent.call(this, el, params)), _this)) {\n      return _possibleConstructorReturn(_this);\n    }\n\n    // Create a calendar element if we weren't passed one.\n    (_this.calendarEl ? noop : _this._createCalendar).call(_this);\n    _this._cacheCalendarElements();\n\n    _this._bindEventListenerCallbacks();\n    _this._addEventListeners();\n    _this._initDatesToShow();\n    return _possibleConstructorReturn(_this);\n  }\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   */\n\n\n  CalendarPopover.prototype.update = function update(el) {\n\n    if (el) {\n      this._removeEventListeners();\n      this.els = el instanceof Array ? el : [el];\n      this._cacheElements();\n      this._addEventListeners();\n    }\n\n    this._parseInputElsParams();\n    this._initDatesToShow();\n\n    if (this.activeIndex !== null) {\n      this.render();\n      this._checkSize();\n    }\n\n    return this;\n  };\n\n  /**\n   * Open the calendar widget.\n   * @param {Number} index Optional The index of the element to tie actions to\n   * @param {Object} params Optional\n   */\n\n\n  CalendarPopover.prototype.open = function open() {\n    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n    if (this._isDisabled[index]) {\n      return this;\n    }\n\n    this._unfillToggle();\n\n    // Allow for only params to be passed\n    if ((typeof index === 'undefined' ? 'undefined' : _typeof(index)) === 'object') {\n      params = index;\n      index = 0;\n    }\n\n    // Already open\n    if (this.activeIndex === index) {\n      return this;\n    }\n\n    // We have an already active item, close it\n    if (this.activeIndex !== null) {\n      this._deactivateElement(this.activeIndex);\n    }\n\n    // Clear any timers which may be running to close or open this\n    clearTimeout(this._openCloseTimer);\n\n    // Set the new index\n    this.activeIndex = index;\n\n    // If we don't have a popover yet, create it.\n    if (!this.popover) {\n      this._createPopover();\n    }\n\n    // Get the list of dates to show for this view.\n    this._initDatesToShow();\n\n    // Ensure the cached values are in line with the input values.\n    this.updateValues();\n\n    // Create a calendar or calendars inside the popover\n    this.render({\n      clearCache: true\n    });\n\n    // Finally, show the popover after a delay or on the next tick.\n    this._openCloseTimer = setTimeout(function () {\n      this.popover.open({\n        affixTo: this.els[index].querySelector('.spark-date__calendar-toggle')\n      });\n    }.bind(this), params.delay || 0);\n\n    // Activate the corresponding element\n    this._activateElement(index);\n\n    return this;\n  };\n\n  /**\n   * Close the calendar widget.\n   * @param {Object} params\n   */\n\n\n  CalendarPopover.prototype.close = function close(params) {\n\n    this._unfillToggle();\n\n    params = params || {};\n\n    // Can't close if we aren't or haven't yet opened.\n    if (this.activeIndex === null || !this.popover) {\n      return this;\n    }\n\n    // Deactive the corresponding element\n    this._deactivateElement(this.activeIndex);\n\n    // Clear any existing close or open events which are queued\n    clearTimeout(this._openCloseTimer);\n\n    // Close after a delay, or on the next tick\n    this.activeIndex = null;\n    this._openCloseTimer = setTimeout(function () {\n      this.popover.close();\n    }.bind(this), params.delay || 0);\n  };\n\n  /**\n   * Get the value.\n   * @param {Number|Element} index Optional\n   * @return {Mixed}\n   */\n\n\n  CalendarPopover.prototype.getValue = function getValue(index) {\n    return this.values[index || 0];\n  };\n\n  /**\n   * Set the date for a given element.\n   * @param {String|Object} value\n   * @param {Number|Element} index\n   * @param {Boolean} skipRangeCheck Optional Don't check for sequential range values.\n   */\n\n\n  CalendarPopover.prototype.setValue = function setValue(value, index, skipRangeCheck) {\n\n    var obj = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' ? value : parsedDomFormat.getValues(value);\n    var el = void 0;\n\n    // If we are passed an element instead of an index, use that.\n    if (index instanceof HTMLElement) {\n      el = index;\n      index = this.inputEls.indexOf(el);\n    }\n    // Otherwise, find the element in our list.\n    else {\n        index = index || 0;\n        el = this.inputEls[index];\n      }\n\n    // Update the stored value\n    this.values[index] = obj;\n\n    // If we are working with a range, make sure that the values are in order.\n    if (value) {\n      this._checkValues(index, skipRangeCheck);\n    }\n\n    // Set the value on the input element. Make sure we don't get into an infinite\n    // loop since we listen to the change event on the input. We have to trigger it\n    // so that other components listening to it get the update.\n    el.value = value && obj === value ? parsedDomFormat.getString(value) : value || '';\n\n    this._inputsChanging = this._inputsChanging || [];\n    if (this._inputsChanging.indexOf(index) === -1) {\n      this._inputsChanging.push(index);\n\n      (0, _triggerEvent2.default)(el, 'change');\n      (this.onChange || noop)(el, el.value, this);\n\n      var pos = this._inputsChanging.indexOf(index);\n      this._inputsChanging.splice(pos, 1);\n    }\n\n    this.render({\n      clearCache: true\n    });\n\n    return this;\n  };\n\n  /**\n   * Clear the selected values.\n   */\n\n\n  CalendarPopover.prototype.clearValues = function clearValues() {\n\n    var els = this.inputEls;\n    var i = 0;\n    var len = els.length;\n\n    for (; i < len; i++) {\n      this.clearValue(i);\n    }\n\n    return this;\n  };\n\n  /**\n   * Clear the selected value.\n   * @param {Number} index\n   */\n\n\n  CalendarPopover.prototype.clearValue = function clearValue() {\n    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    this.values = this.values || [];\n    if (!this.inputEls[index]) throw new Error('Cannot clear value at index ' + index + '. No input element exists with that index!');\n    this.values[index] = this.inputEls[index].value = null;\n    return this;\n  };\n\n  /**\n   * Take the date values from the inputs and set them as dates on the calendar.\n   */\n\n\n  CalendarPopover.prototype.updateValues = function updateValues() {\n\n    var els = this.inputEls;\n    var i = 0;\n    var len = els.length;\n\n    for (; i < len; i++) {\n      this.updateValue(i);\n    }\n\n    return this;\n  };\n\n  /**\n   * Take the date values from the inputs and set them as dates on the calendar.\n   * @param {Number} index\n   */\n\n\n  CalendarPopover.prototype.updateValue = function updateValue() {\n    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    this.values = this.values || [];\n    if (!this.inputEls[index]) throw new Error('Cannot update value at index ' + index + '. No input element exists with that index!');\n    this.values[index] = this.inputEls[index].value ? parsedDomFormat.getValues(this.inputEls[index].value) : null;\n    return this;\n  };\n\n  /**\n   * Disable the calendar functionality.\n   * @param {Number} index\n   */\n\n\n  CalendarPopover.prototype.disable = function disable(index) {\n\n    var i = index || 0;\n    var len = index !== undefined ? index + 1 : this.els.length;\n    var toggle = void 0;\n\n    for (; i < len; i++) {\n      this._isDisabled[i] = true;\n      this.els[i].setAttribute('disabled', '');\n      toggle = this.els[i].querySelector('.spark-date__calendar-toggle');\n      if (toggle) toggle.setAttribute('disabled', '');\n    }\n\n    this.close();\n\n    return this;\n  };\n\n  /**\n   * Enable the calendar functionality.\n   * @param {Number} index\n   */\n\n\n  CalendarPopover.prototype.enable = function enable(index) {\n\n    var i = index || 0;\n    var len = index !== undefined ? index + 1 : this.els.length;\n    var toggle = void 0;\n\n    for (; i < len; i++) {\n      this._isDisabled[i] = false;\n      this.els[i].removeAttribute('disabled', '');\n      toggle = this.els[i].querySelector('.spark-date__calendar-toggle');\n      if (toggle) toggle.removeAttribute('disabled');\n    }\n\n    return this;\n  };\n\n  /**\n   * Render the calendar or calendars into the popover.\n   * @param {Object} params\n   */\n\n\n  CalendarPopover.prototype.render = function render(params) {\n\n    params = params || {};\n\n    // If we don't have a popover yet, create it.\n    if (!this.popover) {\n      this._createPopover();\n    }\n\n    var content = void 0;\n\n    // Clear the cache so that we don't show out-of-date values.\n    if (params.clearCache) {\n      this._renderCache = {};\n    }\n\n    // Create the visible days, weeks, months or years\n    if (this.viewRange === 'year') content = this._renderYears();else if (this.viewRange === 'week') content = this._renderWeeks();else if (this.viewRange === 'day') content = this._renderDays();else content = this._renderMonths();\n\n    this._insertContent(content, params);\n\n    // Update attributes\n    this._updateAttributes();\n\n    return this;\n  };\n\n  /**\n   * Cleans up event listeners and removes helpers.\n   * @param {Boolean} leaveElement Leave the element intact.\n   */\n\n\n  CalendarPopover.prototype.remove = function remove(leaveElement) {\n    this.popover && this.popover.remove();\n    return _BaseComponent.prototype.remove.call(this, leaveElement);\n  };\n\n  /**\n   * Move to the next set of dates.\n   */\n\n\n  CalendarPopover.prototype.next = function next() {\n    if (this._atMax) return this;\n    this._setDatesToShow(1);\n    this.render({\n      append: 1\n    });\n    return this;\n  };\n\n  /**\n   * Move to the previous set of dates.\n   */\n\n\n  CalendarPopover.prototype.previous = function previous() {\n    if (this._atMin) return this;\n    this._setDatesToShow(-1);\n    this.render({\n      prepend: 1\n    });\n    return this;\n  };\n\n  /**\n   * Show a specific date on the calendar.\n   * @param {Object} params\n   */\n\n\n  CalendarPopover.prototype.showDate = function showDate(params) {\n\n    // Open if we're closed.\n    if (this.activeIndex === null) {\n      this.open();\n    }\n\n    var month = params.month || null;\n    var year = params.year || null;\n    var day = params.day || null;\n\n    // Nothing to do.\n    if (!month && !year && !day) {\n      return this;\n    }\n\n    var showing = this._datesToShow[this.activeIndex].clone();\n    var noun = this.viewRange.charAt(0).toUpperCase() + this.viewRange.slice(1);\n\n    // Only change the values we were given\n    if (year) {\n      showing.year = year;\n    }\n    if (month) {\n      showing.month = month;\n    }\n    if (day) {\n      showing.day = day;\n    }\n\n    // Check min\n    var min = this.mins[this.activeIndex];\n    if (min && showing['before' + noun](min)) {\n      showing = min.clone();\n    }\n\n    // Check max\n    var max = this.maxes[this.activeIndex];\n    if (max && showing['after' + noun](max)) {\n      showing = max.clone();\n    }\n    this._datesToShow[this.activeIndex] = showing;\n\n    // Populate the rest of the dates\n    this._setDatesToShow();\n\n    return this.render();\n  };\n\n  /**\n   * Render the appropriate number of years.\n   * @return {Array}\n   */\n\n\n  CalendarPopover.prototype._renderYears = function _renderYears() {\n    throw new Error('Displaying years in the calendar is not yet supported!');\n  };\n\n  /**\n   * Render the appropriate number of weeks.\n   * @return {Array}\n   */\n\n\n  CalendarPopover.prototype._renderWeeks = function _renderWeeks() {\n    throw new Error('Displaying weeks in the calendar is not yet supported!');\n  };\n\n  /**\n   * Render the appropriate number of days.\n   * @return {Array}\n   */\n\n\n  CalendarPopover.prototype._renderDays = function _renderDays() {\n    throw new Error('Displaying days in the calendar is not yet supported!');\n  };\n\n  /**\n   * Render the appropriate number of months.\n   * @return {Array}\n   */\n\n\n  CalendarPopover.prototype._renderMonths = function _renderMonths() {\n\n    var months = [];\n    var i = 0;\n    var len = this._datesToShow.length;\n    var current = _date2.default.now();\n\n    for (; i < len; i++) {\n      months.push(this._renderMonth(this._datesToShow[i], current));\n    }\n\n    return months;\n  };\n\n  /**\n   * Render a month.\n   * @param {Object} date\n   * @param {Object} current\n   * @return {Element}\n   */\n\n\n  CalendarPopover.prototype._renderMonth = function _renderMonth(date, current) {\n\n    // A unique key for this month used for caching\n    var key = date.year + '-' + date.month;\n\n    // Ensure we have a cache\n    this._renderCache = this._renderCache || {};\n\n    // Return a cached instance\n    if (this._renderCache[key]) {\n      return this._renderCache[key];\n    }\n\n    // Create the element\n    var el = document.createElement('div');\n    var html = '';\n    el.className = 'spark-calendar__month ' + this._getMonthClassNames(date);\n\n    // Add the title or dropdowns.\n    html += '<div class=\"spark-calendar__month-title\">';\n    if (this.quickJump && this.visibleCounts[this.activeIndex] === 1) {\n      html += this._renderMonthQuickJump(date);\n    } else {\n      html += date.monthName + ' ' + date.year;\n    }\n    html += '</div>';\n\n    // Add the days of the week headings\n    html += this._renderMonthDaysOfWeek();\n\n    // Add the days\n    html += this._renderMonthDays(date, current);\n\n    el.innerHTML = html;\n\n    // Store in the cache and return\n    return this._renderCache[key] = el;\n  };\n\n  /**\n   * Render the select inputs used for jumping ahead/backward several months.\n   * @param {Object} date\n   */\n\n\n  CalendarPopover.prototype._renderMonthQuickJump = function _renderMonthQuickJump(date) {\n\n    var el = document.createElement('div');\n    var years = void 0;\n    var months = void 0;\n\n    // Min and max year to show\n    var min = this.mins[this.activeIndex] ? this.mins[this.activeIndex].clone() : null;\n    var max = this.maxes[this.activeIndex] ? this.maxes[this.activeIndex].clone() : null;\n    var quickJumpRange = typeof this.quickJumpRange === 'number' && this.quickJumpRange % 1 === 0 ? this.quickJumpRange : 50;\n\n    // No min, go 50 years back\n    if (!min) {\n      min = date.clone();\n      min.year = min.year - quickJumpRange;\n    }\n\n    // No max, go 50 years forward\n    if (!max) {\n      max = date.clone();\n      max.year = max.year + quickJumpRange;\n    }\n\n    // Get the months to show.\n    var monthOpts = _date2.default.getMonthNames().map(function (val, i) {\n\n      // Don't show a month that is out of the valid range.\n      if (min.year === max.year && (i + 1 < min.month || i + 1 > max.month)) {\n        return null;\n      }\n\n      return {\n        value: i + 1,\n        text: val\n      };\n    }).filter(function (i) {\n      return i;\n    });\n\n    // Min and max are the same month, so just show text.\n    if (!monthOpts.length || monthOpts.length === 1) {\n      months = document.createElement('span');\n      months.innerHTML = date.monthName + ' ';\n    } else {\n\n      // Build a select list of months\n      months = document.createElement('label');\n      (0, _addClass2.default)(months, 'spark-select spark-calendar__select');\n      months.appendChild((0, _buildSelect2.default)({\n        selected: date.month,\n        attributes: {\n          class: 'spark-select__input',\n          name: 'month'\n        },\n        options: monthOpts\n      }));\n    }\n\n    // Min and max year are the same, so just show text.\n    if (min.year === max.year) {\n      years = document.createElement('span');\n      years.innerHTML = date.year;\n    } else {\n\n      // Build a select list of years\n      years = document.createElement('label');\n      (0, _addClass2.default)(years, 'spark-select spark-calendar__select');\n      years.appendChild((0, _buildSelect2.default)({\n        selected: date.year,\n        attributes: {\n          class: 'spark-select__input',\n          name: 'year'\n        },\n        options: (0, _range2.default)(max.year, min.year - 1)\n      }));\n    }\n\n    (0, _appendChildren2.default)(el, [months, years]);\n\n    return el.innerHTML;\n  };\n\n  /**\n   * Render the days of week row for a month calendar.\n   * @return {String}\n   */\n\n\n  CalendarPopover.prototype._renderMonthDaysOfWeek = function _renderMonthDaysOfWeek() {\n\n    var daysOfWeek = _date2.default.getDayNames();\n    var i = 0;\n    var len = daysOfWeek.length;\n    var str = '<div class=\"spark-calendar__days-of-week\">';\n\n    for (; i < len; i++) {\n      str += '<span class=\"spark-calendar__day-of-week\">' + daysOfWeek[i][0] + '</span>';\n    }\n\n    return str += '</div>';\n  };\n\n  /**\n   * Render the days of week row for a month calendar.\n   * @param {Object} date\n   * @param {Object} current\n   * @return {String}\n   */\n\n\n  CalendarPopover.prototype._renderMonthDays = function _renderMonthDays(date, current) {\n\n    var dayOfWeek = date.monthStart.dayOfWeek;\n    var startOfWeek = dayOfWeek > 1 ? date.monthStart.weekStart : null;\n    var monthEnd = date.monthEnd;\n    var weeks = 6;\n    var i = 0;\n    var j = 0;\n    var str = '<div class=\"spark-calendar__days\">';\n    var day = 0;\n    var month = startOfWeek ? startOfWeek.month : date.month;\n    var year = startOfWeek ? startOfWeek.year : date.year;\n    var isCurrentMonth = current.year === date.year && current.month === date.month;\n\n    // If we have days that come before the first of the month, the days will start as\n    // inactive. We use a 1 here to indicate the date is inactive and _before_\n    // the start of the month.\n    var inactive = startOfWeek ? 1 : null;\n\n    for (; i < weeks; i++) {\n      for (; j < 7; j++) {\n\n        day = startOfWeek ? startOfWeek.day + j : day + 1;\n        str += this._renderMonthDay(day, month, year, isCurrentMonth, current, inactive);\n\n        if (startOfWeek && j + 1 >= dayOfWeek - 1) {\n          startOfWeek = null;\n          inactive = null;\n          day = 0;\n          month = date.month;\n          year = date.year;\n          isCurrentMonth = current.year === date.year && current.month === date.month;\n        } else if (day >= monthEnd.day && i > 0) {\n\n          // Inactive days that come _after_ the last of the month are denoted with a 2.\n          // _renderMonthDay handles 1s and 2s differently, but both add the inactive class.\n          inactive = 2;\n          isCurrentMonth = false;\n\n          day = 0;\n          month++;\n\n          if (month > 12) {\n            year++;\n            month = 1;\n          }\n        }\n      }\n      j = 0;\n    }\n\n    return str += '</div>';\n  };\n\n  /**\n   * Render a day of the month.\n   * @param {Number} day\n   * @param {Number} month\n   * @param {Number} year\n   * @param {Boolean} isCurrentMonth\n   * @param {Object} current\n   * @param {Boolean} inactive\n   */\n\n\n  CalendarPopover.prototype._renderMonthDay = function _renderMonthDay(day, month, year, isCurrentMonth, current, inactive) {\n\n    var date = _date2.default.create({\n      year: year,\n      month: month,\n      day: day\n    });\n    var str = '<a';\n    var disabled = inactive || this._isDayDisabled(date);\n\n    str += !disabled ? ' data-date=\"' + parsedDomFormat.getString(date) + '\"' : '';\n    str += inactive ? ' data-direction=\"' + (inactive === 2 ? 'next' : 'previous') + '\"' : '';\n    str += ' class=\"spark-calendar__day';\n    str += isCurrentMonth && current.day === day && current.month === month && current.year === year ? ' spark-calendar__day--today' : '';\n    str += inactive ? ' spark-calendar__day--inactive' : '';\n    str += disabled ? ' spark-calendar__day--disabled' : '';\n    str += this._isDaySelected(date) ? ' spark-calendar__day--selected' : '';\n    str += this._isDayRangeStart(date) ? ' spark-calendar__range-start' : '';\n    str += this._isDayRangeMiddle(date) ? ' spark-calendar__range-middle' : '';\n    str += this._isDayRangeEnd(date) ? ' spark-calendar__range-end' : '';\n    str += this._isDayRangeLast(date) ? ' spark-calendar__range-last' : '';\n    str += '\"';\n    str += ' href=\"#\"><span>';\n    str += day;\n    str += this._getDayInfo(date);\n    str += '</span></a>';\n\n    return str;\n  };\n\n  /**\n   * Render the children into the content.\n   * @param {Array} content\n   */\n\n\n  CalendarPopover.prototype._insertContent = function _insertContent(content, params) {\n\n    this._currentContent = this._currentContent || [];\n\n    params = params || {};\n\n    var keep = void 0;\n    var i = 0;\n    var len = void 0;\n\n    // If we've been asked to prepend or append, add the new elements in front,\n    // save the number of old elements we're sliding out, animate,\n    // then clean up.\n    if (this.animate) {\n\n      if (params.prepend) {\n\n        // Get the last elements to keep\n        keep = this._currentContent.slice(-params.prepend);\n        len = keep.length;\n        for (; i < len; i++) {\n          content.push(keep[i]);\n        }\n\n        this.calendarEl.setAttribute('data-prepend-count', len);\n\n        this._animateContent(function () {\n\n          this.calendarEl.removeAttribute('data-prepend-count');\n\n          this._animateContent(function () {\n            content = content.slice(0, -params.prepend);\n            this._insertContent(content);\n          }, this.animationDuration);\n        }, 10);\n      }\n      // Same but appending\n      else if (params.append) {\n\n          // Get the first elements to keep\n          keep = this._currentContent.slice(0, params.append);\n          len = keep.length;\n          for (; i < len; i++) {\n            content.unshift(keep[i]);\n          }\n\n          this.calendarEl.setAttribute('data-append-count', len);\n\n          this._animateContent(function () {\n\n            (0, _addClass2.default)(this.calendarEl, 'no-animate');\n            content = content.slice(params.append);\n            this._insertContent(content);\n            this.calendarEl.removeAttribute('data-append-count');\n\n            this._animateContent(function () {\n              (0, _removeClass2.default)(this.calendarEl, 'no-animate');\n            }, 10);\n          }, this.animationDuration);\n        }\n    }\n\n    (0, _appendChildren2.default)(this.calendarContentEl, this._currentContent = content, true);\n  };\n\n  /**\n   * Is a given day selected?\n   * @param {Object} date\n   * @return {Boolean}\n   */\n\n\n  CalendarPopover.prototype._isDaySelected = function _isDaySelected(date) {\n    return this.values && date.equal(this.values);\n  };\n\n  /**\n   * Is a given day the start of a range?\n   * @param {Object} date\n   * @return {Boolean}\n   */\n\n\n  CalendarPopover.prototype._isDayRangeStart = function _isDayRangeStart(date) {\n    return this.inputEls.length > 1 && this.values && date.equal(this.values[0]);\n  };\n\n  /**\n   * Is a given day the middle of a range?\n   * @param {Object} date\n   * @return {Boolean}\n   */\n\n\n  CalendarPopover.prototype._isDayRangeMiddle = function _isDayRangeMiddle(date) {\n    return this.inputEls.length > 1 && this.values && this.values.length > 1 && date.equal(this.values.slice(1, -1));\n  };\n\n  /**\n   * Is a given day the end of a range?\n   * @param {Object} date\n   * @return {Boolean}\n   */\n\n\n  CalendarPopover.prototype._isDayRangeEnd = function _isDayRangeEnd(date) {\n    return this.inputEls.length > 1 && this.values && this.values.length > 1 && date.equal(this.values[this.values.length - 1]);\n  };\n\n  /**\n   * Is a given day currently the last\n   * @param {Object} date\n   * @return {Boolean}\n   */\n\n\n  CalendarPopover.prototype._isDayRangeLast = function _isDayRangeLast(date) {\n\n    var i = this.values.length - 1;\n\n    for (; i > 0; i--) {\n\n      // We have a value and it's not the same as the date.\n      if (this.values[i]) {\n        if (!date.equal(this.values[i])) {\n          return false;\n        }\n        break;\n      }\n    }\n\n    return true;\n  };\n\n  /**\n   * Is a given day disabled?\n   * @param {Object} date\n   * @return {Boolean}\n   */\n\n\n  CalendarPopover.prototype._isDayDisabled = function _isDayDisabled(date) {\n    return this.daysDisabled && this.daysDisabled[date.year] && this.daysDisabled[date.year][date.month] && this.daysDisabled[date.year][date.month].indexOf(date.day) !== -1 || this.mins[this.activeIndex] && date.before(this.mins[this.activeIndex], true) || this.maxes[this.activeIndex] && date.after(this.maxes[this.activeIndex], true);\n  };\n\n  /**\n   * Get any \"info\" for a given day.\n   * @param {Object} date\n   * @return {String}\n   */\n\n\n  CalendarPopover.prototype._getDayInfo = function _getDayInfo(date) {\n    return this.daysInfo && this.daysInfo[date.year] && this.daysInfo[date.year][date.month] && this.daysInfo[date.year][date.month][date.day] ? '<span class=\"spark-calendar__day-note\">' + this.daysInfo[date.year][date.month][date.day] + '</span>' : '';\n  };\n\n  /**\n   * Get the class names for a month.\n   * @param {Object} date\n   * @return {String}\n   */\n\n\n  CalendarPopover.prototype._getMonthClassNames = function _getMonthClassNames(date) {\n\n    var cls = [];\n\n    // Do we have a value in this month?\n    if (date.equalMonth(this.values)) {\n      cls.push('has-value');\n    }\n\n    // Does this month have the start, middle or end of a range?\n    if (this._isRange && this.els.length > 1) {\n\n      var start = date.equalMonth(this.values[0]);\n      var end = date.equalMonth(this.values[this.values.length - 1]);\n      var middle = date.equalMonth(this.values.slice(1, -1));\n      var valBefore = date.afterMonth(this.values);\n      var valAfter = date.beforeMonth(this.values);\n      var afterEnd = this.values[this.values.length - 1] && date.after(this.values[this.values.length - 1]);\n\n      if (start) {\n        cls.push('range-start');\n      }\n      if (end) {\n        cls.push('range-end');\n      }\n      if (middle) {\n        cls.push('range-middle');\n      }\n      if (valBefore) {\n        cls.push('value-before');\n      }\n      if (valAfter) {\n        cls.push('value-after');\n      }\n      if (afterEnd) {\n        cls.push('after-range-end');\n      }\n    }\n\n    return cls.join(' ');\n  };\n\n  /**\n   * Create the calendar.\n   */\n\n\n  CalendarPopover.prototype._createCalendar = function _createCalendar() {\n    var el = document.createElement('div');\n    (0, _addClass2.default)(el, 'spark-calendar');\n    el.innerHTML = '<nav class=\"spark-calendar__nav\"><button class=\"spark-calendar__previous spark-icon-chevron-left\" title=\"Previous\"></button><button class=\"spark-calendar__next spark-icon-chevron-right\" title=\"Next\"></button></nav><div class=\"spark-calendar__overflow\"><div class=\"spark-calendar__content\"></div></div>';\n    this.calendarEl = el;\n    this.calendarContentEl = el.querySelector('.spark-calendar__content');\n    this.calendarOverflowEl = el.querySelector('.spark-calendar_overflow');\n  };\n\n  /**\n   * Create the popover.\n   */\n\n\n  CalendarPopover.prototype._createPopover = function _createPopover() {\n\n    this.popover = new _popover2.default(document.createElement('div'), {\n      anchorX: 'center',\n      anchorY: 'bottom',\n      contentEl: this.calendarEl,\n      onClose: this._onPopoverClose.bind(this),\n      onOpen: this._onPopoverOpen.bind(this)\n    });\n  };\n\n  /**\n   * Cache elements.\n   */\n\n\n  CalendarPopover.prototype._cacheElements = function _cacheElements() {\n\n    this.inputEls = [];\n\n    var i = 0;\n    var len = this.els.length;\n    var input = void 0;\n\n    for (; i < len; i++) {\n      input = this.els[i].nodeName.toLowerCase() === 'input' ? this.els[i] : this.els[i].querySelector('input[type=\"date\"]');\n      this.inputEls[i] = input;\n    }\n  };\n\n  /**\n   * Cache elements specific to the calendar.\n   */\n\n\n  CalendarPopover.prototype._cacheCalendarElements = function _cacheCalendarElements() {\n    this.nextButtonEl = this.calendarEl.querySelector('.spark-calendar__next');\n    this.previousButtonEl = this.calendarEl.querySelector('.spark-calendar__previous');\n  };\n\n  /**\n   * Parse parameters from the elements.\n   */\n\n\n  CalendarPopover.prototype._parseParams = function _parseParams() {\n\n    this._parseInputElsParams();\n\n    this._isRange = this.els.length > 1 ? true : false;\n    this.autoAdvance = this.autoAdvance !== null ? this.autoAdvance : (0, _parseAttribute.boolean)(this.els[0], 'data-auto-advance', true);\n    this.autoClose = this.autoClose !== null ? this.autoClose : (0, _parseAttribute.boolean)(this.els[0], 'data-auto-close', true);\n    this.closeDelay = this.closeDelay !== null ? this.closeDelay : (0, _parseAttribute.number)(this.els[0], 'data-close-delay', 500);\n    this.quickJump = this.quickJump !== null ? this.quickJump : (0, _parseAttribute.boolean)(this.els[0], 'data-quick-jump', false);\n    this.viewRange = this.viewRange !== null ? this.viewRange : (0, _parseAttribute.string)(this.els[0], 'data-view-range', 'month');\n    this.animate = this.animate !== null ? this.animate : (0, _parseAttribute.boolean)(this.els[0], 'data-animate', true);\n    this.animationDuration = this.animationDuration !== null ? this.animationDuration : (0, _parseAttribute.number)(this.els[0], 'data-animation-duration', 100);\n    this.showOnFocus = this.showOnFocus !== null ? this.showOnFocus : (0, _parseAttribute.boolean)(this.els[0], 'data-show-on-focus', false);\n  };\n\n  /**\n   * Parse the min, max, value and visible counts from the elements if we can.\n   * @return {Number|Boolean}\n   */\n\n\n  CalendarPopover.prototype._parseInputElsParams = function _parseInputElsParams() {\n\n    var els = this.inputEls;\n\n    if (!els) {\n      return;\n    }\n\n    var i = 0;\n    var len = els.length;\n    var mins = [];\n    var maxes = [];\n    var values = [];\n    var visibleCounts = [];\n    var disableds = [];\n\n    for (; i < len; i++) {\n\n      if (!els[i]) {\n        continue;\n      }\n\n      if (this.mins && this.mins[i]) mins[i] = _typeof(this.mins[i]) === 'object' ? this.mins[i] : parsedDomFormat.getValues(this.mins[i]);else if (els[i].getAttribute('min')) mins[i] = parsedDomFormat.getValues(els[i].getAttribute('min'));\n\n      if (this.maxes && this.maxes[i]) maxes[i] = _typeof(this.maxes[i]) === 'object' ? this.maxes[i] : parsedDomFormat.getValues(this.maxes[i]);else if (els[i].getAttribute('max')) maxes[i] = parsedDomFormat.getValues(els[i].getAttribute('max'));\n\n      if (this.values && this.values[i]) values[i] = _typeof(this.values[i]) === 'object' ? this.values[i] : parsedDomFormat.getValues(this.values[i]);else if (els[i].value) values[i] = parsedDomFormat.getValues(els[i].value);\n\n      disableds[i] = (0, _parseAttribute.boolean)(els[i], 'disabled', false);\n\n      if (!this.visibleCounts) visibleCounts[i] = parseInt(els[i].getAttribute('data-visible-count'), 10) || 1;\n    }\n\n    this.mins = mins;\n    this.minVisible = _date2.default.earliest(mins);\n    this.maxes = maxes;\n    this.maxVisible = _date2.default.latest(maxes);\n    this.values = values;\n    this._isDisabled = disableds;\n    if (visibleCounts.length) this.visibleCounts = visibleCounts;\n  };\n\n  /**\n   * Get the dates we should be showing. Start with the first value or today's date.\n   */\n\n\n  CalendarPopover.prototype._initDatesToShow = function _initDatesToShow() {\n\n    var arr = [];\n    var i = 0;\n    var len = this.values.length;\n\n    // Get the date for the current index\n    if (this.values[this.activeIndex]) {\n      arr.push(this.values[this.activeIndex].clone());\n    }\n\n    // Get the first date\n    for (; i < len && !arr.length; i++) {\n      if (this.values[i]) {\n        arr.push(this.values[i].clone());\n      }\n    }\n\n    // If we didn't get a date, use the min\n    for (i = 0, len = this.mins.length; i < len && !arr.length; i++) {\n      if (this.mins[i]) {\n        arr.push(this.mins[i].clone());\n      }\n    }\n\n    // If we still didn't get a date, add today's date.\n    if (!arr.length) {\n      arr.push(_date2.default.now());\n    }\n\n    this._datesToShow = arr;\n\n    this._setDatesToShow();\n  };\n\n  /**\n   * Set the dates to show.\n   * @param {Number} change Optional The direction to change\n   */\n\n\n  CalendarPopover.prototype._setDatesToShow = function _setDatesToShow(change) {\n\n    var arr = this._datesToShow;\n    var visibleCount = this._currentBreakpoint === 'xs' || this._currentBreakpoint === 'sm' ? 1 : this.visibleCounts[this.activeIndex] || this.visibleCounts[0] || 1;\n    var i = 0;\n    var noun = this.viewRange.charAt(0).toUpperCase() + this.viewRange.slice(1);\n\n    // If we have more dates to show than we're supposed to show, remove the excess.\n    // This happens when visible count changes between renders\n    if (arr.length > visibleCount) {\n      arr.splice(visibleCount);\n    }\n\n    // If we are incrementing or decrementing the starting month\n    if (change) {\n\n      // Empty the rest of the dates from the array\n      arr = this._datesToShow = arr.splice(0, 1);\n\n      // Decrement\n      if (change < 0) {\n        for (; i > change; i--) {\n          arr[0] = arr[0]['previous' + noun];\n        }\n      } else {\n        for (; i < change; i++) {\n          arr[0] = arr[0]['next' + noun];\n        }\n      }\n    }\n\n    // Check bounds\n    this._atMin = this._checkMinDateVisible(noun, arr);\n    this._atMax = this._checkMaxDateVisible(noun, arr);\n\n    var addDate = void 0;\n    var lastSelected = void 0;\n    var action = void 0;\n    i = 0;\n\n    // Add additional dates\n    while (arr.length < visibleCount) {\n\n      // If at the max, prepend\n      // If we're in the last input and it has a value and it's a different month than the first value, prepend\n      // If at the min, append\n      // If an item we're adding is before the min, discard it and append an item after the last in the arr\n      // If an item we're adding is after the max, discard it and prepend an item before the first in the arr\n\n      lastSelected = !change && this.activeIndex === this.values.length - 1 && this.values[this.values.length - 1] && this.values[0] && !this.values[this.values.length - 1]['equal' + noun](this.values, true);\n\n      // If we're showing the max date or we have the last input selected and it has a value, add dates before.\n      if (this._atMax || lastSelected) {\n\n        addDate = arr[i]['previous' + noun];\n        action = 'unshift';\n\n        if (addDate['before' + noun](this.minVisible)) {\n          addDate = arr[i]['next' + noun];\n          action = 'push';\n        }\n      } else {\n\n        addDate = arr[i]['next' + noun];\n        action = 'push';\n\n        if (addDate['after' + noun](this.maxVisible)) {\n          addDate = arr[i]['previous' + noun];\n          action = 'unshift';\n        }\n      }\n\n      if (action === 'push') {\n        arr.push(addDate);\n        i = arr.length - 1;\n      } else {\n        arr.unshift(addDate);\n        i = 0;\n      }\n    }\n\n    // Check bounds again\n    this._atMin = this._checkMinDateVisible(noun, arr);\n    this._atMax = this._checkMaxDateVisible(noun, arr);\n\n    // Update the navigation to reflect the _atMin or _atMax state\n    this._updateNav();\n  };\n\n  /**\n   * Check for the min value in an array of values.\n   * @param {Object} min\n   * @param {String} noun The type of date to check\n   * @param {Array} arr\n   * @return {Boolean}\n   */\n\n\n  CalendarPopover.prototype._checkMinDateVisible = function _checkMinDateVisible(noun, arr) {\n\n    if (!this.minVisible) {\n      return;\n    }\n\n    var min = this.minVisible;\n\n    if (min && (arr[0]['equal' + noun](min) || arr[0]['before' + noun](min))) {\n      arr[0] = min;\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * Check for the max value in an array of values.\n   * @param {Object} max\n   * @param {String} noun The type of date to check\n   * @param {Array} arr\n   * @return {Boolean}\n   */\n\n\n  CalendarPopover.prototype._checkMaxDateVisible = function _checkMaxDateVisible(noun, arr) {\n\n    if (!this.maxVisible) {\n      return;\n    }\n\n    var max = this.maxVisible;\n\n    if (max && arr[arr.length - 1] && (arr[arr.length - 1]['equal' + noun](max) || arr[arr.length - 1]['after' + noun](max))) {\n      arr[arr.length - 1] = max;\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * Check that the values are in bounds and, optinoally, in sequential order.\n   * If checking for sequence, remove those which aren't.\n   * @param {Number} setIndex The index of the value most recently set. This shouldn't be removed.\n   * @return {Boolean} Did any values change?\n   */\n\n\n  CalendarPopover.prototype._checkValues = function _checkValues(setIndex, skipRangeCheck) {\n\n    // Check boundaries\n    var changed = this._checkMinMaxValues();\n\n    // Sequential range items check\n    if (this._isRange && !skipRangeCheck) {\n\n      var i = this.values.length - 1;\n\n      for (; i >= 0; i--) {\n        if (this.values[i] && this.values[i - 1] && this.values[i].beforeDay(this.values[i - 1], true)) {\n          if (i === setIndex) {\n            this.setValue(null, i - 1, true);\n          } else {\n            this.setValue(null, i, true);\n          }\n          changed = true;\n        }\n      }\n    }\n\n    return changed;\n  };\n\n  /**\n   * Check minimum/maximum values.\n   * @return {Boolean}\n   */\n\n\n  CalendarPopover.prototype._checkMinMaxValues = function _checkMinMaxValues() {\n\n    var i = 0;\n    var len = this.values.length;\n    var changed = false;\n\n    for (; i < len; i++) {\n      if (this.maxes && this.maxes[i] && this.values[i] && this.values[i].after(this.maxes[i], true)) {\n        this.values[i] = this.maxes[i].clone();\n        changed = true;\n      } else if (this.mins && this.mins[i] && this.values[i] && this.values[i].before(this.mins[i], true)) {\n        this.values[i] = this.mins[i].clone();\n        changed = true;\n      }\n    }\n\n    return changed;\n  };\n\n  /**\n   * Enqueue animations to be run. (Not really animations since those happen w/ CSS. More\n   * of a manager of timeouts).\n   * @param {Function} cb\n   * @param {Number} duration\n   */\n\n\n  CalendarPopover.prototype._animateContent = function _animateContent(cb, duration) {\n    this._animationQueue = this._animationQueue || [];\n    this._animationQueue.push({\n      cb: cb,\n      d: duration\n    });\n    this._runAnimation();\n  };\n\n  /**\n   * Run the first queued animation. When complete, run the next animation.\n   */\n\n\n  CalendarPopover.prototype._runAnimation = function _runAnimation() {\n\n    if (!this._animationTimer) {\n\n      var a = this._animationQueue.shift();\n\n      if (a) {\n\n        this._animationTimer = setTimeout(function () {\n          a.cb.call(this);\n          this._animationTimer = null;\n          this._runAnimation();\n        }.bind(this), a.d);\n      }\n    }\n  };\n\n  /**\n   * Update attributes on the element and its children.\n   */\n\n\n  CalendarPopover.prototype._updateAttributes = function _updateAttributes() {\n    this.calendarEl.setAttribute('data-visible-count', this._currentBreakpoint === 'xs' ? 1 : this.visibleCounts[this.activeIndex] || this.visibleCounts[0] || 1);\n    this._updateNav();\n  };\n\n  /**\n   * Update the navigation to reflect the ability to move forward and backward.\n   */\n\n\n  CalendarPopover.prototype._updateNav = function _updateNav() {\n\n    if (this.previousButtonEl) {\n      if (this._atMin) this.previousButtonEl.setAttribute('disabled', true);else this.previousButtonEl.removeAttribute('disabled');\n    }\n\n    if (this.nextButtonEl) {\n      if (this._atMax) this.nextButtonEl.setAttribute('disabled', true);else this.nextButtonEl.removeAttribute('disabled');\n    }\n  };\n\n  /**\n   * Create bound versions of event listener callbacks and store them.\n   * Otherwise we can't unbind from these events later because the\n   * function signatures won't match.\n   */\n\n\n  CalendarPopover.prototype._bindEventListenerCallbacks = function _bindEventListenerCallbacks() {\n\n    this._onInputChangeBound = this._onInputChange.bind(this);\n    this._onSelectChangeBound = this._onSelectChange.bind(this);\n    this._onInputFocusBound = this._onInputFocus.bind(this);\n    this._onClickBound = this._onClick.bind(this);\n    this._onCalendarClickBound = this._onCalendarClick.bind(this);\n\n    this._onCalendarMouseOverBound = this._onCalendarMouseOver.bind(this);\n    this._onCalendarMouseOutBound = this._onCalendarMouseOut.bind(this);\n\n    this._onResizeBound = this._onResize.bind(this);\n  };\n\n  /**\n   * Add event listeners for DOM events.\n   */\n\n\n  CalendarPopover.prototype._addEventListeners = function _addEventListeners() {\n\n    var i = 0;\n    var len = this.els.length;\n\n    for (; i < len; i++) {\n      this.els[i].addEventListener('click', this._onClickBound);\n      this.inputEls[i].addEventListener('change', this._onInputChangeBound);\n      this.inputEls[i].addEventListener('focus', this._onInputFocusBound);\n    }\n\n    this.calendarEl.addEventListener('mouseover', this._onCalendarMouseOverBound);\n    this.calendarEl.addEventListener('mouseout', this._onCalendarMouseOutBound);\n    this.calendarEl.addEventListener('click', this._onCalendarClickBound);\n\n    this.calendarEl.addEventListener('change', this._onSelectChangeBound);\n\n    window.addEventListener('resize', this._onResizeBound);\n    window.addEventListener('orientationchange', this._onResizeBound);\n  };\n\n  /**\n   * Remove event listeners for DOM events..\n   */\n\n\n  CalendarPopover.prototype._removeEventListeners = function _removeEventListeners() {\n\n    var i = 0;\n    var len = this.els.length;\n\n    for (; i < len; i++) {\n      this.els[i].removeEventListener('click', this._onClickBound);\n      this.inputEls[i].removeEventListener('change', this._onInputChangeBound);\n      this.inputEls[i].removeEventListener('focus', this._onInputFocusBound);\n    }\n\n    this.calendarEl.removeEventListener('mouseover', this._onCalendarMouseOverBound);\n    this.calendarEl.removeEventListener('mouseout', this._onCalendarMouseOutBound);\n    this.calendarEl.removeEventListener('click', this._onCalendarClickBound);\n\n    this.calendarEl.removeEventListener('change', this._onSelectChangeBound);\n\n    window.removeEventListener('resize', this._onResizeBound);\n    window.removeEventListener('orientationchange', this._onResizeBound);\n  };\n\n  /**\n   * Focus on the next input if there is one.\n   */\n\n\n  CalendarPopover.prototype._focusNext = function _focusNext() {\n\n    var index = void 0;\n\n    // If we don't have any null values, don't do anything.\n    if ((index = this.values.indexOf(null)) === -1) {\n      return;\n    }\n\n    if (this.activeIndex < this.els.length - 1) {\n      this.open(this.activeIndex + 1);\n    } else {\n      this.open(index);\n    }\n  };\n\n  /**\n   * Close if we're on the last input and we have values.\n   */\n\n\n  CalendarPopover.prototype._closeOnLast = function _closeOnLast() {\n    if (this.values.indexOf(null) === -1) {\n      this.close({\n        delay: this.closeDelay\n      });\n    }\n  };\n\n  /**\n   * Make the toggle icon a fill icon.\n   */\n\n\n  CalendarPopover.prototype._fillToggle = function _fillToggle() {\n\n    var toggle = void 0;\n\n    if (this.els[this.activeIndex] && (toggle = this.els[this.activeIndex].querySelector('.spark-date__calendar-toggle [class*=\"spark-icon\"]'))) {\n      (0, _addClass2.default)(toggle, 'spark-icon--fill');\n    }\n  };\n\n  /**\n   * Make the toggle icon a line icon.\n   */\n\n\n  CalendarPopover.prototype._unfillToggle = function _unfillToggle() {\n\n    var toggle = void 0;\n\n    if (this.els[this.activeIndex] && (toggle = this.els[this.activeIndex].querySelector('.spark-date__calendar-toggle [class*=\"spark-icon\"]'))) {\n      (0, _removeClass2.default)(toggle, 'spark-icon--fill');\n    }\n  };\n\n  /**\n   * Activate the element associated with the calendar.\n   * @param {Number} index\n   */\n\n\n  CalendarPopover.prototype._activateElement = function _activateElement(index) {\n    var el = this.els[index];\n    if (el) (0, _addClass2.default)(el, 'active');\n  };\n\n  /**\n   * Deactivate the element associated with the calendar.\n   * @param {Number} index\n   */\n\n\n  CalendarPopover.prototype._deactivateElement = function _deactivateElement(index) {\n    var el = this.els[index];\n    if (el && !this.values[index] && !(0, _hasClass2.default)(el, 'focus') && !(0, _hasClass2.default)(el, 'has-partial-value')) {\n      (0, _removeClass2.default)(el, 'active');\n    }\n  };\n\n  /**\n   * Check the size of the popover and see if we should be showing the XS treatment.\n   */\n\n\n  CalendarPopover.prototype._checkSize = function _checkSize() {\n\n    var bp = (0, _breakpoint.get)(window.outerWidth);\n\n    // Don't do anything if the breakpoint hasn't changed.\n    if (this._currentBreakpoint === bp) return;\n\n    // Store the breakpoint\n    this._currentBreakpoint = bp;\n\n    // Re-render the date range\n    this._setDatesToShow();\n    this.render(true);\n    this.popover.update();\n  };\n\n  /**\n   * Scroll the active input element into view.\n   */\n\n\n  CalendarPopover.prototype._scrollToInput = function _scrollToInput() {\n    var el = this.els[this.activeIndex];\n    if (el) (0, _scrollTo2.default)(el);\n  };\n\n  /**\n   * Update the hover classes.\n   * @param {Element} hoverStarts\n   * @param {Element} hoverEnds\n   */\n\n\n  CalendarPopover.prototype._updateHoverClasses = function _updateHoverClasses(hoverStarts, hoverEnds) {\n\n    this._hoverStarts = this._hoverStarts || [];\n    this._hoverEnds = this._hoverEnds || [];\n\n    hoverStarts = hoverStarts instanceof Array ? hoverStarts : hoverStarts ? [hoverStarts] : [];\n    hoverEnds = hoverEnds instanceof Array ? hoverEnds : hoverEnds ? [hoverEnds] : [];\n\n    var allStarts = [];\n    var curStarts = [];\n    var newStarts = [];\n    var allEnds = [];\n    var curEnds = [];\n    var newEnds = [];\n\n    hoverStarts.forEach(function (el) {\n\n      var index = this._hoverStarts.indexOf(el);\n\n      // Already hovered.\n      if (index !== -1) {\n        curStarts.push(el);\n      }\n      // Not already hovered. Ready to add the class.\n      else if (el) {\n          newStarts.push(el);\n          (0, _addClass2.default)(el, 'hover-start');\n        }\n    }, this);\n\n    allStarts = Array.prototype.concat.call([], curStarts, newStarts);\n\n    this._hoverStarts.forEach(function (el) {\n      if (allStarts.indexOf(el) === -1) {\n        (0, _removeClass2.default)(el, 'hover-start');\n      }\n    }, this);\n\n    hoverEnds.forEach(function (el) {\n\n      var index = this._hoverEnds.indexOf(el);\n\n      // Already hovered.\n      if (index !== -1) {\n        curEnds.push(el);\n      }\n      // Not already hovered. Ready to add the class.\n      else if (el) {\n          newEnds.push(el);\n          (0, _addClass2.default)(el, 'hover-end');\n        }\n    }, this);\n\n    allEnds = Array.prototype.concat.call([], curEnds, newEnds);\n\n    this._hoverEnds.forEach(function (el) {\n      if (allEnds.indexOf(el) === -1) {\n        (0, _removeClass2.default)(el, 'hover-end');\n      }\n    }, this);\n\n    this._hoverStarts = allStarts;\n    this._hoverEnds = allEnds;\n  };\n\n  /**\n   * When an element is clicked, if the toggle was the target, open the popover.\n   * @param {Object} e\n   */\n\n\n  CalendarPopover.prototype._onClick = function _onClick(e) {\n\n    if ((0, _getParent2.default)(e.target, '.spark-date__calendar-toggle', this.els)) {\n\n      var el = (0, _getParent2.default)(e.target, '.spark-date', this.els);\n      var index = this.els.indexOf(el);\n\n      e.preventDefault();\n\n      // Open on the next tick. Otherwise we also receive the window click close event.\n      this.open(index, {\n        delay: 1\n      });\n    }\n  };\n\n  /**\n   * When the calendar is hovered, do some highlighting if we're showing a range.\n   * @param {Object} e\n   */\n\n\n  CalendarPopover.prototype._onCalendarMouseOver = function _onCalendarMouseOver(e) {\n    if (this.viewRange === 'month') this._onCalendarMouseOverMonths(e.target);\n  };\n\n  /**\n   * Set hover states for days.\n   * @param  {Element} target\n   */\n\n\n  CalendarPopover.prototype._onCalendarMouseOverMonths = function _onCalendarMouseOverMonths(target) {\n\n    if (!this._isRange) {\n      return;\n    }\n\n    var day = (0, _getParent2.default)(target, '.spark-calendar__day');\n\n    if (!day) {\n      this._updateHoverClasses();\n      return;\n    }\n\n    var month = (0, _getParent2.default)(target, '.spark-calendar__month');\n    var mHasClass = function (c) {\n      return (0, _hasClass2.default)(month, c);\n    }.bind(this);\n    var newStart = [];\n    var newEnd = [];\n    var daySel = void 0;\n\n    // Only do highlights if we don't already have a value for this index.\n    if (!this.values[this.activeIndex]) {\n\n      // A month with a value before it but no value of its own, hover starts\n      // from the first day to the hovered day.\n      if (mHasClass('value-before') && !mHasClass('after-range-end') && !mHasClass('has-value') && !mHasClass('value-after')) {\n\n        newStart.push(month.querySelector('.spark-calendar__day:not(.spark-calendar__day--inactive):not(.spark-calendar__day--disabled)'));\n        newEnd.push(day);\n\n        // Add a hover range to a previous month.\n        var prevMonth = month;\n        while ((prevMonth = (0, _getSiblingBefore2.default)(prevMonth, '.spark-calendar__month')) && !(0, _hasClass2.default)(prevMonth, 'value-after') && ((0, _hasClass2.default)(prevMonth, 'has-value') || (0, _hasClass2.default)(prevMonth, 'value-before'))) {\n\n          daySel = prevMonth.querySelectorAll('.spark-calendar__day--selected');\n          daySel = daySel[daySel.length - 1];\n          daySel = daySel || prevMonth.querySelector('.spark-calendar__day');\n\n          if (daySel) {\n            newStart.push(daySel);\n            daySel = prevMonth.querySelectorAll('.spark-calendar__day');\n            daySel = daySel[daySel.length - 1];\n            newEnd.push(daySel);\n          }\n        }\n      }\n      // A month with a value, highlight either from the hovered day to\n      // the selection or from the selection to the day.\n      else if (mHasClass('has-value') && !mHasClass('value-before') && !mHasClass('value-after') && ((newStart = (0, _getSiblingBefore2.default)(day, '.spark-calendar__day--selected')) || (newEnd = (0, _getSiblingAfter2.default)(day, '.spark-calendar__day--selected')))) {\n\n          if (newStart) {\n            newStart = [newStart];\n            newEnd = [day];\n          } else {\n            newEnd = [newEnd];\n            newStart = [day];\n          }\n\n          if ((0, _hasClass2.default)(newEnd[0], 'spark-calendar__range-start') || (0, _hasClass2.default)(newStart[0], 'spark-calendar__range-end')) {\n            newStart = [];\n            newEnd = [];\n          }\n        }\n        // A month with a middle range should highlight before\n        else if (mHasClass('has-value') && mHasClass('range-middle') && mHasClass('value-before')) {\n            daySel = (0, _getSiblingBefore2.default)(day, '.spark-calendar__day--selected');\n            if (daySel) {\n              newStart = [daySel];\n              newEnd = [day];\n            }\n          }\n    }\n\n    this._updateHoverClasses(newStart, newEnd);\n  };\n\n  /**\n   * When the calendar is hovered, undo some highlighting if we're showing a range.\n   * @param {Object} e\n   */\n\n\n  CalendarPopover.prototype._onCalendarMouseOut = function _onCalendarMouseOut(e) {\n    if (this.viewRange === 'month') this._onCalendarMouseOutMonths(e.target);\n  };\n\n  /**\n   * Clear hover states for days.\n   * @param  {Element} target\n   */\n\n\n  CalendarPopover.prototype._onCalendarMouseOutMonths = function _onCalendarMouseOutMonths(target) {\n\n    var day = (0, _getParent2.default)(target, '.spark-calendar__day');\n    var days = (0, _getParent2.default)(target, '.spark-calendar__days');\n    var month = (0, _getParent2.default)(target, '.spark-calendar__month');\n\n    (0, _removeClass2.default)(day, 'hover');\n    (0, _removeClass2.default)(days, 'hover');\n    (0, _removeClass2.default)(month, 'hover');\n    (0, _removeClass2.default)(this.calendarEl, 'hover');\n  };\n\n  /**\n   * When the calendar is clicked, handle navigation clicks and date selections.\n   * @param {Object} e\n   */\n\n\n  CalendarPopover.prototype._onCalendarClick = function _onCalendarClick(e) {\n\n    var nav = (0, _getParent2.default)(e.target, '.spark-calendar__nav', this.calendarEl);\n    var day = void 0;\n    var dir = void 0;\n\n    // Navigation clicks\n    if (nav) {\n\n      // Previous\n      if ((0, _getParent2.default)(e.target, '.spark-calendar__previous', nav)) {\n        this.previous();\n      }\n      // Next\n      else if ((0, _getParent2.default)(e.target, '.spark-calendar__next', nav)) {\n          this.next();\n        }\n    }\n    // Day click\n    else if (day = (0, _getParent2.default)(e.target, '.spark-calendar__day')) {\n\n        e.preventDefault();\n        e.stopPropagation();\n\n        // Disabled day moves can move us to the next month\n        if ((0, _hasClass2.default)(day, 'spark-calendar__day--disabled')) {\n          dir = day.getAttribute('data-direction');\n          if (dir === 'next') this.next();else if (dir === 'previous') this.previous();\n        }\n        // Enabled day sets the value\n        else {\n            this.setValue(day.getAttribute('data-date'), this.activeIndex);\n            if (this.autoAdvance) this._focusNext();\n            if (this.autoClose) this._closeOnLast();\n          }\n      }\n  };\n\n  /**\n   * When the popover opens, set the toggle state.\n   */\n\n\n  CalendarPopover.prototype._onPopoverOpen = function _onPopoverOpen() {\n    this._fillToggle();\n    this._checkSize();\n    if (this._currentBreakpoint === 'xs') this._scrollToInput();\n  };\n\n  /**\n   * When the popover closes, reset the active state.\n   */\n\n\n  CalendarPopover.prototype._onPopoverClose = function _onPopoverClose() {\n    this._unfillToggle();\n    this._updateHoverClasses();\n    this._deactivateElement(this.activeIndex);\n    this.activeIndex = null;\n  };\n\n  /**\n   * When the input that corresponds to this instance changes. Allows us to listen\n   * and respond to changes made by other components (Calendar Popover, for example).\n   * @param {Object} e\n   */\n\n\n  CalendarPopover.prototype._onInputChange = function _onInputChange(e) {\n\n    var index = this.inputEls.indexOf(e.target);\n\n    if (this._inputsChanging && this._inputsChanging.indexOf(index) !== -1) return;\n\n    this.setValue(e.target.value, index);\n  };\n\n  /**\n   * When an input receives focus, if we are supposed to automatically show\n   * on focus do so.\n   * @param {Object} e\n   */\n\n\n  CalendarPopover.prototype._onInputFocus = function _onInputFocus(e) {\n    if (!this.showOnFocus) return;\n    var index = this.inputEls.indexOf(e.target);\n    if (index !== -1) this.open(index);\n  };\n\n  /**\n   * When one of the calendar quick jump select inputs changes.\n   * We have to set the value of the select input back to its original\n   * value or else it will be out of sync when the currently active\n   * month is shown again.\n   * @param {Object} e\n   */\n\n\n  CalendarPopover.prototype._onSelectChange = function _onSelectChange(e) {\n\n    var name = e.target.name;\n    var val = e.target.value;\n    var curVal = this._datesToShow[this.activeIndex][name];\n    var obj = {};\n\n    obj[name] = val;\n    this.showDate(obj);\n    e.target.value = curVal;\n  };\n\n  /**\n   * When the window resizes, determine if we're at the XS breakpoint so we\n   * can do some mobile-esque stuff!\n   * @param {Object} e\n   */\n\n\n  CalendarPopover.prototype._onResize = function _onResize() {\n    if (this.activeIndex !== null) this._checkSize();\n  };\n\n  return CalendarPopover;\n}(_base2.default);\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nCalendarPopover.prototype._whitelistedParams = ['els', 'visibleCounts', 'autoAdvance', 'autoClose', 'closeDelay', 'mins', 'maxes', 'values', 'daysDisabled', 'daysInfo', 'quickJump', 'quickJumpRange', 'calendarEl', 'viewRange', 'animate', 'animationDuration', 'showOnFocus', 'onChange'];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nCalendarPopover.prototype.defaults = {\n  els: null,\n  inputEls: null,\n  calendarEl: null,\n  calendarContentEl: null,\n  calendarOverflowEl: null,\n  visibleCounts: null,\n  activeIndex: null,\n  mins: null,\n  minVisible: null,\n  maxes: null,\n  maxVisible: null,\n  values: null,\n  daysDisabled: null,\n  daysInfo: null,\n  viewRange: null,\n  autoAdvance: null,\n  autoClose: null,\n  quickJump: null,\n  closeDelay: null,\n  nextButtonEl: null,\n  previousButtonEl: null,\n  animate: null,\n  animationDuration: null,\n  showOnFocus: null,\n  onChange: null,\n  _isDisabled: false,\n  _isRange: null,\n  _hoverStarts: null,\n  _hoverEnds: null,\n  _currentBreakpoint: null,\n  _animationQueue: null,\n  _currentContent: null,\n  _datesToShow: null,\n  _monthsShowing: null,\n  _atMin: false,\n  _atMax: false,\n  _inputsChanging: false,\n  _openCloseTimer: null,\n  _renderCache: null,\n  _onClickBound: null,\n  _onCalendarMouseOverBound: null,\n  _onCalendarMouseOutBound: null,\n  _onCalendarClickBound: null,\n  _onSelectChangeBound: null,\n  _onInputChangeBound: null,\n  _onInputFocusBound: null,\n  _onResizeBound: null\n};\n\nexports.default = CalendarPopover;\nmodule.exports = exports['default'];\n//# sourceMappingURL=calendar-popover.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _base = require('./base');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _addClass = require('../helpers/dom/add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _hasClass = require('../helpers/dom/has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _toggleClass = require('../helpers/dom/toggle-class');\n\nvar _toggleClass2 = _interopRequireDefault(_toggleClass);\n\nvar _appendChildren = require('../helpers/manipulation/append-children');\n\nvar _appendChildren2 = _interopRequireDefault(_appendChildren);\n\nvar _hasParent = require('../helpers/traversal/has-parent');\n\nvar _hasParent2 = _interopRequireDefault(_hasParent);\n\nvar _getParent = require('../helpers/traversal/get-parent');\n\nvar _getParent2 = _interopRequireDefault(_getParent);\n\nvar _parseAttribute = require('../helpers/dom/parse-attribute');\n\nvar _affix = require('../helpers/position/affix');\n\nvar _affix2 = _interopRequireDefault(_affix);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * # Popover\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Show and hide a popover. Should do some sanity checks on positioning as well.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @example\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * new Popover(el, {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   // Optional. Default anchoring of the content's x and y-axis relative to the button.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   defaultAnchorX: 'center', // 'left', 'center', 'right'\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   defaultAnchorY: 'center' // 'left', 'center', 'right'\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * });\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module components/popover.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\nvar noop = function noop() {};\n\nvar Popover = function (_BaseComponent) {\n  _inherits(Popover, _BaseComponent);\n\n  function Popover(el) {\n    var _ret;\n\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Popover);\n\n    var _this = _possibleConstructorReturn(this, _BaseComponent.call(this, el, params));\n\n    if (!el) return _ret = _this, _possibleConstructorReturn(_this, _ret);\n    _this._bindEventListenerCallbacks();\n    _this._addEventListeners();\n    return _this;\n  }\n\n  /**\n   * Open.\n   * @param {Object} params Optional\n   */\n\n\n  Popover.prototype.open = function open() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n    // If there is a timer running for the close event, clear it so it\n    // doesn't close stuff during open.\n    if (this.closeTimer) {\n      clearTimeout(this.closeTimer);\n      this.closeTimer = null;\n    }\n\n    // If the element we anchor the popover to is fixed, we need to know\n    // so that the affixed content can also be fixed.\n    this._checkFixedPosition();\n\n    // Update an existing affixed instance.\n    if (this.affix) {\n      this.affix.targetEl = params.affixTo || this.affix.targetEl;\n      this.affix.update();\n    }\n    // Affix the content to the toggle\n    else {\n        this.affix = new _affix2.default({\n          el: this.contentEl,\n          targetEl: params.affixTo || this.el,\n          caretEl: this.caretEl,\n          anchorX: this.anchorX,\n          anchorY: this.anchorY,\n          isFixed: this.isFixed\n        });\n      }\n\n    // Find all focusable elements in the Popover for navigation\n    var popoverFocusableEls = this.contentEl.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex=\"0\"]');\n\n    if (popoverFocusableEls.length > 0) {\n      this.popoverFocusableEls = Array.prototype.slice.call(popoverFocusableEls);\n      this.firstPopoverFocusableEl = this.popoverFocusableEls[0];\n      this.lastPopoverFocusableEl = this.popoverFocusableEls[this.popoverFocusableEls.length - 1];\n    }\n\n    // Listen for clicks on the window\n    this._addWindowEventListeners();\n\n    this.isActive = true;\n\n    // Dispatch a custom event so content inside the popover can respond\n    var e = document.createEvent('Event');\n    e.initEvent('spark.visible-children', true, true);\n    this.contentEl.dispatchEvent(e);\n\n    // Update bindings\n    this._updateAttributes();\n\n    // Set focus to first focusable element once Popover has been opened\n    if (popoverFocusableEls.length > 0) {\n      this.firstPopoverFocusableEl.focus();\n    }\n\n    // Callbacks\n    (params.complete || noop)();\n    (this.onOpen || noop)();\n\n    return this;\n  };\n\n  /**\n   * Close.\n   * @param {Object} params Optional\n   */\n\n\n  Popover.prototype.close = function close() {\n    var _this2 = this;\n\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n    // Not open, so don't close.\n    if (!this.affix) return this;\n\n    // If there is a timer running for the close event, clear it so we don't run close stuff twice.\n    if (this.closeTimer) {\n      clearTimeout(this.closeTimer);\n      this.closeTimer = null;\n    }\n\n    // Stop listening to window clicks.\n    this._removeWindowEventListeners();\n\n    this.isActive = false;\n\n    // Update bindings\n    this._updateAttributes();\n\n    // Close after the animation has completed\n    this.closeTimer = setTimeout(function () {\n      _this2._finishClose(params);\n    }, 250);\n\n    return this;\n  };\n\n  /**\n   * Toggle the open state.\n   */\n\n\n  Popover.prototype.toggle = function toggle() {\n    return this[this.isActive ? 'close' : 'open']();\n  };\n\n  /**\n   * Set the content. Optionally append instead of replacing.\n   * @param {Element|Array|NodeList} content\n   * @param {Object} params Optional\n   */\n\n\n  Popover.prototype.setContent = function setContent(content, params) {\n    params = params || {};\n    (0, _appendChildren2.default)(this.contentEl, content.length ? content : [content], !(params.append || false));\n    return this;\n  };\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   */\n\n\n  Popover.prototype.update = function update(el) {\n\n    this._removeEventListeners();\n    this._cacheElements(el || this.el);\n    this._addEventListeners();\n\n    if (this.affix) this.affix.update();\n\n    return this;\n  };\n\n  /**\n   * Store a reference to the tabs list, each tab and each panel.\n   * Set which tab is active, or use the first.\n   * @param {Element} el\n   */\n\n\n  Popover.prototype._cacheElements = function _cacheElements(el) {\n\n    // If a content element was already passed, make sure it has a popover content class\n    if (this.contentEl) {\n      (0, _addClass2.default)(this.contentEl, 'spark-popover__content');\n    }\n\n    this.el = el;\n    this.toggleEl = this.el.querySelector('.spark-popover__toggle, [data-role=\"toggle\"]') || this.el;\n    this.contentEl = this.contentEl || this.el.querySelector('.spark-popover__content, [class*=\"spark-popover__content--\"]') || this._createContentEl();\n    this.caretEl = this.contentEl.querySelector('.spark-popover__caret') || this._createCaretEl();\n    this.isActive = (0, _hasClass2.default)(this.toggleEl, 'popover-active');\n  };\n\n  /**\n   * Parse config values from the element.\n   */\n\n\n  Popover.prototype._parseParams = function _parseParams() {\n\n    this.anchorY = this.anchorY !== null ? this.anchorY : (0, _parseAttribute.string)(this.contentEl, 'data-anchor-y', null);\n    this.anchorX = this.anchorX !== null ? this.anchorX : (0, _parseAttribute.string)(this.contentEl, 'data-anchor-x', null);\n\n    // No anchors defined\n    if (!this.anchorY && !this.anchorX) {\n\n      // Left\n      if ((0, _hasClass2.default)(this.contentEl, 'spark-popover__content--left')) {\n        this.anchorY = 'middle';\n        this.anchorX = 'left';\n      }\n      // Right\n      else if ((0, _hasClass2.default)(this.contentEl, 'spark-popover__content--right')) {\n          this.anchorY = 'middle';\n          this.anchorX = 'right';\n        }\n        // Top\n        else if ((0, _hasClass2.default)(this.contentEl, 'spark-popover__content--top')) {\n            this.anchorY = 'top';\n            this.anchorX = 'center';\n          }\n          // Bottom\n          else {\n              this.anchorY = 'bottom';\n              this.anchorX = 'center';\n            }\n    }\n  };\n\n  /**\n   * Check to see if the button triggering the popover is fixed.\n   * If so, then popover needs to be fixed as well.\n   */\n\n\n  Popover.prototype._checkFixedPosition = function _checkFixedPosition() {\n\n    var parent = this.el;\n\n    while (parent && parent !== document) {\n      var style = getComputedStyle(parent);\n      if (style.position === 'fixed') {\n        return this.isFixed = true;\n      }\n      parent = parent.parentNode;\n    }\n\n    return this.isFixed = false;\n  };\n\n  /**\n   * Update classes for the open or close state.\n   */\n\n\n  Popover.prototype._updateAttributes = function _updateAttributes() {\n    (0, _toggleClass2.default)(this.el, 'popover-active', this.isActive);\n    (0, _toggleClass2.default)(this.contentEl, 'active', this.isActive);\n    (0, _toggleClass2.default)(this.toggleEl, 'active', this.isActive);\n  };\n\n  /**\n   * Create bound versions of event listener callbacks and store them.\n   * Otherwise we can't unbind from these events later because the\n   * function signatures won't match.\n   */\n\n\n  Popover.prototype._bindEventListenerCallbacks = function _bindEventListenerCallbacks() {\n    this._onClickBound = this._onClick.bind(this);\n    this._onContentClickBound = this._onContentClick.bind(this);\n    this._onWindowClickBound = this._onWindowClick.bind(this);\n    this._onKeyupBound = this._onKeyup.bind(this);\n    this._onKeydownBound = this._onKeydown.bind(this);\n  };\n\n  /**\n   * Add event listeners for DOM events.\n   */\n\n\n  Popover.prototype._addEventListeners = function _addEventListeners() {\n    this.el.addEventListener('click', this._onClickBound);\n    this.contentEl.addEventListener('click', this._onContentClickBound);\n  };\n\n  /**\n   * Remove event listeners for DOM events..\n   */\n\n\n  Popover.prototype._removeEventListeners = function _removeEventListeners() {\n    this.el.removeEventListener('click', this._onClickBound);\n    this.contentEl.removeEventListener('click', this._onContentClickBound);\n  };\n\n  /**\n   * Add event listeners to the window.\n   */\n\n\n  Popover.prototype._addWindowEventListeners = function _addWindowEventListeners() {\n    this._removeWindowEventListeners();\n    window.addEventListener('click', this._onWindowClickBound);\n    window.addEventListener('keyup', this._onKeyupBound);\n    window.addEventListener('keydown', this._onKeydownBound);\n  };\n\n  /**\n   * Remove window event listeners.\n   */\n\n\n  Popover.prototype._removeWindowEventListeners = function _removeWindowEventListeners() {\n    window.removeEventListener('click', this._onWindowClickBound);\n    window.removeEventListener('keyup', this._onKeyupBound);\n    window.removeEventListener('keydown', this._onKeydownBound);\n  };\n\n  /**\n   * Create a content element.\n   * @return {Element}\n   */\n\n\n  Popover.prototype._createContentEl = function _createContentEl() {\n    var el = document.createElement('div');\n    (0, _addClass2.default)(el, 'spark-popover__content');\n    el.setAttribute('role', 'tooltip');\n    return el;\n  };\n\n  /**\n   * Create the caret element.\n   * @return {Element}\n   */\n\n\n  Popover.prototype._createCaretEl = function _createCaretEl() {\n    var el = document.createElement('div');\n    el.className = 'spark-popover__caret';\n    this.contentEl.appendChild(el);\n    return el;\n  };\n\n  /**\n   * Complete the close event by moving the element back and destroying the affix.\n   * @param  {Object} params\n   */\n\n\n  Popover.prototype._finishClose = function _finishClose() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n    this.closeTimer = null;\n\n    // Move the content back to the parent\n    this.el.appendChild(this.contentEl);\n\n    this.affix.remove({ keepEl: true });\n    this.affix = null;\n\n    (params.complete || noop)();\n    (this.onClose || noop)();\n  };\n\n  /**\n   * When we are clicked, toggle the popover-active state.\n   * @param {Object} e\n   */\n\n\n  Popover.prototype._onClick = function _onClick(e) {\n\n    // If this is the toggle element, toggle.\n    if (e.target === this.toggleEl || (0, _hasParent2.default)(e.target, this.toggleEl)) {\n      e.preventDefault();\n      this.toggle();\n      return;\n    }\n  };\n\n  /**\n   * When a key is pressed on the window and it's an ESC, close the popover.\n   * @param {Object} e\n   */\n\n\n  Popover.prototype._onKeyup = function _onKeyup(e) {\n    if (e.keyCode === 27) {\n      this.close();\n\n      // Set focus back to toggle\n      this.toggleEl.focus();\n    }\n  };\n\n  /**\n   * When a key is pressed in an active Popover and it is a Tab key, or Shift+Tab, navigate the popover\n   * If it the Enter key, and focus is on the close button, close the Popover\n   *\n   * @param {Object} e\n   */\n\n\n  Popover.prototype._onKeydown = function _onKeydown(e) {\n    if (e.keyCode === 9) {\n      if (this.popoverFocusableEls.length === 1) {\n        e.preventDefault();\n      }\n\n      if (e.shiftKey) {\n        this._onBackwardTab(e);\n      } else {\n        this._onForwardTab(e);\n      }\n    }\n\n    // Enter Key\n    if (e.keyCode === 13) {\n      if (e.target === document.querySelector('.spark-popover__close') || (0, _getParent2.default)(e.target, '.spark-popover__close', this.contentEl)) {\n        e.preventDefault();\n        this.close();\n\n        // Set focus back to toggle\n        this.toggleEl.focus();\n      }\n    }\n  };\n\n  /**\n   * When tabbing backwards, localize traversal to Popover elements only\n   * @param {Object} e\n   */\n\n\n  Popover.prototype._onBackwardTab = function _onBackwardTab(e) {\n    if (document.activeElement === this.firstPopoverFocusableEl) {\n      e.preventDefault();\n      this.lastPopoverFocusableEl.focus();\n    }\n  };\n\n  /**\n   * When tabbing forwards, localize traversal to Popover elements only\n   * @param {Object} e\n   */\n\n\n  Popover.prototype._onForwardTab = function _onForwardTab(e) {\n    if (document.activeElement === this.lastPopoverFocusableEl) {\n      e.preventDefault();\n      this.firstPopoverFocusableEl.focus();\n    }\n  };\n\n  /**\n   * When the toggle is clicked, close if it's a link. If it's content, don't do anything but stop\n   * the event from bubbling.\n   * @param {Object} e\n   */\n\n\n  Popover.prototype._onContentClick = function _onContentClick(e) {\n\n    // If this is a link, close.\n    if ((0, _getParent2.default)(e.target, '.spark-popover__list-link', this.contentEl) || (0, _getParent2.default)(e.target, '.spark-popover__close', this.contentEl)) {\n      this.close();\n      return;\n    }\n  };\n\n  /**\n   * When the window is clicked and it's not part of the popover, close the popover.\n   * @param {Objec} e\n   */\n\n\n  Popover.prototype._onWindowClick = function _onWindowClick(e) {\n    if (e.target !== this.el && e.target !== this.contentEl && !(0, _hasParent2.default)(e.target, this.el) && !(0, _hasParent2.default)(e.target, this.contentEl)) {\n      this.close();\n    }\n  };\n\n  return Popover;\n}(_base2.default);\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nPopover.prototype._whitelistedParams = ['anchorX', 'anchorY', 'toggleEl', 'contentEl', 'onOpen', 'onClose'];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nPopover.prototype.defaults = {\n  el: null,\n  toggleEl: null,\n  contentEl: null,\n  caretEl: null,\n  affix: null,\n  isActive: false,\n  isPaused: false,\n  isFixed: false,\n  anchorX: null,\n  anchorY: null,\n  closeTimer: null,\n  onOpen: null,\n  onClose: null,\n  _onClickBound: null,\n  _onKeyupBound: null,\n  _onKeydownBound: null,\n  _onContentClickBound: null,\n  _onWindowClickBound: null,\n  _onWindowResizeBound: null,\n  _onWindowScrollBound: null\n};\n\nexports.default = Popover;\nmodule.exports = exports['default'];\n//# sourceMappingURL=popover.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Request Animation\n * Request animation frame polyfill.\n * @module helpers/animation/request.js\n */\nvar request = window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function () {\n\n  var fps = 60;\n  var del = 1000 / fps;\n  var start = Date.now();\n  var prev = start;\n\n  return function requestAnimationFrame(callback) {\n\n    var requestTime = Date.now();\n    var timeout = Math.max(0, del - (requestTime - prev));\n    var timeToCall = requestTime + timeout;\n\n    prev = timeToCall;\n\n    return window.setTimeout(function onAnimationFrame() {\n      callback(timeToCall - start);\n    }, timeout);\n  };\n}();\n\nexports.default = request;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=request.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _offset = require('../dom/offset');\n\nvar _offset2 = _interopRequireDefault(_offset);\n\nvar _tween = require('./tween');\n\nvar _tween2 = _interopRequireDefault(_tween);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * # Scroll To\n * Scroll the window to a specific element or position.\n * @param {Object} params\n *\n * @module helpers/animation/scroll-to.js\n */\n\nfunction scrollTo(params) {\n\n  params = params || {};\n\n  var offset = void 0;\n  var x = void 0;\n  var y = void 0;\n  var target = params.target || window;\n  var startX = target !== window ? target.scrollLeft : target.pageXOffset;\n  var startY = target !== window ? target.scrollTop : target.pageYOffset;\n\n  if (params instanceof HTMLElement) {\n    offset = (0, _offset2.default)(params);\n    x = offset.left;\n    y = offset.top;\n    params = arguments[1] || {};\n  } else {\n    x = params.x || 0;\n    y = params.y || 0;\n  }\n\n  (0, _tween2.default)({\n    target: target,\n    prop: 'scrollTo',\n    start: [startX, startY],\n    end: [x, y],\n    duration: params.duration,\n    callback: params.callback\n  });\n}\n\nexports.default = scrollTo;\nmodule.exports = exports['default'];\n//# sourceMappingURL=scroll-to.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _request = require('./request');\n\nvar _request2 = _interopRequireDefault(_request);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar noop = function noop() {};\n\n/**\n * Tween from one value to another.\n * @param {Object} params\n * @return {Long}\n */\n/**\n * # Tween\n * Tween between two values.\n * @module helpers/animation/tween.js\n */\n\nfunction tween(params) {\n\n  params = params || {};\n\n  var begin;\n  var obj = params.target;\n\n  if (!obj) {\n    throw new Error('Cannot tween without a target!');\n  }\n\n  var prop = typeof params.prop === 'string' ? [params.prop] : params.prop;\n  var start = typeof params.start === 'number' ? [params.start] : params.start;\n  var end = typeof params.end === 'number' ? [params.end] : params.end;\n  var duration = params.duration || 250;\n  var callback = params.callback || noop;\n\n  // Ensure we have the same number of start and end properties.\n  if (start.length !== end.length) {\n    throw new Error('Cannot tween two different sets of parameters!');\n  }\n\n  var f = function f(ts) {\n\n    // Keep track of when we start\n    if (!begin) begin = ts;\n\n    // Progress\n    var prog = ts - begin;\n\n    // Percentage complete\n    var per = Math.min(prog / duration, 1);\n\n    // Adjust the values for the percentage complete.\n    var args = [];\n    var i = 0;\n    var len = start.length;\n    for (; i < len; i++) {\n      args[i] = start[i] + (end[i] - start[i]) * per;\n    }\n\n    // Apply the values for each property.\n    i = 0;\n    len = prop.length;\n    var arg;\n    for (; i < len; i++) {\n\n      // If this is the last property but we have more arguments, set them all.\n      arg = i + 1 === len && args.length - 1 > i ? args.slice(i) : args[i];\n\n      if (typeof obj[prop[i]] === 'function') {\n        obj[prop[i]].apply(obj, arg);\n      } else {\n        obj[prop[i]] = arg;\n      }\n    }\n\n    // Keep going if we have more to do.\n    if (prog < duration) (0, _request2.default)(f);else callback();\n  };\n\n  return (0, _request2.default)(f);\n}\n\nexports.default = tween;\nmodule.exports = exports['default'];\n//# sourceMappingURL=tween.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Date helper\n * General helpers for working with dates.\n *\n * @module helpers/date/date.js\n */\n\nvar monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\nvar monthNamesShort = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June', 'July', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec'];\nvar dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\nvar dayNamesShort = ['Sun', 'Mon', 'Tues', 'Wed', 'Thur', 'Fri', 'Sat'];\nvar adjustedDayNames = [];\nvar adjustedDayNamesShort = [];\nvar weekStartsOn = 0;\n\nvar dateHelper = {\n\n  /**\n   * Transform a date into an object of date values.\n   * @param {Date} date\n   * @return {Object}\n   */\n  create: function create(date) {\n\n    date = date instanceof Date ? date : new Date(date.year, date.month - 1, date.day);\n\n    var inst = Object.create(dateHelper);\n    inst._date = date;\n    inst._cache = {};\n\n    return inst;\n  },\n\n  /**\n   * Get a year.\n   * @return {Number}\n   */\n  get year() {\n    this._instanceCheck('year');\n    return this._date.getFullYear();\n  },\n\n  /**\n   * Set a year.\n   * @param {Number} y\n   */\n  set year(y) {\n    this._instanceCheck('year');\n    this._clearCache();\n    return this._date.setFullYear(y);\n  },\n\n  /**\n   * Get a month.\n   * @return {Number} 1-12\n   */\n  get month() {\n    this._instanceCheck('month');\n    return this._date.getMonth() + 1;\n  },\n\n  /**\n   * Set a month.\n   * @param {Number} m 1-12\n   */\n  set month(m) {\n    this._instanceCheck('month');\n    this._clearCache();\n    return this._date.setMonth(m - 1);\n  },\n\n  /**\n   * Get a day.\n   * @return {Number} 1-31\n   */\n  get day() {\n    this._instanceCheck('day');\n    return this._date.getDate();\n  },\n\n  /**\n   * Set a day.\n   * @param {Number} d 1-31\n   */\n  set day(d) {\n    this._instanceCheck('day');\n    this._clearCache();\n    return this._date.setDate(d);\n  },\n\n  /**\n   * Sets the day, month and year values at once.\n   * @param {Object} params\n   */\n  set: function set(params) {\n    params = params || {};\n    this.year = params.year || this.year;\n    this.month = params.month || this.month;\n    this.day = params.day || this.day;\n  },\n\n  /**\n   * Get the full name of the month.\n   * @param {Number} num\n   * @return {String}\n   */\n  getMonthName: function getMonthName(num) {\n    return monthNames[num - 1];\n  },\n\n  /**\n   * Get the month name.\n   * @return {String}\n   */\n  get monthName() {\n    this._instanceCheck('monthName');\n    return dateHelper.getMonthName(this.month);\n  },\n\n  /**\n   * Get the list of month names.\n   * @return {Array}\n   */\n  getMonthNames: function getMonthNames() {\n    return monthNames;\n  },\n\n  /**\n   * Get the short name of the month.\n   * @param {Number} num\n   * @return {String}\n   */\n  getMonthNameShort: function getMonthNameShort(num) {\n    return monthNamesShort[num - 1];\n  },\n\n  /**\n   * Get the month name.\n   * @return {String}\n   */\n  get monthNameShort() {\n    this._instanceCheck('monthName');\n    return dateHelper.getMonthNameShort(this.month);\n  },\n\n  /**\n   * Get the list of short month names.\n   * @return {Array}\n   */\n  getMonthNamesShort: function getMonthNamesShort() {\n    return monthNamesShort;\n  },\n\n  /**\n   * Set the month names.\n   * @param {Array} names\n   */\n  setMonthNames: function setMonthNames(names) {\n    if (names.length === 12) monthNames = names;\n  },\n\n  /**\n   * Set the short month names.\n   * @param {Array} names\n   */\n  setMonthNamesShort: function setMonthNamesShort(names) {\n    if (names.length === 12) monthNamesShort = names;\n  },\n\n  /**\n   * Get the day of the week for a given day.\n   * @param {Object} date\n   * @return {Number} 1-7\n   */\n  getDayOfWeek: function getDayOfWeek(date) {\n    var day = (date instanceof Date ? date : new Date(date.year, date.month - 1, date.day)).getDay() - weekStartsOn;\n    return (day < 0 ? 7 - Math.abs(day) : day) + 1;\n  },\n\n  /**\n   * Get the day of the week.\n   * @return {Number}\n   */\n  get dayOfWeek() {\n    return dateHelper.getDayOfWeek(this._date);\n  },\n\n  /**\n   * Get the full name of a day of the week.\n   * @param {Number} num\n   * @return {String}\n   */\n  getDayName: function getDayName(num) {\n    return dayNames[num - 1 + weekStartsOn] || dayNames[dayNames.length - num - 1 + weekStartsOn];\n  },\n\n  /**\n   * Get the day name.\n   * @return {String}\n   */\n  get dayName() {\n    this._instanceCheck('dayName');\n    return dateHelper.getDayName(this.dayOfWeek);\n  },\n\n  /**\n   * Get the full name of the days of the week.\n   * @return {Array}\n   */\n  getDayNames: function getDayNames() {\n    return adjustedDayNames.length ? adjustedDayNames : dayNames;\n  },\n\n  /**\n   * Get the short name of the day.\n   * @param {Number} num\n   * @return {String}\n   */\n  getDayNameShort: function getDayNameShort(num) {\n    return dayNamesShort[num - 1 + weekStartsOn] || dayNames[dayNames.length - num - 1 + weekStartsOn];\n  },\n\n  /**\n   * Get the short day name.\n   * @return {String}\n   */\n  get dayNameShort() {\n    this._instanceCheck('dayNameShort');\n    return dateHelper.getDayNameShort(this.dayOfWeek);\n  },\n\n  /**\n   * Get the full name of the days of the week.\n   * @return {Array}\n   */\n  getDayNamesShort: function getDayNamesShort() {\n    return adjustedDayNamesShort.length ? adjustedDayNamesShort : dayNamesShort;\n  },\n\n  /**\n   * Set the day names.\n   * @param {Array} names\n   */\n  setDayNames: function setDayNames(names) {\n    if (names.length === 7) dayNames = names;\n  },\n\n  /**\n   * Set the short day names.\n   * @param {Array} names\n   */\n  setDayNamesShort: function setDayNamesShort(names) {\n    if (names.length === 7) dayNamesShort = names;\n  },\n\n  /**\n   * Get the index of the first day of the week.\n   * @return {Number}\n   */\n  getWeekStartsOn: function getWeekStartsOn() {\n    return weekStartsOn;\n  },\n\n  /**\n   * Set the index of the first day of the week.\n   * @param {Number} index\n   * @return {String}\n   */\n  setWeekStartsOn: function setWeekStartsOn(number) {\n\n    weekStartsOn = number;\n\n    if (number) {\n      adjustedDayNames = dayNames.slice(weekStartsOn);\n      adjustedDayNames = adjustedDayNames.concat(dayNames.slice(0, weekStartsOn));\n      adjustedDayNamesShort = dayNamesShort.slice(weekStartsOn);\n      adjustedDayNamesShort = adjustedDayNamesShort.concat(dayNamesShort.slice(0, weekStartsOn));\n    } else {\n      adjustedDayNames = [];\n      adjustedDayNamesShort = [];\n    }\n  },\n\n  /**\n   * Get the current date.\n   * @return {Object}\n   */\n  now: function now() {\n    return dateHelper.create(new Date());\n  },\n\n  /**\n   * Get the next year after the given date.\n   * This obviously isn't very complicated, but it exists\n   * for parity with how we get the week, day and month.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getNextYear: function getNextYear(date) {\n    return dateHelper.create(new Date(date.year + 1, date.month - 1, date.day));\n  },\n\n  /**\n   * Get the year following this.\n   * @return {Object}\n   */\n  get nextYear() {\n    this._instanceCheck('nextYear');\n    return this._cache.nextYear || (this._cache.nextYear = dateHelper.getNextYear(this));\n  },\n\n  /**\n   * Get the first day of the week for a given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getWeekStart: function getWeekStart(date) {\n    var inst = dateHelper.create(new Date(date.year, date.month - 1, date.day - dateHelper.getDayOfWeek(date) + 1));\n    inst.weekStartsOn = weekStartsOn;\n    return inst;\n  },\n\n  /**\n   * Get the start of the week for this date.\n   * @return {Object}\n   */\n  get weekStart() {\n    this._instanceCheck('weekStart');\n    return this._cache.weekStart && this._cache.weekStart.weekStartsOn === weekStartsOn ? this._cache.weekStart : this._cache.weekStart = dateHelper.getWeekStart(this);\n  },\n\n  /**\n   * Get the first day of the month for a given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getMonthStart: function getMonthStart(date) {\n    var inst = dateHelper.create(new Date(date.year, date.month - 1, 1));\n    return inst;\n  },\n\n  /**\n   * Get the start of the month for this date.\n   * @return {Object}\n   */\n  get monthStart() {\n    this._instanceCheck('monthStart');\n    return this._cache.monthStart || (this._cache.monthStart = dateHelper.getMonthStart(this));\n  },\n\n  /**\n   * Get the next week after the given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getNextWeek: function getNextWeek(date) {\n    var start = dateHelper.getWeekStart(date);\n    return dateHelper.create(new Date(start.year, start.month - 1, start.day + 7));\n  },\n\n  /**\n   * Get the week following this.\n   * @return {Object}\n   */\n  get nextWeek() {\n    this._instanceCheck('nextWeek');\n    return this._cache.nextWeek || (this._cache.nextWeek = dateHelper.getNextWeek(this));\n  },\n\n  /**\n   * Get the next day after the given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getNextDay: function getNextDay(date) {\n    return dateHelper.create(new Date(date.year, date.month - 1, date.day + 1));\n  },\n\n  /**\n   * Get the day following this.\n   * @return {Object}\n   */\n  get nextDay() {\n    this._instanceCheck('nextDay');\n    return this._cache.nextDay || (this._cache.nextDay = dateHelper.getNextDay(this));\n  },\n\n  /**\n   * Get the next month after the given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getNextMonth: function getNextMonth(date) {\n    // Date() has a *bug/feature* if last day of month is 31 when calculating the next month.\n    // Need to account for that so that it doesn't round up the date/month.\n\n    if (date.day === 31 && date.month !== 1 && date.month !== 7 && date.month !== 12) {\n      // Adjust for months ending in 31 followed by months ending in 30\n      return dateHelper.create(new Date(date.year, date.month, date.day - 1));\n    } else if (date.day > 28 && date.month === 1) {\n      // fix for last day of February\n      return dateHelper.create(new Date(date.year, date.month + 1, 0));\n    } else {\n      return dateHelper.create(new Date(date.year, date.month, date.day));\n    }\n  },\n\n  /**\n   * Get the month following this.\n   * @return {Object}\n   */\n  get nextMonth() {\n    this._instanceCheck('nextMonth');\n    return this._cache.nextMonth || (this._cache.nextMonth = dateHelper.getNextMonth(this));\n  },\n\n  /**\n   * Get the previous year after the given date.\n   * This obviously isn't very complicated, but it exists\n   * for parity with how we get the week, day and month.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getPreviousYear: function getPreviousYear(date) {\n    return dateHelper.create(new Date(date.year - 1, date.month - 1, date.day));\n  },\n\n  /**\n   * Get the year preceding this.\n   * @return {Object}\n   */\n  get previousYear() {\n    this._instanceCheck('previousYear');\n    return this._cache.previousYear || (this._cache.previousYear = dateHelper.getPreviousYear(this));\n  },\n\n  /**\n   * Get the previous week after the given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getPreviousWeek: function getPreviousWeek(date) {\n    var start = dateHelper.getWeekStart(date);\n    var inst = dateHelper.create(new Date(start.year, start.month - 1, start.day - 7));\n    inst.weekStartsOn = weekStartsOn;\n    return inst;\n  },\n\n  /**\n   * Get the week preceding this.\n   * @return {Object}\n   */\n  get previousWeek() {\n    this._instanceCheck('previousWeek');\n    return this._cache.previousWeek || (this._cache.previousWeek = dateHelper.getPreviousWeek(this));\n  },\n\n  /**\n   * Get the previous day after the given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getPreviousDay: function getPreviousDay(date) {\n    return dateHelper.create(new Date(date.year, date.month - 1, date.day - 1));\n  },\n\n  /**\n   * Get the day preceding this.\n   * @return {Object}\n   */\n  get previousDay() {\n    this._instanceCheck('previousDay');\n    return this._cache.previousDay || (this._cache.previousDay = dateHelper.getPreviousDay(this));\n  },\n\n  /**\n   * Get the previous month after the given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getPreviousMonth: function getPreviousMonth(date) {\n    // Date() has a *bug/feature* if last day of month is 31 when calculating the previous month.\n    // Need to account for that so that it doesn't round up the date/month.\n\n    if (date.day === 31 && date.month !== 1 && date.month !== 3 && date.month !== 8) {\n      // Adjust for months ending in 31 that follow months ending in 30\n      return dateHelper.create(new Date(date.year, date.month - 2, date.day - 1));\n    } else if (date.day > 28 && date.month === 3) {\n      // Adjust for last day of February\n      return dateHelper.create(new Date(date.year, date.month - 1, 0));\n    } else {\n      return dateHelper.create(new Date(date.year, date.month - 2, date.day));\n    }\n  },\n\n  /**\n   * Get the month preceding this.\n   * @return {Object}\n   */\n  get previousMonth() {\n    this._instanceCheck('previousMonth');\n    return this._cache.previousMonth || (this._cache.previousMonth = dateHelper.getPreviousMonth(this));\n  },\n\n  /**\n   * Get the last day of the month.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getMonthEnd: function getMonthEnd(date) {\n    return dateHelper.create(new Date(date.year, date.month, 0));\n  },\n\n  /**\n   * Get the last day of the month.\n   * @return {Object}\n   */\n  get monthEnd() {\n    this._instanceCheck('monthEnd');\n    return this._cache.monthEnd || (this._cache.monthEnd = dateHelper.getMonthEnd(this));\n  },\n\n  /**\n   * Does a given day equal another? Or is it present in a list of others?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  equal: function equal(date, compare, full) {\n    return this.equalDay(date, compare, full);\n  },\n\n  /**\n   * Does a given day equal another? Or is it present in a list of others?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  equalDay: function equalDay(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (compare[i] && date.year === compare[i].year && date.month === compare[i].month && date.day === compare[i].day) matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a week equal to another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  equalWeek: function equalWeek(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || !date.weekStart.equalDay(compare[i].weekStart)) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a month equal to another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  equalMonth: function equalMonth(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date.year !== compare[i].year || date.year === compare[i].year && date.month !== compare[i].month) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a year equal to another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  equalYear: function equalYear(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date.year !== compare[i].year) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a date before another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  before: function before(date, compare, full) {\n    return this.beforeDay(date, compare, full);\n  },\n\n  /**\n   * Is a given date before another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  beforeDay: function beforeDay(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date._date >= compare[i]._date) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a week before another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  beforeWeek: function beforeWeek(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || !date.weekStart.beforeDay(compare[i].weekStart)) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a month before another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  beforeMonth: function beforeMonth(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date.year > compare[i].year || date.year === compare[i].year && date.month >= compare[i].month) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a year before another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  beforeYear: function beforeYear(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date.year >= compare[i].year) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a date after another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  after: function after(date, compare, full) {\n    return this.afterDay(date, compare, full);\n  },\n\n  /**\n   * Is a given date after another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  afterDay: function afterDay(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date._date <= compare[i]._date) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a week after another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  afterWeek: function afterWeek(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || !date.weekStart.afterDay(compare[i].weekStart)) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a month after another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  afterMonth: function afterMonth(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date.year < compare[i].year || date.year === compare[i].year && date.month <= compare[i].month) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a year after another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  afterYear: function afterYear(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date.year <= compare[i].year) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Get the earliest date in an array.\n   * @return {Object}\n   */\n  earliest: function earliest(arr) {\n\n    var i = 0;\n    var len = arr.length;\n    var e = void 0;\n\n    for (; i < len; i++) {\n      if (!e || arr[i].before(e)) e = arr[i];\n    }\n\n    return e;\n  },\n\n  /**\n   * Get the latest date in an array.\n   * @return {Object}\n   */\n  latest: function latest(arr) {\n\n    var i = 0;\n    var len = arr.length;\n    var l = void 0;\n\n    for (; i < len; i++) {\n      if (!l || arr[i].after(l)) l = arr[i];\n    }\n\n    return l;\n  },\n\n  /**\n   * Clone a date instance.\n   * @param {Object} date\n   * @return {Object}\n   */\n  clone: function clone(date) {\n\n    // If we weren't passed a date, use this instance.\n    if (!date && this._date && this._date instanceof Date && dateHelper.isPrototypeOf(this)) {\n      date = this;\n    }\n\n    // No date, can't clone.\n    if (!date) {\n      throw new Error('Must pass a date to clone or call on an instance.');\n    }\n\n    return dateHelper.create(new Date(date._date.valueOf()));\n  },\n\n  /**\n   * If a comparison function is called on an instance, properly\n   * assign the vars.\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full\n   */\n  _checkComparisonArgs: function _checkComparisonArgs(date, compare, full) {\n\n    if (compare === undefined || typeof compare === 'boolean') {\n\n      if (!dateHelper.isPrototypeOf(this)) {\n        throw new Error('Cannot compare only one date!');\n      }\n\n      full = compare;\n      compare = date;\n      date = this;\n    }\n\n    compare = compare instanceof Array ? compare : [compare];\n\n    return [date, compare, full];\n  },\n\n  /**\n   * Check to see if we have an instance of the date object.\n   * @param  {String} prop\n   */\n  _instanceCheck: function _instanceCheck(prop) {\n    if (!this._date || !(this._date instanceof Date) || !dateHelper.isPrototypeOf(this)) throw new Error('Cannot access the property \"' + prop + '\" of the date helper with creating an instance!');\n  },\n\n  /**\n   * Clear the cache.\n   */\n  _clearCache: function _clearCache() {\n    this._instanceCheck('clearCache');\n    this._cache = {};\n  }\n};\n\nexports.default = dateHelper;\nmodule.exports = exports['default'];\n//# sourceMappingURL=date.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _pad = require('../util/pad');\n\nvar _pad2 = _interopRequireDefault(_pad);\n\nvar _date = require('./date');\n\nvar _date2 = _interopRequireDefault(_date);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Map characters to their special meanings.\n * @type {Object}\n */\n/**\n * # Parse Date Format\n * Given a date format string, break it down into pieces.\n *\n * @example\n * parseDateFormat('MM-DD-YYYY');\n *\n * @module helpers/date/parse-format.js\n */\n\nvar map = {\n  d: 'day',\n  m: 'month',\n  y: 'year',\n  '-': 'divider',\n  '/': 'divider',\n  ' ': 'space'\n};\n\n/**\n * Given a format and a string, get the day, month and year values from that string.\n * @param {Object} format\n * @return {Function}\n */\nfunction getValues(format) {\n\n  return function (value) {\n\n    var i = 0;\n    var index = 0;\n    var len = format.length;\n    var values = {};\n\n    // Loop through all format pieces\n    for (; i < len; i++) {\n\n      // Only worry about date values\n      if (['day', 'month', 'year'].indexOf(format[i].name) !== -1) {\n\n        // If the passed value doesn't contain a format piece, it's invalid.\n        if (value.length < index + format[i].length) return;\n\n        values[format[i].name] = parseInt(value.substr(index, format[i].length), 10);\n      }\n      index += format[i].length;\n    }\n\n    return _date2.default.create(values);\n  };\n}\n\n/**\n * Create a formatted date string given an object of values.\n * @param {Object} format\n * @return {Function}\n */\nfunction getString(format) {\n\n  /**\n   * @param {Object} vals\n   * @return {String}\n   */\n  return function (vals) {\n\n    var i = 0;\n    var len = format.length;\n    var str = '';\n\n    for (; i < len; i++) {\n\n      // Numbers\n      if (vals[format[i].name]) {\n        str += (0, _pad2.default)(vals[format[i].name], format[i].length);\n      }\n      // Dividers\n      else {\n          str += format[i].value;\n        }\n    }\n\n    return str;\n  };\n}\n\n/**\n * @param {String} format\n * @return {Object}\n */\nfunction parseDateFormat(format) {\n\n  var f = format.toLowerCase();\n  var i = 0;\n  var len = f.length;\n\n  var obj = {\n    parts: []\n  };\n\n  for (; i < len; i++) {\n\n    // If there is a matching character mapping and the last part was of the same name, increment its length\n    // and add to its content.\n    if (map[f[i]] && obj.parts.length && obj.parts[obj.parts.length - 1].name === map[f[i]]) {\n      obj.parts[obj.parts.length - 1].length++;\n      obj.parts[obj.parts.length - 1].value += format[i];\n      continue;\n    }\n\n    obj.parts.push({\n      name: map[f[i]] ? map[f[i]] : '',\n      value: format[i],\n      length: 1\n    });\n  }\n\n  // Add a way to convert the parsed date into a regex-ish string that works with the Typeahead implementation.\n  obj.getValues = getValues(obj.parts);\n  obj.getString = getString(obj.parts);\n\n  return obj;\n}\n\nexports.default = parseDateFormat;\nmodule.exports = exports['default'];\n//# sourceMappingURL=parse-format.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * # Add Class\n * Add a class on an element.\n *\n * @param {Element|Array} el An element or array of elements to update.\n * @param {String} name\n * @return {Element}\n *\n * @module helpers/dom/add-class.js\n */\n\nvar ws = /\\s+/;\nvar cleanup = /\\s{2,}/g;\n\nfunction addClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) {\n      el.classList.add(name[0]);\n    }\n    return el;\n  }\n\n  var toAdd = [];\n  var i = 0;\n  var l = name.length;\n  var item = void 0;\n  var clsName = typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '';\n\n  // see if we have anything to add\n  for (; i < l; i++) {\n    item = name[i];\n    if (item && !(0, _hasClass2.default)(clsName, item)) {\n      toAdd.push(item);\n    }\n  }\n\n  if (toAdd.length) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = addClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=add-class.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Breakpoint Helpers\n * Find the active breakpoint.\n *\n * @param {Number} width\n *\n * @module helpers/dom/breakpoint.js\n */\n\n/**\n * Breakpoints being used in the CSS.\n * @type {Object}\n */\nvar defaultBreakpoints = {\n  xs: {\n    min: 0,\n    max: 543\n  },\n  sm: {\n    min: 544,\n    max: 795\n  },\n  md: {\n    min: 796,\n    max: 1047\n  },\n  lg: {\n    min: 1048,\n    max: 1799\n  },\n  xl: {\n    min: 1800,\n    max: Infinity\n  }\n};\n\nfunction get(width, breakpoints) {\n\n  breakpoints = breakpoints || defaultBreakpoints;\n\n  var i = void 0;\n\n  for (i in breakpoints) {\n    if (width >= breakpoints[i].min && width <= breakpoints[i].max) {\n      return i;\n    }\n  }\n}\n\nexports.get = get;\n//# sourceMappingURL=breakpoint.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * # Has Class\n * See if an element has a class.\n *\n * @param {Element|String} el\n * @param {String} name\n * @return {Boolean}\n *\n * @module helpers/dom/has-class.js\n */\nfunction hasClass(el, name) {\n  var cName = ((typeof el === 'undefined' ? 'undefined' : _typeof(el)) === 'object' ? el.className || el.getAttribute && el.getAttribute('class') || '' : el || '').replace(/[\\t\\r\\n\\f]/g, ' ');\n  return (' ' + cName + ' ').indexOf(' ' + name + ' ') !== -1;\n}\n\nexports.default = hasClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=has-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Offset Position\n * Get the offset position of the element.\n *\n * @param {Element} el\n * @param {Boolean} viewPortOffset The offset relative to the viewport, not page.\n * @return {Object}\n *\n * @module helpers/dom/offset.js\n */\nfunction offset(el, viewPortOffset) {\n\n  var rect = {\n    top: 0,\n    left: 0\n  };\n\n  // Native implementation\n  if (el.getBoundingClientRect) {\n\n    var bounding = el.getBoundingClientRect();\n    rect.left = bounding.left;\n    rect.top = bounding.top;\n\n    if (!viewPortOffset) {\n      rect.left += typeof window.scrollX !== 'undefined' ? window.scrollX : window.pageXOffset;\n      rect.top += typeof window.scrollY !== 'undefined' ? window.scrollY : window.pageYOffset;\n    }\n  } else {\n    var x = 0,\n        y = 0;\n    do {\n      x += el.offsetLeft - (!viewPortOffset ? el.scrollLeft : 0);\n      y += el.offsetTop - (!viewPortOffset ? el.scrollTop : 0);\n    } while (el = el.offsetParent);\n\n    rect.left = x;\n    rect.top = y;\n  }\n\n  return rect;\n}\n\nexports.default = offset;\nmodule.exports = exports['default'];\n//# sourceMappingURL=offset.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Parse DOM attributes\n * Given an element and an attribute name, parse that attribute\n * if it exists or return a default.\n *\n * @module helpers/dom/parse-attribute.js\n */\n\n/**\n * Get the boolean value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction boolean(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return val === 'true' || val === '' ? true : false;\n}\n\n/**\n * Get the numeric value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction number(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return parseInt(val, 10);\n}\n\n/**\n * Get the boolean value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction string(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return val;\n}\n\nexports.boolean = boolean;\nexports.number = number;\nexports.string = string;\n//# sourceMappingURL=parse-attribute.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ws = /\\s+/; /**\n                 * # Remove Class\n                 * Remove a class on an element.\n                 *\n                 * @param {Element|Array} el An element or array of elements to update.\n                 * @param {String} name\n                 * @return {Element}\n                 *\n                 * @module helpers/dom/remove-class.js\n                 */\n\nvar cleanup = /\\s{2,}/g;\n\nfunction removeClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) el.classList.remove(name[0]);\n    return el;\n  }\n\n  // store two copies\n  var clsName = ' ' + (typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '') + ' ';\n  var result = clsName;\n  var current = void 0;\n  var start = void 0;\n  for (var i = 0, l = name.length; i < l; i++) {\n    current = name[i];\n    start = current ? result.indexOf(' ' + current + ' ') : -1;\n    if (start !== -1) {\n      start += 1;\n      result = result.slice(0, start) + result.slice(start + current.length);\n    }\n  }\n\n  // only write if modified\n  if (clsName !== result) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)(result.replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)(result.replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = removeClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=remove-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _addClass = require('./add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _removeClass = require('./remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toggleClass(el, name, enable) {\n\n  if (!el) {\n    return;\n  }\n\n  // If we're passed an array, toggle the class on each.\n  if (el instanceof NodeList || el instanceof Array) {\n\n    for (var i = 0, len = el.length; i < len; i++) {\n      toggleClass(el[i], name, enable);\n    }\n\n    return;\n  }\n\n  var action = void 0;\n  if (enable !== undefined) {\n    enable = typeof enable === 'function' ? enable.call(null, el) : enable;\n    action = enable ? 'add' : 'remove';\n  } else {\n    action = (0, _hasClass2.default)(el, name) ? 'remove' : 'add';\n  }\n\n  return (action === 'add' ? _addClass2.default : _removeClass2.default)(el, name);\n} /**\n   * # Toggle Class\n   * Toggle a class on an element given a condition.\n   *\n   * @param {Element|Array} el An element or array of elements to update.\n   * @param {String} name\n   * @param {Boolean} enable\n   * @return {Element}\n   *\n   * @module  helpers/dom/toggle-class.js\n   */\n\nexports.default = toggleClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=toggle-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Trigger Event\n * Trigger a DOM event on an element.\n *\n * @param {Element} el\n * @param {String} name\n *\n * @module helpers/dom/trigger-event.js\n */\nfunction triggerEvent(el, name) {\n\n  var event = void 0;\n\n  if (document.createEvent) {\n    event = document.createEvent('HTMLEvents');\n    event.initEvent(name, true, true);\n    event.eventName = name;\n    el.dispatchEvent(event);\n  } else {\n    event = document.createEventObject();\n    event.eventType = name;\n    event.eventName = name;\n    el.fireEvent('on' + event.eventType, event);\n  }\n}\n\nexports.default = triggerEvent;\nmodule.exports = exports['default'];\n//# sourceMappingURL=trigger-event.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * # Build Select\n * Build a select input.\n *\n * @param {Object} params\n *\n * @example\n * buildSelect({\n *   attributes: {\n *     name: 'test',\n *     class: 'spark-select__field'\n *   },\n *   options: [1, 2, 3, 4, 5, 6]\n * });\n *\n * @example\n * buildSelect({\n *   attributes: {\n *     name: 'test',\n *     class: 'spark-select__field',\n *     'data-attr': 'thing',\n *      multiple: true\n *   },\n *   selected: [2, 4],\n *   options: [\n *     {text: 'One', value: 1},\n *     {text: 'Two', value: 2},\n *     {text: 'Three', value: 3},\n *     {text: 'Four', value: 4},\n *     {text: 'Five', value: 5},\n *   ]\n * });\n *\n * @module helpers/form/build-select.js\n */\n\nfunction buildSelect(params) {\n\n  var el = document.createElement('select');\n  var html = '';\n  var attrs = params.attributes;\n  var selected = params.selected instanceof Array ? params.selected : params.selected ? [params.selected] : [];\n  var opts = params.options;\n\n  var i = void 0;\n  var len = opts.length;\n\n  // Set attributes\n  for (i in attrs) {\n    el.setAttribute(i, attrs[i]);\n  }\n\n  // Add options\n  for (i = 0; i < len; i++) {\n    if (_typeof(opts[i]) === 'object') {\n      html += '<option value=\"' + opts[i].value + '\" ' + (selected.indexOf(opts[i].value) !== -1 ? 'selected' : '') + '>' + opts[i].text + '</option>';\n    } else {\n      html += '<option value=\"' + opts[i] + '\" ' + (selected.indexOf(opts[i]) !== -1 ? 'selected' : '') + '>' + opts[i] + '</option>';\n    }\n  }\n\n  el.innerHTML = html;\n\n  return el;\n}\n\nexports.default = buildSelect;\nmodule.exports = exports['default'];\n//# sourceMappingURL=build-select.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _each = require('../util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction appendChildren(el, children, empty) {\n\n  empty = empty === undefined ? false : empty;\n\n  if (empty) {\n    el.textContent = '';\n  }\n\n  var domList = children instanceof window.HTMLCollection;\n\n  if (domList) {\n    while (children.length) {\n      el.appendChild(children[0]);\n    }\n  } else {\n    (0, _each2.default)(children, function (c) {\n      if (c) {\n        el.appendChild(c);\n      }\n    });\n  }\n} /**\n   * # Append Children\n   * Append an array of children to a node.\n   *\n   * @param {Element} el\n   * @param {Array} children\n   * @param {Boolean} empty Empty the node before adding children?\n   *\n   * @module helpers/manipulation/append-children.js\n   */\n\nexports.default = appendChildren;\nmodule.exports = exports['default'];\n//# sourceMappingURL=append-children.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _offset2 = require('../dom/offset');\n\nvar _offset3 = _interopRequireDefault(_offset2);\n\nvar _boxPosition = require('./box-position');\n\nvar _boxPosition2 = _interopRequireDefault(_boxPosition);\n\nvar _debounce = require('../util/debounce');\n\nvar _debounce2 = _interopRequireDefault(_debounce);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * # Affix\n                                                                                                                                                           * Affix one element to another.\n                                                                                                                                                           *\n                                                                                                                                                           * @example\n                                                                                                                                                           * new Affix({\n                                                                                                                                                           *   el: el,\n                                                                                                                                                           *   targetEl: el2,\n                                                                                                                                                           *   caretEl: el3,\n                                                                                                                                                           *   anchorY: 'top', // 'middle', 'bottom'\n                                                                                                                                                           *   anchorX: 'left', // 'center', 'right'\n                                                                                                                                                           * })\n                                                                                                                                                           *\n                                                                                                                                                           * @module helpers/position/affix.js\n                                                                                                                                                           */\n\nvar Affix = function () {\n\n  /**\n   * Store the reference elements and position.\n   * @param  {Object} params\n   */\n  function Affix() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Affix);\n\n    this.el = params.el;\n    this.targetEl = params.targetEl;\n    this.caretEl = params.caretEl;\n    this.anchorY = params.anchorY || 'top';\n    this.anchorX = params.anchorX || 'center';\n    this.isFixed = params.isFixed || false;\n\n    this._addEventListeners();\n    this._insertEl();\n    this._setPosition();\n    this._updateDebounced = (0, _debounce2.default)(this.update.bind(this), 500);\n  }\n\n  /**\n   * Stop listening and clean up event listeners\n   * @param {Object} params Optional\n   * @return {Object} this\n   */\n\n\n  Affix.prototype.remove = function remove() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!params.keepEl) this._removeEl();\n    this._removeEventListeners();\n    return this;\n  };\n\n  /**\n   * Update the position.\n   * @return {Object} this\n   */\n\n\n  Affix.prototype.update = function update() {\n    this._setPosition();\n    return this;\n  };\n\n  /**\n   * Listen for window resizes to update the position.\n   */\n\n\n  Affix.prototype._addEventListeners = function _addEventListeners() {\n    this._onResizeBound = this._onResize.bind(this);\n    this._onScrollBound = this._onScroll.bind(this);\n    window.addEventListener('resize', this._onResizeBound);\n    window.addEventListener('scroll', this._onScrollBound);\n  };\n\n  /**\n   * Remove event listeners\n   */\n\n\n  Affix.prototype._removeEventListeners = function _removeEventListeners() {\n    window.removeEventListener('resize', this._onResizeBound);\n    window.removeEventListener('scroll', this._onScrollBound);\n  };\n\n  /**\n   * Insert the element into the DOM.\n   */\n\n\n  Affix.prototype._insertEl = function _insertEl() {\n    this.el.setAttribute('data-affixed', '');\n    this._getRootEl().appendChild(this.el);\n  };\n\n  /**\n   * Remove the element from the DOM.\n   */\n\n\n  Affix.prototype._removeEl = function _removeEl() {\n    this.el.parentNode.removeChild(this.el);\n    this.el.removeAttribute('data-affixed');\n  };\n\n  /**\n   * Set the position of the target element.\n   */\n\n\n  Affix.prototype._setPosition = function _setPosition() {\n\n    // Fixed position\n    this.el.style.setProperty('position', this.isFixed ? 'fixed' : 'absolute', 'important');\n\n    // Target element properties\n\n    var _offset = (0, _offset3.default)(this.targetEl, this.isFixed),\n        targetTop = _offset.top,\n        targetLeft = _offset.left;\n\n    var targetWidth = this.targetEl.offsetWidth;\n    var targetHeight = this.targetEl.offsetHeight;\n\n    // Element to affix properties\n    var elWidth = this.el.offsetWidth;\n    var elHeight = this.el.offsetHeight;\n\n    // Maxes\n    var docHeight = document.documentElement.offsetHeight;\n    var docWidth = document.documentElement.offsetWidth;\n\n    // Get the values\n\n    var _calculatePosition2 = this._calculatePosition({\n      anchorX: this.anchorX,\n      anchorY: this.anchorY,\n      targetTop: targetTop,\n      targetLeft: targetLeft,\n      elHeight: elHeight,\n      elWidth: elWidth,\n      targetHeight: targetHeight,\n      targetWidth: targetWidth,\n      minX: 0,\n      minY: 0,\n      maxX: docWidth - elWidth,\n      maxY: Math.max(docHeight - elHeight, 0)\n    }),\n        elTop = _calculatePosition2.elTop,\n        elLeft = _calculatePosition2.elLeft;\n\n    // Position the caret\n\n\n    var _positionCaret2 = this._positionCaret({\n      elLeft: elLeft,\n      elTop: elTop,\n      elWidth: elWidth,\n      elHeight: elHeight,\n      targetHeight: targetHeight,\n      targetWidth: targetWidth,\n      targetLeft: targetLeft,\n      targetTop: targetTop\n    }),\n        extraLeft = _positionCaret2.extraLeft,\n        extraTop = _positionCaret2.extraTop;\n\n    // Set the position\n\n\n    this.el.style.left = elLeft + extraLeft + 'px';\n    this.el.style.top = elTop + extraTop + 'px';\n  };\n\n  /**\n   * Get the proper top position for an anchor direction.\n   * @param  {Object} p\n   * @return {Object}\n   */\n\n\n  Affix.prototype._calculatePosition = function _calculatePosition(p) {\n\n    // Keep track of what we're trying to do here, so on subsequent, nested calls to this\n    // method we can see what has already been tried.\n    p.previousAttempts = (p.previousAttempts || 0) + 1;\n    p.previousChecks = p.previousChecks || [];\n\n    var finalCheck = p.previousAttempts > 3;\n    var top = void 0;\n    var left = void 0;\n\n    // Y-axis check\n    switch (p.anchorY) {\n      case 'bottom':\n        top = p.targetTop + p.targetHeight;\n        break;\n      case 'middle':\n        top = p.targetTop - (p.elHeight - p.targetHeight) / 2;\n        break;\n      default:\n        top = p.targetTop - p.elHeight;\n        break;\n    }\n\n    // Under min\n    if (top < p.minY) {\n\n      if (!finalCheck && p.previousChecks.indexOf('overY') === -1) {\n        p.previousChecks.push('underY');\n        p.anchorY = this._getNewAnchorY(true, p.anchorY, p.anchorX);\n        return this._calculatePosition(p);\n      } else {\n        top = p.minY;\n      }\n    }\n\n    // Don't check for being too tall because causing a vertical scroll\n    // bar down is okay and this saves us from some real positioning hell.\n    /*if (top > p.maxY) {\n       if (!finalCheck && p.previousChecks.indexOf('underY') === -1) {\n        p.previousChecks.push('overY');\n        p.anchorY = this._getNewAnchorY(false, p.anchorY, p.anchorX);\n        return this._calculatePosition(p);\n      }\n      // On a final check, bottom wins because at least we can scroll\n      else if (!(finalCheck && p.anchorY === 'bottom')) {\n        top = p.maxY;\n      }\n    }*/\n\n    // X-axis check\n    switch (p.anchorX) {\n      case 'right':\n        left = p.targetLeft + (p.anchorY !== 'middle' && !p.isOverlapping ? 0 : p.targetWidth);\n        break;\n      case 'center':\n        left = p.targetLeft - (p.elWidth - p.targetWidth) / 2;\n        break;\n      default:\n        left = p.targetLeft - p.elWidth + (p.anchorY !== 'middle' ? p.targetWidth : 0);\n        break;\n    }\n\n    // Under min\n    if (left < p.minX) {\n\n      if (!finalCheck && p.previousChecks.indexOf('overX') === -1) {\n        p.previousChecks.push('underX');\n        p.anchorX = this._getNewAnchorX(true, p.anchorX, p.anchorY);\n        return this._calculatePosition(p);\n      } else {\n        left = p.minX;\n      }\n    }\n\n    // Over max\n    if (left > p.maxX) {\n\n      if (!finalCheck && p.previousChecks.indexOf('underX') === -1) {\n        p.previousChecks.push('overX');\n        p.anchorX = this._getNewAnchorX(false, p.anchorX, p.anchorY);\n        return this._calculatePosition(p);\n      } else {\n        left = p.maxX;\n      }\n    }\n\n    // One element is covering another. Try to fix that, but bail out after four tries.\n    if ((0, _boxPosition2.default)({ width: p.elWidth, height: p.elHeight, left: left, top: top }, { width: p.targetWidth, height: p.targetHeight, left: p.targetLeft, top: p.targetTop }) === 'overlap') {\n\n      p.isOverlapping = true;\n\n      // Try Y\n      if (p.repositionY !== false) {\n\n        // Will start undefined, then true, then false. This limits us to entering\n        // this loop twice, once to try moving in each direction.\n        p.repositionY = !p.repositionY;\n\n        // First try to put above, then try to put below.\n        p.anchorY = this._getNewAnchorY(p.repositionY, 'middle', p.anchorX);\n\n        // Give us one more shot at positioning\n        p.previousAttempts--;\n\n        return this._calculatePosition(p);\n      }\n      // Try X\n      else if (p.repositionX !== false) {\n\n          // Will start undefined, then true, then false. This limits us to entering\n          // this loop twice, once to try moving in each direction.\n          p.repositionX = !p.repositionX;\n\n          // First try to put above, then try to put below.\n          p.anchorX = this._getNewAnchorX(p.repositionX, 'center', p.anchorY);\n\n          // Give us one more shot at positioning\n          p.previousAttempts--;\n\n          return this._calculatePosition(p);\n        }\n    }\n\n    return { elTop: top, elLeft: left, anchorX: p.anchorX, anchorY: p.anchorY };\n  };\n\n  /**\n   * Determine the new y-axis anchor\n   * @param  {Boolean} underMin Under the min?\n   * @param  {String} anchorY\n   * @param  {String} anchorX\n   * @return {String}\n   */\n\n\n  Affix.prototype._getNewAnchorY = function _getNewAnchorY(underMin, anchorY, anchorX) {\n\n    // If the x-axis is anchored in the center, skip\n    // trying to anchor to the middle because then we'd\n    // be overlaying the button.\n    if (anchorX === 'center' || anchorY === 'middle') {\n      return underMin ? 'bottom' : 'top';\n    } else {\n      return 'middle';\n    }\n  };\n\n  /**\n   * Determine the new y-axis anchor\n   * @param  {Boolean} underMin Under the min?\n   * @param  {String} anchorY\n   * @param  {String} anchorX\n   * @return {String}\n   */\n\n\n  Affix.prototype._getNewAnchorX = function _getNewAnchorX(underMin, anchorX, anchorY) {\n\n    // If the y-axis is anchored in the center, skip\n    // trying to anchor to the middle because then we'd\n    // be overlaying the button.\n    if (anchorY === 'middle' || anchorX === 'center') {\n      return underMin ? 'left' : 'right';\n    } else {\n      return 'center';\n    }\n  };\n\n  /**\n   * Set the position of the caret.\n   * @param {Object} p\n   * @return {Object}\n   */\n\n\n  Affix.prototype._positionCaret = function _positionCaret() {\n    var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n    if (!this.caretEl) return;\n\n    var caretPosition = (0, _boxPosition2.default)({ width: p.elWidth, height: p.elHeight, left: p.elLeft, top: p.elTop }, { width: p.targetWidth, height: p.targetHeight, left: p.targetLeft, top: p.targetTop });\n\n    var caretDimensions = this.caretEl.getBoundingClientRect();\n    var caretWidth = caretDimensions.width;\n    var caretHeight = caretDimensions.height;\n    var left = Math.min(p.elWidth, Math.max(0, p.targetLeft - p.elLeft + p.targetWidth / 2));\n    var top = Math.min(p.elHeight, Math.max(0, p.targetTop - p.elTop + p.targetHeight / 2));\n\n    this.caretEl.style.left = Math.round(left) + 'px';\n    this.caretEl.style.top = Math.round(top) + 'px';\n\n    var extraLeft = 0;\n    var extraTop = 0;\n\n    this.caretEl.setAttribute('data-position', caretPosition);\n\n    switch (caretPosition) {\n      case 'above':\n        extraTop = -caretWidth / 2;\n        break;\n      case 'below':\n        extraTop = caretWidth / 2;\n        break;\n      case 'left':\n        extraLeft = -caretHeight / 2;\n        break;\n      default:\n        extraLeft = caretHeight / 2;\n        break;\n    }\n\n    return {\n      extraLeft: extraLeft,\n      extraTop: extraTop\n    };\n  };\n\n  /**\n   * Get the root element. Want to check if there's a top-level form for working\n   * with ASP .NET pages.\n   */\n\n\n  Affix.prototype._getRootEl = function _getRootEl() {\n    var form = document.querySelector('body > form');\n    return form && form.getAttribute('data-affixed') === null ? form : document.body;\n  };\n\n  /**\n   * On resize, update the position.\n   */\n\n\n  Affix.prototype._onResize = function _onResize() {\n    this.update();\n  };\n\n  /**\n   * When the window scrolls, ensure the proper position of the popover.\n   */\n\n\n  Affix.prototype._onScroll = function _onScroll() {\n    this._updateDebounced();\n  };\n\n  return Affix;\n}();\n\nexports.default = Affix;\nmodule.exports = exports['default'];\n//# sourceMappingURL=affix.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (a, b) {\n\n  var aXSpan = a.left + a.width;\n  var aYSpan = a.top + a.height;\n  var bXSpan = b.left + b.width;\n  var bYSpan = b.top + b.height;\n\n  if (aXSpan <= b.left) return 'left'; // a is fully left of b\n  if (a.left >= bXSpan) return 'right'; // a is fully right of b\n  if (aYSpan <= b.top) return 'above'; // a is fully above b\n  if (a.top >= bYSpan) return 'below'; // a is fully below b\n\n  return 'overlap'; // boxes overlap\n};\n\nmodule.exports = exports['default']; /**\n                                      * # Box Position\n                                      * How is one element positioned relative to another?\n                                      *\n                                      * @example\n                                      * boxPosition(\n                                      * {width: 100, height: 300, left: 0, top: 0},\n                                      * {width: 200, height: 50, left: 100, top: 40}\n                                      * )\n                                      *\n                                      * @module helpers/position/box-position.js\n                                      *\n                                      * @param {Object} a\n                                      * @param {Object} b\n                                      * @return {String}\n                                      */\n//# sourceMappingURL=box-position.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _matches = require('./matches');\n\nvar _matches2 = _interopRequireDefault(_matches);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getParent(parent, query, limitEl) {\n\n  limitEl = limitEl instanceof Array ? limitEl : [limitEl || document.body];\n\n  while (parent) {\n\n    if ((0, _matches2.default)(parent, query)) {\n      return parent;\n    }\n\n    if (limitEl.indexOf(parent) !== -1) {\n      return false;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return false;\n} /**\n   * # Get Parent\n   * See if an element has another element for a parent.\n   *\n   * @param {Element} parent\n   * @param {String} query\n   * @param {Array|Element} limitEl The last element we should check.\n   * @return {Boolean|Element}\n   *\n   * @module helpers/traversal/get-parent.js\n   */\n\nexports.default = getParent;\nmodule.exports = exports['default'];\n//# sourceMappingURL=get-parent.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _matches = require('./matches');\n\nvar _matches2 = _interopRequireDefault(_matches);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getSiblingAfter(el, query) {\n\n  while (el = el.nextElementSibling) {\n    if ((0, _matches2.default)(el, query)) {\n      return el;\n    }\n  }\n\n  return null;\n} /**\n   * # Get Sibling After\n   * Get a nearest sibling after the given element which matches\n   * the given query selector.\n   *\n   * @param {Element} el\n   * @param {String} query\n   * @return {Element|Null}\n   *\n   * @module helpers/traversal/get-sibling-after.js\n   */\n\nexports.default = getSiblingAfter;\nmodule.exports = exports['default'];\n//# sourceMappingURL=get-sibling-after.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _matches = require('./matches');\n\nvar _matches2 = _interopRequireDefault(_matches);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getSiblingBefore(el, query) {\n\n  while (el = el.previousElementSibling) {\n    if ((0, _matches2.default)(el, query)) {\n      return el;\n    }\n  }\n\n  return null;\n} /**\n   * # Get Sibling Before\n   * Get a nearest sibling before the given element which matches\n   * the given query selector.\n   *\n   * @param {Element} el\n   * @param {String} query\n   * @return {Element|Null}\n   *\n   * @module helpers/traversal/get-sibling-before.js\n   */\n\nexports.default = getSiblingBefore;\nmodule.exports = exports['default'];\n//# sourceMappingURL=get-sibling-before.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Has Parent\n * See if an element has another element for a parent.\n *\n * @param {Element} child\n * @param {Element} possibleParent\n * @return {Boolean}\n *\n * @module helpers/traversal/has-parent.js\n */\nfunction hasParent(child, possibleParent) {\n\n  var parent = child.parentNode;\n\n  while (parent) {\n\n    if (parent === possibleParent) {\n      return true;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return false;\n}\n\nexports.default = hasParent;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=has-parent.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Matches\n * See if an element matches a query selector.\n *\n * @param {Element} el\n * @param {String} query\n * @return {Boolean}\n *\n * @module helpers/traversal/matches.js\n */\nvar vendorMatch = typeof Element !== 'undefined' && (Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector);\n\nfunction matches(el, query) {\n\n  if (vendorMatch) return vendorMatch.call(el, query);\n\n  var nodes = el.parentNode ? el.parentNode.querySelectorAll(query) : [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i] === el) return true;\n  }\n\n  return false;\n}\n\nexports.default = matches;\nmodule.exports = exports['default'];\n//# sourceMappingURL=matches.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Debounce\n * Debounce a function call\n *\n * @param {Function} func\n * @param {Integer} delay\n *\n * @module helpers/util/debounce.js\n */\nfunction debounce(func, delay) {\n\n  var timer = void 0;\n\n  return function () {\n    var args = arguments;\n    if (timer) window.clearTimeout(timer);\n    timer = window.setTimeout(function () {\n      func.apply(this, args);\n    }, delay);\n  };\n}\n\nexports.default = debounce;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=debounce.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Each\n * Apply a callback function to a list of any kind: Array, NodeList, HTMLCollection or Object.\n *\n * @param {Array|NodeList|HTMLCollection|Object} list\n * @param {Function} cb\n *\n * @example\n * each([], callback);\n * each(el.children, callback);\n * each(el.childNodes, callback);\n * each({}, callback);\n *\n * @module helpers/util/each.js\n */\nfunction each(list, cb) {\n\n  if (!list) {\n    return;\n  }\n\n  if (typeof cb !== 'function') {\n    throw new Error('Cannot invoke `each` without a callback!');\n  }\n\n  var i = 0;\n  var len = list.length;\n\n  // Object\n  if (len === undefined) {\n    for (i in list) {\n      if (i !== 'prototype' && list.hasOwnProperty(i)) {\n        cb(i, list[i]);\n      }\n    }\n  }\n  // Array-like\n  else {\n      for (; i < len; i++) {\n        cb(list[i]);\n      }\n    }\n}\n\nexports.default = each;\nmodule.exports = exports['default'];\n//# sourceMappingURL=each.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Pad\n * Pad a number with leading zeros\n *\n * @param {Number} n\n * @param {Number} w\n * @param {String} c Optional String to pad with\n *\n * @example\n * pad(4, 2);\n *\n * @module helpers/util/pad.js\n */\nfunction pad(n, w, c) {\n  c = c || '0';\n  n = n + '';\n  return n.length >= w ? n : new Array(w - n.length + 1).join(c) + n;\n}\n\nexports.default = pad;\nmodule.exports = exports['default'];\n//# sourceMappingURL=pad.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Range\n * Create a range of numbers.\n *\n * @param {Number} start\n * @param {Number} stop\n * @param {Number} step Optional\n * @return {Array}\n *\n * @module helpers/util/range.js\n */\nfunction createRange(start, stop, step) {\n  if (stop == null) {\n    stop = start || 0;\n    start = 0;\n  }\n  if (!step) {\n    step = stop < start ? -1 : 1;\n  }\n\n  var length = Math.max(Math.ceil((stop - start) / step), 0);\n  var range = new Array(length);\n\n  for (var idx = 0; idx < length; idx++, start += step) {\n    range[idx] = start;\n  }\n\n  return range;\n}\n\nexports.default = createRange;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=range.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Trim\n * Trim whitespace on a string.\n *\n * @param {String} str\n *\n * @module helpers/util/trim.js\n */\n\nvar trimRE = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\nfunction trim(str) {\n  return str.replace(trimRE, '');\n}\n\nexports.default = trim;\nmodule.exports = exports['default'];\n//# sourceMappingURL=trim.js.map\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9kaXN0L2NvbXBvbmVudHMvYmFzZS5qcyIsImpzL2Rpc3QvY29tcG9uZW50cy9jYWxlbmRhci1wb3BvdmVyLmpzIiwianMvZGlzdC9jb21wb25lbnRzL3BvcG92ZXIuanMiLCJqcy9kaXN0L2hlbHBlcnMvYW5pbWF0aW9uL3JlcXVlc3QuanMiLCJqcy9kaXN0L2hlbHBlcnMvYW5pbWF0aW9uL3Njcm9sbC10by5qcyIsImpzL2Rpc3QvaGVscGVycy9hbmltYXRpb24vdHdlZW4uanMiLCJqcy9kaXN0L2hlbHBlcnMvZGF0ZS9kYXRlLmpzIiwianMvZGlzdC9oZWxwZXJzL2RhdGUvcGFyc2UtZm9ybWF0LmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS9hZGQtY2xhc3MuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL2JyZWFrcG9pbnQuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL2hhcy1jbGFzcy5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vb2Zmc2V0LmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS9wYXJzZS1hdHRyaWJ1dGUuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL3JlbW92ZS1jbGFzcy5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vdG9nZ2xlLWNsYXNzLmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS90cmlnZ2VyLWV2ZW50LmpzIiwianMvZGlzdC9oZWxwZXJzL2Zvcm0vYnVpbGQtc2VsZWN0LmpzIiwianMvZGlzdC9oZWxwZXJzL21hbmlwdWxhdGlvbi9hcHBlbmQtY2hpbGRyZW4uanMiLCJqcy9kaXN0L2hlbHBlcnMvcG9zaXRpb24vYWZmaXguanMiLCJqcy9kaXN0L2hlbHBlcnMvcG9zaXRpb24vYm94LXBvc2l0aW9uLmpzIiwianMvZGlzdC9oZWxwZXJzL3RyYXZlcnNhbC9nZXQtcGFyZW50LmpzIiwianMvZGlzdC9oZWxwZXJzL3RyYXZlcnNhbC9nZXQtc2libGluZy1hZnRlci5qcyIsImpzL2Rpc3QvaGVscGVycy90cmF2ZXJzYWwvZ2V0LXNpYmxpbmctYmVmb3JlLmpzIiwianMvZGlzdC9oZWxwZXJzL3RyYXZlcnNhbC9oYXMtcGFyZW50LmpzIiwianMvZGlzdC9oZWxwZXJzL3RyYXZlcnNhbC9tYXRjaGVzLmpzIiwianMvZGlzdC9oZWxwZXJzL3V0aWwvZGVib3VuY2UuanMiLCJqcy9kaXN0L2hlbHBlcnMvdXRpbC9lYWNoLmpzIiwianMvZGlzdC9oZWxwZXJzL3V0aWwvcGFkLmpzIiwianMvZGlzdC9oZWxwZXJzL3V0aWwvcmFuZ2UuanMiLCJqcy9kaXN0L2hlbHBlcnMvdXRpbC90cmltLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDem1FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc31yZXR1cm4gZX0pKCkiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZWFjaCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdXRpbC9lYWNoJyk7XG5cbnZhciBfZWFjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIyBCYXNlIENvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoZSBiYXNlIGNsYXNzIGZvciBTcGFyayBKUyBjb21wb25lbnRzLiBUaGlzIGNsYXNzIHNob3VsZCBuZXZlciBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGluc3RhbnRpYXRlZCBkaXJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIGNvbXBvbmVudHMvYmFzZS5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIEJhc2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIFNldCBwYXJhbWV0ZXJzIGFuZCBjYWNoZSBlbGVtZW50cy5cbiAgICovXG4gIGZ1bmN0aW9uIEJhc2UoZWwpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlKTtcblxuICAgIGlmIChwYXJhbXMuZWxSZXF1aXJlZCAmJiAhZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldFBhcmFtcyh0aGlzLmRlZmF1bHRzIHx8IHt9LCB0cnVlKTtcbiAgICB0aGlzLnNldFBhcmFtcyhwYXJhbXMpO1xuICAgICh0aGlzLl9jYWNoZUVsZW1lbnRzIHx8IG5vb3ApLmNhbGwodGhpcywgZWwsIHBhcmFtcyk7XG4gICAgKHRoaXMuX3BhcnNlUGFyYW1zIHx8IG5vb3ApLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBjb21wb25lbnQgZnJvbSB0aGUgRE9NIGFuZCBwcmVwYXJlIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24gYnkgZGVyZWZlcmVuY2luZyB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbGVhdmVFbGVtZW50IExlYXZlIHRoZSBlbGVtZW50IGludGFjdC5cbiAgICovXG5cblxuICBCYXNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUobGVhdmVFbGVtZW50KSB7XG5cbiAgICBpZiAodGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgaWYgKCFsZWF2ZUVsZW1lbnQgJiYgdGhpcy5lbCAmJiB0aGlzLmVsLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgICB9XG5cbiAgICB0aGlzLnVuc2V0UGFyYW1zKHRoaXMuZGVmYXVsdHMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY29tcG9uZW50IHRvIHVzZSBhIG5ldyBlbGVtZW50IG9yIHJlcGFyc2UgZnJvbVxuICAgKiB0aGUgZXhpc3RpbmcgZWxlbWVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBPcHRpb25hbFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIE9wdGlvbmFsXG4gICAqL1xuXG5cbiAgQmFzZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGVsKSB7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cblxuICAgIGlmICh0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycykge1xuICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICAodGhpcy5fY2FjaGVFbGVtZW50cyB8fCBub29wKS5jYWxsKHRoaXMsIGVsIHx8IHRoaXMuZWwsIHBhcmFtcyk7XG4gICAgKHRoaXMuX3BhcnNlUGFyYW1zIHx8IG5vb3ApLmNhbGwodGhpcyk7XG5cbiAgICBpZiAodGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIGhhc2ggb2YgcGFyYW1ldGVycyBpZiB0aGV5J3JlIHdoaXRlbGlzdGVkIG9yIHdlJ3JlIHRvbGQgdG8gZm9yY2UgdGhlIHNldC5cbiAgICogVGhpcyBpcyB1c2VkIHRvIHNldCBpbml0aWFsIHZhbHVlcyBhcyB3ZWxsIGFzIHNldCBwYXNzZWQgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlIEZvcmNlIHNldHRpbmcgZXZlbiBpZiB0aGUgcGFyYW0gaXMgbm90IHdoaXRlbGlzdGVkLlxuICAgKi9cblxuXG4gIEJhc2UucHJvdG90eXBlLnNldFBhcmFtcyA9IGZ1bmN0aW9uIHNldFBhcmFtcyhwYXJhbXMsIGZvcmNlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICgwLCBfZWFjaDIuZGVmYXVsdCkocGFyYW1zLCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgaWYgKF90aGlzLl93aGl0ZWxpc3RlZFBhcmFtcy5pbmRleE9mKGspICE9PSAtMSB8fCBmb3JjZSkge1xuICAgICAgICBfdGhpc1trXSA9IHY7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVW5zZXQgYWxsIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSBUaGUgb2JqZWN0IHRvIHVuc2V0IHRoZSBwYXJhbXMgZnJvbS4gRGVmYXVsdHMgdG8gYHRoaXNgLlxuICAgKi9cblxuXG4gIEJhc2UucHJvdG90eXBlLnVuc2V0UGFyYW1zID0gZnVuY3Rpb24gdW5zZXRQYXJhbXMoa2V5cywgc2NvcGUpIHtcblxuICAgIGtleXMgPSBrZXlzIGluc3RhbmNlb2YgQXJyYXkgPyBrZXlzIDogT2JqZWN0LmtleXMoa2V5cyk7XG4gICAgc2NvcGUgPSBzY29wZSB8fCB0aGlzO1xuICAgICgwLCBfZWFjaDIuZGVmYXVsdCkoa2V5cywgZnVuY3Rpb24gKGspIHtcbiAgICAgIGRlbGV0ZSBzY29wZVtrXTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBCYXNlO1xufSgpO1xuXG4vKipcbiAqIFdoaXRlbGlzdGVkIHBhcmFtZXRlcnMgd2hpY2ggY2FuIGJlIHNldCBvbiBjb25zdHJ1Y3Rpb24uXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cblxuXG5CYXNlLnByb3RvdHlwZS5fd2hpdGVsaXN0ZWRQYXJhbXMgPSBbXTtcblxuLyoqXG4gKiBEZWZhdWx0IHZhbHVlcyBmb3IgaW50ZXJuYWwgcHJvcGVydGllcyB3ZSB3aWxsIGJlIHNldHRpbmcuXG4gKiBUaGVzZSBhcmUgc2V0IG9uIGVhY2ggY29uc3RydWN0aW9uIHNvIHdlIGRvbid0IGxlYWsgcHJvcGVydGllc1xuICogaW50byB0aGUgcHJvdG90eXBlIGNoYWluLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuQmFzZS5wcm90b3R5cGUuZGVmYXVsdHMgPSB7fTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQmFzZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2Jhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcblxudmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xuXG52YXIgX3BvcG92ZXIgPSByZXF1aXJlKCcuL3BvcG92ZXInKTtcblxudmFyIF9wb3BvdmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BvcG92ZXIpO1xuXG52YXIgX3BhcnNlRm9ybWF0ID0gcmVxdWlyZSgnLi4vaGVscGVycy9kYXRlL3BhcnNlLWZvcm1hdCcpO1xuXG52YXIgX3BhcnNlRm9ybWF0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcnNlRm9ybWF0KTtcblxudmFyIF9kYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9kYXRlL2RhdGUnKTtcblxudmFyIF9kYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RhdGUpO1xuXG52YXIgX2J1aWxkU2VsZWN0ID0gcmVxdWlyZSgnLi4vaGVscGVycy9mb3JtL2J1aWxkLXNlbGVjdCcpO1xuXG52YXIgX2J1aWxkU2VsZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2J1aWxkU2VsZWN0KTtcblxudmFyIF9hZGRDbGFzcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL2FkZC1jbGFzcycpO1xuXG52YXIgX2FkZENsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FkZENsYXNzKTtcblxudmFyIF9yZW1vdmVDbGFzcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL3JlbW92ZS1jbGFzcycpO1xuXG52YXIgX3JlbW92ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlbW92ZUNsYXNzKTtcblxudmFyIF9oYXNDbGFzcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL2hhcy1jbGFzcycpO1xuXG52YXIgX2hhc0NsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhc0NsYXNzKTtcblxudmFyIF9hcHBlbmRDaGlsZHJlbiA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvbWFuaXB1bGF0aW9uL2FwcGVuZC1jaGlsZHJlbicpO1xuXG52YXIgX2FwcGVuZENoaWxkcmVuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FwcGVuZENoaWxkcmVuKTtcblxudmFyIF9nZXRQYXJlbnQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RyYXZlcnNhbC9nZXQtcGFyZW50Jyk7XG5cbnZhciBfZ2V0UGFyZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFBhcmVudCk7XG5cbnZhciBfdHJpZ2dlckV2ZW50ID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vdHJpZ2dlci1ldmVudCcpO1xuXG52YXIgX3RyaWdnZXJFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmlnZ2VyRXZlbnQpO1xuXG52YXIgX2JyZWFrcG9pbnQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbS9icmVha3BvaW50Jyk7XG5cbnZhciBfc2Nyb2xsVG8gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2FuaW1hdGlvbi9zY3JvbGwtdG8nKTtcblxudmFyIF9zY3JvbGxUbzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zY3JvbGxUbyk7XG5cbnZhciBfZ2V0U2libGluZ0JlZm9yZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdHJhdmVyc2FsL2dldC1zaWJsaW5nLWJlZm9yZScpO1xuXG52YXIgX2dldFNpYmxpbmdCZWZvcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0U2libGluZ0JlZm9yZSk7XG5cbnZhciBfZ2V0U2libGluZ0FmdGVyID0gcmVxdWlyZSgnLi4vaGVscGVycy90cmF2ZXJzYWwvZ2V0LXNpYmxpbmctYWZ0ZXInKTtcblxudmFyIF9nZXRTaWJsaW5nQWZ0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0U2libGluZ0FmdGVyKTtcblxudmFyIF9yYW5nZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdXRpbC9yYW5nZScpO1xuXG52YXIgX3JhbmdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JhbmdlKTtcblxudmFyIF9wYXJzZUF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL3BhcnNlLWF0dHJpYnV0ZScpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIyBDYWxlbmRhciBQb3BvdmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDcmVhdGUgYSBjYWxlbmRhciBmcm9tIHdoaWNoIGRhdGVzIGNhbiBiZSBzZWxlY3RlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogbmV3IENhbGVuZGFyUG9wb3ZlcihlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBjb21wb25lbnRzL2NhbGVuZGFyLXBvcG92ZXIuanNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xudmFyIGRvbURhdGVGb3JtYXQgPSAnWVlZWS1NTS1ERCc7XG52YXIgcGFyc2VkRG9tRm9ybWF0ID0gKDAsIF9wYXJzZUZvcm1hdDIuZGVmYXVsdCkoZG9tRGF0ZUZvcm1hdCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRFbGVtZW50KCkge1xuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGVsLmNsYXNzTmFtZSA9ICdzcGFyay1pbnB1dCBzcGFyay1kYXRlJztcbiAgZWwuaW5uZXJIVE1MID0gJzxpbnB1dCBjbGFzcz1cInNwYXJrLWlucHV0X19maWVsZFwiIHR5cGU9XCJkYXRlXCI+PHNwYW4gY2xhc3M9XCJzcGFyay1sYWJlbFwiPjwvc3Bhbj4nO1xuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIHByb3BlciBwYXJhbXMgZm9yIGluaXRpYWxpemF0aW9uXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbFxuICogQHBhcmFtICB7T2JqZWN0fSBwYXJhbXNcbiAqIEByZXR1cm4ge09iamVjfVxuICovXG5mdW5jdGlvbiBwYXJzZUluaXRQYXJhbXMoZWwsIHBhcmFtcykge1xuXG4gIC8vIElmIHRoZSBmaXJzdCBlbGVtZW50IGlzIGFuIGFycmF5IG9yIGFycmF5LWxpa2UgKE5vZGVMaXN0KSxcbiAgLy8gd2Ugd2lsbCBiZSB3b3JraW5nIHdpdGggYSByYW5nZS5cbiAgaWYgKGVsICYmIGVsLmhhc093blByb3BlcnR5KCdsZW5ndGgnKSkge1xuICAgIHBhcmFtcy5lbHMgPSBlbDtcbiAgfVxuICAvLyBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBwbGFpbiBvYmplY3QsIGNyZWF0ZSBhIGRlZmF1bHQgZWxlbWVudFxuICAvLyBzaW5jZSB0aGUgdXNlciBNVVNUIHByb3ZpZGUgYWRkaXRpb25hbCBwYXJhbXMgYnV0IHRoZSBlbGVtZW50XG4gIC8vIGlzIG9wdGlvbmFsLiBEb2luZyBpdCB0aGlzIHdheSB0byBrZWVwIHRoZSBhcml0eSB0aGUgc2FtZVxuICAvLyBhcyBvdGhlciBjb21wb25lbnRzLlxuICBlbHNlIGlmICghKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgICBwYXJhbXMgPSBlbCB8fCB7fTtcbiAgICAgIHBhcmFtcy5lbHMgPSBbY3JlYXRlRGVmYXVsdEVsZW1lbnQoKV07XG4gICAgfVxuICAgIC8vIEEgc2luZ2xlIGVsZW1lbnQgaXMgcGFzc2VkLlxuICAgIGVsc2Uge1xuICAgICAgICBwYXJhbXMuZWxzID0gW2VsXTtcbiAgICAgIH1cblxuICBwYXJhbXMudmlzaWJsZUNvdW50cyA9IHBhcmFtcy52aXNpYmxlQ291bnRzIHx8IChwYXJhbXMudmlzaWJsZUNvdW50ID8gW3BhcmFtcy52aXNpYmxlQ291bnRdIDogbnVsbCk7XG4gIHBhcmFtcy5taW5zID0gcGFyYW1zLm1pbnMgfHwgKHBhcmFtcy5taW4gPyBbcGFyYW1zLm1pbl0gOiBbXSk7XG4gIHBhcmFtcy5tYXhlcyA9IHBhcmFtcy5tYXhlcyB8fCAocGFyYW1zLm1heCA/IFtwYXJhbXMubWF4XSA6IFtdKTtcbiAgcGFyYW1zLnZhbHVlcyA9IHBhcmFtcy52YWx1ZXMgfHwgKHBhcmFtcy52YWx1ZSA/IFtwYXJhbXMudmFsdWVdIDogW10pO1xuXG4gIHJldHVybiBwYXJhbXM7XG59XG5cbnZhciBDYWxlbmRhclBvcG92ZXIgPSBmdW5jdGlvbiAoX0Jhc2VDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKENhbGVuZGFyUG9wb3ZlciwgX0Jhc2VDb21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDYWxlbmRhciBQb3BvdmVyIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgT3B0aW9uYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBPcHRpb25hbFxuICAgKi9cbiAgZnVuY3Rpb24gQ2FsZW5kYXJQb3BvdmVyKGVsKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FsZW5kYXJQb3BvdmVyKTtcblxuICAgIHBhcmFtcyA9IHBhcnNlSW5pdFBhcmFtcyhlbCwgcGFyYW1zKTtcblxuICAgIGlmICghKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Jhc2VDb21wb25lbnQuY2FsbCh0aGlzLCBlbCwgcGFyYW1zKSksIF90aGlzKSkge1xuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBjYWxlbmRhciBlbGVtZW50IGlmIHdlIHdlcmVuJ3QgcGFzc2VkIG9uZS5cbiAgICAoX3RoaXMuY2FsZW5kYXJFbCA/IG5vb3AgOiBfdGhpcy5fY3JlYXRlQ2FsZW5kYXIpLmNhbGwoX3RoaXMpO1xuICAgIF90aGlzLl9jYWNoZUNhbGVuZGFyRWxlbWVudHMoKTtcblxuICAgIF90aGlzLl9iaW5kRXZlbnRMaXN0ZW5lckNhbGxiYWNrcygpO1xuICAgIF90aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIF90aGlzLl9pbml0RGF0ZXNUb1Nob3coKTtcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY29tcG9uZW50IHRvIHVzZSBhIG5ldyBlbGVtZW50IG9yIHJlcGFyc2UgZnJvbVxuICAgKiB0aGUgZXhpc3RpbmcgZWxlbWVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBPcHRpb25hbFxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGVsKSB7XG5cbiAgICBpZiAoZWwpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLmVscyA9IGVsIGluc3RhbmNlb2YgQXJyYXkgPyBlbCA6IFtlbF07XG4gICAgICB0aGlzLl9jYWNoZUVsZW1lbnRzKCk7XG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIHRoaXMuX3BhcnNlSW5wdXRFbHNQYXJhbXMoKTtcbiAgICB0aGlzLl9pbml0RGF0ZXNUb1Nob3coKTtcblxuICAgIGlmICh0aGlzLmFjdGl2ZUluZGV4ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgdGhpcy5fY2hlY2tTaXplKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIE9wZW4gdGhlIGNhbGVuZGFyIHdpZGdldC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IE9wdGlvbmFsIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byB0aWUgYWN0aW9ucyB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIE9wdGlvbmFsXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gb3BlbigpIHtcbiAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cblxuICAgIGlmICh0aGlzLl9pc0Rpc2FibGVkW2luZGV4XSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5fdW5maWxsVG9nZ2xlKCk7XG5cbiAgICAvLyBBbGxvdyBmb3Igb25seSBwYXJhbXMgdG8gYmUgcGFzc2VkXG4gICAgaWYgKCh0eXBlb2YgaW5kZXggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGluZGV4KSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBwYXJhbXMgPSBpbmRleDtcbiAgICAgIGluZGV4ID0gMDtcbiAgICB9XG5cbiAgICAvLyBBbHJlYWR5IG9wZW5cbiAgICBpZiAodGhpcy5hY3RpdmVJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFdlIGhhdmUgYW4gYWxyZWFkeSBhY3RpdmUgaXRlbSwgY2xvc2UgaXRcbiAgICBpZiAodGhpcy5hY3RpdmVJbmRleCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fZGVhY3RpdmF0ZUVsZW1lbnQodGhpcy5hY3RpdmVJbmRleCk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgYW55IHRpbWVycyB3aGljaCBtYXkgYmUgcnVubmluZyB0byBjbG9zZSBvciBvcGVuIHRoaXNcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fb3BlbkNsb3NlVGltZXIpO1xuXG4gICAgLy8gU2V0IHRoZSBuZXcgaW5kZXhcbiAgICB0aGlzLmFjdGl2ZUluZGV4ID0gaW5kZXg7XG5cbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgcG9wb3ZlciB5ZXQsIGNyZWF0ZSBpdC5cbiAgICBpZiAoIXRoaXMucG9wb3Zlcikge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wb3ZlcigpO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgbGlzdCBvZiBkYXRlcyB0byBzaG93IGZvciB0aGlzIHZpZXcuXG4gICAgdGhpcy5faW5pdERhdGVzVG9TaG93KCk7XG5cbiAgICAvLyBFbnN1cmUgdGhlIGNhY2hlZCB2YWx1ZXMgYXJlIGluIGxpbmUgd2l0aCB0aGUgaW5wdXQgdmFsdWVzLlxuICAgIHRoaXMudXBkYXRlVmFsdWVzKCk7XG5cbiAgICAvLyBDcmVhdGUgYSBjYWxlbmRhciBvciBjYWxlbmRhcnMgaW5zaWRlIHRoZSBwb3BvdmVyXG4gICAgdGhpcy5yZW5kZXIoe1xuICAgICAgY2xlYXJDYWNoZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgLy8gRmluYWxseSwgc2hvdyB0aGUgcG9wb3ZlciBhZnRlciBhIGRlbGF5IG9yIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgdGhpcy5fb3BlbkNsb3NlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucG9wb3Zlci5vcGVuKHtcbiAgICAgICAgYWZmaXhUbzogdGhpcy5lbHNbaW5kZXhdLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1kYXRlX19jYWxlbmRhci10b2dnbGUnKVxuICAgICAgfSk7XG4gICAgfS5iaW5kKHRoaXMpLCBwYXJhbXMuZGVsYXkgfHwgMCk7XG5cbiAgICAvLyBBY3RpdmF0ZSB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50XG4gICAgdGhpcy5fYWN0aXZhdGVFbGVtZW50KGluZGV4KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgY2FsZW5kYXIgd2lkZ2V0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKHBhcmFtcykge1xuXG4gICAgdGhpcy5fdW5maWxsVG9nZ2xlKCk7XG5cbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgICAvLyBDYW4ndCBjbG9zZSBpZiB3ZSBhcmVuJ3Qgb3IgaGF2ZW4ndCB5ZXQgb3BlbmVkLlxuICAgIGlmICh0aGlzLmFjdGl2ZUluZGV4ID09PSBudWxsIHx8ICF0aGlzLnBvcG92ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIERlYWN0aXZlIHRoZSBjb3JyZXNwb25kaW5nIGVsZW1lbnRcbiAgICB0aGlzLl9kZWFjdGl2YXRlRWxlbWVudCh0aGlzLmFjdGl2ZUluZGV4KTtcblxuICAgIC8vIENsZWFyIGFueSBleGlzdGluZyBjbG9zZSBvciBvcGVuIGV2ZW50cyB3aGljaCBhcmUgcXVldWVkXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX29wZW5DbG9zZVRpbWVyKTtcblxuICAgIC8vIENsb3NlIGFmdGVyIGEgZGVsYXksIG9yIG9uIHRoZSBuZXh0IHRpY2tcbiAgICB0aGlzLmFjdGl2ZUluZGV4ID0gbnVsbDtcbiAgICB0aGlzLl9vcGVuQ2xvc2VUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5wb3BvdmVyLmNsb3NlKCk7XG4gICAgfS5iaW5kKHRoaXMpLCBwYXJhbXMuZGVsYXkgfHwgMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfEVsZW1lbnR9IGluZGV4IE9wdGlvbmFsXG4gICAqIEByZXR1cm4ge01peGVkfVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZShpbmRleCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1tpbmRleCB8fCAwXTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBkYXRlIGZvciBhIGdpdmVuIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ8RWxlbWVudH0gaW5kZXhcbiAgICogQHBhcmFtIHtCb29sZWFufSBza2lwUmFuZ2VDaGVjayBPcHRpb25hbCBEb24ndCBjaGVjayBmb3Igc2VxdWVudGlhbCByYW5nZSB2YWx1ZXMuXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uIHNldFZhbHVlKHZhbHVlLCBpbmRleCwgc2tpcFJhbmdlQ2hlY2spIHtcblxuICAgIHZhciBvYmogPSAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09PSAnb2JqZWN0JyA/IHZhbHVlIDogcGFyc2VkRG9tRm9ybWF0LmdldFZhbHVlcyh2YWx1ZSk7XG4gICAgdmFyIGVsID0gdm9pZCAwO1xuXG4gICAgLy8gSWYgd2UgYXJlIHBhc3NlZCBhbiBlbGVtZW50IGluc3RlYWQgb2YgYW4gaW5kZXgsIHVzZSB0aGF0LlxuICAgIGlmIChpbmRleCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICBlbCA9IGluZGV4O1xuICAgICAgaW5kZXggPSB0aGlzLmlucHV0RWxzLmluZGV4T2YoZWwpO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIGZpbmQgdGhlIGVsZW1lbnQgaW4gb3VyIGxpc3QuXG4gICAgZWxzZSB7XG4gICAgICAgIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgICAgICAgZWwgPSB0aGlzLmlucHV0RWxzW2luZGV4XTtcbiAgICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgc3RvcmVkIHZhbHVlXG4gICAgdGhpcy52YWx1ZXNbaW5kZXhdID0gb2JqO1xuXG4gICAgLy8gSWYgd2UgYXJlIHdvcmtpbmcgd2l0aCBhIHJhbmdlLCBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWVzIGFyZSBpbiBvcmRlci5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuX2NoZWNrVmFsdWVzKGluZGV4LCBza2lwUmFuZ2VDaGVjayk7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSB2YWx1ZSBvbiB0aGUgaW5wdXQgZWxlbWVudC4gTWFrZSBzdXJlIHdlIGRvbid0IGdldCBpbnRvIGFuIGluZmluaXRlXG4gICAgLy8gbG9vcCBzaW5jZSB3ZSBsaXN0ZW4gdG8gdGhlIGNoYW5nZSBldmVudCBvbiB0aGUgaW5wdXQuIFdlIGhhdmUgdG8gdHJpZ2dlciBpdFxuICAgIC8vIHNvIHRoYXQgb3RoZXIgY29tcG9uZW50cyBsaXN0ZW5pbmcgdG8gaXQgZ2V0IHRoZSB1cGRhdGUuXG4gICAgZWwudmFsdWUgPSB2YWx1ZSAmJiBvYmogPT09IHZhbHVlID8gcGFyc2VkRG9tRm9ybWF0LmdldFN0cmluZyh2YWx1ZSkgOiB2YWx1ZSB8fCAnJztcblxuICAgIHRoaXMuX2lucHV0c0NoYW5naW5nID0gdGhpcy5faW5wdXRzQ2hhbmdpbmcgfHwgW107XG4gICAgaWYgKHRoaXMuX2lucHV0c0NoYW5naW5nLmluZGV4T2YoaW5kZXgpID09PSAtMSkge1xuICAgICAgdGhpcy5faW5wdXRzQ2hhbmdpbmcucHVzaChpbmRleCk7XG5cbiAgICAgICgwLCBfdHJpZ2dlckV2ZW50Mi5kZWZhdWx0KShlbCwgJ2NoYW5nZScpO1xuICAgICAgKHRoaXMub25DaGFuZ2UgfHwgbm9vcCkoZWwsIGVsLnZhbHVlLCB0aGlzKTtcblxuICAgICAgdmFyIHBvcyA9IHRoaXMuX2lucHV0c0NoYW5naW5nLmluZGV4T2YoaW5kZXgpO1xuICAgICAgdGhpcy5faW5wdXRzQ2hhbmdpbmcuc3BsaWNlKHBvcywgMSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXIoe1xuICAgICAgY2xlYXJDYWNoZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFyIHRoZSBzZWxlY3RlZCB2YWx1ZXMuXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5jbGVhclZhbHVlcyA9IGZ1bmN0aW9uIGNsZWFyVmFsdWVzKCkge1xuXG4gICAgdmFyIGVscyA9IHRoaXMuaW5wdXRFbHM7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBlbHMubGVuZ3RoO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGhpcy5jbGVhclZhbHVlKGkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgc2VsZWN0ZWQgdmFsdWUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuY2xlYXJWYWx1ZSA9IGZ1bmN0aW9uIGNsZWFyVmFsdWUoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuXG4gICAgdGhpcy52YWx1ZXMgPSB0aGlzLnZhbHVlcyB8fCBbXTtcbiAgICBpZiAoIXRoaXMuaW5wdXRFbHNbaW5kZXhdKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjbGVhciB2YWx1ZSBhdCBpbmRleCAnICsgaW5kZXggKyAnLiBObyBpbnB1dCBlbGVtZW50IGV4aXN0cyB3aXRoIHRoYXQgaW5kZXghJyk7XG4gICAgdGhpcy52YWx1ZXNbaW5kZXhdID0gdGhpcy5pbnB1dEVsc1tpbmRleF0udmFsdWUgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUYWtlIHRoZSBkYXRlIHZhbHVlcyBmcm9tIHRoZSBpbnB1dHMgYW5kIHNldCB0aGVtIGFzIGRhdGVzIG9uIHRoZSBjYWxlbmRhci5cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLnVwZGF0ZVZhbHVlcyA9IGZ1bmN0aW9uIHVwZGF0ZVZhbHVlcygpIHtcblxuICAgIHZhciBlbHMgPSB0aGlzLmlucHV0RWxzO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gZWxzLmxlbmd0aDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMudXBkYXRlVmFsdWUoaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRha2UgdGhlIGRhdGUgdmFsdWVzIGZyb20gdGhlIGlucHV0cyBhbmQgc2V0IHRoZW0gYXMgZGF0ZXMgb24gdGhlIGNhbGVuZGFyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLnVwZGF0ZVZhbHVlID0gZnVuY3Rpb24gdXBkYXRlVmFsdWUoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuXG4gICAgdGhpcy52YWx1ZXMgPSB0aGlzLnZhbHVlcyB8fCBbXTtcbiAgICBpZiAoIXRoaXMuaW5wdXRFbHNbaW5kZXhdKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1cGRhdGUgdmFsdWUgYXQgaW5kZXggJyArIGluZGV4ICsgJy4gTm8gaW5wdXQgZWxlbWVudCBleGlzdHMgd2l0aCB0aGF0IGluZGV4IScpO1xuICAgIHRoaXMudmFsdWVzW2luZGV4XSA9IHRoaXMuaW5wdXRFbHNbaW5kZXhdLnZhbHVlID8gcGFyc2VkRG9tRm9ybWF0LmdldFZhbHVlcyh0aGlzLmlucHV0RWxzW2luZGV4XS52YWx1ZSkgOiBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoZSBjYWxlbmRhciBmdW5jdGlvbmFsaXR5LlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKGluZGV4KSB7XG5cbiAgICB2YXIgaSA9IGluZGV4IHx8IDA7XG4gICAgdmFyIGxlbiA9IGluZGV4ICE9PSB1bmRlZmluZWQgPyBpbmRleCArIDEgOiB0aGlzLmVscy5sZW5ndGg7XG4gICAgdmFyIHRvZ2dsZSA9IHZvaWQgMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMuX2lzRGlzYWJsZWRbaV0gPSB0cnVlO1xuICAgICAgdGhpcy5lbHNbaV0uc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICcnKTtcbiAgICAgIHRvZ2dsZSA9IHRoaXMuZWxzW2ldLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1kYXRlX19jYWxlbmRhci10b2dnbGUnKTtcbiAgICAgIGlmICh0b2dnbGUpIHRvZ2dsZS5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJycpO1xuICAgIH1cblxuICAgIHRoaXMuY2xvc2UoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgdGhlIGNhbGVuZGFyIGZ1bmN0aW9uYWxpdHkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKGluZGV4KSB7XG5cbiAgICB2YXIgaSA9IGluZGV4IHx8IDA7XG4gICAgdmFyIGxlbiA9IGluZGV4ICE9PSB1bmRlZmluZWQgPyBpbmRleCArIDEgOiB0aGlzLmVscy5sZW5ndGg7XG4gICAgdmFyIHRvZ2dsZSA9IHZvaWQgMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMuX2lzRGlzYWJsZWRbaV0gPSBmYWxzZTtcbiAgICAgIHRoaXMuZWxzW2ldLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnJyk7XG4gICAgICB0b2dnbGUgPSB0aGlzLmVsc1tpXS5xdWVyeVNlbGVjdG9yKCcuc3BhcmstZGF0ZV9fY2FsZW5kYXItdG9nZ2xlJyk7XG4gICAgICBpZiAodG9nZ2xlKSB0b2dnbGUucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGNhbGVuZGFyIG9yIGNhbGVuZGFycyBpbnRvIHRoZSBwb3BvdmVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIocGFyYW1zKSB7XG5cbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgcG9wb3ZlciB5ZXQsIGNyZWF0ZSBpdC5cbiAgICBpZiAoIXRoaXMucG9wb3Zlcikge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wb3ZlcigpO1xuICAgIH1cblxuICAgIHZhciBjb250ZW50ID0gdm9pZCAwO1xuXG4gICAgLy8gQ2xlYXIgdGhlIGNhY2hlIHNvIHRoYXQgd2UgZG9uJ3Qgc2hvdyBvdXQtb2YtZGF0ZSB2YWx1ZXMuXG4gICAgaWYgKHBhcmFtcy5jbGVhckNhY2hlKSB7XG4gICAgICB0aGlzLl9yZW5kZXJDYWNoZSA9IHt9O1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgdmlzaWJsZSBkYXlzLCB3ZWVrcywgbW9udGhzIG9yIHllYXJzXG4gICAgaWYgKHRoaXMudmlld1JhbmdlID09PSAneWVhcicpIGNvbnRlbnQgPSB0aGlzLl9yZW5kZXJZZWFycygpO2Vsc2UgaWYgKHRoaXMudmlld1JhbmdlID09PSAnd2VlaycpIGNvbnRlbnQgPSB0aGlzLl9yZW5kZXJXZWVrcygpO2Vsc2UgaWYgKHRoaXMudmlld1JhbmdlID09PSAnZGF5JykgY29udGVudCA9IHRoaXMuX3JlbmRlckRheXMoKTtlbHNlIGNvbnRlbnQgPSB0aGlzLl9yZW5kZXJNb250aHMoKTtcblxuICAgIHRoaXMuX2luc2VydENvbnRlbnQoY29udGVudCwgcGFyYW1zKTtcblxuICAgIC8vIFVwZGF0ZSBhdHRyaWJ1dGVzXG4gICAgdGhpcy5fdXBkYXRlQXR0cmlidXRlcygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFucyB1cCBldmVudCBsaXN0ZW5lcnMgYW5kIHJlbW92ZXMgaGVscGVycy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBsZWF2ZUVsZW1lbnQgTGVhdmUgdGhlIGVsZW1lbnQgaW50YWN0LlxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGxlYXZlRWxlbWVudCkge1xuICAgIHRoaXMucG9wb3ZlciAmJiB0aGlzLnBvcG92ZXIucmVtb3ZlKCk7XG4gICAgcmV0dXJuIF9CYXNlQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLCBsZWF2ZUVsZW1lbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNb3ZlIHRvIHRoZSBuZXh0IHNldCBvZiBkYXRlcy5cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGlmICh0aGlzLl9hdE1heCkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5fc2V0RGF0ZXNUb1Nob3coMSk7XG4gICAgdGhpcy5yZW5kZXIoe1xuICAgICAgYXBwZW5kOiAxXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vdmUgdG8gdGhlIHByZXZpb3VzIHNldCBvZiBkYXRlcy5cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLnByZXZpb3VzID0gZnVuY3Rpb24gcHJldmlvdXMoKSB7XG4gICAgaWYgKHRoaXMuX2F0TWluKSByZXR1cm4gdGhpcztcbiAgICB0aGlzLl9zZXREYXRlc1RvU2hvdygtMSk7XG4gICAgdGhpcy5yZW5kZXIoe1xuICAgICAgcHJlcGVuZDogMVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93IGEgc3BlY2lmaWMgZGF0ZSBvbiB0aGUgY2FsZW5kYXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLnNob3dEYXRlID0gZnVuY3Rpb24gc2hvd0RhdGUocGFyYW1zKSB7XG5cbiAgICAvLyBPcGVuIGlmIHdlJ3JlIGNsb3NlZC5cbiAgICBpZiAodGhpcy5hY3RpdmVJbmRleCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5vcGVuKCk7XG4gICAgfVxuXG4gICAgdmFyIG1vbnRoID0gcGFyYW1zLm1vbnRoIHx8IG51bGw7XG4gICAgdmFyIHllYXIgPSBwYXJhbXMueWVhciB8fCBudWxsO1xuICAgIHZhciBkYXkgPSBwYXJhbXMuZGF5IHx8IG51bGw7XG5cbiAgICAvLyBOb3RoaW5nIHRvIGRvLlxuICAgIGlmICghbW9udGggJiYgIXllYXIgJiYgIWRheSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHNob3dpbmcgPSB0aGlzLl9kYXRlc1RvU2hvd1t0aGlzLmFjdGl2ZUluZGV4XS5jbG9uZSgpO1xuICAgIHZhciBub3VuID0gdGhpcy52aWV3UmFuZ2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0aGlzLnZpZXdSYW5nZS5zbGljZSgxKTtcblxuICAgIC8vIE9ubHkgY2hhbmdlIHRoZSB2YWx1ZXMgd2Ugd2VyZSBnaXZlblxuICAgIGlmICh5ZWFyKSB7XG4gICAgICBzaG93aW5nLnllYXIgPSB5ZWFyO1xuICAgIH1cbiAgICBpZiAobW9udGgpIHtcbiAgICAgIHNob3dpbmcubW9udGggPSBtb250aDtcbiAgICB9XG4gICAgaWYgKGRheSkge1xuICAgICAgc2hvd2luZy5kYXkgPSBkYXk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgbWluXG4gICAgdmFyIG1pbiA9IHRoaXMubWluc1t0aGlzLmFjdGl2ZUluZGV4XTtcbiAgICBpZiAobWluICYmIHNob3dpbmdbJ2JlZm9yZScgKyBub3VuXShtaW4pKSB7XG4gICAgICBzaG93aW5nID0gbWluLmNsb25lKCk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgbWF4XG4gICAgdmFyIG1heCA9IHRoaXMubWF4ZXNbdGhpcy5hY3RpdmVJbmRleF07XG4gICAgaWYgKG1heCAmJiBzaG93aW5nWydhZnRlcicgKyBub3VuXShtYXgpKSB7XG4gICAgICBzaG93aW5nID0gbWF4LmNsb25lKCk7XG4gICAgfVxuICAgIHRoaXMuX2RhdGVzVG9TaG93W3RoaXMuYWN0aXZlSW5kZXhdID0gc2hvd2luZztcblxuICAgIC8vIFBvcHVsYXRlIHRoZSByZXN0IG9mIHRoZSBkYXRlc1xuICAgIHRoaXMuX3NldERhdGVzVG9TaG93KCk7XG5cbiAgICByZXR1cm4gdGhpcy5yZW5kZXIoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBhcHByb3ByaWF0ZSBudW1iZXIgb2YgeWVhcnMuXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX3JlbmRlclllYXJzID0gZnVuY3Rpb24gX3JlbmRlclllYXJzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGlzcGxheWluZyB5ZWFycyBpbiB0aGUgY2FsZW5kYXIgaXMgbm90IHlldCBzdXBwb3J0ZWQhJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgYXBwcm9wcmlhdGUgbnVtYmVyIG9mIHdlZWtzLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9yZW5kZXJXZWVrcyA9IGZ1bmN0aW9uIF9yZW5kZXJXZWVrcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Rpc3BsYXlpbmcgd2Vla3MgaW4gdGhlIGNhbGVuZGFyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZiBkYXlzLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9yZW5kZXJEYXlzID0gZnVuY3Rpb24gX3JlbmRlckRheXMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEaXNwbGF5aW5nIGRheXMgaW4gdGhlIGNhbGVuZGFyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZiBtb250aHMuXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX3JlbmRlck1vbnRocyA9IGZ1bmN0aW9uIF9yZW5kZXJNb250aHMoKSB7XG5cbiAgICB2YXIgbW9udGhzID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0aGlzLl9kYXRlc1RvU2hvdy5sZW5ndGg7XG4gICAgdmFyIGN1cnJlbnQgPSBfZGF0ZTIuZGVmYXVsdC5ub3coKTtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG1vbnRocy5wdXNoKHRoaXMuX3JlbmRlck1vbnRoKHRoaXMuX2RhdGVzVG9TaG93W2ldLCBjdXJyZW50KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vbnRocztcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIGEgbW9udGguXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjdXJyZW50XG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fcmVuZGVyTW9udGggPSBmdW5jdGlvbiBfcmVuZGVyTW9udGgoZGF0ZSwgY3VycmVudCkge1xuXG4gICAgLy8gQSB1bmlxdWUga2V5IGZvciB0aGlzIG1vbnRoIHVzZWQgZm9yIGNhY2hpbmdcbiAgICB2YXIga2V5ID0gZGF0ZS55ZWFyICsgJy0nICsgZGF0ZS5tb250aDtcblxuICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGEgY2FjaGVcbiAgICB0aGlzLl9yZW5kZXJDYWNoZSA9IHRoaXMuX3JlbmRlckNhY2hlIHx8IHt9O1xuXG4gICAgLy8gUmV0dXJuIGEgY2FjaGVkIGluc3RhbmNlXG4gICAgaWYgKHRoaXMuX3JlbmRlckNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJDYWNoZVtrZXldO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgZWxlbWVudFxuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhciBodG1sID0gJyc7XG4gICAgZWwuY2xhc3NOYW1lID0gJ3NwYXJrLWNhbGVuZGFyX19tb250aCAnICsgdGhpcy5fZ2V0TW9udGhDbGFzc05hbWVzKGRhdGUpO1xuXG4gICAgLy8gQWRkIHRoZSB0aXRsZSBvciBkcm9wZG93bnMuXG4gICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cInNwYXJrLWNhbGVuZGFyX19tb250aC10aXRsZVwiPic7XG4gICAgaWYgKHRoaXMucXVpY2tKdW1wICYmIHRoaXMudmlzaWJsZUNvdW50c1t0aGlzLmFjdGl2ZUluZGV4XSA9PT0gMSkge1xuICAgICAgaHRtbCArPSB0aGlzLl9yZW5kZXJNb250aFF1aWNrSnVtcChkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaHRtbCArPSBkYXRlLm1vbnRoTmFtZSArICcgJyArIGRhdGUueWVhcjtcbiAgICB9XG4gICAgaHRtbCArPSAnPC9kaXY+JztcblxuICAgIC8vIEFkZCB0aGUgZGF5cyBvZiB0aGUgd2VlayBoZWFkaW5nc1xuICAgIGh0bWwgKz0gdGhpcy5fcmVuZGVyTW9udGhEYXlzT2ZXZWVrKCk7XG5cbiAgICAvLyBBZGQgdGhlIGRheXNcbiAgICBodG1sICs9IHRoaXMuX3JlbmRlck1vbnRoRGF5cyhkYXRlLCBjdXJyZW50KTtcblxuICAgIGVsLmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICAvLyBTdG9yZSBpbiB0aGUgY2FjaGUgYW5kIHJldHVyblxuICAgIHJldHVybiB0aGlzLl9yZW5kZXJDYWNoZVtrZXldID0gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgc2VsZWN0IGlucHV0cyB1c2VkIGZvciBqdW1waW5nIGFoZWFkL2JhY2t3YXJkIHNldmVyYWwgbW9udGhzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX3JlbmRlck1vbnRoUXVpY2tKdW1wID0gZnVuY3Rpb24gX3JlbmRlck1vbnRoUXVpY2tKdW1wKGRhdGUpIHtcblxuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhciB5ZWFycyA9IHZvaWQgMDtcbiAgICB2YXIgbW9udGhzID0gdm9pZCAwO1xuXG4gICAgLy8gTWluIGFuZCBtYXggeWVhciB0byBzaG93XG4gICAgdmFyIG1pbiA9IHRoaXMubWluc1t0aGlzLmFjdGl2ZUluZGV4XSA/IHRoaXMubWluc1t0aGlzLmFjdGl2ZUluZGV4XS5jbG9uZSgpIDogbnVsbDtcbiAgICB2YXIgbWF4ID0gdGhpcy5tYXhlc1t0aGlzLmFjdGl2ZUluZGV4XSA/IHRoaXMubWF4ZXNbdGhpcy5hY3RpdmVJbmRleF0uY2xvbmUoKSA6IG51bGw7XG4gICAgdmFyIHF1aWNrSnVtcFJhbmdlID0gdHlwZW9mIHRoaXMucXVpY2tKdW1wUmFuZ2UgPT09ICdudW1iZXInICYmIHRoaXMucXVpY2tKdW1wUmFuZ2UgJSAxID09PSAwID8gdGhpcy5xdWlja0p1bXBSYW5nZSA6IDUwO1xuXG4gICAgLy8gTm8gbWluLCBnbyA1MCB5ZWFycyBiYWNrXG4gICAgaWYgKCFtaW4pIHtcbiAgICAgIG1pbiA9IGRhdGUuY2xvbmUoKTtcbiAgICAgIG1pbi55ZWFyID0gbWluLnllYXIgLSBxdWlja0p1bXBSYW5nZTtcbiAgICB9XG5cbiAgICAvLyBObyBtYXgsIGdvIDUwIHllYXJzIGZvcndhcmRcbiAgICBpZiAoIW1heCkge1xuICAgICAgbWF4ID0gZGF0ZS5jbG9uZSgpO1xuICAgICAgbWF4LnllYXIgPSBtYXgueWVhciArIHF1aWNrSnVtcFJhbmdlO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgbW9udGhzIHRvIHNob3cuXG4gICAgdmFyIG1vbnRoT3B0cyA9IF9kYXRlMi5kZWZhdWx0LmdldE1vbnRoTmFtZXMoKS5tYXAoZnVuY3Rpb24gKHZhbCwgaSkge1xuXG4gICAgICAvLyBEb24ndCBzaG93IGEgbW9udGggdGhhdCBpcyBvdXQgb2YgdGhlIHZhbGlkIHJhbmdlLlxuICAgICAgaWYgKG1pbi55ZWFyID09PSBtYXgueWVhciAmJiAoaSArIDEgPCBtaW4ubW9udGggfHwgaSArIDEgPiBtYXgubW9udGgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogaSArIDEsXG4gICAgICAgIHRleHQ6IHZhbFxuICAgICAgfTtcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH0pO1xuXG4gICAgLy8gTWluIGFuZCBtYXggYXJlIHRoZSBzYW1lIG1vbnRoLCBzbyBqdXN0IHNob3cgdGV4dC5cbiAgICBpZiAoIW1vbnRoT3B0cy5sZW5ndGggfHwgbW9udGhPcHRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgbW9udGhzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgbW9udGhzLmlubmVySFRNTCA9IGRhdGUubW9udGhOYW1lICsgJyAnO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIEJ1aWxkIGEgc2VsZWN0IGxpc3Qgb2YgbW9udGhzXG4gICAgICBtb250aHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkobW9udGhzLCAnc3Bhcmstc2VsZWN0IHNwYXJrLWNhbGVuZGFyX19zZWxlY3QnKTtcbiAgICAgIG1vbnRocy5hcHBlbmRDaGlsZCgoMCwgX2J1aWxkU2VsZWN0Mi5kZWZhdWx0KSh7XG4gICAgICAgIHNlbGVjdGVkOiBkYXRlLm1vbnRoLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgY2xhc3M6ICdzcGFyay1zZWxlY3RfX2lucHV0JyxcbiAgICAgICAgICBuYW1lOiAnbW9udGgnXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnM6IG1vbnRoT3B0c1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8vIE1pbiBhbmQgbWF4IHllYXIgYXJlIHRoZSBzYW1lLCBzbyBqdXN0IHNob3cgdGV4dC5cbiAgICBpZiAobWluLnllYXIgPT09IG1heC55ZWFyKSB7XG4gICAgICB5ZWFycyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIHllYXJzLmlubmVySFRNTCA9IGRhdGUueWVhcjtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBCdWlsZCBhIHNlbGVjdCBsaXN0IG9mIHllYXJzXG4gICAgICB5ZWFycyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh5ZWFycywgJ3NwYXJrLXNlbGVjdCBzcGFyay1jYWxlbmRhcl9fc2VsZWN0Jyk7XG4gICAgICB5ZWFycy5hcHBlbmRDaGlsZCgoMCwgX2J1aWxkU2VsZWN0Mi5kZWZhdWx0KSh7XG4gICAgICAgIHNlbGVjdGVkOiBkYXRlLnllYXIsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICBjbGFzczogJ3NwYXJrLXNlbGVjdF9faW5wdXQnLFxuICAgICAgICAgIG5hbWU6ICd5ZWFyJ1xuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zOiAoMCwgX3JhbmdlMi5kZWZhdWx0KShtYXgueWVhciwgbWluLnllYXIgLSAxKVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgICgwLCBfYXBwZW5kQ2hpbGRyZW4yLmRlZmF1bHQpKGVsLCBbbW9udGhzLCB5ZWFyc10pO1xuXG4gICAgcmV0dXJuIGVsLmlubmVySFRNTDtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBkYXlzIG9mIHdlZWsgcm93IGZvciBhIG1vbnRoIGNhbGVuZGFyLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fcmVuZGVyTW9udGhEYXlzT2ZXZWVrID0gZnVuY3Rpb24gX3JlbmRlck1vbnRoRGF5c09mV2VlaygpIHtcblxuICAgIHZhciBkYXlzT2ZXZWVrID0gX2RhdGUyLmRlZmF1bHQuZ2V0RGF5TmFtZXMoKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGRheXNPZldlZWsubGVuZ3RoO1xuICAgIHZhciBzdHIgPSAnPGRpdiBjbGFzcz1cInNwYXJrLWNhbGVuZGFyX19kYXlzLW9mLXdlZWtcIj4nO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc3RyICs9ICc8c3BhbiBjbGFzcz1cInNwYXJrLWNhbGVuZGFyX19kYXktb2Ytd2Vla1wiPicgKyBkYXlzT2ZXZWVrW2ldWzBdICsgJzwvc3Bhbj4nO1xuICAgIH1cblxuICAgIHJldHVybiBzdHIgKz0gJzwvZGl2Pic7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgZGF5cyBvZiB3ZWVrIHJvdyBmb3IgYSBtb250aCBjYWxlbmRhci5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGN1cnJlbnRcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX3JlbmRlck1vbnRoRGF5cyA9IGZ1bmN0aW9uIF9yZW5kZXJNb250aERheXMoZGF0ZSwgY3VycmVudCkge1xuXG4gICAgdmFyIGRheU9mV2VlayA9IGRhdGUubW9udGhTdGFydC5kYXlPZldlZWs7XG4gICAgdmFyIHN0YXJ0T2ZXZWVrID0gZGF5T2ZXZWVrID4gMSA/IGRhdGUubW9udGhTdGFydC53ZWVrU3RhcnQgOiBudWxsO1xuICAgIHZhciBtb250aEVuZCA9IGRhdGUubW9udGhFbmQ7XG4gICAgdmFyIHdlZWtzID0gNjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBzdHIgPSAnPGRpdiBjbGFzcz1cInNwYXJrLWNhbGVuZGFyX19kYXlzXCI+JztcbiAgICB2YXIgZGF5ID0gMDtcbiAgICB2YXIgbW9udGggPSBzdGFydE9mV2VlayA/IHN0YXJ0T2ZXZWVrLm1vbnRoIDogZGF0ZS5tb250aDtcbiAgICB2YXIgeWVhciA9IHN0YXJ0T2ZXZWVrID8gc3RhcnRPZldlZWsueWVhciA6IGRhdGUueWVhcjtcbiAgICB2YXIgaXNDdXJyZW50TW9udGggPSBjdXJyZW50LnllYXIgPT09IGRhdGUueWVhciAmJiBjdXJyZW50Lm1vbnRoID09PSBkYXRlLm1vbnRoO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBkYXlzIHRoYXQgY29tZSBiZWZvcmUgdGhlIGZpcnN0IG9mIHRoZSBtb250aCwgdGhlIGRheXMgd2lsbCBzdGFydCBhc1xuICAgIC8vIGluYWN0aXZlLiBXZSB1c2UgYSAxIGhlcmUgdG8gaW5kaWNhdGUgdGhlIGRhdGUgaXMgaW5hY3RpdmUgYW5kIF9iZWZvcmVfXG4gICAgLy8gdGhlIHN0YXJ0IG9mIHRoZSBtb250aC5cbiAgICB2YXIgaW5hY3RpdmUgPSBzdGFydE9mV2VlayA/IDEgOiBudWxsO1xuXG4gICAgZm9yICg7IGkgPCB3ZWVrczsgaSsrKSB7XG4gICAgICBmb3IgKDsgaiA8IDc7IGorKykge1xuXG4gICAgICAgIGRheSA9IHN0YXJ0T2ZXZWVrID8gc3RhcnRPZldlZWsuZGF5ICsgaiA6IGRheSArIDE7XG4gICAgICAgIHN0ciArPSB0aGlzLl9yZW5kZXJNb250aERheShkYXksIG1vbnRoLCB5ZWFyLCBpc0N1cnJlbnRNb250aCwgY3VycmVudCwgaW5hY3RpdmUpO1xuXG4gICAgICAgIGlmIChzdGFydE9mV2VlayAmJiBqICsgMSA+PSBkYXlPZldlZWsgLSAxKSB7XG4gICAgICAgICAgc3RhcnRPZldlZWsgPSBudWxsO1xuICAgICAgICAgIGluYWN0aXZlID0gbnVsbDtcbiAgICAgICAgICBkYXkgPSAwO1xuICAgICAgICAgIG1vbnRoID0gZGF0ZS5tb250aDtcbiAgICAgICAgICB5ZWFyID0gZGF0ZS55ZWFyO1xuICAgICAgICAgIGlzQ3VycmVudE1vbnRoID0gY3VycmVudC55ZWFyID09PSBkYXRlLnllYXIgJiYgY3VycmVudC5tb250aCA9PT0gZGF0ZS5tb250aDtcbiAgICAgICAgfSBlbHNlIGlmIChkYXkgPj0gbW9udGhFbmQuZGF5ICYmIGkgPiAwKSB7XG5cbiAgICAgICAgICAvLyBJbmFjdGl2ZSBkYXlzIHRoYXQgY29tZSBfYWZ0ZXJfIHRoZSBsYXN0IG9mIHRoZSBtb250aCBhcmUgZGVub3RlZCB3aXRoIGEgMi5cbiAgICAgICAgICAvLyBfcmVuZGVyTW9udGhEYXkgaGFuZGxlcyAxcyBhbmQgMnMgZGlmZmVyZW50bHksIGJ1dCBib3RoIGFkZCB0aGUgaW5hY3RpdmUgY2xhc3MuXG4gICAgICAgICAgaW5hY3RpdmUgPSAyO1xuICAgICAgICAgIGlzQ3VycmVudE1vbnRoID0gZmFsc2U7XG5cbiAgICAgICAgICBkYXkgPSAwO1xuICAgICAgICAgIG1vbnRoKys7XG5cbiAgICAgICAgICBpZiAobW9udGggPiAxMikge1xuICAgICAgICAgICAgeWVhcisrO1xuICAgICAgICAgICAgbW9udGggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaiA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ciArPSAnPC9kaXY+JztcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIGEgZGF5IG9mIHRoZSBtb250aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRheVxuICAgKiBAcGFyYW0ge051bWJlcn0gbW9udGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc0N1cnJlbnRNb250aFxuICAgKiBAcGFyYW0ge09iamVjdH0gY3VycmVudFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluYWN0aXZlXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fcmVuZGVyTW9udGhEYXkgPSBmdW5jdGlvbiBfcmVuZGVyTW9udGhEYXkoZGF5LCBtb250aCwgeWVhciwgaXNDdXJyZW50TW9udGgsIGN1cnJlbnQsIGluYWN0aXZlKSB7XG5cbiAgICB2YXIgZGF0ZSA9IF9kYXRlMi5kZWZhdWx0LmNyZWF0ZSh7XG4gICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgbW9udGg6IG1vbnRoLFxuICAgICAgZGF5OiBkYXlcbiAgICB9KTtcbiAgICB2YXIgc3RyID0gJzxhJztcbiAgICB2YXIgZGlzYWJsZWQgPSBpbmFjdGl2ZSB8fCB0aGlzLl9pc0RheURpc2FibGVkKGRhdGUpO1xuXG4gICAgc3RyICs9ICFkaXNhYmxlZCA/ICcgZGF0YS1kYXRlPVwiJyArIHBhcnNlZERvbUZvcm1hdC5nZXRTdHJpbmcoZGF0ZSkgKyAnXCInIDogJyc7XG4gICAgc3RyICs9IGluYWN0aXZlID8gJyBkYXRhLWRpcmVjdGlvbj1cIicgKyAoaW5hY3RpdmUgPT09IDIgPyAnbmV4dCcgOiAncHJldmlvdXMnKSArICdcIicgOiAnJztcbiAgICBzdHIgKz0gJyBjbGFzcz1cInNwYXJrLWNhbGVuZGFyX19kYXknO1xuICAgIHN0ciArPSBpc0N1cnJlbnRNb250aCAmJiBjdXJyZW50LmRheSA9PT0gZGF5ICYmIGN1cnJlbnQubW9udGggPT09IG1vbnRoICYmIGN1cnJlbnQueWVhciA9PT0geWVhciA/ICcgc3BhcmstY2FsZW5kYXJfX2RheS0tdG9kYXknIDogJyc7XG4gICAgc3RyICs9IGluYWN0aXZlID8gJyBzcGFyay1jYWxlbmRhcl9fZGF5LS1pbmFjdGl2ZScgOiAnJztcbiAgICBzdHIgKz0gZGlzYWJsZWQgPyAnIHNwYXJrLWNhbGVuZGFyX19kYXktLWRpc2FibGVkJyA6ICcnO1xuICAgIHN0ciArPSB0aGlzLl9pc0RheVNlbGVjdGVkKGRhdGUpID8gJyBzcGFyay1jYWxlbmRhcl9fZGF5LS1zZWxlY3RlZCcgOiAnJztcbiAgICBzdHIgKz0gdGhpcy5faXNEYXlSYW5nZVN0YXJ0KGRhdGUpID8gJyBzcGFyay1jYWxlbmRhcl9fcmFuZ2Utc3RhcnQnIDogJyc7XG4gICAgc3RyICs9IHRoaXMuX2lzRGF5UmFuZ2VNaWRkbGUoZGF0ZSkgPyAnIHNwYXJrLWNhbGVuZGFyX19yYW5nZS1taWRkbGUnIDogJyc7XG4gICAgc3RyICs9IHRoaXMuX2lzRGF5UmFuZ2VFbmQoZGF0ZSkgPyAnIHNwYXJrLWNhbGVuZGFyX19yYW5nZS1lbmQnIDogJyc7XG4gICAgc3RyICs9IHRoaXMuX2lzRGF5UmFuZ2VMYXN0KGRhdGUpID8gJyBzcGFyay1jYWxlbmRhcl9fcmFuZ2UtbGFzdCcgOiAnJztcbiAgICBzdHIgKz0gJ1wiJztcbiAgICBzdHIgKz0gJyBocmVmPVwiI1wiPjxzcGFuPic7XG4gICAgc3RyICs9IGRheTtcbiAgICBzdHIgKz0gdGhpcy5fZ2V0RGF5SW5mbyhkYXRlKTtcbiAgICBzdHIgKz0gJzwvc3Bhbj48L2E+JztcblxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgY2hpbGRyZW4gaW50byB0aGUgY29udGVudC5cbiAgICogQHBhcmFtIHtBcnJheX0gY29udGVudFxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2luc2VydENvbnRlbnQgPSBmdW5jdGlvbiBfaW5zZXJ0Q29udGVudChjb250ZW50LCBwYXJhbXMpIHtcblxuICAgIHRoaXMuX2N1cnJlbnRDb250ZW50ID0gdGhpcy5fY3VycmVudENvbnRlbnQgfHwgW107XG5cbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgICB2YXIga2VlcCA9IHZvaWQgMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHZvaWQgMDtcblxuICAgIC8vIElmIHdlJ3ZlIGJlZW4gYXNrZWQgdG8gcHJlcGVuZCBvciBhcHBlbmQsIGFkZCB0aGUgbmV3IGVsZW1lbnRzIGluIGZyb250LFxuICAgIC8vIHNhdmUgdGhlIG51bWJlciBvZiBvbGQgZWxlbWVudHMgd2UncmUgc2xpZGluZyBvdXQsIGFuaW1hdGUsXG4gICAgLy8gdGhlbiBjbGVhbiB1cC5cbiAgICBpZiAodGhpcy5hbmltYXRlKSB7XG5cbiAgICAgIGlmIChwYXJhbXMucHJlcGVuZCkge1xuXG4gICAgICAgIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50cyB0byBrZWVwXG4gICAgICAgIGtlZXAgPSB0aGlzLl9jdXJyZW50Q29udGVudC5zbGljZSgtcGFyYW1zLnByZXBlbmQpO1xuICAgICAgICBsZW4gPSBrZWVwLmxlbmd0aDtcbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNvbnRlbnQucHVzaChrZWVwW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsZW5kYXJFbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcHJlcGVuZC1jb3VudCcsIGxlbik7XG5cbiAgICAgICAgdGhpcy5fYW5pbWF0ZUNvbnRlbnQoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgdGhpcy5jYWxlbmRhckVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1wcmVwZW5kLWNvdW50Jyk7XG5cbiAgICAgICAgICB0aGlzLl9hbmltYXRlQ29udGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgwLCAtcGFyYW1zLnByZXBlbmQpO1xuICAgICAgICAgICAgdGhpcy5faW5zZXJ0Q29udGVudChjb250ZW50KTtcbiAgICAgICAgICB9LCB0aGlzLmFuaW1hdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgfSwgMTApO1xuICAgICAgfVxuICAgICAgLy8gU2FtZSBidXQgYXBwZW5kaW5nXG4gICAgICBlbHNlIGlmIChwYXJhbXMuYXBwZW5kKSB7XG5cbiAgICAgICAgICAvLyBHZXQgdGhlIGZpcnN0IGVsZW1lbnRzIHRvIGtlZXBcbiAgICAgICAgICBrZWVwID0gdGhpcy5fY3VycmVudENvbnRlbnQuc2xpY2UoMCwgcGFyYW1zLmFwcGVuZCk7XG4gICAgICAgICAgbGVuID0ga2VlcC5sZW5ndGg7XG4gICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29udGVudC51bnNoaWZ0KGtlZXBbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY2FsZW5kYXJFbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYXBwZW5kLWNvdW50JywgbGVuKTtcblxuICAgICAgICAgIHRoaXMuX2FuaW1hdGVDb250ZW50KGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5jYWxlbmRhckVsLCAnbm8tYW5pbWF0ZScpO1xuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UocGFyYW1zLmFwcGVuZCk7XG4gICAgICAgICAgICB0aGlzLl9pbnNlcnRDb250ZW50KGNvbnRlbnQpO1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhckVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1hcHBlbmQtY291bnQnKTtcblxuICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZUNvbnRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KSh0aGlzLmNhbGVuZGFyRWwsICduby1hbmltYXRlJyk7XG4gICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgfSwgdGhpcy5hbmltYXRpb25EdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAoMCwgX2FwcGVuZENoaWxkcmVuMi5kZWZhdWx0KSh0aGlzLmNhbGVuZGFyQ29udGVudEVsLCB0aGlzLl9jdXJyZW50Q29udGVudCA9IGNvbnRlbnQsIHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJcyBhIGdpdmVuIGRheSBzZWxlY3RlZD9cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9pc0RheVNlbGVjdGVkID0gZnVuY3Rpb24gX2lzRGF5U2VsZWN0ZWQoZGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlcyAmJiBkYXRlLmVxdWFsKHRoaXMudmFsdWVzKTtcbiAgfTtcblxuICAvKipcbiAgICogSXMgYSBnaXZlbiBkYXkgdGhlIHN0YXJ0IG9mIGEgcmFuZ2U/XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5faXNEYXlSYW5nZVN0YXJ0ID0gZnVuY3Rpb24gX2lzRGF5UmFuZ2VTdGFydChkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRFbHMubGVuZ3RoID4gMSAmJiB0aGlzLnZhbHVlcyAmJiBkYXRlLmVxdWFsKHRoaXMudmFsdWVzWzBdKTtcbiAgfTtcblxuICAvKipcbiAgICogSXMgYSBnaXZlbiBkYXkgdGhlIG1pZGRsZSBvZiBhIHJhbmdlP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2lzRGF5UmFuZ2VNaWRkbGUgPSBmdW5jdGlvbiBfaXNEYXlSYW5nZU1pZGRsZShkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRFbHMubGVuZ3RoID4gMSAmJiB0aGlzLnZhbHVlcyAmJiB0aGlzLnZhbHVlcy5sZW5ndGggPiAxICYmIGRhdGUuZXF1YWwodGhpcy52YWx1ZXMuc2xpY2UoMSwgLTEpKTtcbiAgfTtcblxuICAvKipcbiAgICogSXMgYSBnaXZlbiBkYXkgdGhlIGVuZCBvZiBhIHJhbmdlP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2lzRGF5UmFuZ2VFbmQgPSBmdW5jdGlvbiBfaXNEYXlSYW5nZUVuZChkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRFbHMubGVuZ3RoID4gMSAmJiB0aGlzLnZhbHVlcyAmJiB0aGlzLnZhbHVlcy5sZW5ndGggPiAxICYmIGRhdGUuZXF1YWwodGhpcy52YWx1ZXNbdGhpcy52YWx1ZXMubGVuZ3RoIC0gMV0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJcyBhIGdpdmVuIGRheSBjdXJyZW50bHkgdGhlIGxhc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9pc0RheVJhbmdlTGFzdCA9IGZ1bmN0aW9uIF9pc0RheVJhbmdlTGFzdChkYXRlKSB7XG5cbiAgICB2YXIgaSA9IHRoaXMudmFsdWVzLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKDsgaSA+IDA7IGktLSkge1xuXG4gICAgICAvLyBXZSBoYXZlIGEgdmFsdWUgYW5kIGl0J3Mgbm90IHRoZSBzYW1lIGFzIHRoZSBkYXRlLlxuICAgICAgaWYgKHRoaXMudmFsdWVzW2ldKSB7XG4gICAgICAgIGlmICghZGF0ZS5lcXVhbCh0aGlzLnZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIElzIGEgZ2l2ZW4gZGF5IGRpc2FibGVkP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2lzRGF5RGlzYWJsZWQgPSBmdW5jdGlvbiBfaXNEYXlEaXNhYmxlZChkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF5c0Rpc2FibGVkICYmIHRoaXMuZGF5c0Rpc2FibGVkW2RhdGUueWVhcl0gJiYgdGhpcy5kYXlzRGlzYWJsZWRbZGF0ZS55ZWFyXVtkYXRlLm1vbnRoXSAmJiB0aGlzLmRheXNEaXNhYmxlZFtkYXRlLnllYXJdW2RhdGUubW9udGhdLmluZGV4T2YoZGF0ZS5kYXkpICE9PSAtMSB8fCB0aGlzLm1pbnNbdGhpcy5hY3RpdmVJbmRleF0gJiYgZGF0ZS5iZWZvcmUodGhpcy5taW5zW3RoaXMuYWN0aXZlSW5kZXhdLCB0cnVlKSB8fCB0aGlzLm1heGVzW3RoaXMuYWN0aXZlSW5kZXhdICYmIGRhdGUuYWZ0ZXIodGhpcy5tYXhlc1t0aGlzLmFjdGl2ZUluZGV4XSwgdHJ1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbnkgXCJpbmZvXCIgZm9yIGEgZ2l2ZW4gZGF5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fZ2V0RGF5SW5mbyA9IGZ1bmN0aW9uIF9nZXREYXlJbmZvKGRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5kYXlzSW5mbyAmJiB0aGlzLmRheXNJbmZvW2RhdGUueWVhcl0gJiYgdGhpcy5kYXlzSW5mb1tkYXRlLnllYXJdW2RhdGUubW9udGhdICYmIHRoaXMuZGF5c0luZm9bZGF0ZS55ZWFyXVtkYXRlLm1vbnRoXVtkYXRlLmRheV0gPyAnPHNwYW4gY2xhc3M9XCJzcGFyay1jYWxlbmRhcl9fZGF5LW5vdGVcIj4nICsgdGhpcy5kYXlzSW5mb1tkYXRlLnllYXJdW2RhdGUubW9udGhdW2RhdGUuZGF5XSArICc8L3NwYW4+JyA6ICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNsYXNzIG5hbWVzIGZvciBhIG1vbnRoLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fZ2V0TW9udGhDbGFzc05hbWVzID0gZnVuY3Rpb24gX2dldE1vbnRoQ2xhc3NOYW1lcyhkYXRlKSB7XG5cbiAgICB2YXIgY2xzID0gW107XG5cbiAgICAvLyBEbyB3ZSBoYXZlIGEgdmFsdWUgaW4gdGhpcyBtb250aD9cbiAgICBpZiAoZGF0ZS5lcXVhbE1vbnRoKHRoaXMudmFsdWVzKSkge1xuICAgICAgY2xzLnB1c2goJ2hhcy12YWx1ZScpO1xuICAgIH1cblxuICAgIC8vIERvZXMgdGhpcyBtb250aCBoYXZlIHRoZSBzdGFydCwgbWlkZGxlIG9yIGVuZCBvZiBhIHJhbmdlP1xuICAgIGlmICh0aGlzLl9pc1JhbmdlICYmIHRoaXMuZWxzLmxlbmd0aCA+IDEpIHtcblxuICAgICAgdmFyIHN0YXJ0ID0gZGF0ZS5lcXVhbE1vbnRoKHRoaXMudmFsdWVzWzBdKTtcbiAgICAgIHZhciBlbmQgPSBkYXRlLmVxdWFsTW9udGgodGhpcy52YWx1ZXNbdGhpcy52YWx1ZXMubGVuZ3RoIC0gMV0pO1xuICAgICAgdmFyIG1pZGRsZSA9IGRhdGUuZXF1YWxNb250aCh0aGlzLnZhbHVlcy5zbGljZSgxLCAtMSkpO1xuICAgICAgdmFyIHZhbEJlZm9yZSA9IGRhdGUuYWZ0ZXJNb250aCh0aGlzLnZhbHVlcyk7XG4gICAgICB2YXIgdmFsQWZ0ZXIgPSBkYXRlLmJlZm9yZU1vbnRoKHRoaXMudmFsdWVzKTtcbiAgICAgIHZhciBhZnRlckVuZCA9IHRoaXMudmFsdWVzW3RoaXMudmFsdWVzLmxlbmd0aCAtIDFdICYmIGRhdGUuYWZ0ZXIodGhpcy52YWx1ZXNbdGhpcy52YWx1ZXMubGVuZ3RoIC0gMV0pO1xuXG4gICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgY2xzLnB1c2goJ3JhbmdlLXN0YXJ0Jyk7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIGNscy5wdXNoKCdyYW5nZS1lbmQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChtaWRkbGUpIHtcbiAgICAgICAgY2xzLnB1c2goJ3JhbmdlLW1pZGRsZScpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbEJlZm9yZSkge1xuICAgICAgICBjbHMucHVzaCgndmFsdWUtYmVmb3JlJyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsQWZ0ZXIpIHtcbiAgICAgICAgY2xzLnB1c2goJ3ZhbHVlLWFmdGVyJyk7XG4gICAgICB9XG4gICAgICBpZiAoYWZ0ZXJFbmQpIHtcbiAgICAgICAgY2xzLnB1c2goJ2FmdGVyLXJhbmdlLWVuZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbHMuam9pbignICcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGNhbGVuZGFyLlxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2NyZWF0ZUNhbGVuZGFyID0gZnVuY3Rpb24gX2NyZWF0ZUNhbGVuZGFyKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKGVsLCAnc3BhcmstY2FsZW5kYXInKTtcbiAgICBlbC5pbm5lckhUTUwgPSAnPG5hdiBjbGFzcz1cInNwYXJrLWNhbGVuZGFyX19uYXZcIj48YnV0dG9uIGNsYXNzPVwic3BhcmstY2FsZW5kYXJfX3ByZXZpb3VzIHNwYXJrLWljb24tY2hldnJvbi1sZWZ0XCIgdGl0bGU9XCJQcmV2aW91c1wiPjwvYnV0dG9uPjxidXR0b24gY2xhc3M9XCJzcGFyay1jYWxlbmRhcl9fbmV4dCBzcGFyay1pY29uLWNoZXZyb24tcmlnaHRcIiB0aXRsZT1cIk5leHRcIj48L2J1dHRvbj48L25hdj48ZGl2IGNsYXNzPVwic3BhcmstY2FsZW5kYXJfX292ZXJmbG93XCI+PGRpdiBjbGFzcz1cInNwYXJrLWNhbGVuZGFyX19jb250ZW50XCI+PC9kaXY+PC9kaXY+JztcbiAgICB0aGlzLmNhbGVuZGFyRWwgPSBlbDtcbiAgICB0aGlzLmNhbGVuZGFyQ29udGVudEVsID0gZWwucXVlcnlTZWxlY3RvcignLnNwYXJrLWNhbGVuZGFyX19jb250ZW50Jyk7XG4gICAgdGhpcy5jYWxlbmRhck92ZXJmbG93RWwgPSBlbC5xdWVyeVNlbGVjdG9yKCcuc3BhcmstY2FsZW5kYXJfb3ZlcmZsb3cnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBwb3BvdmVyLlxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2NyZWF0ZVBvcG92ZXIgPSBmdW5jdGlvbiBfY3JlYXRlUG9wb3ZlcigpIHtcblxuICAgIHRoaXMucG9wb3ZlciA9IG5ldyBfcG9wb3ZlcjIuZGVmYXVsdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwge1xuICAgICAgYW5jaG9yWDogJ2NlbnRlcicsXG4gICAgICBhbmNob3JZOiAnYm90dG9tJyxcbiAgICAgIGNvbnRlbnRFbDogdGhpcy5jYWxlbmRhckVsLFxuICAgICAgb25DbG9zZTogdGhpcy5fb25Qb3BvdmVyQ2xvc2UuYmluZCh0aGlzKSxcbiAgICAgIG9uT3BlbjogdGhpcy5fb25Qb3BvdmVyT3Blbi5iaW5kKHRoaXMpXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhY2hlIGVsZW1lbnRzLlxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2NhY2hlRWxlbWVudHMgPSBmdW5jdGlvbiBfY2FjaGVFbGVtZW50cygpIHtcblxuICAgIHRoaXMuaW5wdXRFbHMgPSBbXTtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGhpcy5lbHMubGVuZ3RoO1xuICAgIHZhciBpbnB1dCA9IHZvaWQgMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlucHV0ID0gdGhpcy5lbHNbaV0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyA/IHRoaXMuZWxzW2ldIDogdGhpcy5lbHNbaV0ucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1cImRhdGVcIl0nKTtcbiAgICAgIHRoaXMuaW5wdXRFbHNbaV0gPSBpbnB1dDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENhY2hlIGVsZW1lbnRzIHNwZWNpZmljIHRvIHRoZSBjYWxlbmRhci5cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9jYWNoZUNhbGVuZGFyRWxlbWVudHMgPSBmdW5jdGlvbiBfY2FjaGVDYWxlbmRhckVsZW1lbnRzKCkge1xuICAgIHRoaXMubmV4dEJ1dHRvbkVsID0gdGhpcy5jYWxlbmRhckVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1jYWxlbmRhcl9fbmV4dCcpO1xuICAgIHRoaXMucHJldmlvdXNCdXR0b25FbCA9IHRoaXMuY2FsZW5kYXJFbC5xdWVyeVNlbGVjdG9yKCcuc3BhcmstY2FsZW5kYXJfX3ByZXZpb3VzJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIHBhcmFtZXRlcnMgZnJvbSB0aGUgZWxlbWVudHMuXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fcGFyc2VQYXJhbXMgPSBmdW5jdGlvbiBfcGFyc2VQYXJhbXMoKSB7XG5cbiAgICB0aGlzLl9wYXJzZUlucHV0RWxzUGFyYW1zKCk7XG5cbiAgICB0aGlzLl9pc1JhbmdlID0gdGhpcy5lbHMubGVuZ3RoID4gMSA/IHRydWUgOiBmYWxzZTtcbiAgICB0aGlzLmF1dG9BZHZhbmNlID0gdGhpcy5hdXRvQWR2YW5jZSAhPT0gbnVsbCA/IHRoaXMuYXV0b0FkdmFuY2UgOiAoMCwgX3BhcnNlQXR0cmlidXRlLmJvb2xlYW4pKHRoaXMuZWxzWzBdLCAnZGF0YS1hdXRvLWFkdmFuY2UnLCB0cnVlKTtcbiAgICB0aGlzLmF1dG9DbG9zZSA9IHRoaXMuYXV0b0Nsb3NlICE9PSBudWxsID8gdGhpcy5hdXRvQ2xvc2UgOiAoMCwgX3BhcnNlQXR0cmlidXRlLmJvb2xlYW4pKHRoaXMuZWxzWzBdLCAnZGF0YS1hdXRvLWNsb3NlJywgdHJ1ZSk7XG4gICAgdGhpcy5jbG9zZURlbGF5ID0gdGhpcy5jbG9zZURlbGF5ICE9PSBudWxsID8gdGhpcy5jbG9zZURlbGF5IDogKDAsIF9wYXJzZUF0dHJpYnV0ZS5udW1iZXIpKHRoaXMuZWxzWzBdLCAnZGF0YS1jbG9zZS1kZWxheScsIDUwMCk7XG4gICAgdGhpcy5xdWlja0p1bXAgPSB0aGlzLnF1aWNrSnVtcCAhPT0gbnVsbCA/IHRoaXMucXVpY2tKdW1wIDogKDAsIF9wYXJzZUF0dHJpYnV0ZS5ib29sZWFuKSh0aGlzLmVsc1swXSwgJ2RhdGEtcXVpY2stanVtcCcsIGZhbHNlKTtcbiAgICB0aGlzLnZpZXdSYW5nZSA9IHRoaXMudmlld1JhbmdlICE9PSBudWxsID8gdGhpcy52aWV3UmFuZ2UgOiAoMCwgX3BhcnNlQXR0cmlidXRlLnN0cmluZykodGhpcy5lbHNbMF0sICdkYXRhLXZpZXctcmFuZ2UnLCAnbW9udGgnKTtcbiAgICB0aGlzLmFuaW1hdGUgPSB0aGlzLmFuaW1hdGUgIT09IG51bGwgPyB0aGlzLmFuaW1hdGUgOiAoMCwgX3BhcnNlQXR0cmlidXRlLmJvb2xlYW4pKHRoaXMuZWxzWzBdLCAnZGF0YS1hbmltYXRlJywgdHJ1ZSk7XG4gICAgdGhpcy5hbmltYXRpb25EdXJhdGlvbiA9IHRoaXMuYW5pbWF0aW9uRHVyYXRpb24gIT09IG51bGwgPyB0aGlzLmFuaW1hdGlvbkR1cmF0aW9uIDogKDAsIF9wYXJzZUF0dHJpYnV0ZS5udW1iZXIpKHRoaXMuZWxzWzBdLCAnZGF0YS1hbmltYXRpb24tZHVyYXRpb24nLCAxMDApO1xuICAgIHRoaXMuc2hvd09uRm9jdXMgPSB0aGlzLnNob3dPbkZvY3VzICE9PSBudWxsID8gdGhpcy5zaG93T25Gb2N1cyA6ICgwLCBfcGFyc2VBdHRyaWJ1dGUuYm9vbGVhbikodGhpcy5lbHNbMF0sICdkYXRhLXNob3ctb24tZm9jdXMnLCBmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBtaW4sIG1heCwgdmFsdWUgYW5kIHZpc2libGUgY291bnRzIGZyb20gdGhlIGVsZW1lbnRzIGlmIHdlIGNhbi5cbiAgICogQHJldHVybiB7TnVtYmVyfEJvb2xlYW59XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fcGFyc2VJbnB1dEVsc1BhcmFtcyA9IGZ1bmN0aW9uIF9wYXJzZUlucHV0RWxzUGFyYW1zKCkge1xuXG4gICAgdmFyIGVscyA9IHRoaXMuaW5wdXRFbHM7XG5cbiAgICBpZiAoIWVscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gZWxzLmxlbmd0aDtcbiAgICB2YXIgbWlucyA9IFtdO1xuICAgIHZhciBtYXhlcyA9IFtdO1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICB2YXIgdmlzaWJsZUNvdW50cyA9IFtdO1xuICAgIHZhciBkaXNhYmxlZHMgPSBbXTtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgaWYgKCFlbHNbaV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1pbnMgJiYgdGhpcy5taW5zW2ldKSBtaW5zW2ldID0gX3R5cGVvZih0aGlzLm1pbnNbaV0pID09PSAnb2JqZWN0JyA/IHRoaXMubWluc1tpXSA6IHBhcnNlZERvbUZvcm1hdC5nZXRWYWx1ZXModGhpcy5taW5zW2ldKTtlbHNlIGlmIChlbHNbaV0uZ2V0QXR0cmlidXRlKCdtaW4nKSkgbWluc1tpXSA9IHBhcnNlZERvbUZvcm1hdC5nZXRWYWx1ZXMoZWxzW2ldLmdldEF0dHJpYnV0ZSgnbWluJykpO1xuXG4gICAgICBpZiAodGhpcy5tYXhlcyAmJiB0aGlzLm1heGVzW2ldKSBtYXhlc1tpXSA9IF90eXBlb2YodGhpcy5tYXhlc1tpXSkgPT09ICdvYmplY3QnID8gdGhpcy5tYXhlc1tpXSA6IHBhcnNlZERvbUZvcm1hdC5nZXRWYWx1ZXModGhpcy5tYXhlc1tpXSk7ZWxzZSBpZiAoZWxzW2ldLmdldEF0dHJpYnV0ZSgnbWF4JykpIG1heGVzW2ldID0gcGFyc2VkRG9tRm9ybWF0LmdldFZhbHVlcyhlbHNbaV0uZ2V0QXR0cmlidXRlKCdtYXgnKSk7XG5cbiAgICAgIGlmICh0aGlzLnZhbHVlcyAmJiB0aGlzLnZhbHVlc1tpXSkgdmFsdWVzW2ldID0gX3R5cGVvZih0aGlzLnZhbHVlc1tpXSkgPT09ICdvYmplY3QnID8gdGhpcy52YWx1ZXNbaV0gOiBwYXJzZWREb21Gb3JtYXQuZ2V0VmFsdWVzKHRoaXMudmFsdWVzW2ldKTtlbHNlIGlmIChlbHNbaV0udmFsdWUpIHZhbHVlc1tpXSA9IHBhcnNlZERvbUZvcm1hdC5nZXRWYWx1ZXMoZWxzW2ldLnZhbHVlKTtcblxuICAgICAgZGlzYWJsZWRzW2ldID0gKDAsIF9wYXJzZUF0dHJpYnV0ZS5ib29sZWFuKShlbHNbaV0sICdkaXNhYmxlZCcsIGZhbHNlKTtcblxuICAgICAgaWYgKCF0aGlzLnZpc2libGVDb3VudHMpIHZpc2libGVDb3VudHNbaV0gPSBwYXJzZUludChlbHNbaV0uZ2V0QXR0cmlidXRlKCdkYXRhLXZpc2libGUtY291bnQnKSwgMTApIHx8IDE7XG4gICAgfVxuXG4gICAgdGhpcy5taW5zID0gbWlucztcbiAgICB0aGlzLm1pblZpc2libGUgPSBfZGF0ZTIuZGVmYXVsdC5lYXJsaWVzdChtaW5zKTtcbiAgICB0aGlzLm1heGVzID0gbWF4ZXM7XG4gICAgdGhpcy5tYXhWaXNpYmxlID0gX2RhdGUyLmRlZmF1bHQubGF0ZXN0KG1heGVzKTtcbiAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICB0aGlzLl9pc0Rpc2FibGVkID0gZGlzYWJsZWRzO1xuICAgIGlmICh2aXNpYmxlQ291bnRzLmxlbmd0aCkgdGhpcy52aXNpYmxlQ291bnRzID0gdmlzaWJsZUNvdW50cztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBkYXRlcyB3ZSBzaG91bGQgYmUgc2hvd2luZy4gU3RhcnQgd2l0aCB0aGUgZmlyc3QgdmFsdWUgb3IgdG9kYXkncyBkYXRlLlxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2luaXREYXRlc1RvU2hvdyA9IGZ1bmN0aW9uIF9pbml0RGF0ZXNUb1Nob3coKSB7XG5cbiAgICB2YXIgYXJyID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0aGlzLnZhbHVlcy5sZW5ndGg7XG5cbiAgICAvLyBHZXQgdGhlIGRhdGUgZm9yIHRoZSBjdXJyZW50IGluZGV4XG4gICAgaWYgKHRoaXMudmFsdWVzW3RoaXMuYWN0aXZlSW5kZXhdKSB7XG4gICAgICBhcnIucHVzaCh0aGlzLnZhbHVlc1t0aGlzLmFjdGl2ZUluZGV4XS5jbG9uZSgpKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIGZpcnN0IGRhdGVcbiAgICBmb3IgKDsgaSA8IGxlbiAmJiAhYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZXNbaV0pIHtcbiAgICAgICAgYXJyLnB1c2godGhpcy52YWx1ZXNbaV0uY2xvbmUoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZGlkbid0IGdldCBhIGRhdGUsIHVzZSB0aGUgbWluXG4gICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5taW5zLmxlbmd0aDsgaSA8IGxlbiAmJiAhYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5taW5zW2ldKSB7XG4gICAgICAgIGFyci5wdXNoKHRoaXMubWluc1tpXS5jbG9uZSgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBzdGlsbCBkaWRuJ3QgZ2V0IGEgZGF0ZSwgYWRkIHRvZGF5J3MgZGF0ZS5cbiAgICBpZiAoIWFyci5sZW5ndGgpIHtcbiAgICAgIGFyci5wdXNoKF9kYXRlMi5kZWZhdWx0Lm5vdygpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kYXRlc1RvU2hvdyA9IGFycjtcblxuICAgIHRoaXMuX3NldERhdGVzVG9TaG93KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGF0ZXMgdG8gc2hvdy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZSBPcHRpb25hbCBUaGUgZGlyZWN0aW9uIHRvIGNoYW5nZVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX3NldERhdGVzVG9TaG93ID0gZnVuY3Rpb24gX3NldERhdGVzVG9TaG93KGNoYW5nZSkge1xuXG4gICAgdmFyIGFyciA9IHRoaXMuX2RhdGVzVG9TaG93O1xuICAgIHZhciB2aXNpYmxlQ291bnQgPSB0aGlzLl9jdXJyZW50QnJlYWtwb2ludCA9PT0gJ3hzJyB8fCB0aGlzLl9jdXJyZW50QnJlYWtwb2ludCA9PT0gJ3NtJyA/IDEgOiB0aGlzLnZpc2libGVDb3VudHNbdGhpcy5hY3RpdmVJbmRleF0gfHwgdGhpcy52aXNpYmxlQ291bnRzWzBdIHx8IDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBub3VuID0gdGhpcy52aWV3UmFuZ2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0aGlzLnZpZXdSYW5nZS5zbGljZSgxKTtcblxuICAgIC8vIElmIHdlIGhhdmUgbW9yZSBkYXRlcyB0byBzaG93IHRoYW4gd2UncmUgc3VwcG9zZWQgdG8gc2hvdywgcmVtb3ZlIHRoZSBleGNlc3MuXG4gICAgLy8gVGhpcyBoYXBwZW5zIHdoZW4gdmlzaWJsZSBjb3VudCBjaGFuZ2VzIGJldHdlZW4gcmVuZGVyc1xuICAgIGlmIChhcnIubGVuZ3RoID4gdmlzaWJsZUNvdW50KSB7XG4gICAgICBhcnIuc3BsaWNlKHZpc2libGVDb3VudCk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgYXJlIGluY3JlbWVudGluZyBvciBkZWNyZW1lbnRpbmcgdGhlIHN0YXJ0aW5nIG1vbnRoXG4gICAgaWYgKGNoYW5nZSkge1xuXG4gICAgICAvLyBFbXB0eSB0aGUgcmVzdCBvZiB0aGUgZGF0ZXMgZnJvbSB0aGUgYXJyYXlcbiAgICAgIGFyciA9IHRoaXMuX2RhdGVzVG9TaG93ID0gYXJyLnNwbGljZSgwLCAxKTtcblxuICAgICAgLy8gRGVjcmVtZW50XG4gICAgICBpZiAoY2hhbmdlIDwgMCkge1xuICAgICAgICBmb3IgKDsgaSA+IGNoYW5nZTsgaS0tKSB7XG4gICAgICAgICAgYXJyWzBdID0gYXJyWzBdWydwcmV2aW91cycgKyBub3VuXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCBjaGFuZ2U7IGkrKykge1xuICAgICAgICAgIGFyclswXSA9IGFyclswXVsnbmV4dCcgKyBub3VuXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGJvdW5kc1xuICAgIHRoaXMuX2F0TWluID0gdGhpcy5fY2hlY2tNaW5EYXRlVmlzaWJsZShub3VuLCBhcnIpO1xuICAgIHRoaXMuX2F0TWF4ID0gdGhpcy5fY2hlY2tNYXhEYXRlVmlzaWJsZShub3VuLCBhcnIpO1xuXG4gICAgdmFyIGFkZERhdGUgPSB2b2lkIDA7XG4gICAgdmFyIGxhc3RTZWxlY3RlZCA9IHZvaWQgMDtcbiAgICB2YXIgYWN0aW9uID0gdm9pZCAwO1xuICAgIGkgPSAwO1xuXG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgZGF0ZXNcbiAgICB3aGlsZSAoYXJyLmxlbmd0aCA8IHZpc2libGVDb3VudCkge1xuXG4gICAgICAvLyBJZiBhdCB0aGUgbWF4LCBwcmVwZW5kXG4gICAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgbGFzdCBpbnB1dCBhbmQgaXQgaGFzIGEgdmFsdWUgYW5kIGl0J3MgYSBkaWZmZXJlbnQgbW9udGggdGhhbiB0aGUgZmlyc3QgdmFsdWUsIHByZXBlbmRcbiAgICAgIC8vIElmIGF0IHRoZSBtaW4sIGFwcGVuZFxuICAgICAgLy8gSWYgYW4gaXRlbSB3ZSdyZSBhZGRpbmcgaXMgYmVmb3JlIHRoZSBtaW4sIGRpc2NhcmQgaXQgYW5kIGFwcGVuZCBhbiBpdGVtIGFmdGVyIHRoZSBsYXN0IGluIHRoZSBhcnJcbiAgICAgIC8vIElmIGFuIGl0ZW0gd2UncmUgYWRkaW5nIGlzIGFmdGVyIHRoZSBtYXgsIGRpc2NhcmQgaXQgYW5kIHByZXBlbmQgYW4gaXRlbSBiZWZvcmUgdGhlIGZpcnN0IGluIHRoZSBhcnJcblxuICAgICAgbGFzdFNlbGVjdGVkID0gIWNoYW5nZSAmJiB0aGlzLmFjdGl2ZUluZGV4ID09PSB0aGlzLnZhbHVlcy5sZW5ndGggLSAxICYmIHRoaXMudmFsdWVzW3RoaXMudmFsdWVzLmxlbmd0aCAtIDFdICYmIHRoaXMudmFsdWVzWzBdICYmICF0aGlzLnZhbHVlc1t0aGlzLnZhbHVlcy5sZW5ndGggLSAxXVsnZXF1YWwnICsgbm91bl0odGhpcy52YWx1ZXMsIHRydWUpO1xuXG4gICAgICAvLyBJZiB3ZSdyZSBzaG93aW5nIHRoZSBtYXggZGF0ZSBvciB3ZSBoYXZlIHRoZSBsYXN0IGlucHV0IHNlbGVjdGVkIGFuZCBpdCBoYXMgYSB2YWx1ZSwgYWRkIGRhdGVzIGJlZm9yZS5cbiAgICAgIGlmICh0aGlzLl9hdE1heCB8fCBsYXN0U2VsZWN0ZWQpIHtcblxuICAgICAgICBhZGREYXRlID0gYXJyW2ldWydwcmV2aW91cycgKyBub3VuXTtcbiAgICAgICAgYWN0aW9uID0gJ3Vuc2hpZnQnO1xuXG4gICAgICAgIGlmIChhZGREYXRlWydiZWZvcmUnICsgbm91bl0odGhpcy5taW5WaXNpYmxlKSkge1xuICAgICAgICAgIGFkZERhdGUgPSBhcnJbaV1bJ25leHQnICsgbm91bl07XG4gICAgICAgICAgYWN0aW9uID0gJ3B1c2gnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGFkZERhdGUgPSBhcnJbaV1bJ25leHQnICsgbm91bl07XG4gICAgICAgIGFjdGlvbiA9ICdwdXNoJztcblxuICAgICAgICBpZiAoYWRkRGF0ZVsnYWZ0ZXInICsgbm91bl0odGhpcy5tYXhWaXNpYmxlKSkge1xuICAgICAgICAgIGFkZERhdGUgPSBhcnJbaV1bJ3ByZXZpb3VzJyArIG5vdW5dO1xuICAgICAgICAgIGFjdGlvbiA9ICd1bnNoaWZ0JztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aW9uID09PSAncHVzaCcpIHtcbiAgICAgICAgYXJyLnB1c2goYWRkRGF0ZSk7XG4gICAgICAgIGkgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyci51bnNoaWZ0KGFkZERhdGUpO1xuICAgICAgICBpID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBib3VuZHMgYWdhaW5cbiAgICB0aGlzLl9hdE1pbiA9IHRoaXMuX2NoZWNrTWluRGF0ZVZpc2libGUobm91biwgYXJyKTtcbiAgICB0aGlzLl9hdE1heCA9IHRoaXMuX2NoZWNrTWF4RGF0ZVZpc2libGUobm91biwgYXJyKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgbmF2aWdhdGlvbiB0byByZWZsZWN0IHRoZSBfYXRNaW4gb3IgX2F0TWF4IHN0YXRlXG4gICAgdGhpcy5fdXBkYXRlTmF2KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGZvciB0aGUgbWluIHZhbHVlIGluIGFuIGFycmF5IG9mIHZhbHVlcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1pblxuICAgKiBAcGFyYW0ge1N0cmluZ30gbm91biBUaGUgdHlwZSBvZiBkYXRlIHRvIGNoZWNrXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2NoZWNrTWluRGF0ZVZpc2libGUgPSBmdW5jdGlvbiBfY2hlY2tNaW5EYXRlVmlzaWJsZShub3VuLCBhcnIpIHtcblxuICAgIGlmICghdGhpcy5taW5WaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1pbiA9IHRoaXMubWluVmlzaWJsZTtcblxuICAgIGlmIChtaW4gJiYgKGFyclswXVsnZXF1YWwnICsgbm91bl0obWluKSB8fCBhcnJbMF1bJ2JlZm9yZScgKyBub3VuXShtaW4pKSkge1xuICAgICAgYXJyWzBdID0gbWluO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBmb3IgdGhlIG1heCB2YWx1ZSBpbiBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5vdW4gVGhlIHR5cGUgb2YgZGF0ZSB0byBjaGVja1xuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9jaGVja01heERhdGVWaXNpYmxlID0gZnVuY3Rpb24gX2NoZWNrTWF4RGF0ZVZpc2libGUobm91biwgYXJyKSB7XG5cbiAgICBpZiAoIXRoaXMubWF4VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtYXggPSB0aGlzLm1heFZpc2libGU7XG5cbiAgICBpZiAobWF4ICYmIGFyclthcnIubGVuZ3RoIC0gMV0gJiYgKGFyclthcnIubGVuZ3RoIC0gMV1bJ2VxdWFsJyArIG5vdW5dKG1heCkgfHwgYXJyW2Fyci5sZW5ndGggLSAxXVsnYWZ0ZXInICsgbm91bl0obWF4KSkpIHtcbiAgICAgIGFyclthcnIubGVuZ3RoIC0gMV0gPSBtYXg7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoYXQgdGhlIHZhbHVlcyBhcmUgaW4gYm91bmRzIGFuZCwgb3B0aW5vYWxseSwgaW4gc2VxdWVudGlhbCBvcmRlci5cbiAgICogSWYgY2hlY2tpbmcgZm9yIHNlcXVlbmNlLCByZW1vdmUgdGhvc2Ugd2hpY2ggYXJlbid0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2V0SW5kZXggVGhlIGluZGV4IG9mIHRoZSB2YWx1ZSBtb3N0IHJlY2VudGx5IHNldC4gVGhpcyBzaG91bGRuJ3QgYmUgcmVtb3ZlZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gRGlkIGFueSB2YWx1ZXMgY2hhbmdlP1xuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2NoZWNrVmFsdWVzID0gZnVuY3Rpb24gX2NoZWNrVmFsdWVzKHNldEluZGV4LCBza2lwUmFuZ2VDaGVjaykge1xuXG4gICAgLy8gQ2hlY2sgYm91bmRhcmllc1xuICAgIHZhciBjaGFuZ2VkID0gdGhpcy5fY2hlY2tNaW5NYXhWYWx1ZXMoKTtcblxuICAgIC8vIFNlcXVlbnRpYWwgcmFuZ2UgaXRlbXMgY2hlY2tcbiAgICBpZiAodGhpcy5faXNSYW5nZSAmJiAhc2tpcFJhbmdlQ2hlY2spIHtcblxuICAgICAgdmFyIGkgPSB0aGlzLnZhbHVlcy5sZW5ndGggLSAxO1xuXG4gICAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVzW2ldICYmIHRoaXMudmFsdWVzW2kgLSAxXSAmJiB0aGlzLnZhbHVlc1tpXS5iZWZvcmVEYXkodGhpcy52YWx1ZXNbaSAtIDFdLCB0cnVlKSkge1xuICAgICAgICAgIGlmIChpID09PSBzZXRJbmRleCkge1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShudWxsLCBpIC0gMSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUobnVsbCwgaSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIG1pbmltdW0vbWF4aW11bSB2YWx1ZXMuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fY2hlY2tNaW5NYXhWYWx1ZXMgPSBmdW5jdGlvbiBfY2hlY2tNaW5NYXhWYWx1ZXMoKSB7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHRoaXMudmFsdWVzLmxlbmd0aDtcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKHRoaXMubWF4ZXMgJiYgdGhpcy5tYXhlc1tpXSAmJiB0aGlzLnZhbHVlc1tpXSAmJiB0aGlzLnZhbHVlc1tpXS5hZnRlcih0aGlzLm1heGVzW2ldLCB0cnVlKSkge1xuICAgICAgICB0aGlzLnZhbHVlc1tpXSA9IHRoaXMubWF4ZXNbaV0uY2xvbmUoKTtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWlucyAmJiB0aGlzLm1pbnNbaV0gJiYgdGhpcy52YWx1ZXNbaV0gJiYgdGhpcy52YWx1ZXNbaV0uYmVmb3JlKHRoaXMubWluc1tpXSwgdHJ1ZSkpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNbaV0gPSB0aGlzLm1pbnNbaV0uY2xvbmUoKTtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVucXVldWUgYW5pbWF0aW9ucyB0byBiZSBydW4uIChOb3QgcmVhbGx5IGFuaW1hdGlvbnMgc2luY2UgdGhvc2UgaGFwcGVuIHcvIENTUy4gTW9yZVxuICAgKiBvZiBhIG1hbmFnZXIgb2YgdGltZW91dHMpLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb25cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9hbmltYXRlQ29udGVudCA9IGZ1bmN0aW9uIF9hbmltYXRlQ29udGVudChjYiwgZHVyYXRpb24pIHtcbiAgICB0aGlzLl9hbmltYXRpb25RdWV1ZSA9IHRoaXMuX2FuaW1hdGlvblF1ZXVlIHx8IFtdO1xuICAgIHRoaXMuX2FuaW1hdGlvblF1ZXVlLnB1c2goe1xuICAgICAgY2I6IGNiLFxuICAgICAgZDogZHVyYXRpb25cbiAgICB9KTtcbiAgICB0aGlzLl9ydW5BbmltYXRpb24oKTtcbiAgfTtcblxuICAvKipcbiAgICogUnVuIHRoZSBmaXJzdCBxdWV1ZWQgYW5pbWF0aW9uLiBXaGVuIGNvbXBsZXRlLCBydW4gdGhlIG5leHQgYW5pbWF0aW9uLlxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX3J1bkFuaW1hdGlvbiA9IGZ1bmN0aW9uIF9ydW5BbmltYXRpb24oKSB7XG5cbiAgICBpZiAoIXRoaXMuX2FuaW1hdGlvblRpbWVyKSB7XG5cbiAgICAgIHZhciBhID0gdGhpcy5fYW5pbWF0aW9uUXVldWUuc2hpZnQoKTtcblxuICAgICAgaWYgKGEpIHtcblxuICAgICAgICB0aGlzLl9hbmltYXRpb25UaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGEuY2IuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLl9hbmltYXRpb25UaW1lciA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fcnVuQW5pbWF0aW9uKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSwgYS5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhdHRyaWJ1dGVzIG9uIHRoZSBlbGVtZW50IGFuZCBpdHMgY2hpbGRyZW4uXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fdXBkYXRlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIF91cGRhdGVBdHRyaWJ1dGVzKCkge1xuICAgIHRoaXMuY2FsZW5kYXJFbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtdmlzaWJsZS1jb3VudCcsIHRoaXMuX2N1cnJlbnRCcmVha3BvaW50ID09PSAneHMnID8gMSA6IHRoaXMudmlzaWJsZUNvdW50c1t0aGlzLmFjdGl2ZUluZGV4XSB8fCB0aGlzLnZpc2libGVDb3VudHNbMF0gfHwgMSk7XG4gICAgdGhpcy5fdXBkYXRlTmF2KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgbmF2aWdhdGlvbiB0byByZWZsZWN0IHRoZSBhYmlsaXR5IHRvIG1vdmUgZm9yd2FyZCBhbmQgYmFja3dhcmQuXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fdXBkYXRlTmF2ID0gZnVuY3Rpb24gX3VwZGF0ZU5hdigpIHtcblxuICAgIGlmICh0aGlzLnByZXZpb3VzQnV0dG9uRWwpIHtcbiAgICAgIGlmICh0aGlzLl9hdE1pbikgdGhpcy5wcmV2aW91c0J1dHRvbkVsLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCB0cnVlKTtlbHNlIHRoaXMucHJldmlvdXNCdXR0b25FbC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmV4dEJ1dHRvbkVsKSB7XG4gICAgICBpZiAodGhpcy5fYXRNYXgpIHRoaXMubmV4dEJ1dHRvbkVsLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCB0cnVlKTtlbHNlIHRoaXMubmV4dEJ1dHRvbkVsLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBib3VuZCB2ZXJzaW9ucyBvZiBldmVudCBsaXN0ZW5lciBjYWxsYmFja3MgYW5kIHN0b3JlIHRoZW0uXG4gICAqIE90aGVyd2lzZSB3ZSBjYW4ndCB1bmJpbmQgZnJvbSB0aGVzZSBldmVudHMgbGF0ZXIgYmVjYXVzZSB0aGVcbiAgICogZnVuY3Rpb24gc2lnbmF0dXJlcyB3b24ndCBtYXRjaC5cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9iaW5kRXZlbnRMaXN0ZW5lckNhbGxiYWNrcyA9IGZ1bmN0aW9uIF9iaW5kRXZlbnRMaXN0ZW5lckNhbGxiYWNrcygpIHtcblxuICAgIHRoaXMuX29uSW5wdXRDaGFuZ2VCb3VuZCA9IHRoaXMuX29uSW5wdXRDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblNlbGVjdENoYW5nZUJvdW5kID0gdGhpcy5fb25TZWxlY3RDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbklucHV0Rm9jdXNCb3VuZCA9IHRoaXMuX29uSW5wdXRGb2N1cy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQ2xpY2tCb3VuZCA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNhbGVuZGFyQ2xpY2tCb3VuZCA9IHRoaXMuX29uQ2FsZW5kYXJDbGljay5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fb25DYWxlbmRhck1vdXNlT3ZlckJvdW5kID0gdGhpcy5fb25DYWxlbmRhck1vdXNlT3Zlci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQ2FsZW5kYXJNb3VzZU91dEJvdW5kID0gdGhpcy5fb25DYWxlbmRhck1vdXNlT3V0LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9vblJlc2l6ZUJvdW5kID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGV2ZW50IGxpc3RlbmVycyBmb3IgRE9NIGV2ZW50cy5cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIF9hZGRFdmVudExpc3RlbmVycygpIHtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGhpcy5lbHMubGVuZ3RoO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGhpcy5lbHNbaV0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrQm91bmQpO1xuICAgICAgdGhpcy5pbnB1dEVsc1tpXS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbklucHV0Q2hhbmdlQm91bmQpO1xuICAgICAgdGhpcy5pbnB1dEVsc1tpXS5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX29uSW5wdXRGb2N1c0JvdW5kKTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbGVuZGFyRWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5fb25DYWxlbmRhck1vdXNlT3ZlckJvdW5kKTtcbiAgICB0aGlzLmNhbGVuZGFyRWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLl9vbkNhbGVuZGFyTW91c2VPdXRCb3VuZCk7XG4gICAgdGhpcy5jYWxlbmRhckVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DYWxlbmRhckNsaWNrQm91bmQpO1xuXG4gICAgdGhpcy5jYWxlbmRhckVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uU2VsZWN0Q2hhbmdlQm91bmQpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplQm91bmQpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMuX29uUmVzaXplQm91bmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGZvciBET00gZXZlbnRzLi5cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9yZW1vdmVFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZW1vdmVFdmVudExpc3RlbmVycygpIHtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGhpcy5lbHMubGVuZ3RoO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGhpcy5lbHNbaV0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrQm91bmQpO1xuICAgICAgdGhpcy5pbnB1dEVsc1tpXS5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbklucHV0Q2hhbmdlQm91bmQpO1xuICAgICAgdGhpcy5pbnB1dEVsc1tpXS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX29uSW5wdXRGb2N1c0JvdW5kKTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbGVuZGFyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5fb25DYWxlbmRhck1vdXNlT3ZlckJvdW5kKTtcbiAgICB0aGlzLmNhbGVuZGFyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLl9vbkNhbGVuZGFyTW91c2VPdXRCb3VuZCk7XG4gICAgdGhpcy5jYWxlbmRhckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DYWxlbmRhckNsaWNrQm91bmQpO1xuXG4gICAgdGhpcy5jYWxlbmRhckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uU2VsZWN0Q2hhbmdlQm91bmQpO1xuXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplQm91bmQpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMuX29uUmVzaXplQm91bmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGb2N1cyBvbiB0aGUgbmV4dCBpbnB1dCBpZiB0aGVyZSBpcyBvbmUuXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fZm9jdXNOZXh0ID0gZnVuY3Rpb24gX2ZvY3VzTmV4dCgpIHtcblxuICAgIHZhciBpbmRleCA9IHZvaWQgMDtcblxuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG51bGwgdmFsdWVzLCBkb24ndCBkbyBhbnl0aGluZy5cbiAgICBpZiAoKGluZGV4ID0gdGhpcy52YWx1ZXMuaW5kZXhPZihudWxsKSkgPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWN0aXZlSW5kZXggPCB0aGlzLmVscy5sZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLm9wZW4odGhpcy5hY3RpdmVJbmRleCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wZW4oaW5kZXgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2xvc2UgaWYgd2UncmUgb24gdGhlIGxhc3QgaW5wdXQgYW5kIHdlIGhhdmUgdmFsdWVzLlxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2Nsb3NlT25MYXN0ID0gZnVuY3Rpb24gX2Nsb3NlT25MYXN0KCkge1xuICAgIGlmICh0aGlzLnZhbHVlcy5pbmRleE9mKG51bGwpID09PSAtMSkge1xuICAgICAgdGhpcy5jbG9zZSh7XG4gICAgICAgIGRlbGF5OiB0aGlzLmNsb3NlRGVsYXlcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTWFrZSB0aGUgdG9nZ2xlIGljb24gYSBmaWxsIGljb24uXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fZmlsbFRvZ2dsZSA9IGZ1bmN0aW9uIF9maWxsVG9nZ2xlKCkge1xuXG4gICAgdmFyIHRvZ2dsZSA9IHZvaWQgMDtcblxuICAgIGlmICh0aGlzLmVsc1t0aGlzLmFjdGl2ZUluZGV4XSAmJiAodG9nZ2xlID0gdGhpcy5lbHNbdGhpcy5hY3RpdmVJbmRleF0ucXVlcnlTZWxlY3RvcignLnNwYXJrLWRhdGVfX2NhbGVuZGFyLXRvZ2dsZSBbY2xhc3MqPVwic3BhcmstaWNvblwiXScpKSkge1xuICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodG9nZ2xlLCAnc3BhcmstaWNvbi0tZmlsbCcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTWFrZSB0aGUgdG9nZ2xlIGljb24gYSBsaW5lIGljb24uXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fdW5maWxsVG9nZ2xlID0gZnVuY3Rpb24gX3VuZmlsbFRvZ2dsZSgpIHtcblxuICAgIHZhciB0b2dnbGUgPSB2b2lkIDA7XG5cbiAgICBpZiAodGhpcy5lbHNbdGhpcy5hY3RpdmVJbmRleF0gJiYgKHRvZ2dsZSA9IHRoaXMuZWxzW3RoaXMuYWN0aXZlSW5kZXhdLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1kYXRlX19jYWxlbmRhci10b2dnbGUgW2NsYXNzKj1cInNwYXJrLWljb25cIl0nKSkpIHtcbiAgICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKHRvZ2dsZSwgJ3NwYXJrLWljb24tLWZpbGwnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlIHRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgY2FsZW5kYXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2FjdGl2YXRlRWxlbWVudCA9IGZ1bmN0aW9uIF9hY3RpdmF0ZUVsZW1lbnQoaW5kZXgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsc1tpbmRleF07XG4gICAgaWYgKGVsKSAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KShlbCwgJ2FjdGl2ZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlIHRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgY2FsZW5kYXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2RlYWN0aXZhdGVFbGVtZW50ID0gZnVuY3Rpb24gX2RlYWN0aXZhdGVFbGVtZW50KGluZGV4KSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbHNbaW5kZXhdO1xuICAgIGlmIChlbCAmJiAhdGhpcy52YWx1ZXNbaW5kZXhdICYmICEoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KShlbCwgJ2ZvY3VzJykgJiYgISgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKGVsLCAnaGFzLXBhcnRpYWwtdmFsdWUnKSkge1xuICAgICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkoZWwsICdhY3RpdmUnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoZSBzaXplIG9mIHRoZSBwb3BvdmVyIGFuZCBzZWUgaWYgd2Ugc2hvdWxkIGJlIHNob3dpbmcgdGhlIFhTIHRyZWF0bWVudC5cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9jaGVja1NpemUgPSBmdW5jdGlvbiBfY2hlY2tTaXplKCkge1xuXG4gICAgdmFyIGJwID0gKDAsIF9icmVha3BvaW50LmdldCkod2luZG93Lm91dGVyV2lkdGgpO1xuXG4gICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlIGJyZWFrcG9pbnQgaGFzbid0IGNoYW5nZWQuXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRCcmVha3BvaW50ID09PSBicCkgcmV0dXJuO1xuXG4gICAgLy8gU3RvcmUgdGhlIGJyZWFrcG9pbnRcbiAgICB0aGlzLl9jdXJyZW50QnJlYWtwb2ludCA9IGJwO1xuXG4gICAgLy8gUmUtcmVuZGVyIHRoZSBkYXRlIHJhbmdlXG4gICAgdGhpcy5fc2V0RGF0ZXNUb1Nob3coKTtcbiAgICB0aGlzLnJlbmRlcih0cnVlKTtcbiAgICB0aGlzLnBvcG92ZXIudXBkYXRlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNjcm9sbCB0aGUgYWN0aXZlIGlucHV0IGVsZW1lbnQgaW50byB2aWV3LlxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX3Njcm9sbFRvSW5wdXQgPSBmdW5jdGlvbiBfc2Nyb2xsVG9JbnB1dCgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsc1t0aGlzLmFjdGl2ZUluZGV4XTtcbiAgICBpZiAoZWwpICgwLCBfc2Nyb2xsVG8yLmRlZmF1bHQpKGVsKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBob3ZlciBjbGFzc2VzLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGhvdmVyU3RhcnRzXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gaG92ZXJFbmRzXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fdXBkYXRlSG92ZXJDbGFzc2VzID0gZnVuY3Rpb24gX3VwZGF0ZUhvdmVyQ2xhc3Nlcyhob3ZlclN0YXJ0cywgaG92ZXJFbmRzKSB7XG5cbiAgICB0aGlzLl9ob3ZlclN0YXJ0cyA9IHRoaXMuX2hvdmVyU3RhcnRzIHx8IFtdO1xuICAgIHRoaXMuX2hvdmVyRW5kcyA9IHRoaXMuX2hvdmVyRW5kcyB8fCBbXTtcblxuICAgIGhvdmVyU3RhcnRzID0gaG92ZXJTdGFydHMgaW5zdGFuY2VvZiBBcnJheSA/IGhvdmVyU3RhcnRzIDogaG92ZXJTdGFydHMgPyBbaG92ZXJTdGFydHNdIDogW107XG4gICAgaG92ZXJFbmRzID0gaG92ZXJFbmRzIGluc3RhbmNlb2YgQXJyYXkgPyBob3ZlckVuZHMgOiBob3ZlckVuZHMgPyBbaG92ZXJFbmRzXSA6IFtdO1xuXG4gICAgdmFyIGFsbFN0YXJ0cyA9IFtdO1xuICAgIHZhciBjdXJTdGFydHMgPSBbXTtcbiAgICB2YXIgbmV3U3RhcnRzID0gW107XG4gICAgdmFyIGFsbEVuZHMgPSBbXTtcbiAgICB2YXIgY3VyRW5kcyA9IFtdO1xuICAgIHZhciBuZXdFbmRzID0gW107XG5cbiAgICBob3ZlclN0YXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9ob3ZlclN0YXJ0cy5pbmRleE9mKGVsKTtcblxuICAgICAgLy8gQWxyZWFkeSBob3ZlcmVkLlxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBjdXJTdGFydHMucHVzaChlbCk7XG4gICAgICB9XG4gICAgICAvLyBOb3QgYWxyZWFkeSBob3ZlcmVkLiBSZWFkeSB0byBhZGQgdGhlIGNsYXNzLlxuICAgICAgZWxzZSBpZiAoZWwpIHtcbiAgICAgICAgICBuZXdTdGFydHMucHVzaChlbCk7XG4gICAgICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkoZWwsICdob3Zlci1zdGFydCcpO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICBhbGxTdGFydHMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmNhbGwoW10sIGN1clN0YXJ0cywgbmV3U3RhcnRzKTtcblxuICAgIHRoaXMuX2hvdmVyU3RhcnRzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICBpZiAoYWxsU3RhcnRzLmluZGV4T2YoZWwpID09PSAtMSkge1xuICAgICAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KShlbCwgJ2hvdmVyLXN0YXJ0Jyk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICBob3ZlckVuZHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcblxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5faG92ZXJFbmRzLmluZGV4T2YoZWwpO1xuXG4gICAgICAvLyBBbHJlYWR5IGhvdmVyZWQuXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIGN1ckVuZHMucHVzaChlbCk7XG4gICAgICB9XG4gICAgICAvLyBOb3QgYWxyZWFkeSBob3ZlcmVkLiBSZWFkeSB0byBhZGQgdGhlIGNsYXNzLlxuICAgICAgZWxzZSBpZiAoZWwpIHtcbiAgICAgICAgICBuZXdFbmRzLnB1c2goZWwpO1xuICAgICAgICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKGVsLCAnaG92ZXItZW5kJyk7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIGFsbEVuZHMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmNhbGwoW10sIGN1ckVuZHMsIG5ld0VuZHMpO1xuXG4gICAgdGhpcy5faG92ZXJFbmRzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICBpZiAoYWxsRW5kcy5pbmRleE9mKGVsKSA9PT0gLTEpIHtcbiAgICAgICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkoZWwsICdob3Zlci1lbmQnKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuX2hvdmVyU3RhcnRzID0gYWxsU3RhcnRzO1xuICAgIHRoaXMuX2hvdmVyRW5kcyA9IGFsbEVuZHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gYW4gZWxlbWVudCBpcyBjbGlja2VkLCBpZiB0aGUgdG9nZ2xlIHdhcyB0aGUgdGFyZ2V0LCBvcGVuIHRoZSBwb3BvdmVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX29uQ2xpY2sgPSBmdW5jdGlvbiBfb25DbGljayhlKSB7XG5cbiAgICBpZiAoKDAsIF9nZXRQYXJlbnQyLmRlZmF1bHQpKGUudGFyZ2V0LCAnLnNwYXJrLWRhdGVfX2NhbGVuZGFyLXRvZ2dsZScsIHRoaXMuZWxzKSkge1xuXG4gICAgICB2YXIgZWwgPSAoMCwgX2dldFBhcmVudDIuZGVmYXVsdCkoZS50YXJnZXQsICcuc3BhcmstZGF0ZScsIHRoaXMuZWxzKTtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuZWxzLmluZGV4T2YoZWwpO1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIC8vIE9wZW4gb24gdGhlIG5leHQgdGljay4gT3RoZXJ3aXNlIHdlIGFsc28gcmVjZWl2ZSB0aGUgd2luZG93IGNsaWNrIGNsb3NlIGV2ZW50LlxuICAgICAgdGhpcy5vcGVuKGluZGV4LCB7XG4gICAgICAgIGRlbGF5OiAxXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIGNhbGVuZGFyIGlzIGhvdmVyZWQsIGRvIHNvbWUgaGlnaGxpZ2h0aW5nIGlmIHdlJ3JlIHNob3dpbmcgYSByYW5nZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9vbkNhbGVuZGFyTW91c2VPdmVyID0gZnVuY3Rpb24gX29uQ2FsZW5kYXJNb3VzZU92ZXIoZSkge1xuICAgIGlmICh0aGlzLnZpZXdSYW5nZSA9PT0gJ21vbnRoJykgdGhpcy5fb25DYWxlbmRhck1vdXNlT3Zlck1vbnRocyhlLnRhcmdldCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBob3ZlciBzdGF0ZXMgZm9yIGRheXMuXG4gICAqIEBwYXJhbSAge0VsZW1lbnR9IHRhcmdldFxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX29uQ2FsZW5kYXJNb3VzZU92ZXJNb250aHMgPSBmdW5jdGlvbiBfb25DYWxlbmRhck1vdXNlT3Zlck1vbnRocyh0YXJnZXQpIHtcblxuICAgIGlmICghdGhpcy5faXNSYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkYXkgPSAoMCwgX2dldFBhcmVudDIuZGVmYXVsdCkodGFyZ2V0LCAnLnNwYXJrLWNhbGVuZGFyX19kYXknKTtcblxuICAgIGlmICghZGF5KSB7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlckNsYXNzZXMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbW9udGggPSAoMCwgX2dldFBhcmVudDIuZGVmYXVsdCkodGFyZ2V0LCAnLnNwYXJrLWNhbGVuZGFyX19tb250aCcpO1xuICAgIHZhciBtSGFzQ2xhc3MgPSBmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuICgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKG1vbnRoLCBjKTtcbiAgICB9LmJpbmQodGhpcyk7XG4gICAgdmFyIG5ld1N0YXJ0ID0gW107XG4gICAgdmFyIG5ld0VuZCA9IFtdO1xuICAgIHZhciBkYXlTZWwgPSB2b2lkIDA7XG5cbiAgICAvLyBPbmx5IGRvIGhpZ2hsaWdodHMgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGEgdmFsdWUgZm9yIHRoaXMgaW5kZXguXG4gICAgaWYgKCF0aGlzLnZhbHVlc1t0aGlzLmFjdGl2ZUluZGV4XSkge1xuXG4gICAgICAvLyBBIG1vbnRoIHdpdGggYSB2YWx1ZSBiZWZvcmUgaXQgYnV0IG5vIHZhbHVlIG9mIGl0cyBvd24sIGhvdmVyIHN0YXJ0c1xuICAgICAgLy8gZnJvbSB0aGUgZmlyc3QgZGF5IHRvIHRoZSBob3ZlcmVkIGRheS5cbiAgICAgIGlmIChtSGFzQ2xhc3MoJ3ZhbHVlLWJlZm9yZScpICYmICFtSGFzQ2xhc3MoJ2FmdGVyLXJhbmdlLWVuZCcpICYmICFtSGFzQ2xhc3MoJ2hhcy12YWx1ZScpICYmICFtSGFzQ2xhc3MoJ3ZhbHVlLWFmdGVyJykpIHtcblxuICAgICAgICBuZXdTdGFydC5wdXNoKG1vbnRoLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1jYWxlbmRhcl9fZGF5Om5vdCguc3BhcmstY2FsZW5kYXJfX2RheS0taW5hY3RpdmUpOm5vdCguc3BhcmstY2FsZW5kYXJfX2RheS0tZGlzYWJsZWQpJykpO1xuICAgICAgICBuZXdFbmQucHVzaChkYXkpO1xuXG4gICAgICAgIC8vIEFkZCBhIGhvdmVyIHJhbmdlIHRvIGEgcHJldmlvdXMgbW9udGguXG4gICAgICAgIHZhciBwcmV2TW9udGggPSBtb250aDtcbiAgICAgICAgd2hpbGUgKChwcmV2TW9udGggPSAoMCwgX2dldFNpYmxpbmdCZWZvcmUyLmRlZmF1bHQpKHByZXZNb250aCwgJy5zcGFyay1jYWxlbmRhcl9fbW9udGgnKSkgJiYgISgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKHByZXZNb250aCwgJ3ZhbHVlLWFmdGVyJykgJiYgKCgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKHByZXZNb250aCwgJ2hhcy12YWx1ZScpIHx8ICgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKHByZXZNb250aCwgJ3ZhbHVlLWJlZm9yZScpKSkge1xuXG4gICAgICAgICAgZGF5U2VsID0gcHJldk1vbnRoLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zcGFyay1jYWxlbmRhcl9fZGF5LS1zZWxlY3RlZCcpO1xuICAgICAgICAgIGRheVNlbCA9IGRheVNlbFtkYXlTZWwubGVuZ3RoIC0gMV07XG4gICAgICAgICAgZGF5U2VsID0gZGF5U2VsIHx8IHByZXZNb250aC5xdWVyeVNlbGVjdG9yKCcuc3BhcmstY2FsZW5kYXJfX2RheScpO1xuXG4gICAgICAgICAgaWYgKGRheVNlbCkge1xuICAgICAgICAgICAgbmV3U3RhcnQucHVzaChkYXlTZWwpO1xuICAgICAgICAgICAgZGF5U2VsID0gcHJldk1vbnRoLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zcGFyay1jYWxlbmRhcl9fZGF5Jyk7XG4gICAgICAgICAgICBkYXlTZWwgPSBkYXlTZWxbZGF5U2VsLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgbmV3RW5kLnB1c2goZGF5U2VsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEEgbW9udGggd2l0aCBhIHZhbHVlLCBoaWdobGlnaHQgZWl0aGVyIGZyb20gdGhlIGhvdmVyZWQgZGF5IHRvXG4gICAgICAvLyB0aGUgc2VsZWN0aW9uIG9yIGZyb20gdGhlIHNlbGVjdGlvbiB0byB0aGUgZGF5LlxuICAgICAgZWxzZSBpZiAobUhhc0NsYXNzKCdoYXMtdmFsdWUnKSAmJiAhbUhhc0NsYXNzKCd2YWx1ZS1iZWZvcmUnKSAmJiAhbUhhc0NsYXNzKCd2YWx1ZS1hZnRlcicpICYmICgobmV3U3RhcnQgPSAoMCwgX2dldFNpYmxpbmdCZWZvcmUyLmRlZmF1bHQpKGRheSwgJy5zcGFyay1jYWxlbmRhcl9fZGF5LS1zZWxlY3RlZCcpKSB8fCAobmV3RW5kID0gKDAsIF9nZXRTaWJsaW5nQWZ0ZXIyLmRlZmF1bHQpKGRheSwgJy5zcGFyay1jYWxlbmRhcl9fZGF5LS1zZWxlY3RlZCcpKSkpIHtcblxuICAgICAgICAgIGlmIChuZXdTdGFydCkge1xuICAgICAgICAgICAgbmV3U3RhcnQgPSBbbmV3U3RhcnRdO1xuICAgICAgICAgICAgbmV3RW5kID0gW2RheV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0VuZCA9IFtuZXdFbmRdO1xuICAgICAgICAgICAgbmV3U3RhcnQgPSBbZGF5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkobmV3RW5kWzBdLCAnc3BhcmstY2FsZW5kYXJfX3JhbmdlLXN0YXJ0JykgfHwgKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkobmV3U3RhcnRbMF0sICdzcGFyay1jYWxlbmRhcl9fcmFuZ2UtZW5kJykpIHtcbiAgICAgICAgICAgIG5ld1N0YXJ0ID0gW107XG4gICAgICAgICAgICBuZXdFbmQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBtb250aCB3aXRoIGEgbWlkZGxlIHJhbmdlIHNob3VsZCBoaWdobGlnaHQgYmVmb3JlXG4gICAgICAgIGVsc2UgaWYgKG1IYXNDbGFzcygnaGFzLXZhbHVlJykgJiYgbUhhc0NsYXNzKCdyYW5nZS1taWRkbGUnKSAmJiBtSGFzQ2xhc3MoJ3ZhbHVlLWJlZm9yZScpKSB7XG4gICAgICAgICAgICBkYXlTZWwgPSAoMCwgX2dldFNpYmxpbmdCZWZvcmUyLmRlZmF1bHQpKGRheSwgJy5zcGFyay1jYWxlbmRhcl9fZGF5LS1zZWxlY3RlZCcpO1xuICAgICAgICAgICAgaWYgKGRheVNlbCkge1xuICAgICAgICAgICAgICBuZXdTdGFydCA9IFtkYXlTZWxdO1xuICAgICAgICAgICAgICBuZXdFbmQgPSBbZGF5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlSG92ZXJDbGFzc2VzKG5ld1N0YXJ0LCBuZXdFbmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBjYWxlbmRhciBpcyBob3ZlcmVkLCB1bmRvIHNvbWUgaGlnaGxpZ2h0aW5nIGlmIHdlJ3JlIHNob3dpbmcgYSByYW5nZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9vbkNhbGVuZGFyTW91c2VPdXQgPSBmdW5jdGlvbiBfb25DYWxlbmRhck1vdXNlT3V0KGUpIHtcbiAgICBpZiAodGhpcy52aWV3UmFuZ2UgPT09ICdtb250aCcpIHRoaXMuX29uQ2FsZW5kYXJNb3VzZU91dE1vbnRocyhlLnRhcmdldCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFyIGhvdmVyIHN0YXRlcyBmb3IgZGF5cy5cbiAgICogQHBhcmFtICB7RWxlbWVudH0gdGFyZ2V0XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fb25DYWxlbmRhck1vdXNlT3V0TW9udGhzID0gZnVuY3Rpb24gX29uQ2FsZW5kYXJNb3VzZU91dE1vbnRocyh0YXJnZXQpIHtcblxuICAgIHZhciBkYXkgPSAoMCwgX2dldFBhcmVudDIuZGVmYXVsdCkodGFyZ2V0LCAnLnNwYXJrLWNhbGVuZGFyX19kYXknKTtcbiAgICB2YXIgZGF5cyA9ICgwLCBfZ2V0UGFyZW50Mi5kZWZhdWx0KSh0YXJnZXQsICcuc3BhcmstY2FsZW5kYXJfX2RheXMnKTtcbiAgICB2YXIgbW9udGggPSAoMCwgX2dldFBhcmVudDIuZGVmYXVsdCkodGFyZ2V0LCAnLnNwYXJrLWNhbGVuZGFyX19tb250aCcpO1xuXG4gICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkoZGF5LCAnaG92ZXInKTtcbiAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KShkYXlzLCAnaG92ZXInKTtcbiAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KShtb250aCwgJ2hvdmVyJyk7XG4gICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkodGhpcy5jYWxlbmRhckVsLCAnaG92ZXInKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgY2FsZW5kYXIgaXMgY2xpY2tlZCwgaGFuZGxlIG5hdmlnYXRpb24gY2xpY2tzIGFuZCBkYXRlIHNlbGVjdGlvbnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fb25DYWxlbmRhckNsaWNrID0gZnVuY3Rpb24gX29uQ2FsZW5kYXJDbGljayhlKSB7XG5cbiAgICB2YXIgbmF2ID0gKDAsIF9nZXRQYXJlbnQyLmRlZmF1bHQpKGUudGFyZ2V0LCAnLnNwYXJrLWNhbGVuZGFyX19uYXYnLCB0aGlzLmNhbGVuZGFyRWwpO1xuICAgIHZhciBkYXkgPSB2b2lkIDA7XG4gICAgdmFyIGRpciA9IHZvaWQgMDtcblxuICAgIC8vIE5hdmlnYXRpb24gY2xpY2tzXG4gICAgaWYgKG5hdikge1xuXG4gICAgICAvLyBQcmV2aW91c1xuICAgICAgaWYgKCgwLCBfZ2V0UGFyZW50Mi5kZWZhdWx0KShlLnRhcmdldCwgJy5zcGFyay1jYWxlbmRhcl9fcHJldmlvdXMnLCBuYXYpKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXMoKTtcbiAgICAgIH1cbiAgICAgIC8vIE5leHRcbiAgICAgIGVsc2UgaWYgKCgwLCBfZ2V0UGFyZW50Mi5kZWZhdWx0KShlLnRhcmdldCwgJy5zcGFyay1jYWxlbmRhcl9fbmV4dCcsIG5hdikpIHtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBEYXkgY2xpY2tcbiAgICBlbHNlIGlmIChkYXkgPSAoMCwgX2dldFBhcmVudDIuZGVmYXVsdCkoZS50YXJnZXQsICcuc3BhcmstY2FsZW5kYXJfX2RheScpKSB7XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIC8vIERpc2FibGVkIGRheSBtb3ZlcyBjYW4gbW92ZSB1cyB0byB0aGUgbmV4dCBtb250aFxuICAgICAgICBpZiAoKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkoZGF5LCAnc3BhcmstY2FsZW5kYXJfX2RheS0tZGlzYWJsZWQnKSkge1xuICAgICAgICAgIGRpciA9IGRheS5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGlyZWN0aW9uJyk7XG4gICAgICAgICAgaWYgKGRpciA9PT0gJ25leHQnKSB0aGlzLm5leHQoKTtlbHNlIGlmIChkaXIgPT09ICdwcmV2aW91cycpIHRoaXMucHJldmlvdXMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbmFibGVkIGRheSBzZXRzIHRoZSB2YWx1ZVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUoZGF5LmdldEF0dHJpYnV0ZSgnZGF0YS1kYXRlJyksIHRoaXMuYWN0aXZlSW5kZXgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0FkdmFuY2UpIHRoaXMuX2ZvY3VzTmV4dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0Nsb3NlKSB0aGlzLl9jbG9zZU9uTGFzdCgpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgcG9wb3ZlciBvcGVucywgc2V0IHRoZSB0b2dnbGUgc3RhdGUuXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fb25Qb3BvdmVyT3BlbiA9IGZ1bmN0aW9uIF9vblBvcG92ZXJPcGVuKCkge1xuICAgIHRoaXMuX2ZpbGxUb2dnbGUoKTtcbiAgICB0aGlzLl9jaGVja1NpemUoKTtcbiAgICBpZiAodGhpcy5fY3VycmVudEJyZWFrcG9pbnQgPT09ICd4cycpIHRoaXMuX3Njcm9sbFRvSW5wdXQoKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgcG9wb3ZlciBjbG9zZXMsIHJlc2V0IHRoZSBhY3RpdmUgc3RhdGUuXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fb25Qb3BvdmVyQ2xvc2UgPSBmdW5jdGlvbiBfb25Qb3BvdmVyQ2xvc2UoKSB7XG4gICAgdGhpcy5fdW5maWxsVG9nZ2xlKCk7XG4gICAgdGhpcy5fdXBkYXRlSG92ZXJDbGFzc2VzKCk7XG4gICAgdGhpcy5fZGVhY3RpdmF0ZUVsZW1lbnQodGhpcy5hY3RpdmVJbmRleCk7XG4gICAgdGhpcy5hY3RpdmVJbmRleCA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIGlucHV0IHRoYXQgY29ycmVzcG9uZHMgdG8gdGhpcyBpbnN0YW5jZSBjaGFuZ2VzLiBBbGxvd3MgdXMgdG8gbGlzdGVuXG4gICAqIGFuZCByZXNwb25kIHRvIGNoYW5nZXMgbWFkZSBieSBvdGhlciBjb21wb25lbnRzIChDYWxlbmRhciBQb3BvdmVyLCBmb3IgZXhhbXBsZSkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fb25JbnB1dENoYW5nZSA9IGZ1bmN0aW9uIF9vbklucHV0Q2hhbmdlKGUpIHtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuaW5wdXRFbHMuaW5kZXhPZihlLnRhcmdldCk7XG5cbiAgICBpZiAodGhpcy5faW5wdXRzQ2hhbmdpbmcgJiYgdGhpcy5faW5wdXRzQ2hhbmdpbmcuaW5kZXhPZihpbmRleCkgIT09IC0xKSByZXR1cm47XG5cbiAgICB0aGlzLnNldFZhbHVlKGUudGFyZ2V0LnZhbHVlLCBpbmRleCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gYW4gaW5wdXQgcmVjZWl2ZXMgZm9jdXMsIGlmIHdlIGFyZSBzdXBwb3NlZCB0byBhdXRvbWF0aWNhbGx5IHNob3dcbiAgICogb24gZm9jdXMgZG8gc28uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fb25JbnB1dEZvY3VzID0gZnVuY3Rpb24gX29uSW5wdXRGb2N1cyhlKSB7XG4gICAgaWYgKCF0aGlzLnNob3dPbkZvY3VzKSByZXR1cm47XG4gICAgdmFyIGluZGV4ID0gdGhpcy5pbnB1dEVscy5pbmRleE9mKGUudGFyZ2V0KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB0aGlzLm9wZW4oaW5kZXgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIG9uZSBvZiB0aGUgY2FsZW5kYXIgcXVpY2sganVtcCBzZWxlY3QgaW5wdXRzIGNoYW5nZXMuXG4gICAqIFdlIGhhdmUgdG8gc2V0IHRoZSB2YWx1ZSBvZiB0aGUgc2VsZWN0IGlucHV0IGJhY2sgdG8gaXRzIG9yaWdpbmFsXG4gICAqIHZhbHVlIG9yIGVsc2UgaXQgd2lsbCBiZSBvdXQgb2Ygc3luYyB3aGVuIHRoZSBjdXJyZW50bHkgYWN0aXZlXG4gICAqIG1vbnRoIGlzIHNob3duIGFnYWluLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX29uU2VsZWN0Q2hhbmdlID0gZnVuY3Rpb24gX29uU2VsZWN0Q2hhbmdlKGUpIHtcblxuICAgIHZhciBuYW1lID0gZS50YXJnZXQubmFtZTtcbiAgICB2YXIgdmFsID0gZS50YXJnZXQudmFsdWU7XG4gICAgdmFyIGN1clZhbCA9IHRoaXMuX2RhdGVzVG9TaG93W3RoaXMuYWN0aXZlSW5kZXhdW25hbWVdO1xuICAgIHZhciBvYmogPSB7fTtcblxuICAgIG9ialtuYW1lXSA9IHZhbDtcbiAgICB0aGlzLnNob3dEYXRlKG9iaik7XG4gICAgZS50YXJnZXQudmFsdWUgPSBjdXJWYWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHdpbmRvdyByZXNpemVzLCBkZXRlcm1pbmUgaWYgd2UncmUgYXQgdGhlIFhTIGJyZWFrcG9pbnQgc28gd2VcbiAgICogY2FuIGRvIHNvbWUgbW9iaWxlLWVzcXVlIHN0dWZmIVxuICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX29uUmVzaXplID0gZnVuY3Rpb24gX29uUmVzaXplKCkge1xuICAgIGlmICh0aGlzLmFjdGl2ZUluZGV4ICE9PSBudWxsKSB0aGlzLl9jaGVja1NpemUoKTtcbiAgfTtcblxuICByZXR1cm4gQ2FsZW5kYXJQb3BvdmVyO1xufShfYmFzZTIuZGVmYXVsdCk7XG5cbi8qKlxuICogV2hpdGVsaXN0ZWQgcGFyYW1ldGVycyB3aGljaCBjYW4gYmUgc2V0IG9uIGNvbnN0cnVjdGlvbi5cbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuXG5cbkNhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX3doaXRlbGlzdGVkUGFyYW1zID0gWydlbHMnLCAndmlzaWJsZUNvdW50cycsICdhdXRvQWR2YW5jZScsICdhdXRvQ2xvc2UnLCAnY2xvc2VEZWxheScsICdtaW5zJywgJ21heGVzJywgJ3ZhbHVlcycsICdkYXlzRGlzYWJsZWQnLCAnZGF5c0luZm8nLCAncXVpY2tKdW1wJywgJ3F1aWNrSnVtcFJhbmdlJywgJ2NhbGVuZGFyRWwnLCAndmlld1JhbmdlJywgJ2FuaW1hdGUnLCAnYW5pbWF0aW9uRHVyYXRpb24nLCAnc2hvd09uRm9jdXMnLCAnb25DaGFuZ2UnXTtcblxuLyoqXG4gKiBEZWZhdWx0IHZhbHVlcyBmb3IgaW50ZXJuYWwgcHJvcGVydGllcyB3ZSB3aWxsIGJlIHNldHRpbmcuXG4gKiBUaGVzZSBhcmUgc2V0IG9uIGVhY2ggY29uc3RydWN0aW9uIHNvIHdlIGRvbid0IGxlYWsgcHJvcGVydGllc1xuICogaW50byB0aGUgcHJvdG90eXBlIGNoYWluLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5kZWZhdWx0cyA9IHtcbiAgZWxzOiBudWxsLFxuICBpbnB1dEVsczogbnVsbCxcbiAgY2FsZW5kYXJFbDogbnVsbCxcbiAgY2FsZW5kYXJDb250ZW50RWw6IG51bGwsXG4gIGNhbGVuZGFyT3ZlcmZsb3dFbDogbnVsbCxcbiAgdmlzaWJsZUNvdW50czogbnVsbCxcbiAgYWN0aXZlSW5kZXg6IG51bGwsXG4gIG1pbnM6IG51bGwsXG4gIG1pblZpc2libGU6IG51bGwsXG4gIG1heGVzOiBudWxsLFxuICBtYXhWaXNpYmxlOiBudWxsLFxuICB2YWx1ZXM6IG51bGwsXG4gIGRheXNEaXNhYmxlZDogbnVsbCxcbiAgZGF5c0luZm86IG51bGwsXG4gIHZpZXdSYW5nZTogbnVsbCxcbiAgYXV0b0FkdmFuY2U6IG51bGwsXG4gIGF1dG9DbG9zZTogbnVsbCxcbiAgcXVpY2tKdW1wOiBudWxsLFxuICBjbG9zZURlbGF5OiBudWxsLFxuICBuZXh0QnV0dG9uRWw6IG51bGwsXG4gIHByZXZpb3VzQnV0dG9uRWw6IG51bGwsXG4gIGFuaW1hdGU6IG51bGwsXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiBudWxsLFxuICBzaG93T25Gb2N1czogbnVsbCxcbiAgb25DaGFuZ2U6IG51bGwsXG4gIF9pc0Rpc2FibGVkOiBmYWxzZSxcbiAgX2lzUmFuZ2U6IG51bGwsXG4gIF9ob3ZlclN0YXJ0czogbnVsbCxcbiAgX2hvdmVyRW5kczogbnVsbCxcbiAgX2N1cnJlbnRCcmVha3BvaW50OiBudWxsLFxuICBfYW5pbWF0aW9uUXVldWU6IG51bGwsXG4gIF9jdXJyZW50Q29udGVudDogbnVsbCxcbiAgX2RhdGVzVG9TaG93OiBudWxsLFxuICBfbW9udGhzU2hvd2luZzogbnVsbCxcbiAgX2F0TWluOiBmYWxzZSxcbiAgX2F0TWF4OiBmYWxzZSxcbiAgX2lucHV0c0NoYW5naW5nOiBmYWxzZSxcbiAgX29wZW5DbG9zZVRpbWVyOiBudWxsLFxuICBfcmVuZGVyQ2FjaGU6IG51bGwsXG4gIF9vbkNsaWNrQm91bmQ6IG51bGwsXG4gIF9vbkNhbGVuZGFyTW91c2VPdmVyQm91bmQ6IG51bGwsXG4gIF9vbkNhbGVuZGFyTW91c2VPdXRCb3VuZDogbnVsbCxcbiAgX29uQ2FsZW5kYXJDbGlja0JvdW5kOiBudWxsLFxuICBfb25TZWxlY3RDaGFuZ2VCb3VuZDogbnVsbCxcbiAgX29uSW5wdXRDaGFuZ2VCb3VuZDogbnVsbCxcbiAgX29uSW5wdXRGb2N1c0JvdW5kOiBudWxsLFxuICBfb25SZXNpemVCb3VuZDogbnVsbFxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ2FsZW5kYXJQb3BvdmVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxlbmRhci1wb3BvdmVyLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2Jhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcblxudmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xuXG52YXIgX2FkZENsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vYWRkLWNsYXNzJyk7XG5cbnZhciBfYWRkQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWRkQ2xhc3MpO1xuXG52YXIgX2hhc0NsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vaGFzLWNsYXNzJyk7XG5cbnZhciBfaGFzQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzQ2xhc3MpO1xuXG52YXIgX3RvZ2dsZUNsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vdG9nZ2xlLWNsYXNzJyk7XG5cbnZhciBfdG9nZ2xlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9nZ2xlQ2xhc3MpO1xuXG52YXIgX2FwcGVuZENoaWxkcmVuID0gcmVxdWlyZSgnLi4vaGVscGVycy9tYW5pcHVsYXRpb24vYXBwZW5kLWNoaWxkcmVuJyk7XG5cbnZhciBfYXBwZW5kQ2hpbGRyZW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXBwZW5kQ2hpbGRyZW4pO1xuXG52YXIgX2hhc1BhcmVudCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdHJhdmVyc2FsL2hhcy1wYXJlbnQnKTtcblxudmFyIF9oYXNQYXJlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzUGFyZW50KTtcblxudmFyIF9nZXRQYXJlbnQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RyYXZlcnNhbC9nZXQtcGFyZW50Jyk7XG5cbnZhciBfZ2V0UGFyZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFBhcmVudCk7XG5cbnZhciBfcGFyc2VBdHRyaWJ1dGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbS9wYXJzZS1hdHRyaWJ1dGUnKTtcblxudmFyIF9hZmZpeCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcG9zaXRpb24vYWZmaXgnKTtcblxudmFyIF9hZmZpeDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hZmZpeCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAjIFBvcG92ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNob3cgYW5kIGhpZGUgYSBwb3BvdmVyLiBTaG91bGQgZG8gc29tZSBzYW5pdHkgY2hlY2tzIG9uIHBvc2l0aW9uaW5nIGFzIHdlbGwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG5ldyBQb3BvdmVyKGVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIC8vIE9wdGlvbmFsLiBEZWZhdWx0IGFuY2hvcmluZyBvZiB0aGUgY29udGVudCdzIHggYW5kIHktYXhpcyByZWxhdGl2ZSB0byB0aGUgYnV0dG9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICBkZWZhdWx0QW5jaG9yWDogJ2NlbnRlcicsIC8vICdsZWZ0JywgJ2NlbnRlcicsICdyaWdodCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgZGVmYXVsdEFuY2hvclk6ICdjZW50ZXInIC8vICdsZWZ0JywgJ2NlbnRlcicsICdyaWdodCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgY29tcG9uZW50cy9wb3BvdmVyLmpzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIFBvcG92ZXIgPSBmdW5jdGlvbiAoX0Jhc2VDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFBvcG92ZXIsIF9CYXNlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBQb3BvdmVyKGVsKSB7XG4gICAgdmFyIF9yZXQ7XG5cbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb3BvdmVyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CYXNlQ29tcG9uZW50LmNhbGwodGhpcywgZWwsIHBhcmFtcykpO1xuXG4gICAgaWYgKCFlbCkgcmV0dXJuIF9yZXQgPSBfdGhpcywgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICAgIF90aGlzLl9iaW5kRXZlbnRMaXN0ZW5lckNhbGxiYWNrcygpO1xuICAgIF90aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVuLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIE9wdGlvbmFsXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgdGltZXIgcnVubmluZyBmb3IgdGhlIGNsb3NlIGV2ZW50LCBjbGVhciBpdCBzbyBpdFxuICAgIC8vIGRvZXNuJ3QgY2xvc2Ugc3R1ZmYgZHVyaW5nIG9wZW4uXG4gICAgaWYgKHRoaXMuY2xvc2VUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2xvc2VUaW1lcik7XG4gICAgICB0aGlzLmNsb3NlVGltZXIgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBlbGVtZW50IHdlIGFuY2hvciB0aGUgcG9wb3ZlciB0byBpcyBmaXhlZCwgd2UgbmVlZCB0byBrbm93XG4gICAgLy8gc28gdGhhdCB0aGUgYWZmaXhlZCBjb250ZW50IGNhbiBhbHNvIGJlIGZpeGVkLlxuICAgIHRoaXMuX2NoZWNrRml4ZWRQb3NpdGlvbigpO1xuXG4gICAgLy8gVXBkYXRlIGFuIGV4aXN0aW5nIGFmZml4ZWQgaW5zdGFuY2UuXG4gICAgaWYgKHRoaXMuYWZmaXgpIHtcbiAgICAgIHRoaXMuYWZmaXgudGFyZ2V0RWwgPSBwYXJhbXMuYWZmaXhUbyB8fCB0aGlzLmFmZml4LnRhcmdldEVsO1xuICAgICAgdGhpcy5hZmZpeC51cGRhdGUoKTtcbiAgICB9XG4gICAgLy8gQWZmaXggdGhlIGNvbnRlbnQgdG8gdGhlIHRvZ2dsZVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmFmZml4ID0gbmV3IF9hZmZpeDIuZGVmYXVsdCh7XG4gICAgICAgICAgZWw6IHRoaXMuY29udGVudEVsLFxuICAgICAgICAgIHRhcmdldEVsOiBwYXJhbXMuYWZmaXhUbyB8fCB0aGlzLmVsLFxuICAgICAgICAgIGNhcmV0RWw6IHRoaXMuY2FyZXRFbCxcbiAgICAgICAgICBhbmNob3JYOiB0aGlzLmFuY2hvclgsXG4gICAgICAgICAgYW5jaG9yWTogdGhpcy5hbmNob3JZLFxuICAgICAgICAgIGlzRml4ZWQ6IHRoaXMuaXNGaXhlZFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgIC8vIEZpbmQgYWxsIGZvY3VzYWJsZSBlbGVtZW50cyBpbiB0aGUgUG9wb3ZlciBmb3IgbmF2aWdhdGlvblxuICAgIHZhciBwb3BvdmVyRm9jdXNhYmxlRWxzID0gdGhpcy5jb250ZW50RWwucXVlcnlTZWxlY3RvckFsbCgnYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLCBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLCB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSksIFt0YWJpbmRleD1cIjBcIl0nKTtcblxuICAgIGlmIChwb3BvdmVyRm9jdXNhYmxlRWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucG9wb3ZlckZvY3VzYWJsZUVscyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHBvcG92ZXJGb2N1c2FibGVFbHMpO1xuICAgICAgdGhpcy5maXJzdFBvcG92ZXJGb2N1c2FibGVFbCA9IHRoaXMucG9wb3ZlckZvY3VzYWJsZUVsc1swXTtcbiAgICAgIHRoaXMubGFzdFBvcG92ZXJGb2N1c2FibGVFbCA9IHRoaXMucG9wb3ZlckZvY3VzYWJsZUVsc1t0aGlzLnBvcG92ZXJGb2N1c2FibGVFbHMubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgLy8gTGlzdGVuIGZvciBjbGlja3Mgb24gdGhlIHdpbmRvd1xuICAgIHRoaXMuX2FkZFdpbmRvd0V2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcblxuICAgIC8vIERpc3BhdGNoIGEgY3VzdG9tIGV2ZW50IHNvIGNvbnRlbnQgaW5zaWRlIHRoZSBwb3BvdmVyIGNhbiByZXNwb25kXG4gICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBlLmluaXRFdmVudCgnc3BhcmsudmlzaWJsZS1jaGlsZHJlbicsIHRydWUsIHRydWUpO1xuICAgIHRoaXMuY29udGVudEVsLmRpc3BhdGNoRXZlbnQoZSk7XG5cbiAgICAvLyBVcGRhdGUgYmluZGluZ3NcbiAgICB0aGlzLl91cGRhdGVBdHRyaWJ1dGVzKCk7XG5cbiAgICAvLyBTZXQgZm9jdXMgdG8gZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgb25jZSBQb3BvdmVyIGhhcyBiZWVuIG9wZW5lZFxuICAgIGlmIChwb3BvdmVyRm9jdXNhYmxlRWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZmlyc3RQb3BvdmVyRm9jdXNhYmxlRWwuZm9jdXMoKTtcbiAgICB9XG5cbiAgICAvLyBDYWxsYmFja3NcbiAgICAocGFyYW1zLmNvbXBsZXRlIHx8IG5vb3ApKCk7XG4gICAgKHRoaXMub25PcGVuIHx8IG5vb3ApKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQ2xvc2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgT3B0aW9uYWxcbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cblxuICAgIC8vIE5vdCBvcGVuLCBzbyBkb24ndCBjbG9zZS5cbiAgICBpZiAoIXRoaXMuYWZmaXgpIHJldHVybiB0aGlzO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSB0aW1lciBydW5uaW5nIGZvciB0aGUgY2xvc2UgZXZlbnQsIGNsZWFyIGl0IHNvIHdlIGRvbid0IHJ1biBjbG9zZSBzdHVmZiB0d2ljZS5cbiAgICBpZiAodGhpcy5jbG9zZVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jbG9zZVRpbWVyKTtcbiAgICAgIHRoaXMuY2xvc2VUaW1lciA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU3RvcCBsaXN0ZW5pbmcgdG8gd2luZG93IGNsaWNrcy5cbiAgICB0aGlzLl9yZW1vdmVXaW5kb3dFdmVudExpc3RlbmVycygpO1xuXG4gICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgLy8gVXBkYXRlIGJpbmRpbmdzXG4gICAgdGhpcy5fdXBkYXRlQXR0cmlidXRlcygpO1xuXG4gICAgLy8gQ2xvc2UgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgY29tcGxldGVkXG4gICAgdGhpcy5jbG9zZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczIuX2ZpbmlzaENsb3NlKHBhcmFtcyk7XG4gICAgfSwgMjUwKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUb2dnbGUgdGhlIG9wZW4gc3RhdGUuXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgIHJldHVybiB0aGlzW3RoaXMuaXNBY3RpdmUgPyAnY2xvc2UnIDogJ29wZW4nXSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvbnRlbnQuIE9wdGlvbmFsbHkgYXBwZW5kIGluc3RlYWQgb2YgcmVwbGFjaW5nLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXl8Tm9kZUxpc3R9IGNvbnRlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBPcHRpb25hbFxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiBzZXRDb250ZW50KGNvbnRlbnQsIHBhcmFtcykge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAoMCwgX2FwcGVuZENoaWxkcmVuMi5kZWZhdWx0KSh0aGlzLmNvbnRlbnRFbCwgY29udGVudC5sZW5ndGggPyBjb250ZW50IDogW2NvbnRlbnRdLCAhKHBhcmFtcy5hcHBlbmQgfHwgZmFsc2UpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjb21wb25lbnQgdG8gdXNlIGEgbmV3IGVsZW1lbnQgb3IgcmVwYXJzZSBmcm9tXG4gICAqIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIE9wdGlvbmFsXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGVsKSB7XG5cbiAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuX2NhY2hlRWxlbWVudHMoZWwgfHwgdGhpcy5lbCk7XG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgIGlmICh0aGlzLmFmZml4KSB0aGlzLmFmZml4LnVwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSB0YWJzIGxpc3QsIGVhY2ggdGFiIGFuZCBlYWNoIHBhbmVsLlxuICAgKiBTZXQgd2hpY2ggdGFiIGlzIGFjdGl2ZSwgb3IgdXNlIHRoZSBmaXJzdC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl9jYWNoZUVsZW1lbnRzID0gZnVuY3Rpb24gX2NhY2hlRWxlbWVudHMoZWwpIHtcblxuICAgIC8vIElmIGEgY29udGVudCBlbGVtZW50IHdhcyBhbHJlYWR5IHBhc3NlZCwgbWFrZSBzdXJlIGl0IGhhcyBhIHBvcG92ZXIgY29udGVudCBjbGFzc1xuICAgIGlmICh0aGlzLmNvbnRlbnRFbCkge1xuICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5jb250ZW50RWwsICdzcGFyay1wb3BvdmVyX19jb250ZW50Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMudG9nZ2xlRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1wb3BvdmVyX190b2dnbGUsIFtkYXRhLXJvbGU9XCJ0b2dnbGVcIl0nKSB8fCB0aGlzLmVsO1xuICAgIHRoaXMuY29udGVudEVsID0gdGhpcy5jb250ZW50RWwgfHwgdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuc3BhcmstcG9wb3Zlcl9fY29udGVudCwgW2NsYXNzKj1cInNwYXJrLXBvcG92ZXJfX2NvbnRlbnQtLVwiXScpIHx8IHRoaXMuX2NyZWF0ZUNvbnRlbnRFbCgpO1xuICAgIHRoaXMuY2FyZXRFbCA9IHRoaXMuY29udGVudEVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1wb3BvdmVyX19jYXJldCcpIHx8IHRoaXMuX2NyZWF0ZUNhcmV0RWwoKTtcbiAgICB0aGlzLmlzQWN0aXZlID0gKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkodGhpcy50b2dnbGVFbCwgJ3BvcG92ZXItYWN0aXZlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIGNvbmZpZyB2YWx1ZXMgZnJvbSB0aGUgZWxlbWVudC5cbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fcGFyc2VQYXJhbXMgPSBmdW5jdGlvbiBfcGFyc2VQYXJhbXMoKSB7XG5cbiAgICB0aGlzLmFuY2hvclkgPSB0aGlzLmFuY2hvclkgIT09IG51bGwgPyB0aGlzLmFuY2hvclkgOiAoMCwgX3BhcnNlQXR0cmlidXRlLnN0cmluZykodGhpcy5jb250ZW50RWwsICdkYXRhLWFuY2hvci15JywgbnVsbCk7XG4gICAgdGhpcy5hbmNob3JYID0gdGhpcy5hbmNob3JYICE9PSBudWxsID8gdGhpcy5hbmNob3JYIDogKDAsIF9wYXJzZUF0dHJpYnV0ZS5zdHJpbmcpKHRoaXMuY29udGVudEVsLCAnZGF0YS1hbmNob3IteCcsIG51bGwpO1xuXG4gICAgLy8gTm8gYW5jaG9ycyBkZWZpbmVkXG4gICAgaWYgKCF0aGlzLmFuY2hvclkgJiYgIXRoaXMuYW5jaG9yWCkge1xuXG4gICAgICAvLyBMZWZ0XG4gICAgICBpZiAoKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkodGhpcy5jb250ZW50RWwsICdzcGFyay1wb3BvdmVyX19jb250ZW50LS1sZWZ0JykpIHtcbiAgICAgICAgdGhpcy5hbmNob3JZID0gJ21pZGRsZSc7XG4gICAgICAgIHRoaXMuYW5jaG9yWCA9ICdsZWZ0JztcbiAgICAgIH1cbiAgICAgIC8vIFJpZ2h0XG4gICAgICBlbHNlIGlmICgoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KSh0aGlzLmNvbnRlbnRFbCwgJ3NwYXJrLXBvcG92ZXJfX2NvbnRlbnQtLXJpZ2h0JykpIHtcbiAgICAgICAgICB0aGlzLmFuY2hvclkgPSAnbWlkZGxlJztcbiAgICAgICAgICB0aGlzLmFuY2hvclggPSAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRvcFxuICAgICAgICBlbHNlIGlmICgoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KSh0aGlzLmNvbnRlbnRFbCwgJ3NwYXJrLXBvcG92ZXJfX2NvbnRlbnQtLXRvcCcpKSB7XG4gICAgICAgICAgICB0aGlzLmFuY2hvclkgPSAndG9wJztcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yWCA9ICdjZW50ZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBCb3R0b21cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5hbmNob3JZID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgIHRoaXMuYW5jaG9yWCA9ICdjZW50ZXInO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBidXR0b24gdHJpZ2dlcmluZyB0aGUgcG9wb3ZlciBpcyBmaXhlZC5cbiAgICogSWYgc28sIHRoZW4gcG9wb3ZlciBuZWVkcyB0byBiZSBmaXhlZCBhcyB3ZWxsLlxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl9jaGVja0ZpeGVkUG9zaXRpb24gPSBmdW5jdGlvbiBfY2hlY2tGaXhlZFBvc2l0aW9uKCkge1xuXG4gICAgdmFyIHBhcmVudCA9IHRoaXMuZWw7XG5cbiAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUocGFyZW50KTtcbiAgICAgIGlmIChzdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0ZpeGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmlzRml4ZWQgPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGNsYXNzZXMgZm9yIHRoZSBvcGVuIG9yIGNsb3NlIHN0YXRlLlxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl91cGRhdGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gX3VwZGF0ZUF0dHJpYnV0ZXMoKSB7XG4gICAgKDAsIF90b2dnbGVDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ3BvcG92ZXItYWN0aXZlJywgdGhpcy5pc0FjdGl2ZSk7XG4gICAgKDAsIF90b2dnbGVDbGFzczIuZGVmYXVsdCkodGhpcy5jb250ZW50RWwsICdhY3RpdmUnLCB0aGlzLmlzQWN0aXZlKTtcbiAgICAoMCwgX3RvZ2dsZUNsYXNzMi5kZWZhdWx0KSh0aGlzLnRvZ2dsZUVsLCAnYWN0aXZlJywgdGhpcy5pc0FjdGl2ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBib3VuZCB2ZXJzaW9ucyBvZiBldmVudCBsaXN0ZW5lciBjYWxsYmFja3MgYW5kIHN0b3JlIHRoZW0uXG4gICAqIE90aGVyd2lzZSB3ZSBjYW4ndCB1bmJpbmQgZnJvbSB0aGVzZSBldmVudHMgbGF0ZXIgYmVjYXVzZSB0aGVcbiAgICogZnVuY3Rpb24gc2lnbmF0dXJlcyB3b24ndCBtYXRjaC5cbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fYmluZEV2ZW50TGlzdGVuZXJDYWxsYmFja3MgPSBmdW5jdGlvbiBfYmluZEV2ZW50TGlzdGVuZXJDYWxsYmFja3MoKSB7XG4gICAgdGhpcy5fb25DbGlja0JvdW5kID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQ29udGVudENsaWNrQm91bmQgPSB0aGlzLl9vbkNvbnRlbnRDbGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uV2luZG93Q2xpY2tCb3VuZCA9IHRoaXMuX29uV2luZG93Q2xpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbktleXVwQm91bmQgPSB0aGlzLl9vbktleXVwLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25LZXlkb3duQm91bmQgPSB0aGlzLl9vbktleWRvd24uYmluZCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGV2ZW50IGxpc3RlbmVycyBmb3IgRE9NIGV2ZW50cy5cbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2tCb3VuZCk7XG4gICAgdGhpcy5jb250ZW50RWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNvbnRlbnRDbGlja0JvdW5kKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBmb3IgRE9NIGV2ZW50cy4uXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuX3JlbW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrQm91bmQpO1xuICAgIHRoaXMuY29udGVudEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25Db250ZW50Q2xpY2tCb3VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHdpbmRvdy5cbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fYWRkV2luZG93RXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfYWRkV2luZG93RXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fcmVtb3ZlV2luZG93RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbldpbmRvd0NsaWNrQm91bmQpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuX29uS2V5dXBCb3VuZCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleWRvd25Cb3VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB3aW5kb3cgZXZlbnQgbGlzdGVuZXJzLlxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl9yZW1vdmVXaW5kb3dFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZW1vdmVXaW5kb3dFdmVudExpc3RlbmVycygpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbldpbmRvd0NsaWNrQm91bmQpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuX29uS2V5dXBCb3VuZCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleWRvd25Cb3VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNvbnRlbnQgZWxlbWVudC5cbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fY3JlYXRlQ29udGVudEVsID0gZnVuY3Rpb24gX2NyZWF0ZUNvbnRlbnRFbCgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KShlbCwgJ3NwYXJrLXBvcG92ZXJfX2NvbnRlbnQnKTtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndG9vbHRpcCcpO1xuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBjYXJldCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl9jcmVhdGVDYXJldEVsID0gZnVuY3Rpb24gX2NyZWF0ZUNhcmV0RWwoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuY2xhc3NOYW1lID0gJ3NwYXJrLXBvcG92ZXJfX2NhcmV0JztcbiAgICB0aGlzLmNvbnRlbnRFbC5hcHBlbmRDaGlsZChlbCk7XG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb21wbGV0ZSB0aGUgY2xvc2UgZXZlbnQgYnkgbW92aW5nIHRoZSBlbGVtZW50IGJhY2sgYW5kIGRlc3Ryb3lpbmcgdGhlIGFmZml4LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHBhcmFtc1xuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl9maW5pc2hDbG9zZSA9IGZ1bmN0aW9uIF9maW5pc2hDbG9zZSgpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuXG4gICAgdGhpcy5jbG9zZVRpbWVyID0gbnVsbDtcblxuICAgIC8vIE1vdmUgdGhlIGNvbnRlbnQgYmFjayB0byB0aGUgcGFyZW50XG4gICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbCk7XG5cbiAgICB0aGlzLmFmZml4LnJlbW92ZSh7IGtlZXBFbDogdHJ1ZSB9KTtcbiAgICB0aGlzLmFmZml4ID0gbnVsbDtcblxuICAgIChwYXJhbXMuY29tcGxldGUgfHwgbm9vcCkoKTtcbiAgICAodGhpcy5vbkNsb3NlIHx8IG5vb3ApKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gd2UgYXJlIGNsaWNrZWQsIHRvZ2dsZSB0aGUgcG9wb3Zlci1hY3RpdmUgc3RhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuX29uQ2xpY2sgPSBmdW5jdGlvbiBfb25DbGljayhlKSB7XG5cbiAgICAvLyBJZiB0aGlzIGlzIHRoZSB0b2dnbGUgZWxlbWVudCwgdG9nZ2xlLlxuICAgIGlmIChlLnRhcmdldCA9PT0gdGhpcy50b2dnbGVFbCB8fCAoMCwgX2hhc1BhcmVudDIuZGVmYXVsdCkoZS50YXJnZXQsIHRoaXMudG9nZ2xlRWwpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2hlbiBhIGtleSBpcyBwcmVzc2VkIG9uIHRoZSB3aW5kb3cgYW5kIGl0J3MgYW4gRVNDLCBjbG9zZSB0aGUgcG9wb3Zlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fb25LZXl1cCA9IGZ1bmN0aW9uIF9vbktleXVwKGUpIHtcbiAgICBpZiAoZS5rZXlDb2RlID09PSAyNykge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuXG4gICAgICAvLyBTZXQgZm9jdXMgYmFjayB0byB0b2dnbGVcbiAgICAgIHRoaXMudG9nZ2xlRWwuZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gYSBrZXkgaXMgcHJlc3NlZCBpbiBhbiBhY3RpdmUgUG9wb3ZlciBhbmQgaXQgaXMgYSBUYWIga2V5LCBvciBTaGlmdCtUYWIsIG5hdmlnYXRlIHRoZSBwb3BvdmVyXG4gICAqIElmIGl0IHRoZSBFbnRlciBrZXksIGFuZCBmb2N1cyBpcyBvbiB0aGUgY2xvc2UgYnV0dG9uLCBjbG9zZSB0aGUgUG9wb3ZlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl9vbktleWRvd24gPSBmdW5jdGlvbiBfb25LZXlkb3duKGUpIHtcbiAgICBpZiAoZS5rZXlDb2RlID09PSA5KSB7XG4gICAgICBpZiAodGhpcy5wb3BvdmVyRm9jdXNhYmxlRWxzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgIHRoaXMuX29uQmFja3dhcmRUYWIoZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vbkZvcndhcmRUYWIoZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW50ZXIgS2V5XG4gICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGlmIChlLnRhcmdldCA9PT0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNwYXJrLXBvcG92ZXJfX2Nsb3NlJykgfHwgKDAsIF9nZXRQYXJlbnQyLmRlZmF1bHQpKGUudGFyZ2V0LCAnLnNwYXJrLXBvcG92ZXJfX2Nsb3NlJywgdGhpcy5jb250ZW50RWwpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuXG4gICAgICAgIC8vIFNldCBmb2N1cyBiYWNrIHRvIHRvZ2dsZVxuICAgICAgICB0aGlzLnRvZ2dsZUVsLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRhYmJpbmcgYmFja3dhcmRzLCBsb2NhbGl6ZSB0cmF2ZXJzYWwgdG8gUG9wb3ZlciBlbGVtZW50cyBvbmx5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuX29uQmFja3dhcmRUYWIgPSBmdW5jdGlvbiBfb25CYWNrd2FyZFRhYihlKSB7XG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuZmlyc3RQb3BvdmVyRm9jdXNhYmxlRWwpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMubGFzdFBvcG92ZXJGb2N1c2FibGVFbC5mb2N1cygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0YWJiaW5nIGZvcndhcmRzLCBsb2NhbGl6ZSB0cmF2ZXJzYWwgdG8gUG9wb3ZlciBlbGVtZW50cyBvbmx5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuX29uRm9yd2FyZFRhYiA9IGZ1bmN0aW9uIF9vbkZvcndhcmRUYWIoZSkge1xuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLmxhc3RQb3BvdmVyRm9jdXNhYmxlRWwpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuZmlyc3RQb3BvdmVyRm9jdXNhYmxlRWwuZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHRvZ2dsZSBpcyBjbGlja2VkLCBjbG9zZSBpZiBpdCdzIGEgbGluay4gSWYgaXQncyBjb250ZW50LCBkb24ndCBkbyBhbnl0aGluZyBidXQgc3RvcFxuICAgKiB0aGUgZXZlbnQgZnJvbSBidWJibGluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fb25Db250ZW50Q2xpY2sgPSBmdW5jdGlvbiBfb25Db250ZW50Q2xpY2soZSkge1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhIGxpbmssIGNsb3NlLlxuICAgIGlmICgoMCwgX2dldFBhcmVudDIuZGVmYXVsdCkoZS50YXJnZXQsICcuc3BhcmstcG9wb3Zlcl9fbGlzdC1saW5rJywgdGhpcy5jb250ZW50RWwpIHx8ICgwLCBfZ2V0UGFyZW50Mi5kZWZhdWx0KShlLnRhcmdldCwgJy5zcGFyay1wb3BvdmVyX19jbG9zZScsIHRoaXMuY29udGVudEVsKSkge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgd2luZG93IGlzIGNsaWNrZWQgYW5kIGl0J3Mgbm90IHBhcnQgb2YgdGhlIHBvcG92ZXIsIGNsb3NlIHRoZSBwb3BvdmVyLlxuICAgKiBAcGFyYW0ge09iamVjfSBlXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuX29uV2luZG93Q2xpY2sgPSBmdW5jdGlvbiBfb25XaW5kb3dDbGljayhlKSB7XG4gICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzLmVsICYmIGUudGFyZ2V0ICE9PSB0aGlzLmNvbnRlbnRFbCAmJiAhKDAsIF9oYXNQYXJlbnQyLmRlZmF1bHQpKGUudGFyZ2V0LCB0aGlzLmVsKSAmJiAhKDAsIF9oYXNQYXJlbnQyLmRlZmF1bHQpKGUudGFyZ2V0LCB0aGlzLmNvbnRlbnRFbCkpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFBvcG92ZXI7XG59KF9iYXNlMi5kZWZhdWx0KTtcblxuLyoqXG4gKiBXaGl0ZWxpc3RlZCBwYXJhbWV0ZXJzIHdoaWNoIGNhbiBiZSBzZXQgb24gY29uc3RydWN0aW9uLlxuICogQHR5cGUge0FycmF5fVxuICovXG5cblxuUG9wb3Zlci5wcm90b3R5cGUuX3doaXRlbGlzdGVkUGFyYW1zID0gWydhbmNob3JYJywgJ2FuY2hvclknLCAndG9nZ2xlRWwnLCAnY29udGVudEVsJywgJ29uT3BlbicsICdvbkNsb3NlJ107XG5cbi8qKlxuICogRGVmYXVsdCB2YWx1ZXMgZm9yIGludGVybmFsIHByb3BlcnRpZXMgd2Ugd2lsbCBiZSBzZXR0aW5nLlxuICogVGhlc2UgYXJlIHNldCBvbiBlYWNoIGNvbnN0cnVjdGlvbiBzbyB3ZSBkb24ndCBsZWFrIHByb3BlcnRpZXNcbiAqIGludG8gdGhlIHByb3RvdHlwZSBjaGFpbi5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblBvcG92ZXIucHJvdG90eXBlLmRlZmF1bHRzID0ge1xuICBlbDogbnVsbCxcbiAgdG9nZ2xlRWw6IG51bGwsXG4gIGNvbnRlbnRFbDogbnVsbCxcbiAgY2FyZXRFbDogbnVsbCxcbiAgYWZmaXg6IG51bGwsXG4gIGlzQWN0aXZlOiBmYWxzZSxcbiAgaXNQYXVzZWQ6IGZhbHNlLFxuICBpc0ZpeGVkOiBmYWxzZSxcbiAgYW5jaG9yWDogbnVsbCxcbiAgYW5jaG9yWTogbnVsbCxcbiAgY2xvc2VUaW1lcjogbnVsbCxcbiAgb25PcGVuOiBudWxsLFxuICBvbkNsb3NlOiBudWxsLFxuICBfb25DbGlja0JvdW5kOiBudWxsLFxuICBfb25LZXl1cEJvdW5kOiBudWxsLFxuICBfb25LZXlkb3duQm91bmQ6IG51bGwsXG4gIF9vbkNvbnRlbnRDbGlja0JvdW5kOiBudWxsLFxuICBfb25XaW5kb3dDbGlja0JvdW5kOiBudWxsLFxuICBfb25XaW5kb3dSZXNpemVCb3VuZDogbnVsbCxcbiAgX29uV2luZG93U2Nyb2xsQm91bmQ6IG51bGxcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFBvcG92ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcG92ZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBSZXF1ZXN0IEFuaW1hdGlvblxuICogUmVxdWVzdCBhbmltYXRpb24gZnJhbWUgcG9seWZpbGwuXG4gKiBAbW9kdWxlIGhlbHBlcnMvYW5pbWF0aW9uL3JlcXVlc3QuanNcbiAqL1xudmFyIHJlcXVlc3QgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24gKCkge1xuXG4gIHZhciBmcHMgPSA2MDtcbiAgdmFyIGRlbCA9IDEwMDAgLyBmcHM7XG4gIHZhciBzdGFydCA9IERhdGUubm93KCk7XG4gIHZhciBwcmV2ID0gc3RhcnQ7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xuXG4gICAgdmFyIHJlcXVlc3RUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgdGltZW91dCA9IE1hdGgubWF4KDAsIGRlbCAtIChyZXF1ZXN0VGltZSAtIHByZXYpKTtcbiAgICB2YXIgdGltZVRvQ2FsbCA9IHJlcXVlc3RUaW1lICsgdGltZW91dDtcblxuICAgIHByZXYgPSB0aW1lVG9DYWxsO1xuXG4gICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uIG9uQW5pbWF0aW9uRnJhbWUoKSB7XG4gICAgICBjYWxsYmFjayh0aW1lVG9DYWxsIC0gc3RhcnQpO1xuICAgIH0sIHRpbWVvdXQpO1xuICB9O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSByZXF1ZXN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVlc3QuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfb2Zmc2V0ID0gcmVxdWlyZSgnLi4vZG9tL29mZnNldCcpO1xuXG52YXIgX29mZnNldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vZmZzZXQpO1xuXG52YXIgX3R3ZWVuID0gcmVxdWlyZSgnLi90d2VlbicpO1xuXG52YXIgX3R3ZWVuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R3ZWVuKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiAjIFNjcm9sbCBUb1xuICogU2Nyb2xsIHRoZSB3aW5kb3cgdG8gYSBzcGVjaWZpYyBlbGVtZW50IG9yIHBvc2l0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICpcbiAqIEBtb2R1bGUgaGVscGVycy9hbmltYXRpb24vc2Nyb2xsLXRvLmpzXG4gKi9cblxuZnVuY3Rpb24gc2Nyb2xsVG8ocGFyYW1zKSB7XG5cbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gIHZhciBvZmZzZXQgPSB2b2lkIDA7XG4gIHZhciB4ID0gdm9pZCAwO1xuICB2YXIgeSA9IHZvaWQgMDtcbiAgdmFyIHRhcmdldCA9IHBhcmFtcy50YXJnZXQgfHwgd2luZG93O1xuICB2YXIgc3RhcnRYID0gdGFyZ2V0ICE9PSB3aW5kb3cgPyB0YXJnZXQuc2Nyb2xsTGVmdCA6IHRhcmdldC5wYWdlWE9mZnNldDtcbiAgdmFyIHN0YXJ0WSA9IHRhcmdldCAhPT0gd2luZG93ID8gdGFyZ2V0LnNjcm9sbFRvcCA6IHRhcmdldC5wYWdlWU9mZnNldDtcblxuICBpZiAocGFyYW1zIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICBvZmZzZXQgPSAoMCwgX29mZnNldDIuZGVmYXVsdCkocGFyYW1zKTtcbiAgICB4ID0gb2Zmc2V0LmxlZnQ7XG4gICAgeSA9IG9mZnNldC50b3A7XG4gICAgcGFyYW1zID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuICB9IGVsc2Uge1xuICAgIHggPSBwYXJhbXMueCB8fCAwO1xuICAgIHkgPSBwYXJhbXMueSB8fCAwO1xuICB9XG5cbiAgKDAsIF90d2VlbjIuZGVmYXVsdCkoe1xuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIHByb3A6ICdzY3JvbGxUbycsXG4gICAgc3RhcnQ6IFtzdGFydFgsIHN0YXJ0WV0sXG4gICAgZW5kOiBbeCwgeV0sXG4gICAgZHVyYXRpb246IHBhcmFtcy5kdXJhdGlvbixcbiAgICBjYWxsYmFjazogcGFyYW1zLmNhbGxiYWNrXG4gIH0pO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBzY3JvbGxUbztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Nyb2xsLXRvLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlcXVlc3QgPSByZXF1aXJlKCcuL3JlcXVlc3QnKTtcblxudmFyIF9yZXF1ZXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlcXVlc3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxuLyoqXG4gKiBUd2VlbiBmcm9tIG9uZSB2YWx1ZSB0byBhbm90aGVyLlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICogQHJldHVybiB7TG9uZ31cbiAqL1xuLyoqXG4gKiAjIFR3ZWVuXG4gKiBUd2VlbiBiZXR3ZWVuIHR3byB2YWx1ZXMuXG4gKiBAbW9kdWxlIGhlbHBlcnMvYW5pbWF0aW9uL3R3ZWVuLmpzXG4gKi9cblxuZnVuY3Rpb24gdHdlZW4ocGFyYW1zKSB7XG5cbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gIHZhciBiZWdpbjtcbiAgdmFyIG9iaiA9IHBhcmFtcy50YXJnZXQ7XG5cbiAgaWYgKCFvYmopIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB0d2VlbiB3aXRob3V0IGEgdGFyZ2V0IScpO1xuICB9XG5cbiAgdmFyIHByb3AgPSB0eXBlb2YgcGFyYW1zLnByb3AgPT09ICdzdHJpbmcnID8gW3BhcmFtcy5wcm9wXSA6IHBhcmFtcy5wcm9wO1xuICB2YXIgc3RhcnQgPSB0eXBlb2YgcGFyYW1zLnN0YXJ0ID09PSAnbnVtYmVyJyA/IFtwYXJhbXMuc3RhcnRdIDogcGFyYW1zLnN0YXJ0O1xuICB2YXIgZW5kID0gdHlwZW9mIHBhcmFtcy5lbmQgPT09ICdudW1iZXInID8gW3BhcmFtcy5lbmRdIDogcGFyYW1zLmVuZDtcbiAgdmFyIGR1cmF0aW9uID0gcGFyYW1zLmR1cmF0aW9uIHx8IDI1MDtcbiAgdmFyIGNhbGxiYWNrID0gcGFyYW1zLmNhbGxiYWNrIHx8IG5vb3A7XG5cbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHN0YXJ0IGFuZCBlbmQgcHJvcGVydGllcy5cbiAgaWYgKHN0YXJ0Lmxlbmd0aCAhPT0gZW5kLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHR3ZWVuIHR3byBkaWZmZXJlbnQgc2V0cyBvZiBwYXJhbWV0ZXJzIScpO1xuICB9XG5cbiAgdmFyIGYgPSBmdW5jdGlvbiBmKHRzKSB7XG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIHdoZW4gd2Ugc3RhcnRcbiAgICBpZiAoIWJlZ2luKSBiZWdpbiA9IHRzO1xuXG4gICAgLy8gUHJvZ3Jlc3NcbiAgICB2YXIgcHJvZyA9IHRzIC0gYmVnaW47XG5cbiAgICAvLyBQZXJjZW50YWdlIGNvbXBsZXRlXG4gICAgdmFyIHBlciA9IE1hdGgubWluKHByb2cgLyBkdXJhdGlvbiwgMSk7XG5cbiAgICAvLyBBZGp1c3QgdGhlIHZhbHVlcyBmb3IgdGhlIHBlcmNlbnRhZ2UgY29tcGxldGUuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHN0YXJ0Lmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gc3RhcnRbaV0gKyAoZW5kW2ldIC0gc3RhcnRbaV0pICogcGVyO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IHRoZSB2YWx1ZXMgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAgaSA9IDA7XG4gICAgbGVuID0gcHJvcC5sZW5ndGg7XG4gICAgdmFyIGFyZztcbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGxhc3QgcHJvcGVydHkgYnV0IHdlIGhhdmUgbW9yZSBhcmd1bWVudHMsIHNldCB0aGVtIGFsbC5cbiAgICAgIGFyZyA9IGkgKyAxID09PSBsZW4gJiYgYXJncy5sZW5ndGggLSAxID4gaSA/IGFyZ3Muc2xpY2UoaSkgOiBhcmdzW2ldO1xuXG4gICAgICBpZiAodHlwZW9mIG9ialtwcm9wW2ldXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYmpbcHJvcFtpXV0uYXBwbHkob2JqLCBhcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW3Byb3BbaV1dID0gYXJnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEtlZXAgZ29pbmcgaWYgd2UgaGF2ZSBtb3JlIHRvIGRvLlxuICAgIGlmIChwcm9nIDwgZHVyYXRpb24pICgwLCBfcmVxdWVzdDIuZGVmYXVsdCkoZik7ZWxzZSBjYWxsYmFjaygpO1xuICB9O1xuXG4gIHJldHVybiAoMCwgX3JlcXVlc3QyLmRlZmF1bHQpKGYpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0d2Vlbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHdlZW4uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgRGF0ZSBoZWxwZXJcbiAqIEdlbmVyYWwgaGVscGVycyBmb3Igd29ya2luZyB3aXRoIGRhdGVzLlxuICpcbiAqIEBtb2R1bGUgaGVscGVycy9kYXRlL2RhdGUuanNcbiAqL1xuXG52YXIgbW9udGhOYW1lcyA9IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddO1xudmFyIG1vbnRoTmFtZXNTaG9ydCA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVnJywgJ1NlcHQnLCAnT2N0JywgJ05vdicsICdEZWMnXTtcbnZhciBkYXlOYW1lcyA9IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXTtcbnZhciBkYXlOYW1lc1Nob3J0ID0gWydTdW4nLCAnTW9uJywgJ1R1ZXMnLCAnV2VkJywgJ1RodXInLCAnRnJpJywgJ1NhdCddO1xudmFyIGFkanVzdGVkRGF5TmFtZXMgPSBbXTtcbnZhciBhZGp1c3RlZERheU5hbWVzU2hvcnQgPSBbXTtcbnZhciB3ZWVrU3RhcnRzT24gPSAwO1xuXG52YXIgZGF0ZUhlbHBlciA9IHtcblxuICAvKipcbiAgICogVHJhbnNmb3JtIGEgZGF0ZSBpbnRvIGFuIG9iamVjdCBvZiBkYXRlIHZhbHVlcy5cbiAgICogQHBhcmFtIHtEYXRlfSBkYXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKGRhdGUpIHtcblxuICAgIGRhdGUgPSBkYXRlIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGUgOiBuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGggLSAxLCBkYXRlLmRheSk7XG5cbiAgICB2YXIgaW5zdCA9IE9iamVjdC5jcmVhdGUoZGF0ZUhlbHBlcik7XG4gICAgaW5zdC5fZGF0ZSA9IGRhdGU7XG4gICAgaW5zdC5fY2FjaGUgPSB7fTtcblxuICAgIHJldHVybiBpbnN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSB5ZWFyLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgeWVhcigpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCd5ZWFyJyk7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGUuZ2V0RnVsbFllYXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0IGEgeWVhci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICovXG4gIHNldCB5ZWFyKHkpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCd5ZWFyJyk7XG4gICAgdGhpcy5fY2xlYXJDYWNoZSgpO1xuICAgIHJldHVybiB0aGlzLl9kYXRlLnNldEZ1bGxZZWFyKHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSBtb250aC5cbiAgICogQHJldHVybiB7TnVtYmVyfSAxLTEyXG4gICAqL1xuICBnZXQgbW9udGgoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnbW9udGgnKTtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZS5nZXRNb250aCgpICsgMTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0IGEgbW9udGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtIDEtMTJcbiAgICovXG4gIHNldCBtb250aChtKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnbW9udGgnKTtcbiAgICB0aGlzLl9jbGVhckNhY2hlKCk7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGUuc2V0TW9udGgobSAtIDEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSBkYXkuXG4gICAqIEByZXR1cm4ge051bWJlcn0gMS0zMVxuICAgKi9cbiAgZ2V0IGRheSgpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCdkYXknKTtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZS5nZXREYXRlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCBhIGRheS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGQgMS0zMVxuICAgKi9cbiAgc2V0IGRheShkKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnZGF5Jyk7XG4gICAgdGhpcy5fY2xlYXJDYWNoZSgpO1xuICAgIHJldHVybiB0aGlzLl9kYXRlLnNldERhdGUoZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRheSwgbW9udGggYW5kIHllYXIgdmFsdWVzIGF0IG9uY2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICovXG4gIHNldDogZnVuY3Rpb24gc2V0KHBhcmFtcykge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICB0aGlzLnllYXIgPSBwYXJhbXMueWVhciB8fCB0aGlzLnllYXI7XG4gICAgdGhpcy5tb250aCA9IHBhcmFtcy5tb250aCB8fCB0aGlzLm1vbnRoO1xuICAgIHRoaXMuZGF5ID0gcGFyYW1zLmRheSB8fCB0aGlzLmRheTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBmdWxsIG5hbWUgb2YgdGhlIG1vbnRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldE1vbnRoTmFtZTogZnVuY3Rpb24gZ2V0TW9udGhOYW1lKG51bSkge1xuICAgIHJldHVybiBtb250aE5hbWVzW251bSAtIDFdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vbnRoIG5hbWUuXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldCBtb250aE5hbWUoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnbW9udGhOYW1lJyk7XG4gICAgcmV0dXJuIGRhdGVIZWxwZXIuZ2V0TW9udGhOYW1lKHRoaXMubW9udGgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2YgbW9udGggbmFtZXMuXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZ2V0TW9udGhOYW1lczogZnVuY3Rpb24gZ2V0TW9udGhOYW1lcygpIHtcbiAgICByZXR1cm4gbW9udGhOYW1lcztcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBzaG9ydCBuYW1lIG9mIHRoZSBtb250aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG51bVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXRNb250aE5hbWVTaG9ydDogZnVuY3Rpb24gZ2V0TW9udGhOYW1lU2hvcnQobnVtKSB7XG4gICAgcmV0dXJuIG1vbnRoTmFtZXNTaG9ydFtudW0gLSAxXTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBtb250aCBuYW1lLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgbW9udGhOYW1lU2hvcnQoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnbW9udGhOYW1lJyk7XG4gICAgcmV0dXJuIGRhdGVIZWxwZXIuZ2V0TW9udGhOYW1lU2hvcnQodGhpcy5tb250aCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGlzdCBvZiBzaG9ydCBtb250aCBuYW1lcy5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBnZXRNb250aE5hbWVzU2hvcnQ6IGZ1bmN0aW9uIGdldE1vbnRoTmFtZXNTaG9ydCgpIHtcbiAgICByZXR1cm4gbW9udGhOYW1lc1Nob3J0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG1vbnRoIG5hbWVzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBuYW1lc1xuICAgKi9cbiAgc2V0TW9udGhOYW1lczogZnVuY3Rpb24gc2V0TW9udGhOYW1lcyhuYW1lcykge1xuICAgIGlmIChuYW1lcy5sZW5ndGggPT09IDEyKSBtb250aE5hbWVzID0gbmFtZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc2hvcnQgbW9udGggbmFtZXMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IG5hbWVzXG4gICAqL1xuICBzZXRNb250aE5hbWVzU2hvcnQ6IGZ1bmN0aW9uIHNldE1vbnRoTmFtZXNTaG9ydChuYW1lcykge1xuICAgIGlmIChuYW1lcy5sZW5ndGggPT09IDEyKSBtb250aE5hbWVzU2hvcnQgPSBuYW1lcztcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBkYXkgb2YgdGhlIHdlZWsgZm9yIGEgZ2l2ZW4gZGF5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IDEtN1xuICAgKi9cbiAgZ2V0RGF5T2ZXZWVrOiBmdW5jdGlvbiBnZXREYXlPZldlZWsoZGF0ZSkge1xuICAgIHZhciBkYXkgPSAoZGF0ZSBpbnN0YW5jZW9mIERhdGUgPyBkYXRlIDogbmV3IERhdGUoZGF0ZS55ZWFyLCBkYXRlLm1vbnRoIC0gMSwgZGF0ZS5kYXkpKS5nZXREYXkoKSAtIHdlZWtTdGFydHNPbjtcbiAgICByZXR1cm4gKGRheSA8IDAgPyA3IC0gTWF0aC5hYnMoZGF5KSA6IGRheSkgKyAxO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheSBvZiB0aGUgd2Vlay5cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheU9mV2VlaygpIHtcbiAgICByZXR1cm4gZGF0ZUhlbHBlci5nZXREYXlPZldlZWsodGhpcy5fZGF0ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZnVsbCBuYW1lIG9mIGEgZGF5IG9mIHRoZSB3ZWVrLlxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldERheU5hbWU6IGZ1bmN0aW9uIGdldERheU5hbWUobnVtKSB7XG4gICAgcmV0dXJuIGRheU5hbWVzW251bSAtIDEgKyB3ZWVrU3RhcnRzT25dIHx8IGRheU5hbWVzW2RheU5hbWVzLmxlbmd0aCAtIG51bSAtIDEgKyB3ZWVrU3RhcnRzT25dO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheSBuYW1lLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgZGF5TmFtZSgpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCdkYXlOYW1lJyk7XG4gICAgcmV0dXJuIGRhdGVIZWxwZXIuZ2V0RGF5TmFtZSh0aGlzLmRheU9mV2Vlayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZnVsbCBuYW1lIG9mIHRoZSBkYXlzIG9mIHRoZSB3ZWVrLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGdldERheU5hbWVzOiBmdW5jdGlvbiBnZXREYXlOYW1lcygpIHtcbiAgICByZXR1cm4gYWRqdXN0ZWREYXlOYW1lcy5sZW5ndGggPyBhZGp1c3RlZERheU5hbWVzIDogZGF5TmFtZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2hvcnQgbmFtZSBvZiB0aGUgZGF5LlxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldERheU5hbWVTaG9ydDogZnVuY3Rpb24gZ2V0RGF5TmFtZVNob3J0KG51bSkge1xuICAgIHJldHVybiBkYXlOYW1lc1Nob3J0W251bSAtIDEgKyB3ZWVrU3RhcnRzT25dIHx8IGRheU5hbWVzW2RheU5hbWVzLmxlbmd0aCAtIG51bSAtIDEgKyB3ZWVrU3RhcnRzT25dO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNob3J0IGRheSBuYW1lLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgZGF5TmFtZVNob3J0KCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ2hlY2soJ2RheU5hbWVTaG9ydCcpO1xuICAgIHJldHVybiBkYXRlSGVscGVyLmdldERheU5hbWVTaG9ydCh0aGlzLmRheU9mV2Vlayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZnVsbCBuYW1lIG9mIHRoZSBkYXlzIG9mIHRoZSB3ZWVrLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGdldERheU5hbWVzU2hvcnQ6IGZ1bmN0aW9uIGdldERheU5hbWVzU2hvcnQoKSB7XG4gICAgcmV0dXJuIGFkanVzdGVkRGF5TmFtZXNTaG9ydC5sZW5ndGggPyBhZGp1c3RlZERheU5hbWVzU2hvcnQgOiBkYXlOYW1lc1Nob3J0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRheSBuYW1lcy5cbiAgICogQHBhcmFtIHtBcnJheX0gbmFtZXNcbiAgICovXG4gIHNldERheU5hbWVzOiBmdW5jdGlvbiBzZXREYXlOYW1lcyhuYW1lcykge1xuICAgIGlmIChuYW1lcy5sZW5ndGggPT09IDcpIGRheU5hbWVzID0gbmFtZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc2hvcnQgZGF5IG5hbWVzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBuYW1lc1xuICAgKi9cbiAgc2V0RGF5TmFtZXNTaG9ydDogZnVuY3Rpb24gc2V0RGF5TmFtZXNTaG9ydChuYW1lcykge1xuICAgIGlmIChuYW1lcy5sZW5ndGggPT09IDcpIGRheU5hbWVzU2hvcnQgPSBuYW1lcztcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRXZWVrU3RhcnRzT246IGZ1bmN0aW9uIGdldFdlZWtTdGFydHNPbigpIHtcbiAgICByZXR1cm4gd2Vla1N0YXJ0c09uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBzZXRXZWVrU3RhcnRzT246IGZ1bmN0aW9uIHNldFdlZWtTdGFydHNPbihudW1iZXIpIHtcblxuICAgIHdlZWtTdGFydHNPbiA9IG51bWJlcjtcblxuICAgIGlmIChudW1iZXIpIHtcbiAgICAgIGFkanVzdGVkRGF5TmFtZXMgPSBkYXlOYW1lcy5zbGljZSh3ZWVrU3RhcnRzT24pO1xuICAgICAgYWRqdXN0ZWREYXlOYW1lcyA9IGFkanVzdGVkRGF5TmFtZXMuY29uY2F0KGRheU5hbWVzLnNsaWNlKDAsIHdlZWtTdGFydHNPbikpO1xuICAgICAgYWRqdXN0ZWREYXlOYW1lc1Nob3J0ID0gZGF5TmFtZXNTaG9ydC5zbGljZSh3ZWVrU3RhcnRzT24pO1xuICAgICAgYWRqdXN0ZWREYXlOYW1lc1Nob3J0ID0gYWRqdXN0ZWREYXlOYW1lc1Nob3J0LmNvbmNhdChkYXlOYW1lc1Nob3J0LnNsaWNlKDAsIHdlZWtTdGFydHNPbikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGp1c3RlZERheU5hbWVzID0gW107XG4gICAgICBhZGp1c3RlZERheU5hbWVzU2hvcnQgPSBbXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBkYXRlLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBub3c6IGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gZGF0ZUhlbHBlci5jcmVhdGUobmV3IERhdGUoKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV4dCB5ZWFyIGFmdGVyIHRoZSBnaXZlbiBkYXRlLlxuICAgKiBUaGlzIG9idmlvdXNseSBpc24ndCB2ZXJ5IGNvbXBsaWNhdGVkLCBidXQgaXQgZXhpc3RzXG4gICAqIGZvciBwYXJpdHkgd2l0aCBob3cgd2UgZ2V0IHRoZSB3ZWVrLCBkYXkgYW5kIG1vbnRoLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXROZXh0WWVhcjogZnVuY3Rpb24gZ2V0TmV4dFllYXIoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLnllYXIgKyAxLCBkYXRlLm1vbnRoIC0gMSwgZGF0ZS5kYXkpKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSB5ZWFyIGZvbGxvd2luZyB0aGlzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXQgbmV4dFllYXIoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnbmV4dFllYXInKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUubmV4dFllYXIgfHwgKHRoaXMuX2NhY2hlLm5leHRZZWFyID0gZGF0ZUhlbHBlci5nZXROZXh0WWVhcih0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrIGZvciBhIGdpdmVuIGRhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldFdlZWtTdGFydDogZnVuY3Rpb24gZ2V0V2Vla1N0YXJ0KGRhdGUpIHtcbiAgICB2YXIgaW5zdCA9IGRhdGVIZWxwZXIuY3JlYXRlKG5ldyBEYXRlKGRhdGUueWVhciwgZGF0ZS5tb250aCAtIDEsIGRhdGUuZGF5IC0gZGF0ZUhlbHBlci5nZXREYXlPZldlZWsoZGF0ZSkgKyAxKSk7XG4gICAgaW5zdC53ZWVrU3RhcnRzT24gPSB3ZWVrU3RhcnRzT247XG4gICAgcmV0dXJuIGluc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhcnQgb2YgdGhlIHdlZWsgZm9yIHRoaXMgZGF0ZS5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0IHdlZWtTdGFydCgpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCd3ZWVrU3RhcnQnKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUud2Vla1N0YXJ0ICYmIHRoaXMuX2NhY2hlLndlZWtTdGFydC53ZWVrU3RhcnRzT24gPT09IHdlZWtTdGFydHNPbiA/IHRoaXMuX2NhY2hlLndlZWtTdGFydCA6IHRoaXMuX2NhY2hlLndlZWtTdGFydCA9IGRhdGVIZWxwZXIuZ2V0V2Vla1N0YXJ0KHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpcnN0IGRheSBvZiB0aGUgbW9udGggZm9yIGEgZ2l2ZW4gZGF0ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0TW9udGhTdGFydDogZnVuY3Rpb24gZ2V0TW9udGhTdGFydChkYXRlKSB7XG4gICAgdmFyIGluc3QgPSBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGggLSAxLCAxKSk7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhcnQgb2YgdGhlIG1vbnRoIGZvciB0aGlzIGRhdGUuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldCBtb250aFN0YXJ0KCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ2hlY2soJ21vbnRoU3RhcnQnKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUubW9udGhTdGFydCB8fCAodGhpcy5fY2FjaGUubW9udGhTdGFydCA9IGRhdGVIZWxwZXIuZ2V0TW9udGhTdGFydCh0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV4dCB3ZWVrIGFmdGVyIHRoZSBnaXZlbiBkYXRlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXROZXh0V2VlazogZnVuY3Rpb24gZ2V0TmV4dFdlZWsoZGF0ZSkge1xuICAgIHZhciBzdGFydCA9IGRhdGVIZWxwZXIuZ2V0V2Vla1N0YXJ0KGRhdGUpO1xuICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShzdGFydC55ZWFyLCBzdGFydC5tb250aCAtIDEsIHN0YXJ0LmRheSArIDcpKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrIGZvbGxvd2luZyB0aGlzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXQgbmV4dFdlZWsoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnbmV4dFdlZWsnKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUubmV4dFdlZWsgfHwgKHRoaXMuX2NhY2hlLm5leHRXZWVrID0gZGF0ZUhlbHBlci5nZXROZXh0V2Vlayh0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV4dCBkYXkgYWZ0ZXIgdGhlIGdpdmVuIGRhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldE5leHREYXk6IGZ1bmN0aW9uIGdldE5leHREYXkoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGggLSAxLCBkYXRlLmRheSArIDEpKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBkYXkgZm9sbG93aW5nIHRoaXMuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldCBuZXh0RGF5KCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ2hlY2soJ25leHREYXknKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUubmV4dERheSB8fCAodGhpcy5fY2FjaGUubmV4dERheSA9IGRhdGVIZWxwZXIuZ2V0TmV4dERheSh0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV4dCBtb250aCBhZnRlciB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0TmV4dE1vbnRoOiBmdW5jdGlvbiBnZXROZXh0TW9udGgoZGF0ZSkge1xuICAgIC8vIERhdGUoKSBoYXMgYSAqYnVnL2ZlYXR1cmUqIGlmIGxhc3QgZGF5IG9mIG1vbnRoIGlzIDMxIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG5leHQgbW9udGguXG4gICAgLy8gTmVlZCB0byBhY2NvdW50IGZvciB0aGF0IHNvIHRoYXQgaXQgZG9lc24ndCByb3VuZCB1cCB0aGUgZGF0ZS9tb250aC5cblxuICAgIGlmIChkYXRlLmRheSA9PT0gMzEgJiYgZGF0ZS5tb250aCAhPT0gMSAmJiBkYXRlLm1vbnRoICE9PSA3ICYmIGRhdGUubW9udGggIT09IDEyKSB7XG4gICAgICAvLyBBZGp1c3QgZm9yIG1vbnRocyBlbmRpbmcgaW4gMzEgZm9sbG93ZWQgYnkgbW9udGhzIGVuZGluZyBpbiAzMFxuICAgICAgcmV0dXJuIGRhdGVIZWxwZXIuY3JlYXRlKG5ldyBEYXRlKGRhdGUueWVhciwgZGF0ZS5tb250aCwgZGF0ZS5kYXkgLSAxKSk7XG4gICAgfSBlbHNlIGlmIChkYXRlLmRheSA+IDI4ICYmIGRhdGUubW9udGggPT09IDEpIHtcbiAgICAgIC8vIGZpeCBmb3IgbGFzdCBkYXkgb2YgRmVicnVhcnlcbiAgICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGggKyAxLCAwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGgsIGRhdGUuZGF5KSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vbnRoIGZvbGxvd2luZyB0aGlzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXQgbmV4dE1vbnRoKCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ2hlY2soJ25leHRNb250aCcpO1xuICAgIHJldHVybiB0aGlzLl9jYWNoZS5uZXh0TW9udGggfHwgKHRoaXMuX2NhY2hlLm5leHRNb250aCA9IGRhdGVIZWxwZXIuZ2V0TmV4dE1vbnRoKHRoaXMpKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBwcmV2aW91cyB5ZWFyIGFmdGVyIHRoZSBnaXZlbiBkYXRlLlxuICAgKiBUaGlzIG9idmlvdXNseSBpc24ndCB2ZXJ5IGNvbXBsaWNhdGVkLCBidXQgaXQgZXhpc3RzXG4gICAqIGZvciBwYXJpdHkgd2l0aCBob3cgd2UgZ2V0IHRoZSB3ZWVrLCBkYXkgYW5kIG1vbnRoLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRQcmV2aW91c1llYXI6IGZ1bmN0aW9uIGdldFByZXZpb3VzWWVhcihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGVIZWxwZXIuY3JlYXRlKG5ldyBEYXRlKGRhdGUueWVhciAtIDEsIGRhdGUubW9udGggLSAxLCBkYXRlLmRheSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHllYXIgcHJlY2VkaW5nIHRoaXMuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldCBwcmV2aW91c1llYXIoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygncHJldmlvdXNZZWFyJyk7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlLnByZXZpb3VzWWVhciB8fCAodGhpcy5fY2FjaGUucHJldmlvdXNZZWFyID0gZGF0ZUhlbHBlci5nZXRQcmV2aW91c1llYXIodGhpcykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByZXZpb3VzIHdlZWsgYWZ0ZXIgdGhlIGdpdmVuIGRhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldFByZXZpb3VzV2VlazogZnVuY3Rpb24gZ2V0UHJldmlvdXNXZWVrKGRhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBkYXRlSGVscGVyLmdldFdlZWtTdGFydChkYXRlKTtcbiAgICB2YXIgaW5zdCA9IGRhdGVIZWxwZXIuY3JlYXRlKG5ldyBEYXRlKHN0YXJ0LnllYXIsIHN0YXJ0Lm1vbnRoIC0gMSwgc3RhcnQuZGF5IC0gNykpO1xuICAgIGluc3Qud2Vla1N0YXJ0c09uID0gd2Vla1N0YXJ0c09uO1xuICAgIHJldHVybiBpbnN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWsgcHJlY2VkaW5nIHRoaXMuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldCBwcmV2aW91c1dlZWsoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygncHJldmlvdXNXZWVrJyk7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlLnByZXZpb3VzV2VlayB8fCAodGhpcy5fY2FjaGUucHJldmlvdXNXZWVrID0gZGF0ZUhlbHBlci5nZXRQcmV2aW91c1dlZWsodGhpcykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByZXZpb3VzIGRheSBhZnRlciB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0UHJldmlvdXNEYXk6IGZ1bmN0aW9uIGdldFByZXZpb3VzRGF5KGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZUhlbHBlci5jcmVhdGUobmV3IERhdGUoZGF0ZS55ZWFyLCBkYXRlLm1vbnRoIC0gMSwgZGF0ZS5kYXkgLSAxKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5IHByZWNlZGluZyB0aGlzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXQgcHJldmlvdXNEYXkoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygncHJldmlvdXNEYXknKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUucHJldmlvdXNEYXkgfHwgKHRoaXMuX2NhY2hlLnByZXZpb3VzRGF5ID0gZGF0ZUhlbHBlci5nZXRQcmV2aW91c0RheSh0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJldmlvdXMgbW9udGggYWZ0ZXIgdGhlIGdpdmVuIGRhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldFByZXZpb3VzTW9udGg6IGZ1bmN0aW9uIGdldFByZXZpb3VzTW9udGgoZGF0ZSkge1xuICAgIC8vIERhdGUoKSBoYXMgYSAqYnVnL2ZlYXR1cmUqIGlmIGxhc3QgZGF5IG9mIG1vbnRoIGlzIDMxIHdoZW4gY2FsY3VsYXRpbmcgdGhlIHByZXZpb3VzIG1vbnRoLlxuICAgIC8vIE5lZWQgdG8gYWNjb3VudCBmb3IgdGhhdCBzbyB0aGF0IGl0IGRvZXNuJ3Qgcm91bmQgdXAgdGhlIGRhdGUvbW9udGguXG5cbiAgICBpZiAoZGF0ZS5kYXkgPT09IDMxICYmIGRhdGUubW9udGggIT09IDEgJiYgZGF0ZS5tb250aCAhPT0gMyAmJiBkYXRlLm1vbnRoICE9PSA4KSB7XG4gICAgICAvLyBBZGp1c3QgZm9yIG1vbnRocyBlbmRpbmcgaW4gMzEgdGhhdCBmb2xsb3cgbW9udGhzIGVuZGluZyBpbiAzMFxuICAgICAgcmV0dXJuIGRhdGVIZWxwZXIuY3JlYXRlKG5ldyBEYXRlKGRhdGUueWVhciwgZGF0ZS5tb250aCAtIDIsIGRhdGUuZGF5IC0gMSkpO1xuICAgIH0gZWxzZSBpZiAoZGF0ZS5kYXkgPiAyOCAmJiBkYXRlLm1vbnRoID09PSAzKSB7XG4gICAgICAvLyBBZGp1c3QgZm9yIGxhc3QgZGF5IG9mIEZlYnJ1YXJ5XG4gICAgICByZXR1cm4gZGF0ZUhlbHBlci5jcmVhdGUobmV3IERhdGUoZGF0ZS55ZWFyLCBkYXRlLm1vbnRoIC0gMSwgMCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGF0ZUhlbHBlci5jcmVhdGUobmV3IERhdGUoZGF0ZS55ZWFyLCBkYXRlLm1vbnRoIC0gMiwgZGF0ZS5kYXkpKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9udGggcHJlY2VkaW5nIHRoaXMuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldCBwcmV2aW91c01vbnRoKCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ2hlY2soJ3ByZXZpb3VzTW9udGgnKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUucHJldmlvdXNNb250aCB8fCAodGhpcy5fY2FjaGUucHJldmlvdXNNb250aCA9IGRhdGVIZWxwZXIuZ2V0UHJldmlvdXNNb250aCh0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFzdCBkYXkgb2YgdGhlIG1vbnRoLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRNb250aEVuZDogZnVuY3Rpb24gZ2V0TW9udGhFbmQoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGgsIDApKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBsYXN0IGRheSBvZiB0aGUgbW9udGguXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldCBtb250aEVuZCgpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCdtb250aEVuZCcpO1xuICAgIHJldHVybiB0aGlzLl9jYWNoZS5tb250aEVuZCB8fCAodGhpcy5fY2FjaGUubW9udGhFbmQgPSBkYXRlSGVscGVyLmdldE1vbnRoRW5kKHRoaXMpKTtcbiAgfSxcblxuICAvKipcbiAgICogRG9lcyBhIGdpdmVuIGRheSBlcXVhbCBhbm90aGVyPyBPciBpcyBpdCBwcmVzZW50IGluIGEgbGlzdCBvZiBvdGhlcnM/XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBjb21wYXJlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnVsbCBSZXR1cm4gYSBzdWNjZXNzZnVsIG1hdGNoIG9ubHkgaWYgYWxsIG1hdGNoZXMgYXJlIGZvdW5kLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZXF1YWw6IGZ1bmN0aW9uIGVxdWFsKGRhdGUsIGNvbXBhcmUsIGZ1bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lcXVhbERheShkYXRlLCBjb21wYXJlLCBmdWxsKTtcbiAgfSxcblxuICAvKipcbiAgICogRG9lcyBhIGdpdmVuIGRheSBlcXVhbCBhbm90aGVyPyBPciBpcyBpdCBwcmVzZW50IGluIGEgbGlzdCBvZiBvdGhlcnM/XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBjb21wYXJlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnVsbCBSZXR1cm4gYSBzdWNjZXNzZnVsIG1hdGNoIG9ubHkgaWYgYWxsIG1hdGNoZXMgYXJlIGZvdW5kLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZXF1YWxEYXk6IGZ1bmN0aW9uIGVxdWFsRGF5KGRhdGUsIGNvbXBhcmUsIGZ1bGwpIHtcblxuICAgIHZhciBhcmdzID0gdGhpcy5fY2hlY2tDb21wYXJpc29uQXJncyhkYXRlLCBjb21wYXJlLCBmdWxsKTtcbiAgICBkYXRlID0gYXJnc1swXTtcbiAgICBjb21wYXJlID0gYXJnc1sxXTtcbiAgICBmdWxsID0gYXJnc1syXTtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gY29tcGFyZS5sZW5ndGg7XG4gICAgdmFyIG1hdGNoZXMgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNvbXBhcmVbaV0gJiYgZGF0ZS55ZWFyID09PSBjb21wYXJlW2ldLnllYXIgJiYgZGF0ZS5tb250aCA9PT0gY29tcGFyZVtpXS5tb250aCAmJiBkYXRlLmRheSA9PT0gY29tcGFyZVtpXS5kYXkpIG1hdGNoZXMrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVsbCA/IG1hdGNoZXMgPT09IGxlbiA6ICEhbWF0Y2hlcztcbiAgfSxcblxuICAvKipcbiAgICogSXMgYSB3ZWVrIGVxdWFsIHRvIGFub3RoZXI/XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBjb21wYXJlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnVsbCBSZXR1cm4gYSBzdWNjZXNzZnVsIG1hdGNoIG9ubHkgaWYgYWxsIG1hdGNoZXMgYXJlIGZvdW5kLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZXF1YWxXZWVrOiBmdW5jdGlvbiBlcXVhbFdlZWsoZGF0ZSwgY29tcGFyZSwgZnVsbCkge1xuXG4gICAgdmFyIGFyZ3MgPSB0aGlzLl9jaGVja0NvbXBhcmlzb25BcmdzKGRhdGUsIGNvbXBhcmUsIGZ1bGwpO1xuICAgIGRhdGUgPSBhcmdzWzBdO1xuICAgIGNvbXBhcmUgPSBhcmdzWzFdO1xuICAgIGZ1bGwgPSBhcmdzWzJdO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBjb21wYXJlLmxlbmd0aDtcbiAgICB2YXIgbWF0Y2hlcyA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWNvbXBhcmVbaV0gfHwgIWRhdGUud2Vla1N0YXJ0LmVxdWFsRGF5KGNvbXBhcmVbaV0ud2Vla1N0YXJ0KSkgY29udGludWU7ZWxzZSBtYXRjaGVzKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bGwgPyBtYXRjaGVzID09PSBsZW4gOiAhIW1hdGNoZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElzIGEgbW9udGggZXF1YWwgdG8gYW5vdGhlcj9cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGNvbXBhcmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBmdWxsIFJldHVybiBhIHN1Y2Nlc3NmdWwgbWF0Y2ggb25seSBpZiBhbGwgbWF0Y2hlcyBhcmUgZm91bmQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBlcXVhbE1vbnRoOiBmdW5jdGlvbiBlcXVhbE1vbnRoKGRhdGUsIGNvbXBhcmUsIGZ1bGwpIHtcblxuICAgIHZhciBhcmdzID0gdGhpcy5fY2hlY2tDb21wYXJpc29uQXJncyhkYXRlLCBjb21wYXJlLCBmdWxsKTtcbiAgICBkYXRlID0gYXJnc1swXTtcbiAgICBjb21wYXJlID0gYXJnc1sxXTtcbiAgICBmdWxsID0gYXJnc1syXTtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gY29tcGFyZS5sZW5ndGg7XG4gICAgdmFyIG1hdGNoZXMgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCFjb21wYXJlW2ldIHx8IGRhdGUueWVhciAhPT0gY29tcGFyZVtpXS55ZWFyIHx8IGRhdGUueWVhciA9PT0gY29tcGFyZVtpXS55ZWFyICYmIGRhdGUubW9udGggIT09IGNvbXBhcmVbaV0ubW9udGgpIGNvbnRpbnVlO2Vsc2UgbWF0Y2hlcysrO1xuICAgIH1cblxuICAgIHJldHVybiBmdWxsID8gbWF0Y2hlcyA9PT0gbGVuIDogISFtYXRjaGVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJcyBhIHllYXIgZXF1YWwgdG8gYW5vdGhlcj9cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGNvbXBhcmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBmdWxsIFJldHVybiBhIHN1Y2Nlc3NmdWwgbWF0Y2ggb25seSBpZiBhbGwgbWF0Y2hlcyBhcmUgZm91bmQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBlcXVhbFllYXI6IGZ1bmN0aW9uIGVxdWFsWWVhcihkYXRlLCBjb21wYXJlLCBmdWxsKSB7XG5cbiAgICB2YXIgYXJncyA9IHRoaXMuX2NoZWNrQ29tcGFyaXNvbkFyZ3MoZGF0ZSwgY29tcGFyZSwgZnVsbCk7XG4gICAgZGF0ZSA9IGFyZ3NbMF07XG4gICAgY29tcGFyZSA9IGFyZ3NbMV07XG4gICAgZnVsbCA9IGFyZ3NbMl07XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGNvbXBhcmUubGVuZ3RoO1xuICAgIHZhciBtYXRjaGVzID0gMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghY29tcGFyZVtpXSB8fCBkYXRlLnllYXIgIT09IGNvbXBhcmVbaV0ueWVhcikgY29udGludWU7ZWxzZSBtYXRjaGVzKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bGwgPyBtYXRjaGVzID09PSBsZW4gOiAhIW1hdGNoZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElzIGEgZGF0ZSBiZWZvcmUgYW5vdGhlcj9cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGNvbXBhcmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBmdWxsIFJldHVybiBhIHN1Y2Nlc3NmdWwgbWF0Y2ggb25seSBpZiBhbGwgbWF0Y2hlcyBhcmUgZm91bmQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZShkYXRlLCBjb21wYXJlLCBmdWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuYmVmb3JlRGF5KGRhdGUsIGNvbXBhcmUsIGZ1bGwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJcyBhIGdpdmVuIGRhdGUgYmVmb3JlIGFub3RoZXI/XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBjb21wYXJlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnVsbCBSZXR1cm4gYSBzdWNjZXNzZnVsIG1hdGNoIG9ubHkgaWYgYWxsIG1hdGNoZXMgYXJlIGZvdW5kLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgYmVmb3JlRGF5OiBmdW5jdGlvbiBiZWZvcmVEYXkoZGF0ZSwgY29tcGFyZSwgZnVsbCkge1xuXG4gICAgdmFyIGFyZ3MgPSB0aGlzLl9jaGVja0NvbXBhcmlzb25BcmdzKGRhdGUsIGNvbXBhcmUsIGZ1bGwpO1xuICAgIGRhdGUgPSBhcmdzWzBdO1xuICAgIGNvbXBhcmUgPSBhcmdzWzFdO1xuICAgIGZ1bGwgPSBhcmdzWzJdO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBjb21wYXJlLmxlbmd0aDtcbiAgICB2YXIgbWF0Y2hlcyA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWNvbXBhcmVbaV0gfHwgZGF0ZS5fZGF0ZSA+PSBjb21wYXJlW2ldLl9kYXRlKSBjb250aW51ZTtlbHNlIG1hdGNoZXMrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVsbCA/IG1hdGNoZXMgPT09IGxlbiA6ICEhbWF0Y2hlcztcbiAgfSxcblxuICAvKipcbiAgICogSXMgYSB3ZWVrIGJlZm9yZSBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGJlZm9yZVdlZWs6IGZ1bmN0aW9uIGJlZm9yZVdlZWsoZGF0ZSwgY29tcGFyZSwgZnVsbCkge1xuXG4gICAgdmFyIGFyZ3MgPSB0aGlzLl9jaGVja0NvbXBhcmlzb25BcmdzKGRhdGUsIGNvbXBhcmUsIGZ1bGwpO1xuICAgIGRhdGUgPSBhcmdzWzBdO1xuICAgIGNvbXBhcmUgPSBhcmdzWzFdO1xuICAgIGZ1bGwgPSBhcmdzWzJdO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBjb21wYXJlLmxlbmd0aDtcbiAgICB2YXIgbWF0Y2hlcyA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWNvbXBhcmVbaV0gfHwgIWRhdGUud2Vla1N0YXJ0LmJlZm9yZURheShjb21wYXJlW2ldLndlZWtTdGFydCkpIGNvbnRpbnVlO2Vsc2UgbWF0Y2hlcysrO1xuICAgIH1cblxuICAgIHJldHVybiBmdWxsID8gbWF0Y2hlcyA9PT0gbGVuIDogISFtYXRjaGVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJcyBhIG1vbnRoIGJlZm9yZSBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGJlZm9yZU1vbnRoOiBmdW5jdGlvbiBiZWZvcmVNb250aChkYXRlLCBjb21wYXJlLCBmdWxsKSB7XG5cbiAgICB2YXIgYXJncyA9IHRoaXMuX2NoZWNrQ29tcGFyaXNvbkFyZ3MoZGF0ZSwgY29tcGFyZSwgZnVsbCk7XG4gICAgZGF0ZSA9IGFyZ3NbMF07XG4gICAgY29tcGFyZSA9IGFyZ3NbMV07XG4gICAgZnVsbCA9IGFyZ3NbMl07XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGNvbXBhcmUubGVuZ3RoO1xuICAgIHZhciBtYXRjaGVzID0gMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghY29tcGFyZVtpXSB8fCBkYXRlLnllYXIgPiBjb21wYXJlW2ldLnllYXIgfHwgZGF0ZS55ZWFyID09PSBjb21wYXJlW2ldLnllYXIgJiYgZGF0ZS5tb250aCA+PSBjb21wYXJlW2ldLm1vbnRoKSBjb250aW51ZTtlbHNlIG1hdGNoZXMrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVsbCA/IG1hdGNoZXMgPT09IGxlbiA6ICEhbWF0Y2hlcztcbiAgfSxcblxuICAvKipcbiAgICogSXMgYSB5ZWFyIGJlZm9yZSBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGJlZm9yZVllYXI6IGZ1bmN0aW9uIGJlZm9yZVllYXIoZGF0ZSwgY29tcGFyZSwgZnVsbCkge1xuXG4gICAgdmFyIGFyZ3MgPSB0aGlzLl9jaGVja0NvbXBhcmlzb25BcmdzKGRhdGUsIGNvbXBhcmUsIGZ1bGwpO1xuICAgIGRhdGUgPSBhcmdzWzBdO1xuICAgIGNvbXBhcmUgPSBhcmdzWzFdO1xuICAgIGZ1bGwgPSBhcmdzWzJdO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBjb21wYXJlLmxlbmd0aDtcbiAgICB2YXIgbWF0Y2hlcyA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWNvbXBhcmVbaV0gfHwgZGF0ZS55ZWFyID49IGNvbXBhcmVbaV0ueWVhcikgY29udGludWU7ZWxzZSBtYXRjaGVzKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bGwgPyBtYXRjaGVzID09PSBsZW4gOiAhIW1hdGNoZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElzIGEgZGF0ZSBhZnRlciBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGFmdGVyOiBmdW5jdGlvbiBhZnRlcihkYXRlLCBjb21wYXJlLCBmdWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuYWZ0ZXJEYXkoZGF0ZSwgY29tcGFyZSwgZnVsbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElzIGEgZ2l2ZW4gZGF0ZSBhZnRlciBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGFmdGVyRGF5OiBmdW5jdGlvbiBhZnRlckRheShkYXRlLCBjb21wYXJlLCBmdWxsKSB7XG5cbiAgICB2YXIgYXJncyA9IHRoaXMuX2NoZWNrQ29tcGFyaXNvbkFyZ3MoZGF0ZSwgY29tcGFyZSwgZnVsbCk7XG4gICAgZGF0ZSA9IGFyZ3NbMF07XG4gICAgY29tcGFyZSA9IGFyZ3NbMV07XG4gICAgZnVsbCA9IGFyZ3NbMl07XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGNvbXBhcmUubGVuZ3RoO1xuICAgIHZhciBtYXRjaGVzID0gMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghY29tcGFyZVtpXSB8fCBkYXRlLl9kYXRlIDw9IGNvbXBhcmVbaV0uX2RhdGUpIGNvbnRpbnVlO2Vsc2UgbWF0Y2hlcysrO1xuICAgIH1cblxuICAgIHJldHVybiBmdWxsID8gbWF0Y2hlcyA9PT0gbGVuIDogISFtYXRjaGVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJcyBhIHdlZWsgYWZ0ZXIgYW5vdGhlcj9cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGNvbXBhcmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBmdWxsIFJldHVybiBhIHN1Y2Nlc3NmdWwgbWF0Y2ggb25seSBpZiBhbGwgbWF0Y2hlcyBhcmUgZm91bmQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBhZnRlcldlZWs6IGZ1bmN0aW9uIGFmdGVyV2VlayhkYXRlLCBjb21wYXJlLCBmdWxsKSB7XG5cbiAgICB2YXIgYXJncyA9IHRoaXMuX2NoZWNrQ29tcGFyaXNvbkFyZ3MoZGF0ZSwgY29tcGFyZSwgZnVsbCk7XG4gICAgZGF0ZSA9IGFyZ3NbMF07XG4gICAgY29tcGFyZSA9IGFyZ3NbMV07XG4gICAgZnVsbCA9IGFyZ3NbMl07XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGNvbXBhcmUubGVuZ3RoO1xuICAgIHZhciBtYXRjaGVzID0gMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghY29tcGFyZVtpXSB8fCAhZGF0ZS53ZWVrU3RhcnQuYWZ0ZXJEYXkoY29tcGFyZVtpXS53ZWVrU3RhcnQpKSBjb250aW51ZTtlbHNlIG1hdGNoZXMrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVsbCA/IG1hdGNoZXMgPT09IGxlbiA6ICEhbWF0Y2hlcztcbiAgfSxcblxuICAvKipcbiAgICogSXMgYSBtb250aCBhZnRlciBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGFmdGVyTW9udGg6IGZ1bmN0aW9uIGFmdGVyTW9udGgoZGF0ZSwgY29tcGFyZSwgZnVsbCkge1xuXG4gICAgdmFyIGFyZ3MgPSB0aGlzLl9jaGVja0NvbXBhcmlzb25BcmdzKGRhdGUsIGNvbXBhcmUsIGZ1bGwpO1xuICAgIGRhdGUgPSBhcmdzWzBdO1xuICAgIGNvbXBhcmUgPSBhcmdzWzFdO1xuICAgIGZ1bGwgPSBhcmdzWzJdO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBjb21wYXJlLmxlbmd0aDtcbiAgICB2YXIgbWF0Y2hlcyA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWNvbXBhcmVbaV0gfHwgZGF0ZS55ZWFyIDwgY29tcGFyZVtpXS55ZWFyIHx8IGRhdGUueWVhciA9PT0gY29tcGFyZVtpXS55ZWFyICYmIGRhdGUubW9udGggPD0gY29tcGFyZVtpXS5tb250aCkgY29udGludWU7ZWxzZSBtYXRjaGVzKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bGwgPyBtYXRjaGVzID09PSBsZW4gOiAhIW1hdGNoZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElzIGEgeWVhciBhZnRlciBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGFmdGVyWWVhcjogZnVuY3Rpb24gYWZ0ZXJZZWFyKGRhdGUsIGNvbXBhcmUsIGZ1bGwpIHtcblxuICAgIHZhciBhcmdzID0gdGhpcy5fY2hlY2tDb21wYXJpc29uQXJncyhkYXRlLCBjb21wYXJlLCBmdWxsKTtcbiAgICBkYXRlID0gYXJnc1swXTtcbiAgICBjb21wYXJlID0gYXJnc1sxXTtcbiAgICBmdWxsID0gYXJnc1syXTtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gY29tcGFyZS5sZW5ndGg7XG4gICAgdmFyIG1hdGNoZXMgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCFjb21wYXJlW2ldIHx8IGRhdGUueWVhciA8PSBjb21wYXJlW2ldLnllYXIpIGNvbnRpbnVlO2Vsc2UgbWF0Y2hlcysrO1xuICAgIH1cblxuICAgIHJldHVybiBmdWxsID8gbWF0Y2hlcyA9PT0gbGVuIDogISFtYXRjaGVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVhcmxpZXN0IGRhdGUgaW4gYW4gYXJyYXkuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGVhcmxpZXN0OiBmdW5jdGlvbiBlYXJsaWVzdChhcnIpIHtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICB2YXIgZSA9IHZvaWQgMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghZSB8fCBhcnJbaV0uYmVmb3JlKGUpKSBlID0gYXJyW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxhdGVzdCBkYXRlIGluIGFuIGFycmF5LlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBsYXRlc3Q6IGZ1bmN0aW9uIGxhdGVzdChhcnIpIHtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICB2YXIgbCA9IHZvaWQgMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghbCB8fCBhcnJbaV0uYWZ0ZXIobCkpIGwgPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsb25lIGEgZGF0ZSBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKGRhdGUpIHtcblxuICAgIC8vIElmIHdlIHdlcmVuJ3QgcGFzc2VkIGEgZGF0ZSwgdXNlIHRoaXMgaW5zdGFuY2UuXG4gICAgaWYgKCFkYXRlICYmIHRoaXMuX2RhdGUgJiYgdGhpcy5fZGF0ZSBpbnN0YW5jZW9mIERhdGUgJiYgZGF0ZUhlbHBlci5pc1Byb3RvdHlwZU9mKHRoaXMpKSB7XG4gICAgICBkYXRlID0gdGhpcztcbiAgICB9XG5cbiAgICAvLyBObyBkYXRlLCBjYW4ndCBjbG9uZS5cbiAgICBpZiAoIWRhdGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwYXNzIGEgZGF0ZSB0byBjbG9uZSBvciBjYWxsIG9uIGFuIGluc3RhbmNlLicpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLl9kYXRlLnZhbHVlT2YoKSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBhIGNvbXBhcmlzb24gZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGFuIGluc3RhbmNlLCBwcm9wZXJseVxuICAgKiBhc3NpZ24gdGhlIHZhcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBjb21wYXJlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnVsbFxuICAgKi9cbiAgX2NoZWNrQ29tcGFyaXNvbkFyZ3M6IGZ1bmN0aW9uIF9jaGVja0NvbXBhcmlzb25BcmdzKGRhdGUsIGNvbXBhcmUsIGZ1bGwpIHtcblxuICAgIGlmIChjb21wYXJlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGNvbXBhcmUgPT09ICdib29sZWFuJykge1xuXG4gICAgICBpZiAoIWRhdGVIZWxwZXIuaXNQcm90b3R5cGVPZih0aGlzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wYXJlIG9ubHkgb25lIGRhdGUhJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bGwgPSBjb21wYXJlO1xuICAgICAgY29tcGFyZSA9IGRhdGU7XG4gICAgICBkYXRlID0gdGhpcztcbiAgICB9XG5cbiAgICBjb21wYXJlID0gY29tcGFyZSBpbnN0YW5jZW9mIEFycmF5ID8gY29tcGFyZSA6IFtjb21wYXJlXTtcblxuICAgIHJldHVybiBbZGF0ZSwgY29tcGFyZSwgZnVsbF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGFuIGluc3RhbmNlIG9mIHRoZSBkYXRlIG9iamVjdC5cbiAgICogQHBhcmFtICB7U3RyaW5nfSBwcm9wXG4gICAqL1xuICBfaW5zdGFuY2VDaGVjazogZnVuY3Rpb24gX2luc3RhbmNlQ2hlY2socHJvcCkge1xuICAgIGlmICghdGhpcy5fZGF0ZSB8fCAhKHRoaXMuX2RhdGUgaW5zdGFuY2VvZiBEYXRlKSB8fCAhZGF0ZUhlbHBlci5pc1Byb3RvdHlwZU9mKHRoaXMpKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhY2Nlc3MgdGhlIHByb3BlcnR5IFwiJyArIHByb3AgKyAnXCIgb2YgdGhlIGRhdGUgaGVscGVyIHdpdGggY3JlYXRpbmcgYW4gaW5zdGFuY2UhJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsZWFyIHRoZSBjYWNoZS5cbiAgICovXG4gIF9jbGVhckNhY2hlOiBmdW5jdGlvbiBfY2xlYXJDYWNoZSgpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCdjbGVhckNhY2hlJyk7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgfVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZGF0ZUhlbHBlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0ZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wYWQgPSByZXF1aXJlKCcuLi91dGlsL3BhZCcpO1xuXG52YXIgX3BhZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYWQpO1xuXG52YXIgX2RhdGUgPSByZXF1aXJlKCcuL2RhdGUnKTtcblxudmFyIF9kYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RhdGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIE1hcCBjaGFyYWN0ZXJzIHRvIHRoZWlyIHNwZWNpYWwgbWVhbmluZ3MuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG4vKipcbiAqICMgUGFyc2UgRGF0ZSBGb3JtYXRcbiAqIEdpdmVuIGEgZGF0ZSBmb3JtYXQgc3RyaW5nLCBicmVhayBpdCBkb3duIGludG8gcGllY2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBwYXJzZURhdGVGb3JtYXQoJ01NLURELVlZWVknKTtcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZGF0ZS9wYXJzZS1mb3JtYXQuanNcbiAqL1xuXG52YXIgbWFwID0ge1xuICBkOiAnZGF5JyxcbiAgbTogJ21vbnRoJyxcbiAgeTogJ3llYXInLFxuICAnLSc6ICdkaXZpZGVyJyxcbiAgJy8nOiAnZGl2aWRlcicsXG4gICcgJzogJ3NwYWNlJ1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIGZvcm1hdCBhbmQgYSBzdHJpbmcsIGdldCB0aGUgZGF5LCBtb250aCBhbmQgeWVhciB2YWx1ZXMgZnJvbSB0aGF0IHN0cmluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBmb3JtYXRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZXMoZm9ybWF0KSB7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbiA9IGZvcm1hdC5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IHt9O1xuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGFsbCBmb3JtYXQgcGllY2VzXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAvLyBPbmx5IHdvcnJ5IGFib3V0IGRhdGUgdmFsdWVzXG4gICAgICBpZiAoWydkYXknLCAnbW9udGgnLCAneWVhciddLmluZGV4T2YoZm9ybWF0W2ldLm5hbWUpICE9PSAtMSkge1xuXG4gICAgICAgIC8vIElmIHRoZSBwYXNzZWQgdmFsdWUgZG9lc24ndCBjb250YWluIGEgZm9ybWF0IHBpZWNlLCBpdCdzIGludmFsaWQuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPCBpbmRleCArIGZvcm1hdFtpXS5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICB2YWx1ZXNbZm9ybWF0W2ldLm5hbWVdID0gcGFyc2VJbnQodmFsdWUuc3Vic3RyKGluZGV4LCBmb3JtYXRbaV0ubGVuZ3RoKSwgMTApO1xuICAgICAgfVxuICAgICAgaW5kZXggKz0gZm9ybWF0W2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gX2RhdGUyLmRlZmF1bHQuY3JlYXRlKHZhbHVlcyk7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZm9ybWF0dGVkIGRhdGUgc3RyaW5nIGdpdmVuIGFuIG9iamVjdCBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gZm9ybWF0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0U3RyaW5nKGZvcm1hdCkge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsc1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHMpIHtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gZm9ybWF0Lmxlbmd0aDtcbiAgICB2YXIgc3RyID0gJyc7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgIC8vIE51bWJlcnNcbiAgICAgIGlmICh2YWxzW2Zvcm1hdFtpXS5uYW1lXSkge1xuICAgICAgICBzdHIgKz0gKDAsIF9wYWQyLmRlZmF1bHQpKHZhbHNbZm9ybWF0W2ldLm5hbWVdLCBmb3JtYXRbaV0ubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIC8vIERpdmlkZXJzXG4gICAgICBlbHNlIHtcbiAgICAgICAgICBzdHIgKz0gZm9ybWF0W2ldLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGF0ZUZvcm1hdChmb3JtYXQpIHtcblxuICB2YXIgZiA9IGZvcm1hdC50b0xvd2VyQ2FzZSgpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsZW4gPSBmLmxlbmd0aDtcblxuICB2YXIgb2JqID0ge1xuICAgIHBhcnRzOiBbXVxuICB9O1xuXG4gIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgIC8vIElmIHRoZXJlIGlzIGEgbWF0Y2hpbmcgY2hhcmFjdGVyIG1hcHBpbmcgYW5kIHRoZSBsYXN0IHBhcnQgd2FzIG9mIHRoZSBzYW1lIG5hbWUsIGluY3JlbWVudCBpdHMgbGVuZ3RoXG4gICAgLy8gYW5kIGFkZCB0byBpdHMgY29udGVudC5cbiAgICBpZiAobWFwW2ZbaV1dICYmIG9iai5wYXJ0cy5sZW5ndGggJiYgb2JqLnBhcnRzW29iai5wYXJ0cy5sZW5ndGggLSAxXS5uYW1lID09PSBtYXBbZltpXV0pIHtcbiAgICAgIG9iai5wYXJ0c1tvYmoucGFydHMubGVuZ3RoIC0gMV0ubGVuZ3RoKys7XG4gICAgICBvYmoucGFydHNbb2JqLnBhcnRzLmxlbmd0aCAtIDFdLnZhbHVlICs9IGZvcm1hdFtpXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIG9iai5wYXJ0cy5wdXNoKHtcbiAgICAgIG5hbWU6IG1hcFtmW2ldXSA/IG1hcFtmW2ldXSA6ICcnLFxuICAgICAgdmFsdWU6IGZvcm1hdFtpXSxcbiAgICAgIGxlbmd0aDogMVxuICAgIH0pO1xuICB9XG5cbiAgLy8gQWRkIGEgd2F5IHRvIGNvbnZlcnQgdGhlIHBhcnNlZCBkYXRlIGludG8gYSByZWdleC1pc2ggc3RyaW5nIHRoYXQgd29ya3Mgd2l0aCB0aGUgVHlwZWFoZWFkIGltcGxlbWVudGF0aW9uLlxuICBvYmouZ2V0VmFsdWVzID0gZ2V0VmFsdWVzKG9iai5wYXJ0cyk7XG4gIG9iai5nZXRTdHJpbmcgPSBnZXRTdHJpbmcob2JqLnBhcnRzKTtcblxuICByZXR1cm4gb2JqO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBwYXJzZURhdGVGb3JtYXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLWZvcm1hdC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90cmltID0gcmVxdWlyZSgnLi4vdXRpbC90cmltJyk7XG5cbnZhciBfdHJpbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmltKTtcblxudmFyIF9oYXNDbGFzcyA9IHJlcXVpcmUoJy4vaGFzLWNsYXNzJyk7XG5cbnZhciBfaGFzQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzQ2xhc3MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqICMgQWRkIENsYXNzXG4gKiBBZGQgYSBjbGFzcyBvbiBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxBcnJheX0gZWwgQW4gZWxlbWVudCBvciBhcnJheSBvZiBlbGVtZW50cyB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7RWxlbWVudH1cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZG9tL2FkZC1jbGFzcy5qc1xuICovXG5cbnZhciB3cyA9IC9cXHMrLztcbnZhciBjbGVhbnVwID0gL1xcc3syLH0vZztcblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIG5hbWUpIHtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gKDAsIF90cmltMi5kZWZhdWx0KShuYW1lKS5zcGxpdCh3cyk7XG4gIH0gZWxzZSB7XG4gICAgbmFtZSA9IG5hbWUgaW5zdGFuY2VvZiBBcnJheSA/IG5hbWUgOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB9XG5cbiAgLy8gb3B0aW1pemUgZm9yIGJlc3QsIG1vc3QgY29tbW9uIGNhc2VcbiAgaWYgKG5hbWUubGVuZ3RoID09PSAxICYmIGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChuYW1lWzBdKSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKG5hbWVbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICB2YXIgdG9BZGQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IG5hbWUubGVuZ3RoO1xuICB2YXIgaXRlbSA9IHZvaWQgMDtcbiAgdmFyIGNsc05hbWUgPSB0eXBlb2YgZWwuY2xhc3NOYW1lID09PSAnc3RyaW5nJyA/IGVsLmNsYXNzTmFtZSA6IGVsLmdldEF0dHJpYnV0ZSA/IGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSA6ICcnO1xuXG4gIC8vIHNlZSBpZiB3ZSBoYXZlIGFueXRoaW5nIHRvIGFkZFxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGl0ZW0gPSBuYW1lW2ldO1xuICAgIGlmIChpdGVtICYmICEoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KShjbHNOYW1lLCBpdGVtKSkge1xuICAgICAgdG9BZGQucHVzaChpdGVtKTtcbiAgICB9XG4gIH1cblxuICBpZiAodG9BZGQubGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBlbC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbC5jbGFzc05hbWUgPSAoMCwgX3RyaW0yLmRlZmF1bHQpKChjbHNOYW1lICsgJyAnICsgdG9BZGQuam9pbignICcpKS5yZXBsYWNlKGNsZWFudXAsICcgJykpO1xuICAgIH0gZWxzZSBpZiAoZWwuc2V0QXR0cmlidXRlKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKDAsIF90cmltMi5kZWZhdWx0KSgoY2xzTmFtZSArICcgJyArIHRvQWRkLmpvaW4oJyAnKSkucmVwbGFjZShjbGVhbnVwLCAnICcpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBhZGRDbGFzcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkLWNsYXNzLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgQnJlYWtwb2ludCBIZWxwZXJzXG4gKiBGaW5kIHRoZSBhY3RpdmUgYnJlYWtwb2ludC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZG9tL2JyZWFrcG9pbnQuanNcbiAqL1xuXG4vKipcbiAqIEJyZWFrcG9pbnRzIGJlaW5nIHVzZWQgaW4gdGhlIENTUy5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBkZWZhdWx0QnJlYWtwb2ludHMgPSB7XG4gIHhzOiB7XG4gICAgbWluOiAwLFxuICAgIG1heDogNTQzXG4gIH0sXG4gIHNtOiB7XG4gICAgbWluOiA1NDQsXG4gICAgbWF4OiA3OTVcbiAgfSxcbiAgbWQ6IHtcbiAgICBtaW46IDc5NixcbiAgICBtYXg6IDEwNDdcbiAgfSxcbiAgbGc6IHtcbiAgICBtaW46IDEwNDgsXG4gICAgbWF4OiAxNzk5XG4gIH0sXG4gIHhsOiB7XG4gICAgbWluOiAxODAwLFxuICAgIG1heDogSW5maW5pdHlcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0KHdpZHRoLCBicmVha3BvaW50cykge1xuXG4gIGJyZWFrcG9pbnRzID0gYnJlYWtwb2ludHMgfHwgZGVmYXVsdEJyZWFrcG9pbnRzO1xuXG4gIHZhciBpID0gdm9pZCAwO1xuXG4gIGZvciAoaSBpbiBicmVha3BvaW50cykge1xuICAgIGlmICh3aWR0aCA+PSBicmVha3BvaW50c1tpXS5taW4gJiYgd2lkdGggPD0gYnJlYWtwb2ludHNbaV0ubWF4KSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5nZXQgPSBnZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icmVha3BvaW50LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbi8qKlxuICogIyBIYXMgQ2xhc3NcbiAqIFNlZSBpZiBhbiBlbGVtZW50IGhhcyBhIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZG9tL2hhcy1jbGFzcy5qc1xuICovXG5mdW5jdGlvbiBoYXNDbGFzcyhlbCwgbmFtZSkge1xuICB2YXIgY05hbWUgPSAoKHR5cGVvZiBlbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZWwpKSA9PT0gJ29iamVjdCcgPyBlbC5jbGFzc05hbWUgfHwgZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJyA6IGVsIHx8ICcnKS5yZXBsYWNlKC9bXFx0XFxyXFxuXFxmXS9nLCAnICcpO1xuICByZXR1cm4gKCcgJyArIGNOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIG5hbWUgKyAnICcpICE9PSAtMTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gaGFzQ2xhc3M7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhcy1jbGFzcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBPZmZzZXQgUG9zaXRpb25cbiAqIEdldCB0aGUgb2Zmc2V0IHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlld1BvcnRPZmZzZXQgVGhlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQsIG5vdCBwYWdlLlxuICogQHJldHVybiB7T2JqZWN0fVxuICpcbiAqIEBtb2R1bGUgaGVscGVycy9kb20vb2Zmc2V0LmpzXG4gKi9cbmZ1bmN0aW9uIG9mZnNldChlbCwgdmlld1BvcnRPZmZzZXQpIHtcblxuICB2YXIgcmVjdCA9IHtcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMFxuICB9O1xuXG4gIC8vIE5hdGl2ZSBpbXBsZW1lbnRhdGlvblxuICBpZiAoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG5cbiAgICB2YXIgYm91bmRpbmcgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZWN0LmxlZnQgPSBib3VuZGluZy5sZWZ0O1xuICAgIHJlY3QudG9wID0gYm91bmRpbmcudG9wO1xuXG4gICAgaWYgKCF2aWV3UG9ydE9mZnNldCkge1xuICAgICAgcmVjdC5sZWZ0ICs9IHR5cGVvZiB3aW5kb3cuc2Nyb2xsWCAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuc2Nyb2xsWCA6IHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICAgIHJlY3QudG9wICs9IHR5cGVvZiB3aW5kb3cuc2Nyb2xsWSAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuc2Nyb2xsWSA6IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHggPSAwLFxuICAgICAgICB5ID0gMDtcbiAgICBkbyB7XG4gICAgICB4ICs9IGVsLm9mZnNldExlZnQgLSAoIXZpZXdQb3J0T2Zmc2V0ID8gZWwuc2Nyb2xsTGVmdCA6IDApO1xuICAgICAgeSArPSBlbC5vZmZzZXRUb3AgLSAoIXZpZXdQb3J0T2Zmc2V0ID8gZWwuc2Nyb2xsVG9wIDogMCk7XG4gICAgfSB3aGlsZSAoZWwgPSBlbC5vZmZzZXRQYXJlbnQpO1xuXG4gICAgcmVjdC5sZWZ0ID0geDtcbiAgICByZWN0LnRvcCA9IHk7XG4gIH1cblxuICByZXR1cm4gcmVjdDtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gb2Zmc2V0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vZmZzZXQuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgUGFyc2UgRE9NIGF0dHJpYnV0ZXNcbiAqIEdpdmVuIGFuIGVsZW1lbnQgYW5kIGFuIGF0dHJpYnV0ZSBuYW1lLCBwYXJzZSB0aGF0IGF0dHJpYnV0ZVxuICogaWYgaXQgZXhpc3RzIG9yIHJldHVybiBhIGRlZmF1bHQuXG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL2RvbS9wYXJzZS1hdHRyaWJ1dGUuanNcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgYm9vbGVhbiB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcbiAqIGZhbGxpbmcgYmFjayB0byB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGRlZlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYm9vbGVhbihlbCwgbmFtZSwgZGVmKSB7XG4gIHZhciB2YWwgPSBlbC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiBkZWY7XG4gIHJldHVybiB2YWwgPT09ICd0cnVlJyB8fCB2YWwgPT09ICcnID8gdHJ1ZSA6IGZhbHNlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbnVtZXJpYyB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcbiAqIGZhbGxpbmcgYmFjayB0byB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGRlZlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gbnVtYmVyKGVsLCBuYW1lLCBkZWYpIHtcbiAgdmFyIHZhbCA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuIGRlZjtcbiAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYm9vbGVhbiB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcbiAqIGZhbGxpbmcgYmFjayB0byB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGRlZlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc3RyaW5nKGVsLCBuYW1lLCBkZWYpIHtcbiAgdmFyIHZhbCA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuIGRlZjtcbiAgcmV0dXJuIHZhbDtcbn1cblxuZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhbjtcbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS1hdHRyaWJ1dGUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHJpbSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJpbScpO1xuXG52YXIgX3RyaW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJpbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciB3cyA9IC9cXHMrLzsgLyoqXG4gICAgICAgICAgICAgICAgICogIyBSZW1vdmUgQ2xhc3NcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmUgYSBjbGFzcyBvbiBhbiBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fEFycmF5fSBlbCBBbiBlbGVtZW50IG9yIGFycmF5IG9mIGVsZW1lbnRzIHRvIHVwZGF0ZS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIGhlbHBlcnMvZG9tL3JlbW92ZS1jbGFzcy5qc1xuICAgICAgICAgICAgICAgICAqL1xuXG52YXIgY2xlYW51cCA9IC9cXHN7Mix9L2c7XG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBuYW1lKSB7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgbmFtZSA9ICgwLCBfdHJpbTIuZGVmYXVsdCkobmFtZSkuc3BsaXQod3MpO1xuICB9IGVsc2Uge1xuICAgIG5hbWUgPSBuYW1lIGluc3RhbmNlb2YgQXJyYXkgPyBuYW1lIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgfVxuXG4gIC8vIG9wdGltaXplIGZvciBiZXN0LCBtb3N0IGNvbW1vbiBjYXNlXG4gIGlmIChuYW1lLmxlbmd0aCA9PT0gMSAmJiBlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAobmFtZVswXSkgZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lWzBdKTtcbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICAvLyBzdG9yZSB0d28gY29waWVzXG4gIHZhciBjbHNOYW1lID0gJyAnICsgKHR5cGVvZiBlbC5jbGFzc05hbWUgPT09ICdzdHJpbmcnID8gZWwuY2xhc3NOYW1lIDogZWwuZ2V0QXR0cmlidXRlID8gZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIDogJycpICsgJyAnO1xuICB2YXIgcmVzdWx0ID0gY2xzTmFtZTtcbiAgdmFyIGN1cnJlbnQgPSB2b2lkIDA7XG4gIHZhciBzdGFydCA9IHZvaWQgMDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBuYW1lLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGN1cnJlbnQgPSBuYW1lW2ldO1xuICAgIHN0YXJ0ID0gY3VycmVudCA/IHJlc3VsdC5pbmRleE9mKCcgJyArIGN1cnJlbnQgKyAnICcpIDogLTE7XG4gICAgaWYgKHN0YXJ0ICE9PSAtMSkge1xuICAgICAgc3RhcnQgKz0gMTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBzdGFydCkgKyByZXN1bHQuc2xpY2Uoc3RhcnQgKyBjdXJyZW50Lmxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgLy8gb25seSB3cml0ZSBpZiBtb2RpZmllZFxuICBpZiAoY2xzTmFtZSAhPT0gcmVzdWx0KSB7XG4gICAgaWYgKHR5cGVvZiBlbC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbC5jbGFzc05hbWUgPSAoMCwgX3RyaW0yLmRlZmF1bHQpKHJlc3VsdC5yZXBsYWNlKGNsZWFudXAsICcgJykpO1xuICAgIH0gZWxzZSBpZiAoZWwuc2V0QXR0cmlidXRlKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKDAsIF90cmltMi5kZWZhdWx0KShyZXN1bHQucmVwbGFjZShjbGVhbnVwLCAnICcpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSByZW1vdmVDbGFzcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZlLWNsYXNzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2hhc0NsYXNzID0gcmVxdWlyZSgnLi9oYXMtY2xhc3MnKTtcblxudmFyIF9oYXNDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYXNDbGFzcyk7XG5cbnZhciBfYWRkQ2xhc3MgPSByZXF1aXJlKCcuL2FkZC1jbGFzcycpO1xuXG52YXIgX2FkZENsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FkZENsYXNzKTtcblxudmFyIF9yZW1vdmVDbGFzcyA9IHJlcXVpcmUoJy4vcmVtb3ZlLWNsYXNzJyk7XG5cbnZhciBfcmVtb3ZlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVtb3ZlQ2xhc3MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB0b2dnbGVDbGFzcyhlbCwgbmFtZSwgZW5hYmxlKSB7XG5cbiAgaWYgKCFlbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIHdlJ3JlIHBhc3NlZCBhbiBhcnJheSwgdG9nZ2xlIHRoZSBjbGFzcyBvbiBlYWNoLlxuICBpZiAoZWwgaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCBlbCBpbnN0YW5jZW9mIEFycmF5KSB7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRvZ2dsZUNsYXNzKGVsW2ldLCBuYW1lLCBlbmFibGUpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBhY3Rpb24gPSB2b2lkIDA7XG4gIGlmIChlbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuYWJsZSA9IHR5cGVvZiBlbmFibGUgPT09ICdmdW5jdGlvbicgPyBlbmFibGUuY2FsbChudWxsLCBlbCkgOiBlbmFibGU7XG4gICAgYWN0aW9uID0gZW5hYmxlID8gJ2FkZCcgOiAncmVtb3ZlJztcbiAgfSBlbHNlIHtcbiAgICBhY3Rpb24gPSAoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KShlbCwgbmFtZSkgPyAncmVtb3ZlJyA6ICdhZGQnO1xuICB9XG5cbiAgcmV0dXJuIChhY3Rpb24gPT09ICdhZGQnID8gX2FkZENsYXNzMi5kZWZhdWx0IDogX3JlbW92ZUNsYXNzMi5kZWZhdWx0KShlbCwgbmFtZSk7XG59IC8qKlxuICAgKiAjIFRvZ2dsZSBDbGFzc1xuICAgKiBUb2dnbGUgYSBjbGFzcyBvbiBhbiBlbGVtZW50IGdpdmVuIGEgY29uZGl0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXl9IGVsIEFuIGVsZW1lbnQgb3IgYXJyYXkgb2YgZWxlbWVudHMgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZVxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKlxuICAgKiBAbW9kdWxlICBoZWxwZXJzL2RvbS90b2dnbGUtY2xhc3MuanNcbiAgICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IHRvZ2dsZUNsYXNzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2dnbGUtY2xhc3MuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgVHJpZ2dlciBFdmVudFxuICogVHJpZ2dlciBhIERPTSBldmVudCBvbiBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL2RvbS90cmlnZ2VyLWV2ZW50LmpzXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJFdmVudChlbCwgbmFtZSkge1xuXG4gIHZhciBldmVudCA9IHZvaWQgMDtcblxuICBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KG5hbWUsIHRydWUsIHRydWUpO1xuICAgIGV2ZW50LmV2ZW50TmFtZSA9IG5hbWU7XG4gICAgZWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpO1xuICAgIGV2ZW50LmV2ZW50VHlwZSA9IG5hbWU7XG4gICAgZXZlbnQuZXZlbnROYW1lID0gbmFtZTtcbiAgICBlbC5maXJlRXZlbnQoJ29uJyArIGV2ZW50LmV2ZW50VHlwZSwgZXZlbnQpO1xuICB9XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHRyaWdnZXJFdmVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJpZ2dlci1ldmVudC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4vKipcbiAqICMgQnVpbGQgU2VsZWN0XG4gKiBCdWlsZCBhIHNlbGVjdCBpbnB1dC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gKlxuICogQGV4YW1wbGVcbiAqIGJ1aWxkU2VsZWN0KHtcbiAqICAgYXR0cmlidXRlczoge1xuICogICAgIG5hbWU6ICd0ZXN0JyxcbiAqICAgICBjbGFzczogJ3NwYXJrLXNlbGVjdF9fZmllbGQnXG4gKiAgIH0sXG4gKiAgIG9wdGlvbnM6IFsxLCAyLCAzLCA0LCA1LCA2XVxuICogfSk7XG4gKlxuICogQGV4YW1wbGVcbiAqIGJ1aWxkU2VsZWN0KHtcbiAqICAgYXR0cmlidXRlczoge1xuICogICAgIG5hbWU6ICd0ZXN0JyxcbiAqICAgICBjbGFzczogJ3NwYXJrLXNlbGVjdF9fZmllbGQnLFxuICogICAgICdkYXRhLWF0dHInOiAndGhpbmcnLFxuICogICAgICBtdWx0aXBsZTogdHJ1ZVxuICogICB9LFxuICogICBzZWxlY3RlZDogWzIsIDRdLFxuICogICBvcHRpb25zOiBbXG4gKiAgICAge3RleHQ6ICdPbmUnLCB2YWx1ZTogMX0sXG4gKiAgICAge3RleHQ6ICdUd28nLCB2YWx1ZTogMn0sXG4gKiAgICAge3RleHQ6ICdUaHJlZScsIHZhbHVlOiAzfSxcbiAqICAgICB7dGV4dDogJ0ZvdXInLCB2YWx1ZTogNH0sXG4gKiAgICAge3RleHQ6ICdGaXZlJywgdmFsdWU6IDV9LFxuICogICBdXG4gKiB9KTtcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZm9ybS9idWlsZC1zZWxlY3QuanNcbiAqL1xuXG5mdW5jdGlvbiBidWlsZFNlbGVjdChwYXJhbXMpIHtcblxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGF0dHJzID0gcGFyYW1zLmF0dHJpYnV0ZXM7XG4gIHZhciBzZWxlY3RlZCA9IHBhcmFtcy5zZWxlY3RlZCBpbnN0YW5jZW9mIEFycmF5ID8gcGFyYW1zLnNlbGVjdGVkIDogcGFyYW1zLnNlbGVjdGVkID8gW3BhcmFtcy5zZWxlY3RlZF0gOiBbXTtcbiAgdmFyIG9wdHMgPSBwYXJhbXMub3B0aW9ucztcblxuICB2YXIgaSA9IHZvaWQgMDtcbiAgdmFyIGxlbiA9IG9wdHMubGVuZ3RoO1xuXG4gIC8vIFNldCBhdHRyaWJ1dGVzXG4gIGZvciAoaSBpbiBhdHRycykge1xuICAgIGVsLnNldEF0dHJpYnV0ZShpLCBhdHRyc1tpXSk7XG4gIH1cblxuICAvLyBBZGQgb3B0aW9uc1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoX3R5cGVvZihvcHRzW2ldKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGh0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCInICsgb3B0c1tpXS52YWx1ZSArICdcIiAnICsgKHNlbGVjdGVkLmluZGV4T2Yob3B0c1tpXS52YWx1ZSkgIT09IC0xID8gJ3NlbGVjdGVkJyA6ICcnKSArICc+JyArIG9wdHNbaV0udGV4dCArICc8L29wdGlvbj4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArIG9wdHNbaV0gKyAnXCIgJyArIChzZWxlY3RlZC5pbmRleE9mKG9wdHNbaV0pICE9PSAtMSA/ICdzZWxlY3RlZCcgOiAnJykgKyAnPicgKyBvcHRzW2ldICsgJzwvb3B0aW9uPic7XG4gICAgfVxuICB9XG5cbiAgZWwuaW5uZXJIVE1MID0gaHRtbDtcblxuICByZXR1cm4gZWw7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGJ1aWxkU2VsZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZC1zZWxlY3QuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZWFjaCA9IHJlcXVpcmUoJy4uL3V0aWwvZWFjaCcpO1xuXG52YXIgX2VhY2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFjaCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkcmVuKGVsLCBjaGlsZHJlbiwgZW1wdHkpIHtcblxuICBlbXB0eSA9IGVtcHR5ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGVtcHR5O1xuXG4gIGlmIChlbXB0eSkge1xuICAgIGVsLnRleHRDb250ZW50ID0gJyc7XG4gIH1cblxuICB2YXIgZG9tTGlzdCA9IGNoaWxkcmVuIGluc3RhbmNlb2Ygd2luZG93LkhUTUxDb2xsZWN0aW9uO1xuXG4gIGlmIChkb21MaXN0KSB7XG4gICAgd2hpbGUgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgZWwuYXBwZW5kQ2hpbGQoY2hpbGRyZW5bMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAoMCwgX2VhY2gyLmRlZmF1bHQpKGNoaWxkcmVuLCBmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMpIHtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0gLyoqXG4gICAqICMgQXBwZW5kIENoaWxkcmVuXG4gICAqIEFwcGVuZCBhbiBhcnJheSBvZiBjaGlsZHJlbiB0byBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtBcnJheX0gY2hpbGRyZW5cbiAgICogQHBhcmFtIHtCb29sZWFufSBlbXB0eSBFbXB0eSB0aGUgbm9kZSBiZWZvcmUgYWRkaW5nIGNoaWxkcmVuP1xuICAgKlxuICAgKiBAbW9kdWxlIGhlbHBlcnMvbWFuaXB1bGF0aW9uL2FwcGVuZC1jaGlsZHJlbi5qc1xuICAgKi9cblxuZXhwb3J0cy5kZWZhdWx0ID0gYXBwZW5kQ2hpbGRyZW47XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcGVuZC1jaGlsZHJlbi5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9vZmZzZXQyID0gcmVxdWlyZSgnLi4vZG9tL29mZnNldCcpO1xuXG52YXIgX29mZnNldDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vZmZzZXQyKTtcblxudmFyIF9ib3hQb3NpdGlvbiA9IHJlcXVpcmUoJy4vYm94LXBvc2l0aW9uJyk7XG5cbnZhciBfYm94UG9zaXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYm94UG9zaXRpb24pO1xuXG52YXIgX2RlYm91bmNlID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJvdW5jZScpO1xuXG52YXIgX2RlYm91bmNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlYm91bmNlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIyBBZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEFmZml4IG9uZSBlbGVtZW50IHRvIGFub3RoZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG5ldyBBZmZpeCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICBlbDogZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICB0YXJnZXRFbDogZWwyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgY2FyZXRFbDogZWwzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgYW5jaG9yWTogJ3RvcCcsIC8vICdtaWRkbGUnLCAnYm90dG9tJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgYW5jaG9yWDogJ2xlZnQnLCAvLyAnY2VudGVyJywgJ3JpZ2h0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIGhlbHBlcnMvcG9zaXRpb24vYWZmaXguanNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxudmFyIEFmZml4ID0gZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBTdG9yZSB0aGUgcmVmZXJlbmNlIGVsZW1lbnRzIGFuZCBwb3NpdGlvbi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBwYXJhbXNcbiAgICovXG4gIGZ1bmN0aW9uIEFmZml4KCkge1xuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFmZml4KTtcblxuICAgIHRoaXMuZWwgPSBwYXJhbXMuZWw7XG4gICAgdGhpcy50YXJnZXRFbCA9IHBhcmFtcy50YXJnZXRFbDtcbiAgICB0aGlzLmNhcmV0RWwgPSBwYXJhbXMuY2FyZXRFbDtcbiAgICB0aGlzLmFuY2hvclkgPSBwYXJhbXMuYW5jaG9yWSB8fCAndG9wJztcbiAgICB0aGlzLmFuY2hvclggPSBwYXJhbXMuYW5jaG9yWCB8fCAnY2VudGVyJztcbiAgICB0aGlzLmlzRml4ZWQgPSBwYXJhbXMuaXNGaXhlZCB8fCBmYWxzZTtcblxuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5faW5zZXJ0RWwoKTtcbiAgICB0aGlzLl9zZXRQb3NpdGlvbigpO1xuICAgIHRoaXMuX3VwZGF0ZURlYm91bmNlZCA9ICgwLCBfZGVib3VuY2UyLmRlZmF1bHQpKHRoaXMudXBkYXRlLmJpbmQodGhpcyksIDUwMCk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBsaXN0ZW5pbmcgYW5kIGNsZWFuIHVwIGV2ZW50IGxpc3RlbmVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIE9wdGlvbmFsXG4gICAqIEByZXR1cm4ge09iamVjdH0gdGhpc1xuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBpZiAoIXBhcmFtcy5rZWVwRWwpIHRoaXMuX3JlbW92ZUVsKCk7XG4gICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBwb3NpdGlvbi5cbiAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzXG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9zZXRQb3NpdGlvbigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMaXN0ZW4gZm9yIHdpbmRvdyByZXNpemVzIHRvIHVwZGF0ZSB0aGUgcG9zaXRpb24uXG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9vblJlc2l6ZUJvdW5kID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblNjcm9sbEJvdW5kID0gdGhpcy5fb25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemVCb3VuZCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsQm91bmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9yZW1vdmVFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemVCb3VuZCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsQm91bmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnNlcnQgdGhlIGVsZW1lbnQgaW50byB0aGUgRE9NLlxuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5faW5zZXJ0RWwgPSBmdW5jdGlvbiBfaW5zZXJ0RWwoKSB7XG4gICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYWZmaXhlZCcsICcnKTtcbiAgICB0aGlzLl9nZXRSb290RWwoKS5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gdGhlIERPTS5cbiAgICovXG5cblxuICBBZmZpeC5wcm90b3R5cGUuX3JlbW92ZUVsID0gZnVuY3Rpb24gX3JlbW92ZUVsKCkge1xuICAgIHRoaXMuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1hZmZpeGVkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBlbGVtZW50LlxuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5fc2V0UG9zaXRpb24gPSBmdW5jdGlvbiBfc2V0UG9zaXRpb24oKSB7XG5cbiAgICAvLyBGaXhlZCBwb3NpdGlvblxuICAgIHRoaXMuZWwuc3R5bGUuc2V0UHJvcGVydHkoJ3Bvc2l0aW9uJywgdGhpcy5pc0ZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZScsICdpbXBvcnRhbnQnKTtcblxuICAgIC8vIFRhcmdldCBlbGVtZW50IHByb3BlcnRpZXNcblxuICAgIHZhciBfb2Zmc2V0ID0gKDAsIF9vZmZzZXQzLmRlZmF1bHQpKHRoaXMudGFyZ2V0RWwsIHRoaXMuaXNGaXhlZCksXG4gICAgICAgIHRhcmdldFRvcCA9IF9vZmZzZXQudG9wLFxuICAgICAgICB0YXJnZXRMZWZ0ID0gX29mZnNldC5sZWZ0O1xuXG4gICAgdmFyIHRhcmdldFdpZHRoID0gdGhpcy50YXJnZXRFbC5vZmZzZXRXaWR0aDtcbiAgICB2YXIgdGFyZ2V0SGVpZ2h0ID0gdGhpcy50YXJnZXRFbC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAvLyBFbGVtZW50IHRvIGFmZml4IHByb3BlcnRpZXNcbiAgICB2YXIgZWxXaWR0aCA9IHRoaXMuZWwub2Zmc2V0V2lkdGg7XG4gICAgdmFyIGVsSGVpZ2h0ID0gdGhpcy5lbC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAvLyBNYXhlc1xuICAgIHZhciBkb2NIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIHZhciBkb2NXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRXaWR0aDtcblxuICAgIC8vIEdldCB0aGUgdmFsdWVzXG5cbiAgICB2YXIgX2NhbGN1bGF0ZVBvc2l0aW9uMiA9IHRoaXMuX2NhbGN1bGF0ZVBvc2l0aW9uKHtcbiAgICAgIGFuY2hvclg6IHRoaXMuYW5jaG9yWCxcbiAgICAgIGFuY2hvclk6IHRoaXMuYW5jaG9yWSxcbiAgICAgIHRhcmdldFRvcDogdGFyZ2V0VG9wLFxuICAgICAgdGFyZ2V0TGVmdDogdGFyZ2V0TGVmdCxcbiAgICAgIGVsSGVpZ2h0OiBlbEhlaWdodCxcbiAgICAgIGVsV2lkdGg6IGVsV2lkdGgsXG4gICAgICB0YXJnZXRIZWlnaHQ6IHRhcmdldEhlaWdodCxcbiAgICAgIHRhcmdldFdpZHRoOiB0YXJnZXRXaWR0aCxcbiAgICAgIG1pblg6IDAsXG4gICAgICBtaW5ZOiAwLFxuICAgICAgbWF4WDogZG9jV2lkdGggLSBlbFdpZHRoLFxuICAgICAgbWF4WTogTWF0aC5tYXgoZG9jSGVpZ2h0IC0gZWxIZWlnaHQsIDApXG4gICAgfSksXG4gICAgICAgIGVsVG9wID0gX2NhbGN1bGF0ZVBvc2l0aW9uMi5lbFRvcCxcbiAgICAgICAgZWxMZWZ0ID0gX2NhbGN1bGF0ZVBvc2l0aW9uMi5lbExlZnQ7XG5cbiAgICAvLyBQb3NpdGlvbiB0aGUgY2FyZXRcblxuXG4gICAgdmFyIF9wb3NpdGlvbkNhcmV0MiA9IHRoaXMuX3Bvc2l0aW9uQ2FyZXQoe1xuICAgICAgZWxMZWZ0OiBlbExlZnQsXG4gICAgICBlbFRvcDogZWxUb3AsXG4gICAgICBlbFdpZHRoOiBlbFdpZHRoLFxuICAgICAgZWxIZWlnaHQ6IGVsSGVpZ2h0LFxuICAgICAgdGFyZ2V0SGVpZ2h0OiB0YXJnZXRIZWlnaHQsXG4gICAgICB0YXJnZXRXaWR0aDogdGFyZ2V0V2lkdGgsXG4gICAgICB0YXJnZXRMZWZ0OiB0YXJnZXRMZWZ0LFxuICAgICAgdGFyZ2V0VG9wOiB0YXJnZXRUb3BcbiAgICB9KSxcbiAgICAgICAgZXh0cmFMZWZ0ID0gX3Bvc2l0aW9uQ2FyZXQyLmV4dHJhTGVmdCxcbiAgICAgICAgZXh0cmFUb3AgPSBfcG9zaXRpb25DYXJldDIuZXh0cmFUb3A7XG5cbiAgICAvLyBTZXQgdGhlIHBvc2l0aW9uXG5cblxuICAgIHRoaXMuZWwuc3R5bGUubGVmdCA9IGVsTGVmdCArIGV4dHJhTGVmdCArICdweCc7XG4gICAgdGhpcy5lbC5zdHlsZS50b3AgPSBlbFRvcCArIGV4dHJhVG9wICsgJ3B4JztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBwcm9wZXIgdG9wIHBvc2l0aW9uIGZvciBhbiBhbmNob3IgZGlyZWN0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHBcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5fY2FsY3VsYXRlUG9zaXRpb24gPSBmdW5jdGlvbiBfY2FsY3VsYXRlUG9zaXRpb24ocCkge1xuXG4gICAgLy8gS2VlcCB0cmFjayBvZiB3aGF0IHdlJ3JlIHRyeWluZyB0byBkbyBoZXJlLCBzbyBvbiBzdWJzZXF1ZW50LCBuZXN0ZWQgY2FsbHMgdG8gdGhpc1xuICAgIC8vIG1ldGhvZCB3ZSBjYW4gc2VlIHdoYXQgaGFzIGFscmVhZHkgYmVlbiB0cmllZC5cbiAgICBwLnByZXZpb3VzQXR0ZW1wdHMgPSAocC5wcmV2aW91c0F0dGVtcHRzIHx8IDApICsgMTtcbiAgICBwLnByZXZpb3VzQ2hlY2tzID0gcC5wcmV2aW91c0NoZWNrcyB8fCBbXTtcblxuICAgIHZhciBmaW5hbENoZWNrID0gcC5wcmV2aW91c0F0dGVtcHRzID4gMztcbiAgICB2YXIgdG9wID0gdm9pZCAwO1xuICAgIHZhciBsZWZ0ID0gdm9pZCAwO1xuXG4gICAgLy8gWS1heGlzIGNoZWNrXG4gICAgc3dpdGNoIChwLmFuY2hvclkpIHtcbiAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIHRvcCA9IHAudGFyZ2V0VG9wICsgcC50YXJnZXRIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgdG9wID0gcC50YXJnZXRUb3AgLSAocC5lbEhlaWdodCAtIHAudGFyZ2V0SGVpZ2h0KSAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdG9wID0gcC50YXJnZXRUb3AgLSBwLmVsSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBVbmRlciBtaW5cbiAgICBpZiAodG9wIDwgcC5taW5ZKSB7XG5cbiAgICAgIGlmICghZmluYWxDaGVjayAmJiBwLnByZXZpb3VzQ2hlY2tzLmluZGV4T2YoJ292ZXJZJykgPT09IC0xKSB7XG4gICAgICAgIHAucHJldmlvdXNDaGVja3MucHVzaCgndW5kZXJZJyk7XG4gICAgICAgIHAuYW5jaG9yWSA9IHRoaXMuX2dldE5ld0FuY2hvclkodHJ1ZSwgcC5hbmNob3JZLCBwLmFuY2hvclgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlUG9zaXRpb24ocCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3AgPSBwLm1pblk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgY2hlY2sgZm9yIGJlaW5nIHRvbyB0YWxsIGJlY2F1c2UgY2F1c2luZyBhIHZlcnRpY2FsIHNjcm9sbFxuICAgIC8vIGJhciBkb3duIGlzIG9rYXkgYW5kIHRoaXMgc2F2ZXMgdXMgZnJvbSBzb21lIHJlYWwgcG9zaXRpb25pbmcgaGVsbC5cbiAgICAvKmlmICh0b3AgPiBwLm1heFkpIHtcbiAgICAgICBpZiAoIWZpbmFsQ2hlY2sgJiYgcC5wcmV2aW91c0NoZWNrcy5pbmRleE9mKCd1bmRlclknKSA9PT0gLTEpIHtcbiAgICAgICAgcC5wcmV2aW91c0NoZWNrcy5wdXNoKCdvdmVyWScpO1xuICAgICAgICBwLmFuY2hvclkgPSB0aGlzLl9nZXROZXdBbmNob3JZKGZhbHNlLCBwLmFuY2hvclksIHAuYW5jaG9yWCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVQb3NpdGlvbihwKTtcbiAgICAgIH1cbiAgICAgIC8vIE9uIGEgZmluYWwgY2hlY2ssIGJvdHRvbSB3aW5zIGJlY2F1c2UgYXQgbGVhc3Qgd2UgY2FuIHNjcm9sbFxuICAgICAgZWxzZSBpZiAoIShmaW5hbENoZWNrICYmIHAuYW5jaG9yWSA9PT0gJ2JvdHRvbScpKSB7XG4gICAgICAgIHRvcCA9IHAubWF4WTtcbiAgICAgIH1cbiAgICB9Ki9cblxuICAgIC8vIFgtYXhpcyBjaGVja1xuICAgIHN3aXRjaCAocC5hbmNob3JYKSB7XG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGxlZnQgPSBwLnRhcmdldExlZnQgKyAocC5hbmNob3JZICE9PSAnbWlkZGxlJyAmJiAhcC5pc092ZXJsYXBwaW5nID8gMCA6IHAudGFyZ2V0V2lkdGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIGxlZnQgPSBwLnRhcmdldExlZnQgLSAocC5lbFdpZHRoIC0gcC50YXJnZXRXaWR0aCkgLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlZnQgPSBwLnRhcmdldExlZnQgLSBwLmVsV2lkdGggKyAocC5hbmNob3JZICE9PSAnbWlkZGxlJyA/IHAudGFyZ2V0V2lkdGggOiAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gVW5kZXIgbWluXG4gICAgaWYgKGxlZnQgPCBwLm1pblgpIHtcblxuICAgICAgaWYgKCFmaW5hbENoZWNrICYmIHAucHJldmlvdXNDaGVja3MuaW5kZXhPZignb3ZlclgnKSA9PT0gLTEpIHtcbiAgICAgICAgcC5wcmV2aW91c0NoZWNrcy5wdXNoKCd1bmRlclgnKTtcbiAgICAgICAgcC5hbmNob3JYID0gdGhpcy5fZ2V0TmV3QW5jaG9yWCh0cnVlLCBwLmFuY2hvclgsIHAuYW5jaG9yWSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVQb3NpdGlvbihwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnQgPSBwLm1pblg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3ZlciBtYXhcbiAgICBpZiAobGVmdCA+IHAubWF4WCkge1xuXG4gICAgICBpZiAoIWZpbmFsQ2hlY2sgJiYgcC5wcmV2aW91c0NoZWNrcy5pbmRleE9mKCd1bmRlclgnKSA9PT0gLTEpIHtcbiAgICAgICAgcC5wcmV2aW91c0NoZWNrcy5wdXNoKCdvdmVyWCcpO1xuICAgICAgICBwLmFuY2hvclggPSB0aGlzLl9nZXROZXdBbmNob3JYKGZhbHNlLCBwLmFuY2hvclgsIHAuYW5jaG9yWSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVQb3NpdGlvbihwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnQgPSBwLm1heFg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT25lIGVsZW1lbnQgaXMgY292ZXJpbmcgYW5vdGhlci4gVHJ5IHRvIGZpeCB0aGF0LCBidXQgYmFpbCBvdXQgYWZ0ZXIgZm91ciB0cmllcy5cbiAgICBpZiAoKDAsIF9ib3hQb3NpdGlvbjIuZGVmYXVsdCkoeyB3aWR0aDogcC5lbFdpZHRoLCBoZWlnaHQ6IHAuZWxIZWlnaHQsIGxlZnQ6IGxlZnQsIHRvcDogdG9wIH0sIHsgd2lkdGg6IHAudGFyZ2V0V2lkdGgsIGhlaWdodDogcC50YXJnZXRIZWlnaHQsIGxlZnQ6IHAudGFyZ2V0TGVmdCwgdG9wOiBwLnRhcmdldFRvcCB9KSA9PT0gJ292ZXJsYXAnKSB7XG5cbiAgICAgIHAuaXNPdmVybGFwcGluZyA9IHRydWU7XG5cbiAgICAgIC8vIFRyeSBZXG4gICAgICBpZiAocC5yZXBvc2l0aW9uWSAhPT0gZmFsc2UpIHtcblxuICAgICAgICAvLyBXaWxsIHN0YXJ0IHVuZGVmaW5lZCwgdGhlbiB0cnVlLCB0aGVuIGZhbHNlLiBUaGlzIGxpbWl0cyB1cyB0byBlbnRlcmluZ1xuICAgICAgICAvLyB0aGlzIGxvb3AgdHdpY2UsIG9uY2UgdG8gdHJ5IG1vdmluZyBpbiBlYWNoIGRpcmVjdGlvbi5cbiAgICAgICAgcC5yZXBvc2l0aW9uWSA9ICFwLnJlcG9zaXRpb25ZO1xuXG4gICAgICAgIC8vIEZpcnN0IHRyeSB0byBwdXQgYWJvdmUsIHRoZW4gdHJ5IHRvIHB1dCBiZWxvdy5cbiAgICAgICAgcC5hbmNob3JZID0gdGhpcy5fZ2V0TmV3QW5jaG9yWShwLnJlcG9zaXRpb25ZLCAnbWlkZGxlJywgcC5hbmNob3JYKTtcblxuICAgICAgICAvLyBHaXZlIHVzIG9uZSBtb3JlIHNob3QgYXQgcG9zaXRpb25pbmdcbiAgICAgICAgcC5wcmV2aW91c0F0dGVtcHRzLS07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZVBvc2l0aW9uKHApO1xuICAgICAgfVxuICAgICAgLy8gVHJ5IFhcbiAgICAgIGVsc2UgaWYgKHAucmVwb3NpdGlvblggIT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAvLyBXaWxsIHN0YXJ0IHVuZGVmaW5lZCwgdGhlbiB0cnVlLCB0aGVuIGZhbHNlLiBUaGlzIGxpbWl0cyB1cyB0byBlbnRlcmluZ1xuICAgICAgICAgIC8vIHRoaXMgbG9vcCB0d2ljZSwgb25jZSB0byB0cnkgbW92aW5nIGluIGVhY2ggZGlyZWN0aW9uLlxuICAgICAgICAgIHAucmVwb3NpdGlvblggPSAhcC5yZXBvc2l0aW9uWDtcblxuICAgICAgICAgIC8vIEZpcnN0IHRyeSB0byBwdXQgYWJvdmUsIHRoZW4gdHJ5IHRvIHB1dCBiZWxvdy5cbiAgICAgICAgICBwLmFuY2hvclggPSB0aGlzLl9nZXROZXdBbmNob3JYKHAucmVwb3NpdGlvblgsICdjZW50ZXInLCBwLmFuY2hvclkpO1xuXG4gICAgICAgICAgLy8gR2l2ZSB1cyBvbmUgbW9yZSBzaG90IGF0IHBvc2l0aW9uaW5nXG4gICAgICAgICAgcC5wcmV2aW91c0F0dGVtcHRzLS07XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlUG9zaXRpb24ocCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBlbFRvcDogdG9wLCBlbExlZnQ6IGxlZnQsIGFuY2hvclg6IHAuYW5jaG9yWCwgYW5jaG9yWTogcC5hbmNob3JZIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgbmV3IHktYXhpcyBhbmNob3JcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gdW5kZXJNaW4gVW5kZXIgdGhlIG1pbj9cbiAgICogQHBhcmFtICB7U3RyaW5nfSBhbmNob3JZXG4gICAqIEBwYXJhbSAge1N0cmluZ30gYW5jaG9yWFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9nZXROZXdBbmNob3JZID0gZnVuY3Rpb24gX2dldE5ld0FuY2hvclkodW5kZXJNaW4sIGFuY2hvclksIGFuY2hvclgpIHtcblxuICAgIC8vIElmIHRoZSB4LWF4aXMgaXMgYW5jaG9yZWQgaW4gdGhlIGNlbnRlciwgc2tpcFxuICAgIC8vIHRyeWluZyB0byBhbmNob3IgdG8gdGhlIG1pZGRsZSBiZWNhdXNlIHRoZW4gd2UnZFxuICAgIC8vIGJlIG92ZXJsYXlpbmcgdGhlIGJ1dHRvbi5cbiAgICBpZiAoYW5jaG9yWCA9PT0gJ2NlbnRlcicgfHwgYW5jaG9yWSA9PT0gJ21pZGRsZScpIHtcbiAgICAgIHJldHVybiB1bmRlck1pbiA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnbWlkZGxlJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgbmV3IHktYXhpcyBhbmNob3JcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gdW5kZXJNaW4gVW5kZXIgdGhlIG1pbj9cbiAgICogQHBhcmFtICB7U3RyaW5nfSBhbmNob3JZXG4gICAqIEBwYXJhbSAge1N0cmluZ30gYW5jaG9yWFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9nZXROZXdBbmNob3JYID0gZnVuY3Rpb24gX2dldE5ld0FuY2hvclgodW5kZXJNaW4sIGFuY2hvclgsIGFuY2hvclkpIHtcblxuICAgIC8vIElmIHRoZSB5LWF4aXMgaXMgYW5jaG9yZWQgaW4gdGhlIGNlbnRlciwgc2tpcFxuICAgIC8vIHRyeWluZyB0byBhbmNob3IgdG8gdGhlIG1pZGRsZSBiZWNhdXNlIHRoZW4gd2UnZFxuICAgIC8vIGJlIG92ZXJsYXlpbmcgdGhlIGJ1dHRvbi5cbiAgICBpZiAoYW5jaG9yWSA9PT0gJ21pZGRsZScgfHwgYW5jaG9yWCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHJldHVybiB1bmRlck1pbiA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnY2VudGVyJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIGNhcmV0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gcFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9wb3NpdGlvbkNhcmV0ID0gZnVuY3Rpb24gX3Bvc2l0aW9uQ2FyZXQoKSB7XG4gICAgdmFyIHAgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG5cbiAgICBpZiAoIXRoaXMuY2FyZXRFbCkgcmV0dXJuO1xuXG4gICAgdmFyIGNhcmV0UG9zaXRpb24gPSAoMCwgX2JveFBvc2l0aW9uMi5kZWZhdWx0KSh7IHdpZHRoOiBwLmVsV2lkdGgsIGhlaWdodDogcC5lbEhlaWdodCwgbGVmdDogcC5lbExlZnQsIHRvcDogcC5lbFRvcCB9LCB7IHdpZHRoOiBwLnRhcmdldFdpZHRoLCBoZWlnaHQ6IHAudGFyZ2V0SGVpZ2h0LCBsZWZ0OiBwLnRhcmdldExlZnQsIHRvcDogcC50YXJnZXRUb3AgfSk7XG5cbiAgICB2YXIgY2FyZXREaW1lbnNpb25zID0gdGhpcy5jYXJldEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBjYXJldFdpZHRoID0gY2FyZXREaW1lbnNpb25zLndpZHRoO1xuICAgIHZhciBjYXJldEhlaWdodCA9IGNhcmV0RGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgdmFyIGxlZnQgPSBNYXRoLm1pbihwLmVsV2lkdGgsIE1hdGgubWF4KDAsIHAudGFyZ2V0TGVmdCAtIHAuZWxMZWZ0ICsgcC50YXJnZXRXaWR0aCAvIDIpKTtcbiAgICB2YXIgdG9wID0gTWF0aC5taW4ocC5lbEhlaWdodCwgTWF0aC5tYXgoMCwgcC50YXJnZXRUb3AgLSBwLmVsVG9wICsgcC50YXJnZXRIZWlnaHQgLyAyKSk7XG5cbiAgICB0aGlzLmNhcmV0RWwuc3R5bGUubGVmdCA9IE1hdGgucm91bmQobGVmdCkgKyAncHgnO1xuICAgIHRoaXMuY2FyZXRFbC5zdHlsZS50b3AgPSBNYXRoLnJvdW5kKHRvcCkgKyAncHgnO1xuXG4gICAgdmFyIGV4dHJhTGVmdCA9IDA7XG4gICAgdmFyIGV4dHJhVG9wID0gMDtcblxuICAgIHRoaXMuY2FyZXRFbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcG9zaXRpb24nLCBjYXJldFBvc2l0aW9uKTtcblxuICAgIHN3aXRjaCAoY2FyZXRQb3NpdGlvbikge1xuICAgICAgY2FzZSAnYWJvdmUnOlxuICAgICAgICBleHRyYVRvcCA9IC1jYXJldFdpZHRoIC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdiZWxvdyc6XG4gICAgICAgIGV4dHJhVG9wID0gY2FyZXRXaWR0aCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGV4dHJhTGVmdCA9IC1jYXJldEhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZXh0cmFMZWZ0ID0gY2FyZXRIZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXh0cmFMZWZ0OiBleHRyYUxlZnQsXG4gICAgICBleHRyYVRvcDogZXh0cmFUb3BcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJvb3QgZWxlbWVudC4gV2FudCB0byBjaGVjayBpZiB0aGVyZSdzIGEgdG9wLWxldmVsIGZvcm0gZm9yIHdvcmtpbmdcbiAgICogd2l0aCBBU1AgLk5FVCBwYWdlcy5cbiAgICovXG5cblxuICBBZmZpeC5wcm90b3R5cGUuX2dldFJvb3RFbCA9IGZ1bmN0aW9uIF9nZXRSb290RWwoKSB7XG4gICAgdmFyIGZvcm0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5ID4gZm9ybScpO1xuICAgIHJldHVybiBmb3JtICYmIGZvcm0uZ2V0QXR0cmlidXRlKCdkYXRhLWFmZml4ZWQnKSA9PT0gbnVsbCA/IGZvcm0gOiBkb2N1bWVudC5ib2R5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBPbiByZXNpemUsIHVwZGF0ZSB0aGUgcG9zaXRpb24uXG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9vblJlc2l6ZSA9IGZ1bmN0aW9uIF9vblJlc2l6ZSgpIHtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSB3aW5kb3cgc2Nyb2xscywgZW5zdXJlIHRoZSBwcm9wZXIgcG9zaXRpb24gb2YgdGhlIHBvcG92ZXIuXG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9vblNjcm9sbCA9IGZ1bmN0aW9uIF9vblNjcm9sbCgpIHtcbiAgICB0aGlzLl91cGRhdGVEZWJvdW5jZWQoKTtcbiAgfTtcblxuICByZXR1cm4gQWZmaXg7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEFmZml4O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZmZpeC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGEsIGIpIHtcblxuICB2YXIgYVhTcGFuID0gYS5sZWZ0ICsgYS53aWR0aDtcbiAgdmFyIGFZU3BhbiA9IGEudG9wICsgYS5oZWlnaHQ7XG4gIHZhciBiWFNwYW4gPSBiLmxlZnQgKyBiLndpZHRoO1xuICB2YXIgYllTcGFuID0gYi50b3AgKyBiLmhlaWdodDtcblxuICBpZiAoYVhTcGFuIDw9IGIubGVmdCkgcmV0dXJuICdsZWZ0JzsgLy8gYSBpcyBmdWxseSBsZWZ0IG9mIGJcbiAgaWYgKGEubGVmdCA+PSBiWFNwYW4pIHJldHVybiAncmlnaHQnOyAvLyBhIGlzIGZ1bGx5IHJpZ2h0IG9mIGJcbiAgaWYgKGFZU3BhbiA8PSBiLnRvcCkgcmV0dXJuICdhYm92ZSc7IC8vIGEgaXMgZnVsbHkgYWJvdmUgYlxuICBpZiAoYS50b3AgPj0gYllTcGFuKSByZXR1cm4gJ2JlbG93JzsgLy8gYSBpcyBmdWxseSBiZWxvdyBiXG5cbiAgcmV0dXJuICdvdmVybGFwJzsgLy8gYm94ZXMgb3ZlcmxhcFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICMgQm94IFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogSG93IGlzIG9uZSBlbGVtZW50IHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gYW5vdGhlcj9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogYm94UG9zaXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICoge3dpZHRoOiAxMDAsIGhlaWdodDogMzAwLCBsZWZ0OiAwLCB0b3A6IDB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHt3aWR0aDogMjAwLCBoZWlnaHQ6IDUwLCBsZWZ0OiAxMDAsIHRvcDogNDB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBoZWxwZXJzL3Bvc2l0aW9uL2JveC1wb3NpdGlvbi5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJveC1wb3NpdGlvbi5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tYXRjaGVzID0gcmVxdWlyZSgnLi9tYXRjaGVzJyk7XG5cbnZhciBfbWF0Y2hlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRjaGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0UGFyZW50KHBhcmVudCwgcXVlcnksIGxpbWl0RWwpIHtcblxuICBsaW1pdEVsID0gbGltaXRFbCBpbnN0YW5jZW9mIEFycmF5ID8gbGltaXRFbCA6IFtsaW1pdEVsIHx8IGRvY3VtZW50LmJvZHldO1xuXG4gIHdoaWxlIChwYXJlbnQpIHtcblxuICAgIGlmICgoMCwgX21hdGNoZXMyLmRlZmF1bHQpKHBhcmVudCwgcXVlcnkpKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIGlmIChsaW1pdEVsLmluZGV4T2YocGFyZW50KSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLyoqXG4gICAqICMgR2V0IFBhcmVudFxuICAgKiBTZWUgaWYgYW4gZWxlbWVudCBoYXMgYW5vdGhlciBlbGVtZW50IGZvciBhIHBhcmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5XG4gICAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gbGltaXRFbCBUaGUgbGFzdCBlbGVtZW50IHdlIHNob3VsZCBjaGVjay5cbiAgICogQHJldHVybiB7Qm9vbGVhbnxFbGVtZW50fVxuICAgKlxuICAgKiBAbW9kdWxlIGhlbHBlcnMvdHJhdmVyc2FsL2dldC1wYXJlbnQuanNcbiAgICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGdldFBhcmVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXBhcmVudC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tYXRjaGVzID0gcmVxdWlyZSgnLi9tYXRjaGVzJyk7XG5cbnZhciBfbWF0Y2hlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRjaGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0U2libGluZ0FmdGVyKGVsLCBxdWVyeSkge1xuXG4gIHdoaWxlIChlbCA9IGVsLm5leHRFbGVtZW50U2libGluZykge1xuICAgIGlmICgoMCwgX21hdGNoZXMyLmRlZmF1bHQpKGVsLCBxdWVyeSkpIHtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0gLyoqXG4gICAqICMgR2V0IFNpYmxpbmcgQWZ0ZXJcbiAgICogR2V0IGEgbmVhcmVzdCBzaWJsaW5nIGFmdGVyIHRoZSBnaXZlbiBlbGVtZW50IHdoaWNoIG1hdGNoZXNcbiAgICogdGhlIGdpdmVuIHF1ZXJ5IHNlbGVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeVxuICAgKiBAcmV0dXJuIHtFbGVtZW50fE51bGx9XG4gICAqXG4gICAqIEBtb2R1bGUgaGVscGVycy90cmF2ZXJzYWwvZ2V0LXNpYmxpbmctYWZ0ZXIuanNcbiAgICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGdldFNpYmxpbmdBZnRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXNpYmxpbmctYWZ0ZXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWF0Y2hlcyA9IHJlcXVpcmUoJy4vbWF0Y2hlcycpO1xuXG52YXIgX21hdGNoZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0Y2hlcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldFNpYmxpbmdCZWZvcmUoZWwsIHF1ZXJ5KSB7XG5cbiAgd2hpbGUgKGVsID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgIGlmICgoMCwgX21hdGNoZXMyLmRlZmF1bHQpKGVsLCBxdWVyeSkpIHtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0gLyoqXG4gICAqICMgR2V0IFNpYmxpbmcgQmVmb3JlXG4gICAqIEdldCBhIG5lYXJlc3Qgc2libGluZyBiZWZvcmUgdGhlIGdpdmVuIGVsZW1lbnQgd2hpY2ggbWF0Y2hlc1xuICAgKiB0aGUgZ2l2ZW4gcXVlcnkgc2VsZWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5XG4gICAqIEByZXR1cm4ge0VsZW1lbnR8TnVsbH1cbiAgICpcbiAgICogQG1vZHVsZSBoZWxwZXJzL3RyYXZlcnNhbC9nZXQtc2libGluZy1iZWZvcmUuanNcbiAgICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGdldFNpYmxpbmdCZWZvcmU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1zaWJsaW5nLWJlZm9yZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIEhhcyBQYXJlbnRcbiAqIFNlZSBpZiBhbiBlbGVtZW50IGhhcyBhbm90aGVyIGVsZW1lbnQgZm9yIGEgcGFyZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gY2hpbGRcbiAqIEBwYXJhbSB7RWxlbWVudH0gcG9zc2libGVQYXJlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL3RyYXZlcnNhbC9oYXMtcGFyZW50LmpzXG4gKi9cbmZ1bmN0aW9uIGhhc1BhcmVudChjaGlsZCwgcG9zc2libGVQYXJlbnQpIHtcblxuICB2YXIgcGFyZW50ID0gY2hpbGQucGFyZW50Tm9kZTtcblxuICB3aGlsZSAocGFyZW50KSB7XG5cbiAgICBpZiAocGFyZW50ID09PSBwb3NzaWJsZVBhcmVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGhhc1BhcmVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXMtcGFyZW50LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIE1hdGNoZXNcbiAqIFNlZSBpZiBhbiBlbGVtZW50IG1hdGNoZXMgYSBxdWVyeSBzZWxlY3Rvci5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL3RyYXZlcnNhbC9tYXRjaGVzLmpzXG4gKi9cbnZhciB2ZW5kb3JNYXRjaCA9IHR5cGVvZiBFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAoRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5vTWF0Y2hlc1NlbGVjdG9yKTtcblxuZnVuY3Rpb24gbWF0Y2hlcyhlbCwgcXVlcnkpIHtcblxuICBpZiAodmVuZG9yTWF0Y2gpIHJldHVybiB2ZW5kb3JNYXRjaC5jYWxsKGVsLCBxdWVyeSk7XG5cbiAgdmFyIG5vZGVzID0gZWwucGFyZW50Tm9kZSA/IGVsLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChxdWVyeSkgOiBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5vZGVzW2ldID09PSBlbCkgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG1hdGNoZXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGNoZXMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBEZWJvdW5jZVxuICogRGVib3VuY2UgYSBmdW5jdGlvbiBjYWxsXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICogQHBhcmFtIHtJbnRlZ2VyfSBkZWxheVxuICpcbiAqIEBtb2R1bGUgaGVscGVycy91dGlsL2RlYm91bmNlLmpzXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIGRlbGF5KSB7XG5cbiAgdmFyIHRpbWVyID0gdm9pZCAwO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgaWYgKHRpbWVyKSB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB0aW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSwgZGVsYXkpO1xuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBkZWJvdW5jZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJvdW5jZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBFYWNoXG4gKiBBcHBseSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGEgbGlzdCBvZiBhbnkga2luZDogQXJyYXksIE5vZGVMaXN0LCBIVE1MQ29sbGVjdGlvbiBvciBPYmplY3QuXG4gKlxuICogQHBhcmFtIHtBcnJheXxOb2RlTGlzdHxIVE1MQ29sbGVjdGlvbnxPYmplY3R9IGxpc3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKlxuICogQGV4YW1wbGVcbiAqIGVhY2goW10sIGNhbGxiYWNrKTtcbiAqIGVhY2goZWwuY2hpbGRyZW4sIGNhbGxiYWNrKTtcbiAqIGVhY2goZWwuY2hpbGROb2RlcywgY2FsbGJhY2spO1xuICogZWFjaCh7fSwgY2FsbGJhY2spO1xuICpcbiAqIEBtb2R1bGUgaGVscGVycy91dGlsL2VhY2guanNcbiAqL1xuZnVuY3Rpb24gZWFjaChsaXN0LCBjYikge1xuXG4gIGlmICghbGlzdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2UgYGVhY2hgIHdpdGhvdXQgYSBjYWxsYmFjayEnKTtcbiAgfVxuXG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuXG4gIC8vIE9iamVjdFxuICBpZiAobGVuID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGkgaW4gbGlzdCkge1xuICAgICAgaWYgKGkgIT09ICdwcm90b3R5cGUnICYmIGxpc3QuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgY2IoaSwgbGlzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIEFycmF5LWxpa2VcbiAgZWxzZSB7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNiKGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZWFjaDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWFjaC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBQYWRcbiAqIFBhZCBhIG51bWJlciB3aXRoIGxlYWRpbmcgemVyb3NcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHBhcmFtIHtOdW1iZXJ9IHdcbiAqIEBwYXJhbSB7U3RyaW5nfSBjIE9wdGlvbmFsIFN0cmluZyB0byBwYWQgd2l0aFxuICpcbiAqIEBleGFtcGxlXG4gKiBwYWQoNCwgMik7XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL3V0aWwvcGFkLmpzXG4gKi9cbmZ1bmN0aW9uIHBhZChuLCB3LCBjKSB7XG4gIGMgPSBjIHx8ICcwJztcbiAgbiA9IG4gKyAnJztcbiAgcmV0dXJuIG4ubGVuZ3RoID49IHcgPyBuIDogbmV3IEFycmF5KHcgLSBuLmxlbmd0aCArIDEpLmpvaW4oYykgKyBuO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBwYWQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIFJhbmdlXG4gKiBDcmVhdGUgYSByYW5nZSBvZiBudW1iZXJzLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFxuICogQHBhcmFtIHtOdW1iZXJ9IHN0b3BcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwIE9wdGlvbmFsXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdXRpbC9yYW5nZS5qc1xuICovXG5mdW5jdGlvbiBjcmVhdGVSYW5nZShzdGFydCwgc3RvcCwgc3RlcCkge1xuICBpZiAoc3RvcCA9PSBudWxsKSB7XG4gICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIGlmICghc3RlcCkge1xuICAgIHN0ZXAgPSBzdG9wIDwgc3RhcnQgPyAtMSA6IDE7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICB2YXIgcmFuZ2UgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblxuICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgcmFuZ2VbaWR4XSA9IHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIHJhbmdlO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVSYW5nZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5nZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBUcmltXG4gKiBUcmltIHdoaXRlc3BhY2Ugb24gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICpcbiAqIEBtb2R1bGUgaGVscGVycy91dGlsL3RyaW0uanNcbiAqL1xuXG52YXIgdHJpbVJFID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UodHJpbVJFLCAnJyk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHRyaW07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyaW0uanMubWFwXG4iXX0="}