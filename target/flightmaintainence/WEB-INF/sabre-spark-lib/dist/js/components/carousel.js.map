{"version":3,"sources":["js/dist/components/node_modules/browser-pack/_prelude.js","js/dist/components/js/dist/components/base.js","js/dist/components/js/dist/components/carousel.js","js/dist/components/js/dist/helpers/css/transform.js","js/dist/components/js/dist/helpers/dom/add-class.js","js/dist/components/js/dist/helpers/dom/has-class.js","js/dist/components/js/dist/helpers/dom/remove-class.js","js/dist/components/js/dist/helpers/util/debounce.js","js/dist/components/js/dist/helpers/util/each.js","js/dist/components/js/dist/helpers/util/trim.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9pCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"carousel.js","sourcesContent":["(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _each = require('../helpers/util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * # Base Component\n                                                                                                                                                           * The base class for Spark JS components. This class should never be\n                                                                                                                                                           * instantiated directly.\n                                                                                                                                                           *\n                                                                                                                                                           * @param {Element} el\n                                                                                                                                                           * @param {Object} params\n                                                                                                                                                           *\n                                                                                                                                                           * @module components/base.js\n                                                                                                                                                           */\n\nvar noop = function noop() {};\n\nvar Base = function () {\n\n  /**\n   * Set parameters and cache elements.\n   */\n  function Base(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Base);\n\n    if (params.elRequired && !el) {\n      return;\n    }\n\n    this.setParams(this.defaults || {}, true);\n    this.setParams(params);\n    (this._cacheElements || noop).call(this, el, params);\n    (this._parseParams || noop).call(this);\n  }\n\n  /**\n   * Remove the component from the DOM and prepare for garbage collection by dereferencing values.\n   * @param {Boolean} leaveElement Leave the element intact.\n   */\n\n\n  Base.prototype.remove = function remove(leaveElement) {\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    if (!leaveElement && this.el && this.el.parentNode) {\n      this.el.parentNode.removeChild(this.el);\n    }\n\n    this.unsetParams(this.defaults);\n\n    return this;\n  };\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   * @param {Object} params Optional\n   */\n\n\n  Base.prototype.update = function update(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    (this._cacheElements || noop).call(this, el || this.el, params);\n    (this._parseParams || noop).call(this);\n\n    if (this._addEventListeners) {\n      this._addEventListeners();\n    }\n\n    return this;\n  };\n\n  /**\n   * Set a hash of parameters if they're whitelisted or we're told to force the set.\n   * This is used to set initial values as well as set passed parameters.\n   * @param {Object} params\n   * @param {Boolean} force Force setting even if the param is not whitelisted.\n   */\n\n\n  Base.prototype.setParams = function setParams(params, force) {\n    var _this = this;\n\n    (0, _each2.default)(params, function (k, v) {\n      if (_this._whitelistedParams.indexOf(k) !== -1 || force) {\n        _this[k] = v;\n      }\n    });\n\n    return this;\n  };\n\n  /**\n   * Unset all parameters.\n   * @param {Array|Object} keys\n   * @param {Object} scope The object to unset the params from. Defaults to `this`.\n   */\n\n\n  Base.prototype.unsetParams = function unsetParams(keys, scope) {\n\n    keys = keys instanceof Array ? keys : Object.keys(keys);\n    scope = scope || this;\n    (0, _each2.default)(keys, function (k) {\n      delete scope[k];\n    });\n\n    return this;\n  };\n\n  return Base;\n}();\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nBase.prototype._whitelistedParams = [];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nBase.prototype.defaults = {};\n\nexports.default = Base;\nmodule.exports = exports['default'];\n//# sourceMappingURL=base.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _base = require('./base');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _debounce = require('../helpers/util/debounce');\n\nvar _debounce2 = _interopRequireDefault(_debounce);\n\nvar _transform = require('../helpers/css/transform');\n\nvar _transform2 = _interopRequireDefault(_transform);\n\nvar _addClass = require('../helpers/dom/add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _removeClass = require('../helpers/dom/remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * # Carousel\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Create a Carousel\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @example\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * new Carousel(el);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module components/carousel.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\nvar Carousel = function (_BaseComponent) {\n  _inherits(Carousel, _BaseComponent);\n\n  /**\n   * Carousel constructor.\n   * @param {Element} el\n   * @param {Object} params\n   */\n  function Carousel(el, params) {\n    _classCallCheck(this, Carousel);\n\n    var _this = _possibleConstructorReturn(this, _BaseComponent.call(this, el, params));\n\n    params = params || {};\n\n    if (!el) {\n      return _possibleConstructorReturn(_this);\n    }\n\n    _this._init(el);\n    return _this;\n  }\n\n  /**\n   * Carousel Item Contructor, exposes access to functions setTransform, setSelected, and currentPosition\n   * @param {Element} el Node to initalize as carouselItem\n   * @param {Object} parent reference to the parent carousel\n   * @param {Element} dot Node to use as dot element\n   * @param {Number} order original order in the markup\n   */\n\n\n  Carousel.prototype._carouselItem = function _carouselItem(el, parent, dot, order) {\n    var a = {};\n    a.el = el;\n    a.parent = parent;\n    a.dot = dot;\n    a.order = order;\n    a.addTransform = function (x) {\n      a.setTransform(a.transform.x + x);\n    };\n    a.setTransform = function (x) {\n      x = x ? x : 0;\n      a.transform = {\n        'x': x\n      };\n      a.el.setAttribute('style', (0, _transform2.default)('translate3d', a.transform.x + 'px, 0px, 0px'));\n    };\n    a.setSelected = function (b) {\n      if (a.setSelected.selected === b && typeof a.setSelected.selected !== 'undefined') {\n        return;\n      }\n      if (b) {\n        (0, _addClass2.default)(a.el, 'selected');\n        (0, _addClass2.default)(a.dot, 'selected');\n        a.setSelected.selected = true;\n      } else {\n        (0, _removeClass2.default)(a.el, 'selected');\n        (0, _removeClass2.default)(a.dot, 'selected');\n        a.setSelected.selected = false;\n      }\n    };\n    a.currentPosition = function () {\n      return parent.transform.x + a.transform.x + a.dims.left + a.width / 2 - parent.dims.left;\n    };\n    a.setTransform();\n    a.dims = el.getBoundingClientRect();\n    a.width = a.dims.width;\n    a.el.sparkcarouselitem = a;\n    a.dot.sparkcarouselitemdot = a;\n    return a;\n  };\n\n  /**\n   * Scans element and sets up or resets the carousel based on configuration\n   * @param {Element} el Node to initalize as the carousel\n   */\n\n\n  Carousel.prototype._init = function _init(el) {\n    //cache elements and controls\n    this.el = el;\n    this.el.sparkcarousel = this;\n    this.backe = this.el.querySelector('.spark-carousel__back');\n    this.forwarde = this.el.querySelector('.spark-carousel__forward');\n    this.outerContainer = this.el.querySelector('.spark-carousel__outer-container');\n    this.containerMask = this.el.querySelector('.spark-carousel__container-mask');\n    this.container = this.el.querySelector('.spark-carousel__container');\n    this.dots = this.el.querySelector('.spark-carousel__dots');\n    this.pauseEl = this.el.querySelector('.spark-carousel__pause');\n    //get the options from the element\n    this.opts = {};\n    this.opts.wrapItems = this.el.attributes['data-spark-carousel-wrap-items'] ? true : false;\n    this.opts.startingVelocity = this.el.attributes['data-spark-carousel-scroll-velocity'] ? this.el.attributes['data-spark-carousel-scroll-velocity'].value : 10;\n    this.opts.smoothScroll = this.el.attributes['data-spark-carousel-smooth-scroll'] ? true : false;\n    this.opts.smoothScrollCenterItems = this.el.attributes['data-spark-carousel-smooth-scroll-center'] ? true : false;\n    this.opts.panelScroll = this.el.attributes['data-spark-carousel-panel'] ? true : false;\n    this.opts.edgeScroll = this.opts.panelScroll || this.el.attributes['data-spark-carousel-edge'] ? true : false;\n    this.opts.autoAdvance = this.el.attributes['data-spark-carousel-auto-advance'] ? this.el.attributes['data-spark-carousel-auto-advance'].value : false;\n    //setup autoAdvance\n    if (this.opts.autoAdvance && !this.autoAdvance && !this.pause) {\n      this.autoAdvance = window.setTimeout(function () {\n        this._autoAdvance();\n      }.bind(this), this.opts.autoAdvance * 1000);\n    }\n    //conditionally bind pause handlers.\n    //needs to be done here so that resetting the carousel will work correctly\n    if (this.opts.autoAdvance && !this.pauseH) {\n      this.pauseH = this._pause.bind(this);\n      this.pauseEl.addEventListener('click', this.pauseH);\n    }\n    //collect items and cache sizing\n    var a = this.el.querySelectorAll('.spark-carousel__item');\n    this.items = [];\n    this.totalItemWidth = 0;\n    this.dims = this.containerMask.getBoundingClientRect();\n    this.width = this.dims.width;\n    this.height = this.dims.height;\n    var dots = document.createDocumentFragment();\n    var b;\n    //create our carouselItems\n    for (var i = 0; i < a.length; i++) {\n      b = document.createElement('div');\n      dots.appendChild(b);\n      this.items.push(new this._carouselItem(a[i], this, b, i));\n      this.totalItemWidth += this.items[i].width;\n    }\n    //if we're resetting we need to empty out the exisiting elements first\n    while (this.dots.firstChild) {\n      this.dots.removeChild(this.dots.firstChild);\n    }\n    this.dots.appendChild(dots);\n    //this is to test if we're dealing with 2011 flexbox (IE10) and need to do an adjustment\n    //this is because ms-flex-pack: center doesn't work like 2012 flexbox center-pack\n    if (typeof this.container.style.msFlexAlign !== 'undefined') {\n      this._transformItems(-(this.totalItemWidth - this.width) / 2);\n    }\n    //setup inital transform\n    this._setTransform();\n    //need to bind this event handler here as we are always going to need to be listening\n    //for this event, in order to react to container visibility changing\n    this._handleVisibleChildren = this._handleVisibleChildrenH.bind(this);\n    document.addEventListener('spark.visible-children', this._handleVisibleChildren, true);\n    if (!this._rafHandler) {\n      this._rafHandler = this._rafHandlerH.bind(this);\n    }\n    //need to also listen to resize events, even if we don't have items overflowing\n    if (!this.resizeH) {\n      this.resizeH = (0, _debounce2.default)(this._resize.bind(this), 100);\n      window.addEventListener('resize', this.resizeH);\n    }\n    //if we haven't already init'd event listerers, and we have items overflowing\n    if (this.totalItemWidth > this.width) {\n      if (!this.touchstartH) {\n        (0, _removeClass2.default)(this.el, 'noscroll');\n        this._setupListeners();\n        //center the first item\n        this._addTransform(-this.items[0].currentPosition() + this.width / 2);\n      }\n    }\n    //if we don't have overflowing items, then disable scrolling and remove listeners\n    else {\n        (0, _addClass2.default)(this.el, 'noscroll');\n        this._removeListeners();\n      }\n    //set the new selected item\n    this._updateSelected();\n    //finally, display the element\n    (0, _addClass2.default)(this.el, 'ready');\n  };\n\n  /**\n   * Tears down the component, removes listeners, and conditionally delete the DOM element\n   * @param {Boolean} leaveElement Falsey value will remove the DOM element as well as the component instance\n   */\n\n\n  Carousel.prototype.remove = function remove(leaveElement) {\n    window.removeEventListener('resize', this.resizeH);\n    delete this.resizeH;\n    document.removeEventListener('spark.visible-children', this._handleVisibleChildren, true);\n    delete this._handleVisibleChildren;\n    _BaseComponent.prototype.remove.call(this, leaveElement);\n  };\n\n  /**\n   * Pause/unpause the autoAdvance feature\n   */\n\n\n  Carousel.prototype._pause = function _pause() {\n    if (this.pause) {\n      delete this.moves;\n      this.autoAdvance = window.setTimeout(function () {\n        this._autoAdvance();\n      }.bind(this), this.opts.autoAdvance * 1000);\n    } else {\n      this._rafCancel();\n      if (!this.opts.smoothScroll || this.opts.smoothScrollCenterItems) {\n        this._scrollTo(this._selectedItem());\n      }\n      window.clearTimeout(this.autoAdvance);\n      delete this.autoAdvance;\n    }\n    this._setPause(!this.pause);\n  };\n\n  /**\n   * toggles the pause class on the element\n   * @param {Boolean} b Truthy value will give the element the pause class\n   */\n\n\n  Carousel.prototype._setPause = function _setPause(b) {\n    if (typeof b === 'undefined') {\n      this.pause = typeof this.pause === 'undefined' ? false : this.pause;\n      return this.pause;\n    } else {\n      if (b) {\n        (0, _addClass2.default)(this.el, 'pause');\n      } else {\n        (0, _removeClass2.default)(this.el, 'pause');\n      }\n      this.pause = b;\n      return this.pause;\n    }\n  };\n\n  /**\n   * function called by window.setTimeout, will check first to see if element is in use before triggering a slide advance\n   */\n\n\n  Carousel.prototype._autoAdvance = function _autoAdvance() {\n    if (!this.moves && !this._laststart && !this.paused) {\n      this._rafCancel();\n      var a = this.items.indexOf(this._selectedItem());\n      this._scrollToItem = true;\n      this._scrollTo(this.items[a === this.items.length - 1 ? 0 : a + 1]);\n      this.autoAdvance = window.setTimeout(function () {\n        this._autoAdvance();\n      }.bind(this), this.opts.autoAdvance * 1000);\n    }\n  };\n\n  /**\n   * initalize and bind even listeners\n   */\n\n\n  Carousel.prototype._setupListeners = function _setupListeners() {\n    this.touchstartH = this._touchstart.bind(this);\n    this.container.addEventListener('touchstart', this.touchstartH);\n    this.touchmoveH = this._touchmove.bind(this);\n    window.addEventListener('touchmove', this.touchmoveH);\n    this.touchendH = this._touchend.bind(this);\n    window.addEventListener('touchend', this.touchendH);\n    this.mousedownH = this._mousedown.bind(this);\n    this.container.addEventListener('mousedown', this.mousedownH);\n    this.mousemoveH = this._mousemove.bind(this);\n    window.addEventListener('mousemove', this.mousemoveH);\n    this.mouseupH = this._mouseup.bind(this);\n    window.addEventListener('mouseup', this.mouseupH);\n    this.forwardH = this._forward.bind(this);\n    this.forwarde.addEventListener('click', this.forwardH);\n    this.backH = this._back.bind(this);\n    this.backe.addEventListener('click', this.backH);\n    this.clickH = this._click.bind(this);\n    this.el.addEventListener('click', this.clickH);\n    this._focusHandler = this._scrollToClicked.bind(this);\n    this.container.addEventListener('focus', this._focusHandler, true);\n  };\n\n  /**\n   * Removes non-essential event listeners, called when tearing down the component, or our content\n   * does not exceed the width of our element\n   */\n\n\n  Carousel.prototype._removeListeners = function _removeListeners() {\n    this.el.removeEventListener('touchstart', this.touchstartH);\n    delete this.touchstartH;\n    window.removeEventListener('touchmove', this.touchmoveH);\n    delete this.touchmoveH;\n    window.removeEventListener('touchend', this.touchendH);\n    delete this.touchendH;\n    this.el.removeEventListener('mousedown', this.mousedownH);\n    delete this.mousedownH;\n    window.removeEventListener('mousemove', this.mousemoveH);\n    delete this.mousemoveH;\n    window.removeEventListener('mouseup', this.mouseupH);\n    delete this.mouseupH;\n    this.forwarde.removeEventListener('click', this.forwardH);\n    delete this.forwardH;\n    this.backe.removeEventListener('click', this.backH);\n    delete this.backH;\n    this.el.removeEventListener('click', this.clickH);\n    delete this.clickH;\n    this.container.removeEventListener('focus', this._focusHandler, true);\n    delete this._focusHandler;\n    if (this.pauseEl) {\n      this.pauseEl.removeEventListener('click', this.pauseH);\n      delete this.pauseH;\n    }\n  };\n\n  /**\n   * Event handler for the spark.visible-children event, just call the change function to handle any\n   * visibility or sizing changes\n   * @param {Event} e The spark.visible-children event\n   */\n\n\n  Carousel.prototype._handleVisibleChildrenH = function _handleVisibleChildrenH(e) {\n    if (e.target.contains(this.el)) {\n      window.setTimeout(function () {\n        this.change();\n      }.bind(this), 0);\n    }\n  };\n\n  /**\n   * Forward button click handler triggers a scrollTo to the \"next\" element\n   * @param {Event} e The click event\n   */\n\n\n  Carousel.prototype._forward = function _forward(e) {\n    var s = this.items.indexOf(this._selectedItem());\n    s++;\n    if (s > this.items.length - 1) {\n      if (this.opts.wrapItems) {\n        s = 0;\n      } else {\n        s--;\n      }\n    }\n    delete this.moves;\n    var a = this._startingVelocity;\n    a = a < -this.opts.startingVelocity ? a : -this.opts.startingVelocity;\n    this._rafCancel();\n    this._scrollToItem = true;\n    this._scrollTo(this.items[s], a);\n    if (e) {\n      e.preventDefault();\n    }\n  };\n\n  /**\n   * Back button click handler triggers a scrollTo to the \"previous\" element\n   * @param {Event} e The click event\n   */\n\n\n  Carousel.prototype._back = function _back(e) {\n    var s = this.items.indexOf(this._selectedItem());\n    s--;\n    if (s < 0) {\n      if (this.opts.wrapItems) {\n        s = this.items.length - 1;\n      } else {\n        s++;\n      }\n    }\n    delete this.moves;\n    var a = this._startingVelocity;\n    a = a > this.opts.startingVelocity ? a : this.opts.startingVelocity;\n    this._rafCancel();\n    this._scrollToItem = true;\n    this._scrollTo(this.items[s], a);\n    if (e) {\n      e.preventDefault();\n    }\n  };\n\n  /**\n   * Move start handler, handles both touchstart and mousedown events\n   * @param {Object} e The start event\n   */\n\n\n  Carousel.prototype._movestart = function _movestart(e) {\n    this._rafCancel();\n    this.moves = [];\n    this.moves.push(e);\n  };\n\n  /**\n   * Move handler, handles internal move event objects\n   * @param {Object} e The move event\n   */\n\n\n  Carousel.prototype._move = function _move(e) {\n    if (this.moves && this.moves.length > 1) {\n      this._addTransform(e.pageX - this.moves[this.moves.length - 1].pageX);\n      this.moves.push(e);\n      e.preventDefault = true;\n    } else {\n      if (this.moves && this.moves[0]) {\n        if (Math.abs(this.moves[0].pageX - e.pageX) > Math.abs(this.moves[0].pageY - e.pageY) && Math.abs(this.moves[0].pageX - e.pageX) > 5 && e.cancelable) {\n          this._addTransform(e.pageX - this.moves[0].pageX);\n          this.moves.push(e);\n          e.preventDefault = true;\n        } else {\n          if (Math.abs(this.moves[0].pageX - e.pageX) > 5) {\n            this.moves[0] = e;\n          }\n        }\n      }\n      if (e.type === 'touchend' || e.type === 'mouseup') {\n        delete this.moves;\n      }\n    }\n  };\n\n  /**\n   * Move end handler, handles both touchend and mouseup events\n   * @param {Object} e The moveend event\n   */\n\n\n  Carousel.prototype._moveend = function _moveend(e) {\n    this._move(e);\n    if (!this.opts.smoothScroll) {\n      this._settle(this.moves);\n    } else {\n      this._interiaScroll(this.moves);\n    }\n    return e;\n  };\n\n  /**\n   * Resize event handler, calls change to handle any element dimension changes\n   */\n\n\n  Carousel.prototype._resize = function _resize() {\n    this.change();\n  };\n\n  /**\n   * Calling the change function will handle updating the element to take into account\n   * any styling, sizing, or visibility changes, and the addition or removal of any carouselItems\n   */\n\n\n  Carousel.prototype.change = function change() {\n    var dims = this.el.getBoundingClientRect();\n    if (dims.width !== this.width || dims.height !== this.height) {\n      if (this.autoAdvance) {\n        window.clearTimeout(this.autoAdvance);\n        delete this.autoAdvance;\n      }\n      this._rafCancel();\n      var c = this._selectedItem();\n      this._setTransform(0);\n      this._setTransformItems(0);\n      this._init(this.el);\n      if (this.items.indexOf(c.el.sparkcarouselitem) > -1 && this.totalItemWidth > this.width) {\n        if (this.opts.wrapItems) {\n          this._addTransform(-this.totalItemWidth + (-c.el.sparkcarouselitem.currentPosition() + this.width / 2));\n        } else {\n          this._addTransform(-c.el.sparkcarouselitem.currentPosition() + this.width / 2);\n        }\n      }\n    }\n  };\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   */\n\n\n  Carousel.prototype.update = function update(el) {\n\n    el = el || this.el;\n\n    this._removeListeners();\n    window.removeEventListener('resize', this.resizeH);\n    delete this.resizeH;\n    document.removeEventListener('spark.visible-children', this._handleVisibleChildren, true);\n    delete this._handleVisibleChildren;\n    this._init(el);\n\n    this.change();\n\n    return this;\n  };\n\n  /**\n   * Touchstart event handler, passes necessary data points to the movestart function\n   * @param {Object} e The touchstart event\n   */\n\n\n  Carousel.prototype._touchstart = function _touchstart(e) {\n    var a = {\n      'type': e.type,\n      'pageX': e.touches[0].pageX,\n      'pageY': e.touches[0].pageY,\n      'timeStamp': e.timeStamp\n    };\n    this._movestart(a);\n  };\n\n  /**\n   * Touchmove event handler, passes necessary data points to the move function\n   * @param {Object} e The touchmove event\n   */\n\n\n  Carousel.prototype._touchmove = function _touchmove(e) {\n    var a = {\n      'type': e.type,\n      'pageX': e.touches[0].pageX,\n      'pageY': e.touches[0].pageY,\n      'timeStamp': e.timeStamp,\n      'cancelable': e.cancelable\n    };\n    this._move(a);\n    if (a.preventDefault) {\n      e.preventDefault();\n    }\n  };\n\n  /**\n   * Touchend event handler, passes necessary data points to the moveend function\n   * @param {Object} e The touchend event\n   */\n\n\n  Carousel.prototype._touchend = function _touchend(e) {\n    if (this.moves && this.moves.length > 2 && e.cancelable) {\n      var a = {\n        'type': e.type,\n        'pageX': this.moves[this.moves.length - 1].pageX,\n        'pageY': this.moves[this.moves.length - 1].pageY,\n        'timeStamp': e.timeStamp\n      };\n      this._moveend(a);\n    } else {\n      delete this.moves;\n    }\n  };\n\n  /**\n   * Mousedown event handler, passes necessary data points to the movestart function\n   * @param {Object} e The mousedown event\n   */\n\n\n  Carousel.prototype._mousedown = function _mousedown(e) {\n    if (e.button !== 0) {\n      return e;\n    }\n    this.isMouseDown = true;\n    var a = {\n      'type': e.type,\n      'pageX': e.pageX,\n      'pageY': e.pageY,\n      'timeStamp': e.timeStamp\n    };\n    this._movestart(a);\n    e.preventDefault();\n  };\n\n  /**\n   * Mousemove event handler, passes necessary data points to the move function\n   * @param {Object} e The mousemove event\n   */\n\n\n  Carousel.prototype._mousemove = function _mousemove(e) {\n    if (this.isMouseDown) {\n      var a = {\n        'type': e.type,\n        'pageX': e.clientX,\n        'pageY': e.clientY,\n        'timeStamp': e.timeStamp,\n        //this was changed to correct an issue in safari - it doesn't report cancelable correctly\n        'cancelable': true\n      };\n      this._move(a);\n      if (a.preventDefault) {\n        e.preventDefault();\n      }\n    }\n  };\n\n  /**\n   * Mouseup event handler, passes necessary data points to the moveend function\n   * @param {Object} e The mouseup event\n   */\n\n\n  Carousel.prototype._mouseup = function _mouseup(e) {\n    if (this.moves && this.moves.length > 2) {\n      var a = {\n        'type': e.type,\n        'pageX': e.pageX,\n        'pageY': e.pageY,\n        'timeStamp': e.timeStamp\n      };\n      this._moveend(a);\n      this.mouseUpHandled = true;\n    } else {\n      delete this.moves;\n      this._scrollToClicked(e);\n    }\n    this.isMouseDown = false;\n  };\n\n  /**\n   * Click event handler\n   * @param {Object} e The click event\n   */\n\n\n  Carousel.prototype._click = function _click(e) {\n    //if we are already tracking moves, then this will be handled by the mouseend event handler and we should prevent the default action\n    if (this.moves) {\n      e.preventDefault();\n    }\n    //if it has already been handled by mouseup handler, prevent the action\n    if (this.mouseUpHandled) {\n      e.preventDefault();\n    }\n    //reset our handled state\n    delete this.mouseUpHandled;\n    //checking both this.moves and this.mouseUpHandled ensures we capture events correctly in all browsers, where the order of the mouseup/click events can vary\n  };\n\n  /**\n   * Calculate the user's recent cursor/finger velocity\n   * @param {Array} moves The array of cursor positions\n   */\n\n\n  Carousel.prototype._velocity = function _velocity(moves) {\n    var avg = 0;\n    var m = Math.min(6, moves.length - 1);\n    for (var i = 1; i < m; i++) {\n      if (moves[moves.length - i].timeStamp === moves[moves.length - i - 1].timeStamp) {\n        avg += avg / i;\n      } else {\n        avg += 10 * (moves[moves.length - i].pageX - moves[moves.length - i - 1].pageX) / (moves[moves.length - i].timeStamp - moves[moves.length - i - 1].timeStamp) / m;\n      }\n    }\n    return avg;\n  };\n\n  /**\n   * Handles click events on items and dots, scrolling to the clicked item\n   * @param {Event} e The click event\n   */\n\n\n  Carousel.prototype._scrollToClicked = function _scrollToClicked(e) {\n    var tar = e.target;\n    if (this.el.contains(tar)) {\n      while (!tar.sparkcarousel) {\n        if (tar.sparkcarouselitem) {\n          this.containerMask.scrollLeft = 0;\n          delete this.moves;\n          this._rafCancel();\n          this._scrollTo(tar.sparkcarouselitem);\n          e.preventDefault();\n          break;\n        }\n        if (tar.sparkcarouselitemdot) {\n          this.containerMask.scrollLeft = 0;\n          delete this.moves;\n          this._rafCancel();\n          var v = tar.sparkcarouselitemdot.order < this._selectedItem().order ? this.opts.startingVelocity : -this.opts.startingVelocity;\n          this._scrollTo(tar.sparkcarouselitemdot, v);\n          e.preventDefault();\n          break;\n        }\n        tar = tar.parentNode;\n      }\n    }\n  };\n\n  /**\n   * Scroll to the carouselItem, with specified startingVelocity, auto determines default velocity if not specified\n   * @param {Object} item The carouselItem to scroll to\n   * @param {Number} startingVelocity The startingVelocity of the scroll animation\n   */\n\n\n  Carousel.prototype._scrollTo = function _scrollTo(item, startingVelocity) {\n    var offset = this.width / 2;\n    var currentPosition = item.currentPosition();\n    if (!startingVelocity) {\n      startingVelocity = offset - item.currentPosition() > 0 ? this.opts.startingVelocity : -this.opts.startingVelocity;\n    }\n    if (this.opts.wrapItems) {\n      if (startingVelocity > 0) {\n        //left\n        if (currentPosition > offset) {\n          this._totalDistance = offset + this.totalItemWidth - currentPosition;\n        } else {\n          this._totalDistance = offset - currentPosition;\n        }\n      } else {\n        //right\n        if (currentPosition < offset) {\n          this._totalDistance = -(this.totalItemWidth + currentPosition - offset);\n        } else {\n          this._totalDistance = offset - currentPosition;\n        }\n      }\n    } else {\n      this._totalDistance = offset - currentPosition;\n    }\n    this._startingVelocity = startingVelocity;\n    delete this.moves;\n    this._scrollToItem = true;\n    this._raf = window.requestAnimationFrame(this._rafHandler);\n  };\n\n  /**\n   * This is the animator function, it examines the options set on the carousel object\n   * and selectively adds transform and requests addtional animation frames if necesary\n   * @param {Number} t The timestamp for the current animation frame\n   */\n\n\n  Carousel.prototype._rafHandlerH = function _rafHandlerH(t) {\n    if (this.opts.autoAdvance && this.autoAdvance) {\n      window.clearTimeout(this.autoAdvance);\n      delete this.autoAdvance;\n    }\n    var frames;\n    if (this.moves || !this._startingVelocity) {\n      this._rafCancel();\n      return;\n    }\n    if (!this._laststart) {\n      this._laststart = t;\n    }\n    if (!this._remainingDistance) {\n      this._remainingDistance = this._totalDistance;\n    }\n    if (!this._lastframe) {\n      this._lastframe = t;\n      frames = 1;\n    } else {\n      frames = (t - this._lastframe) / (1 / 60 * 1000);\n    }\n    var d = this._startingVelocity * frames;\n    if (this.opts.smoothScroll && !this._scrollToItem) {\n      this._addTransform(d);\n      this._startingVelocity *= Math.pow(0.97, frames);\n      if (this.opts.smoothScrollCenterItems && Math.abs(this._startingVelocity) < 1) {\n        this._scrollTo(this._selectedItem());\n      }\n      if (Math.abs(this._startingVelocity) < 0.5) {\n        if (this._startingVelocity > 0 && this.transform.x > this.totalItemWidth / 2 - this.items[0].width / 2 || this._startingVelocity < 0 && this.transform.x < -(this.totalItemWidth / 2 - this.items[this.items.length - 1].width / 2)) {\n          this._scrollToItem = true;\n          this._scrollTo(this._selectedItem());\n        } else {\n          this._rafCancel();\n        }\n      } else {\n        this._raf = window.requestAnimationFrame(this._rafHandler);\n      }\n    } else {\n      if (this._startingVelocity > 0) {\n        if (d < this._remainingDistance) {\n          this._addTransform(d);\n          this._remainingDistance -= d;\n          if (this._remainingDistance > this._totalDistance / 2) {\n            this._startingVelocity *= Math.pow(1.15, frames);\n          } else {\n            this._startingVelocity *= Math.pow(0.9, frames);\n            this._startingVelocity = this._startingVelocity > 2 ? this._startingVelocity : 2;\n          }\n          this._raf = window.requestAnimationFrame(this._rafHandler);\n        } else {\n          this._addTransform(this._remainingDistance);\n          this._rafCancel();\n        }\n      } else {\n        if (d > this._remainingDistance) {\n          this._addTransform(d);\n          this._remainingDistance -= d;\n          if (this._remainingDistance < this._totalDistance / 2) {\n            this._startingVelocity *= Math.pow(1.15, frames);\n          } else {\n            this._startingVelocity *= Math.pow(0.9, frames);\n            this._startingVelocity = this._startingVelocity < -2 ? this._startingVelocity : -2;\n          }\n          this._raf = window.requestAnimationFrame(this._rafHandler);\n        } else {\n          this._addTransform(this._remainingDistance);\n          this._rafCancel();\n        }\n      }\n    }\n    this._lastframe = t;\n  };\n\n  /**\n   * This is the animator clearing function\n   * it clears values used during animation, and selectively enables autoAdvance\n   */\n\n\n  Carousel.prototype._rafCancel = function _rafCancel() {\n    if (this.opts.autoAdvance && !this.autoAdvance && !this.pause) {\n      this.autoAdvance = window.setTimeout(function () {\n        this._autoAdvance();\n      }.bind(this), this.opts.autoAdvance * 1000);\n    }\n    window.cancelAnimationFrame(this._raf);\n    delete this._scrollToItem;\n    delete this._laststart;\n    delete this._startingVelocity;\n    delete this._remainingDistance;\n    delete this._totalDistance;\n    delete this._lastframe;\n  };\n\n  /**\n   * This computes values necessary to start an animation frame when the carousel is\n   * configured to use smoothScroll\n   * @param {Array} moves The captured move events\n   */\n\n\n  Carousel.prototype._interiaScroll = function _interiaScroll(moves) {\n    if (moves[moves.length - 1].timeStamp - moves[moves.length - 2].timeStamp > 100 || moves.length < 3) {\n      if (this.opts.smoothScrollCenterItems) {\n        return this._scrollTo(this._selectedItem());\n      }\n      return;\n    }\n    this._startingVelocity = this._velocity(moves);\n    delete this.moves;\n    this._raf = window.requestAnimationFrame(this._rafHandler);\n  };\n\n  /**\n   * This determines which carousel item should be focused based on the previous moves\n   * made by the user\n   * @param {Array} moves The captured move events\n   */\n\n\n  Carousel.prototype._settle = function _settle(moves) {\n    if (moves && moves.length > 3) {\n      if (moves[moves.length - 1].timeStamp - moves[moves.length - 2].timeStamp > 80) {\n        return this._scrollTo(this._selectedItem());\n      }\n      var v1 = 10 * (moves[moves.length - 3].pageX - moves[moves.length - 4].pageX) / (moves[moves.length - 3].timeStamp - moves[moves.length - 4].timeStamp);\n      var v2 = 10 * (moves[moves.length - 2].pageX - moves[moves.length - 3].pageX) / (moves[moves.length - 2].timeStamp - moves[moves.length - 3].timeStamp);\n      if (Math.abs(v1) < Math.abs(v2) || Math.abs(v2) > 0.5 && Math.abs(v2) > 0.5) {\n        //user is probably trying to go to next or prev item\n        var s = this.items.indexOf(this._selectedItem());\n        if (v2 > 0) {\n          //prev\n          if (s > 0) {\n            this._scrollTo(this.items[s - 1], v2);\n          } else {\n            if (this.opts.wrapItems) {\n              this._scrollTo(this.items[this.items.length - 1], v2);\n            } else {\n              this._scrollTo(this.items[0]);\n            }\n          }\n        } else {\n          //next\n          if (s < this.items.length - 1) {\n            this._scrollTo(this.items[s + 1], v2);\n          } else {\n            if (this.opts.wrapItems) {\n              this._scrollTo(this.items[0], v2);\n            } else {\n              this._scrollTo(this.items[this.items.length - 1]);\n            }\n          }\n        }\n      } else {\n        if (this._selectedItem().currentPosition() > this.width / 2) {\n          this._scrollTo(this._selectedItem(), -this.opts.startingVelocity);\n        } else {\n          this._scrollTo(this._selectedItem(), this.opts.startingVelocity);\n        }\n      }\n    }\n  };\n\n  /**\n   * Transforms the position of all carouselItems\n   * @param {Number} x The pixel value to transform\n   */\n\n\n  Carousel.prototype._transformItems = function _transformItems(x) {\n    for (var i = 0; i < this.items.length; i++) {\n      this.items[i].addTransform(x);\n    }\n  };\n\n  /**\n   * Sets the transform position of all carouselItems\n   * @param {Number} x The pixel value to transform\n   */\n\n\n  Carousel.prototype._setTransformItems = function _setTransformItems(x) {\n    for (var i = 0; i < this.items.length; i++) {\n      this.items[i].setTransform(x);\n    }\n  };\n\n  /**\n   * Adds transform to the container element, does checking for bounds conditions and\n   * wraps items if necessary and configured\n   * @param {Number} x The pixel value to transform\n   */\n\n\n  Carousel.prototype._addTransform = function _addTransform(x) {\n    var a;\n    if ((this.opts.smoothScrollCenterItems || !this.opts.smoothScroll) && !this.opts.wrapItems && !this.opts.edgeScroll) {\n      var l = this.items.indexOf(this.selectedItem);\n      if (l === this.items.length - 1) {\n        this._leftbound(true);\n      } else {\n        this._leftbound(false);\n      }\n      if (l === 0) {\n        this._rightbound(true);\n      } else {\n        this._rightbound(false);\n      }\n    } else {\n      this._leftbound(false);\n      this._rightbound(false);\n    }\n    if (this.transform.x + x < 0 && x < 0) {\n      if (this.opts.wrapItems) {\n        //wrap items until we have covered the visible area\n        while (this.transform.x + x < -(this.totalItemWidth - this.width) / 2 && (this.totalItemWidth < this.width ? this.transform.x + x < -this.totalItemWidth / 2 : true)) {\n          a = this.items.shift();\n          this.items.push(a);\n          a.addTransform(this.totalItemWidth);\n          this._transformItems(-a.width);\n          x += a.width;\n        }\n      } else {\n        //there is a 1 pixel adjustment to account for some math rounding\n        if (this.opts.edgeScroll && x < 0 && this.transform.x + x - 1 <= -(this.totalItemWidth - this.width) / 2) {\n          this._leftbound(true);\n          return this._setTransform(-(this.totalItemWidth - this.width) / 2);\n        }\n        //progressively reduce scrolling when no more items to the right\n        if (x < 0 && this.transform.x + x < -(this.totalItemWidth / 2 - this.items[this.items.length - 1].width / 2)) {\n          x = x * ((this.totalItemWidth / 2 + this.items[this.items.length - 1].width / 2 + (this.transform.x + x)) / this.items[this.items.length - 1].width);\n          x = x > 0 ? 0 : x;\n        }\n      }\n      return this._setTransform(this.transform.x + x);\n    } else {\n      if (this.transform.x + x > 0 && x > 0) {\n        if (this.opts.wrapItems) {\n          //wrap items until we have covered the visible area\n          while (this.transform.x + x > -(this.width - this.totalItemWidth) / 2 && (this.totalItemWidth < this.width ? this.transform.x + x > this.totalItemWidth / 2 : true)) {\n            a = this.items.pop();\n            this.items.unshift(a);\n            a.addTransform(-this.totalItemWidth);\n            this._transformItems(a.width);\n            x -= a.width;\n          }\n        } else {\n          //there is a 1 pixel adjustment to account for some math rounding\n          if (this.opts.edgeScroll && x > 0 && this.transform.x + x + 1 >= (this.totalItemWidth - this.width) / 2) {\n            this._rightbound(true);\n            return this._setTransform((this.totalItemWidth - this.width) / 2);\n          }\n          //progressively reduce scrolling when no more items to the left\n          if (x > 0 && this.transform.x + x > this.totalItemWidth / 2 - this.items[0].width / 2) {\n            x = x * ((this.totalItemWidth / 2 + this.items[0].width / 2 - (this.transform.x + x)) / this.items[0].width);\n            x = x < 0 ? 0 : x;\n          }\n        }\n      }\n      return this._setTransform(this.transform.x + x);\n    }\n  };\n\n  /**\n   * Sets the leftbound class\n   * @param {Boolean} b Set or unset the leftbound class\n   */\n\n\n  Carousel.prototype._leftbound = function _leftbound(b) {\n    if (typeof b === 'undefined') {\n      this.leftbound = typeof this.leftbound === 'undefined' ? false : this.leftbound;\n      return this.leftbound;\n    } else {\n      if (b) {\n        (0, _addClass2.default)(this.el, 'leftbound');\n      } else {\n        (0, _removeClass2.default)(this.el, 'leftbound');\n      }\n      this.leftbound = b;\n      return this.leftbound;\n    }\n  };\n\n  /**\n   * Sets the rightbound class\n   * @param {Boolean} b Set or unset the rightbound class\n   */\n\n\n  Carousel.prototype._rightbound = function _rightbound(b) {\n    if (typeof b === 'undefined') {\n      this.rightbound = typeof this.rightbound === 'undefined' ? false : this.rightbound;\n      return this.rightbound;\n    } else {\n      if (b) {\n        (0, _addClass2.default)(this.el, 'rightbound');\n      } else {\n        (0, _removeClass2.default)(this.el, 'rightbound');\n      }\n      this.rightbound = b;\n      return this.rightbound;\n    }\n  };\n\n  /**\n   * Updates the selected item, by seeing which item has its center closest\n   * to the center of the carousel\n   */\n\n\n  Carousel.prototype._updateSelected = function _updateSelected() {\n    var tar = this.width / 2;\n    var i = -1;\n    var a = 1;\n    var b = 0;\n    while (a > b) {\n      i++;\n      if (i > this.items.length - 2) {\n        break;\n      }\n      a = Math.abs(tar - this.items[i].currentPosition());\n      b = Math.abs(tar - this.items[i + 1].currentPosition());\n    }\n    return this._selectedItem(this.items[i]);\n  };\n\n  /**\n   * Stores the selected item for the carousel, and updates the previously\n   * selected item and newly selected item to have the correct states\n   * Conditionally sets the leftbound/rightbound states depending on configuration\n   * @param {Object} item Optional: the new item select, if omitted it will\n   * return the currently selected item.\n   */\n\n\n  Carousel.prototype._selectedItem = function _selectedItem(item) {\n    if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) !== 'object') {\n      if (this.selectedItem) {\n        return this.selectedItem;\n      } else {\n        return this._updateSelected();\n      }\n    } else {\n      if (this.selectedItem) {\n        this.selectedItem.setSelected(false);\n      }\n      this.selectedItem = item;\n      if ((this.opts.smoothScrollCenterItems || !this.opts.smoothScroll) && !this.opts.wrapItems && !this.opts.edgeScroll) {\n        var l = this.items.indexOf(this.selectedItem);\n        if (l === this.items.length - 1) {\n          this._leftbound(true);\n        } else {\n          this._leftbound(false);\n        }\n        if (l === 0) {\n          this._rightbound(true);\n        } else {\n          this._rightbound(false);\n        }\n      }\n      this.selectedItem.setSelected(true);\n    }\n  };\n\n  /**\n   * Sets the transform for the carousel container\n   * @param {Number} x The pixel value to transform\n   */\n\n\n  Carousel.prototype._setTransform = function _setTransform(x) {\n    x = x ? x : 0;\n    this.transform = {\n      'x': x\n    };\n    this.container.setAttribute('style', (0, _transform2.default)('translate3d', x + 'px, 0px, 0px'));\n    this._updateSelected();\n    return x;\n  };\n\n  return Carousel;\n}(_base2.default);\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\n\n\nCarousel.prototype.defaults = {\n  el: null\n};\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\nCarousel.prototype._whitelistedParams = [];\n\nexports.default = Carousel;\nmodule.exports = exports['default'];\n//# sourceMappingURL=carousel.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /**\n                                                                                                                                                                                                                                                                               * # Transform\n                                                                                                                                                                                                                                                                               * Apply a cross-browser transform style.\n                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                               * @example\n                                                                                                                                                                                                                                                                               * transform('translateX', '-100px');\n                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                               * @param {String} type\n                                                                                                                                                                                                                                                                               * @param {String} val\n                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                               * @module helpers/css/transform.js\n                                                                                                                                                                                                                                                                               */\n\nvar _each = require('../util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar prefixes = ['-webkit-', '-moz-', '-o-', '-ms-', ''];\n\nfunction transform(type, val) {\n\n  var str = '';\n\n  (0, _each2.default)(prefixes, function (p) {\n\n    if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {\n      str += p + 'transform: ';\n\n      for (var j in val) {\n        str += j + '(' + val[j] + '); ';\n      }\n    } else {\n      str += p + 'transform: ' + type + '(' + val + '); ';\n    }\n  });\n\n  return str;\n}\n\nexports.default = transform;\nmodule.exports = exports['default'];\n//# sourceMappingURL=transform.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * # Add Class\n * Add a class on an element.\n *\n * @param {Element|Array} el An element or array of elements to update.\n * @param {String} name\n * @return {Element}\n *\n * @module helpers/dom/add-class.js\n */\n\nvar ws = /\\s+/;\nvar cleanup = /\\s{2,}/g;\n\nfunction addClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) {\n      el.classList.add(name[0]);\n    }\n    return el;\n  }\n\n  var toAdd = [];\n  var i = 0;\n  var l = name.length;\n  var item = void 0;\n  var clsName = typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '';\n\n  // see if we have anything to add\n  for (; i < l; i++) {\n    item = name[i];\n    if (item && !(0, _hasClass2.default)(clsName, item)) {\n      toAdd.push(item);\n    }\n  }\n\n  if (toAdd.length) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = addClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=add-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * # Has Class\n * See if an element has a class.\n *\n * @param {Element|String} el\n * @param {String} name\n * @return {Boolean}\n *\n * @module helpers/dom/has-class.js\n */\nfunction hasClass(el, name) {\n  var cName = ((typeof el === 'undefined' ? 'undefined' : _typeof(el)) === 'object' ? el.className || el.getAttribute && el.getAttribute('class') || '' : el || '').replace(/[\\t\\r\\n\\f]/g, ' ');\n  return (' ' + cName + ' ').indexOf(' ' + name + ' ') !== -1;\n}\n\nexports.default = hasClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=has-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ws = /\\s+/; /**\n                 * # Remove Class\n                 * Remove a class on an element.\n                 *\n                 * @param {Element|Array} el An element or array of elements to update.\n                 * @param {String} name\n                 * @return {Element}\n                 *\n                 * @module helpers/dom/remove-class.js\n                 */\n\nvar cleanup = /\\s{2,}/g;\n\nfunction removeClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) el.classList.remove(name[0]);\n    return el;\n  }\n\n  // store two copies\n  var clsName = ' ' + (typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '') + ' ';\n  var result = clsName;\n  var current = void 0;\n  var start = void 0;\n  for (var i = 0, l = name.length; i < l; i++) {\n    current = name[i];\n    start = current ? result.indexOf(' ' + current + ' ') : -1;\n    if (start !== -1) {\n      start += 1;\n      result = result.slice(0, start) + result.slice(start + current.length);\n    }\n  }\n\n  // only write if modified\n  if (clsName !== result) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)(result.replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)(result.replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = removeClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=remove-class.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Debounce\n * Debounce a function call\n *\n * @param {Function} func\n * @param {Integer} delay\n *\n * @module helpers/util/debounce.js\n */\nfunction debounce(func, delay) {\n\n  var timer = void 0;\n\n  return function () {\n    var args = arguments;\n    if (timer) window.clearTimeout(timer);\n    timer = window.setTimeout(function () {\n      func.apply(this, args);\n    }, delay);\n  };\n}\n\nexports.default = debounce;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=debounce.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Each\n * Apply a callback function to a list of any kind: Array, NodeList, HTMLCollection or Object.\n *\n * @param {Array|NodeList|HTMLCollection|Object} list\n * @param {Function} cb\n *\n * @example\n * each([], callback);\n * each(el.children, callback);\n * each(el.childNodes, callback);\n * each({}, callback);\n *\n * @module helpers/util/each.js\n */\nfunction each(list, cb) {\n\n  if (!list) {\n    return;\n  }\n\n  if (typeof cb !== 'function') {\n    throw new Error('Cannot invoke `each` without a callback!');\n  }\n\n  var i = 0;\n  var len = list.length;\n\n  // Object\n  if (len === undefined) {\n    for (i in list) {\n      if (i !== 'prototype' && list.hasOwnProperty(i)) {\n        cb(i, list[i]);\n      }\n    }\n  }\n  // Array-like\n  else {\n      for (; i < len; i++) {\n        cb(list[i]);\n      }\n    }\n}\n\nexports.default = each;\nmodule.exports = exports['default'];\n//# sourceMappingURL=each.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Trim\n * Trim whitespace on a string.\n *\n * @param {String} str\n *\n * @module helpers/util/trim.js\n */\n\nvar trimRE = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\nfunction trim(str) {\n  return str.replace(trimRE, '');\n}\n\nexports.default = trim;\nmodule.exports = exports['default'];\n//# sourceMappingURL=trim.js.map\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9kaXN0L2NvbXBvbmVudHMvYmFzZS5qcyIsImpzL2Rpc3QvY29tcG9uZW50cy9jYXJvdXNlbC5qcyIsImpzL2Rpc3QvaGVscGVycy9jc3MvdHJhbnNmb3JtLmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS9hZGQtY2xhc3MuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL2hhcy1jbGFzcy5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vcmVtb3ZlLWNsYXNzLmpzIiwianMvZGlzdC9oZWxwZXJzL3V0aWwvZGVib3VuY2UuanMiLCJqcy9kaXN0L2hlbHBlcnMvdXRpbC9lYWNoLmpzIiwianMvZGlzdC9oZWxwZXJzL3V0aWwvdHJpbS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfXJldHVybiBlfSkoKSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9lYWNoID0gcmVxdWlyZSgnLi4vaGVscGVycy91dGlsL2VhY2gnKTtcblxudmFyIF9lYWNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfSAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAjIEJhc2UgQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGhlIGJhc2UgY2xhc3MgZm9yIFNwYXJrIEpTIGNvbXBvbmVudHMuIFRoaXMgY2xhc3Mgc2hvdWxkIG5ldmVyIGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgY29tcG9uZW50cy9iYXNlLmpzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG52YXIgQmFzZSA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogU2V0IHBhcmFtZXRlcnMgYW5kIGNhY2hlIGVsZW1lbnRzLlxuICAgKi9cbiAgZnVuY3Rpb24gQmFzZShlbCkge1xuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2UpO1xuXG4gICAgaWYgKHBhcmFtcy5lbFJlcXVpcmVkICYmICFlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2V0UGFyYW1zKHRoaXMuZGVmYXVsdHMgfHwge30sIHRydWUpO1xuICAgIHRoaXMuc2V0UGFyYW1zKHBhcmFtcyk7XG4gICAgKHRoaXMuX2NhY2hlRWxlbWVudHMgfHwgbm9vcCkuY2FsbCh0aGlzLCBlbCwgcGFyYW1zKTtcbiAgICAodGhpcy5fcGFyc2VQYXJhbXMgfHwgbm9vcCkuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGNvbXBvbmVudCBmcm9tIHRoZSBET00gYW5kIHByZXBhcmUgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiBieSBkZXJlZmVyZW5jaW5nIHZhbHVlcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBsZWF2ZUVsZW1lbnQgTGVhdmUgdGhlIGVsZW1lbnQgaW50YWN0LlxuICAgKi9cblxuXG4gIEJhc2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShsZWF2ZUVsZW1lbnQpIHtcblxuICAgIGlmICh0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycykge1xuICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBpZiAoIWxlYXZlRWxlbWVudCAmJiB0aGlzLmVsICYmIHRoaXMuZWwucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgIH1cblxuICAgIHRoaXMudW5zZXRQYXJhbXModGhpcy5kZWZhdWx0cyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjb21wb25lbnQgdG8gdXNlIGEgbmV3IGVsZW1lbnQgb3IgcmVwYXJzZSBmcm9tXG4gICAqIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIE9wdGlvbmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgT3B0aW9uYWxcbiAgICovXG5cblxuICBCYXNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZWwpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuXG4gICAgaWYgKHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgICh0aGlzLl9jYWNoZUVsZW1lbnRzIHx8IG5vb3ApLmNhbGwodGhpcywgZWwgfHwgdGhpcy5lbCwgcGFyYW1zKTtcbiAgICAodGhpcy5fcGFyc2VQYXJhbXMgfHwgbm9vcCkuY2FsbCh0aGlzKTtcblxuICAgIGlmICh0aGlzLl9hZGRFdmVudExpc3RlbmVycykge1xuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgaGFzaCBvZiBwYXJhbWV0ZXJzIGlmIHRoZXkncmUgd2hpdGVsaXN0ZWQgb3Igd2UncmUgdG9sZCB0byBmb3JjZSB0aGUgc2V0LlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gc2V0IGluaXRpYWwgdmFsdWVzIGFzIHdlbGwgYXMgc2V0IHBhc3NlZCBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2UgRm9yY2Ugc2V0dGluZyBldmVuIGlmIHRoZSBwYXJhbSBpcyBub3Qgd2hpdGVsaXN0ZWQuXG4gICAqL1xuXG5cbiAgQmFzZS5wcm90b3R5cGUuc2V0UGFyYW1zID0gZnVuY3Rpb24gc2V0UGFyYW1zKHBhcmFtcywgZm9yY2UpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgKDAsIF9lYWNoMi5kZWZhdWx0KShwYXJhbXMsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICBpZiAoX3RoaXMuX3doaXRlbGlzdGVkUGFyYW1zLmluZGV4T2YoaykgIT09IC0xIHx8IGZvcmNlKSB7XG4gICAgICAgIF90aGlzW2tdID0gdjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbnNldCBhbGwgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGtleXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFRoZSBvYmplY3QgdG8gdW5zZXQgdGhlIHBhcmFtcyBmcm9tLiBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAqL1xuXG5cbiAgQmFzZS5wcm90b3R5cGUudW5zZXRQYXJhbXMgPSBmdW5jdGlvbiB1bnNldFBhcmFtcyhrZXlzLCBzY29wZSkge1xuXG4gICAga2V5cyA9IGtleXMgaW5zdGFuY2VvZiBBcnJheSA/IGtleXMgOiBPYmplY3Qua2V5cyhrZXlzKTtcbiAgICBzY29wZSA9IHNjb3BlIHx8IHRoaXM7XG4gICAgKDAsIF9lYWNoMi5kZWZhdWx0KShrZXlzLCBmdW5jdGlvbiAoaykge1xuICAgICAgZGVsZXRlIHNjb3BlW2tdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIEJhc2U7XG59KCk7XG5cbi8qKlxuICogV2hpdGVsaXN0ZWQgcGFyYW1ldGVycyB3aGljaCBjYW4gYmUgc2V0IG9uIGNvbnN0cnVjdGlvbi5cbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuXG5cbkJhc2UucHJvdG90eXBlLl93aGl0ZWxpc3RlZFBhcmFtcyA9IFtdO1xuXG4vKipcbiAqIERlZmF1bHQgdmFsdWVzIGZvciBpbnRlcm5hbCBwcm9wZXJ0aWVzIHdlIHdpbGwgYmUgc2V0dGluZy5cbiAqIFRoZXNlIGFyZSBzZXQgb24gZWFjaCBjb25zdHJ1Y3Rpb24gc28gd2UgZG9uJ3QgbGVhayBwcm9wZXJ0aWVzXG4gKiBpbnRvIHRoZSBwcm90b3R5cGUgY2hhaW4uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5CYXNlLnByb3RvdHlwZS5kZWZhdWx0cyA9IHt9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfYmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuXG52YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XG5cbnZhciBfZGVib3VuY2UgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3V0aWwvZGVib3VuY2UnKTtcblxudmFyIF9kZWJvdW5jZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWJvdW5jZSk7XG5cbnZhciBfdHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vaGVscGVycy9jc3MvdHJhbnNmb3JtJyk7XG5cbnZhciBfdHJhbnNmb3JtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RyYW5zZm9ybSk7XG5cbnZhciBfYWRkQ2xhc3MgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbS9hZGQtY2xhc3MnKTtcblxudmFyIF9hZGRDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hZGRDbGFzcyk7XG5cbnZhciBfcmVtb3ZlQ2xhc3MgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbS9yZW1vdmUtY2xhc3MnKTtcblxudmFyIF9yZW1vdmVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZW1vdmVDbGFzcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAjIENhcm91c2VsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDcmVhdGUgYSBDYXJvdXNlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBuZXcgQ2Fyb3VzZWwoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgY29tcG9uZW50cy9jYXJvdXNlbC5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBDYXJvdXNlbCA9IGZ1bmN0aW9uIChfQmFzZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoQ2Fyb3VzZWwsIF9CYXNlQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ2Fyb3VzZWwgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgKi9cbiAgZnVuY3Rpb24gQ2Fyb3VzZWwoZWwsIHBhcmFtcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYXJvdXNlbCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQmFzZUNvbXBvbmVudC5jYWxsKHRoaXMsIGVsLCBwYXJhbXMpKTtcblxuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgIGlmICghZWwpIHtcbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG4gICAgfVxuXG4gICAgX3RoaXMuX2luaXQoZWwpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXJvdXNlbCBJdGVtIENvbnRydWN0b3IsIGV4cG9zZXMgYWNjZXNzIHRvIGZ1bmN0aW9ucyBzZXRUcmFuc2Zvcm0sIHNldFNlbGVjdGVkLCBhbmQgY3VycmVudFBvc2l0aW9uXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgTm9kZSB0byBpbml0YWxpemUgYXMgY2Fyb3VzZWxJdGVtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgY2Fyb3VzZWxcbiAgICogQHBhcmFtIHtFbGVtZW50fSBkb3QgTm9kZSB0byB1c2UgYXMgZG90IGVsZW1lbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9yZGVyIG9yaWdpbmFsIG9yZGVyIGluIHRoZSBtYXJrdXBcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX2Nhcm91c2VsSXRlbSA9IGZ1bmN0aW9uIF9jYXJvdXNlbEl0ZW0oZWwsIHBhcmVudCwgZG90LCBvcmRlcikge1xuICAgIHZhciBhID0ge307XG4gICAgYS5lbCA9IGVsO1xuICAgIGEucGFyZW50ID0gcGFyZW50O1xuICAgIGEuZG90ID0gZG90O1xuICAgIGEub3JkZXIgPSBvcmRlcjtcbiAgICBhLmFkZFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICBhLnNldFRyYW5zZm9ybShhLnRyYW5zZm9ybS54ICsgeCk7XG4gICAgfTtcbiAgICBhLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICB4ID0geCA/IHggOiAwO1xuICAgICAgYS50cmFuc2Zvcm0gPSB7XG4gICAgICAgICd4JzogeFxuICAgICAgfTtcbiAgICAgIGEuZWwuc2V0QXR0cmlidXRlKCdzdHlsZScsICgwLCBfdHJhbnNmb3JtMi5kZWZhdWx0KSgndHJhbnNsYXRlM2QnLCBhLnRyYW5zZm9ybS54ICsgJ3B4LCAwcHgsIDBweCcpKTtcbiAgICB9O1xuICAgIGEuc2V0U2VsZWN0ZWQgPSBmdW5jdGlvbiAoYikge1xuICAgICAgaWYgKGEuc2V0U2VsZWN0ZWQuc2VsZWN0ZWQgPT09IGIgJiYgdHlwZW9mIGEuc2V0U2VsZWN0ZWQuc2VsZWN0ZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChiKSB7XG4gICAgICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKGEuZWwsICdzZWxlY3RlZCcpO1xuICAgICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KShhLmRvdCwgJ3NlbGVjdGVkJyk7XG4gICAgICAgIGEuc2V0U2VsZWN0ZWQuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkoYS5lbCwgJ3NlbGVjdGVkJyk7XG4gICAgICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKGEuZG90LCAnc2VsZWN0ZWQnKTtcbiAgICAgICAgYS5zZXRTZWxlY3RlZC5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgYS5jdXJyZW50UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGFyZW50LnRyYW5zZm9ybS54ICsgYS50cmFuc2Zvcm0ueCArIGEuZGltcy5sZWZ0ICsgYS53aWR0aCAvIDIgLSBwYXJlbnQuZGltcy5sZWZ0O1xuICAgIH07XG4gICAgYS5zZXRUcmFuc2Zvcm0oKTtcbiAgICBhLmRpbXMgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBhLndpZHRoID0gYS5kaW1zLndpZHRoO1xuICAgIGEuZWwuc3BhcmtjYXJvdXNlbGl0ZW0gPSBhO1xuICAgIGEuZG90LnNwYXJrY2Fyb3VzZWxpdGVtZG90ID0gYTtcbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICAvKipcbiAgICogU2NhbnMgZWxlbWVudCBhbmQgc2V0cyB1cCBvciByZXNldHMgdGhlIGNhcm91c2VsIGJhc2VkIG9uIGNvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBOb2RlIHRvIGluaXRhbGl6ZSBhcyB0aGUgY2Fyb3VzZWxcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBfaW5pdChlbCkge1xuICAgIC8vY2FjaGUgZWxlbWVudHMgYW5kIGNvbnRyb2xzXG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMuZWwuc3BhcmtjYXJvdXNlbCA9IHRoaXM7XG4gICAgdGhpcy5iYWNrZSA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnNwYXJrLWNhcm91c2VsX19iYWNrJyk7XG4gICAgdGhpcy5mb3J3YXJkZSA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnNwYXJrLWNhcm91c2VsX19mb3J3YXJkJyk7XG4gICAgdGhpcy5vdXRlckNvbnRhaW5lciA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnNwYXJrLWNhcm91c2VsX19vdXRlci1jb250YWluZXInKTtcbiAgICB0aGlzLmNvbnRhaW5lck1hc2sgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1jYXJvdXNlbF9fY29udGFpbmVyLW1hc2snKTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnNwYXJrLWNhcm91c2VsX19jb250YWluZXInKTtcbiAgICB0aGlzLmRvdHMgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1jYXJvdXNlbF9fZG90cycpO1xuICAgIHRoaXMucGF1c2VFbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnNwYXJrLWNhcm91c2VsX19wYXVzZScpO1xuICAgIC8vZ2V0IHRoZSBvcHRpb25zIGZyb20gdGhlIGVsZW1lbnRcbiAgICB0aGlzLm9wdHMgPSB7fTtcbiAgICB0aGlzLm9wdHMud3JhcEl0ZW1zID0gdGhpcy5lbC5hdHRyaWJ1dGVzWydkYXRhLXNwYXJrLWNhcm91c2VsLXdyYXAtaXRlbXMnXSA/IHRydWUgOiBmYWxzZTtcbiAgICB0aGlzLm9wdHMuc3RhcnRpbmdWZWxvY2l0eSA9IHRoaXMuZWwuYXR0cmlidXRlc1snZGF0YS1zcGFyay1jYXJvdXNlbC1zY3JvbGwtdmVsb2NpdHknXSA/IHRoaXMuZWwuYXR0cmlidXRlc1snZGF0YS1zcGFyay1jYXJvdXNlbC1zY3JvbGwtdmVsb2NpdHknXS52YWx1ZSA6IDEwO1xuICAgIHRoaXMub3B0cy5zbW9vdGhTY3JvbGwgPSB0aGlzLmVsLmF0dHJpYnV0ZXNbJ2RhdGEtc3BhcmstY2Fyb3VzZWwtc21vb3RoLXNjcm9sbCddID8gdHJ1ZSA6IGZhbHNlO1xuICAgIHRoaXMub3B0cy5zbW9vdGhTY3JvbGxDZW50ZXJJdGVtcyA9IHRoaXMuZWwuYXR0cmlidXRlc1snZGF0YS1zcGFyay1jYXJvdXNlbC1zbW9vdGgtc2Nyb2xsLWNlbnRlciddID8gdHJ1ZSA6IGZhbHNlO1xuICAgIHRoaXMub3B0cy5wYW5lbFNjcm9sbCA9IHRoaXMuZWwuYXR0cmlidXRlc1snZGF0YS1zcGFyay1jYXJvdXNlbC1wYW5lbCddID8gdHJ1ZSA6IGZhbHNlO1xuICAgIHRoaXMub3B0cy5lZGdlU2Nyb2xsID0gdGhpcy5vcHRzLnBhbmVsU2Nyb2xsIHx8IHRoaXMuZWwuYXR0cmlidXRlc1snZGF0YS1zcGFyay1jYXJvdXNlbC1lZGdlJ10gPyB0cnVlIDogZmFsc2U7XG4gICAgdGhpcy5vcHRzLmF1dG9BZHZhbmNlID0gdGhpcy5lbC5hdHRyaWJ1dGVzWydkYXRhLXNwYXJrLWNhcm91c2VsLWF1dG8tYWR2YW5jZSddID8gdGhpcy5lbC5hdHRyaWJ1dGVzWydkYXRhLXNwYXJrLWNhcm91c2VsLWF1dG8tYWR2YW5jZSddLnZhbHVlIDogZmFsc2U7XG4gICAgLy9zZXR1cCBhdXRvQWR2YW5jZVxuICAgIGlmICh0aGlzLm9wdHMuYXV0b0FkdmFuY2UgJiYgIXRoaXMuYXV0b0FkdmFuY2UgJiYgIXRoaXMucGF1c2UpIHtcbiAgICAgIHRoaXMuYXV0b0FkdmFuY2UgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2F1dG9BZHZhbmNlKCk7XG4gICAgICB9LmJpbmQodGhpcyksIHRoaXMub3B0cy5hdXRvQWR2YW5jZSAqIDEwMDApO1xuICAgIH1cbiAgICAvL2NvbmRpdGlvbmFsbHkgYmluZCBwYXVzZSBoYW5kbGVycy5cbiAgICAvL25lZWRzIHRvIGJlIGRvbmUgaGVyZSBzbyB0aGF0IHJlc2V0dGluZyB0aGUgY2Fyb3VzZWwgd2lsbCB3b3JrIGNvcnJlY3RseVxuICAgIGlmICh0aGlzLm9wdHMuYXV0b0FkdmFuY2UgJiYgIXRoaXMucGF1c2VIKSB7XG4gICAgICB0aGlzLnBhdXNlSCA9IHRoaXMuX3BhdXNlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLnBhdXNlRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnBhdXNlSCk7XG4gICAgfVxuICAgIC8vY29sbGVjdCBpdGVtcyBhbmQgY2FjaGUgc2l6aW5nXG4gICAgdmFyIGEgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zcGFyay1jYXJvdXNlbF9faXRlbScpO1xuICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICB0aGlzLnRvdGFsSXRlbVdpZHRoID0gMDtcbiAgICB0aGlzLmRpbXMgPSB0aGlzLmNvbnRhaW5lck1hc2suZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMuZGltcy53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuZGltcy5oZWlnaHQ7XG4gICAgdmFyIGRvdHMgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgdmFyIGI7XG4gICAgLy9jcmVhdGUgb3VyIGNhcm91c2VsSXRlbXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRvdHMuYXBwZW5kQ2hpbGQoYik7XG4gICAgICB0aGlzLml0ZW1zLnB1c2gobmV3IHRoaXMuX2Nhcm91c2VsSXRlbShhW2ldLCB0aGlzLCBiLCBpKSk7XG4gICAgICB0aGlzLnRvdGFsSXRlbVdpZHRoICs9IHRoaXMuaXRlbXNbaV0ud2lkdGg7XG4gICAgfVxuICAgIC8vaWYgd2UncmUgcmVzZXR0aW5nIHdlIG5lZWQgdG8gZW1wdHkgb3V0IHRoZSBleGlzaXRpbmcgZWxlbWVudHMgZmlyc3RcbiAgICB3aGlsZSAodGhpcy5kb3RzLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHRoaXMuZG90cy5yZW1vdmVDaGlsZCh0aGlzLmRvdHMuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHRoaXMuZG90cy5hcHBlbmRDaGlsZChkb3RzKTtcbiAgICAvL3RoaXMgaXMgdG8gdGVzdCBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggMjAxMSBmbGV4Ym94IChJRTEwKSBhbmQgbmVlZCB0byBkbyBhbiBhZGp1c3RtZW50XG4gICAgLy90aGlzIGlzIGJlY2F1c2UgbXMtZmxleC1wYWNrOiBjZW50ZXIgZG9lc24ndCB3b3JrIGxpa2UgMjAxMiBmbGV4Ym94IGNlbnRlci1wYWNrXG4gICAgaWYgKHR5cGVvZiB0aGlzLmNvbnRhaW5lci5zdHlsZS5tc0ZsZXhBbGlnbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybUl0ZW1zKC0odGhpcy50b3RhbEl0ZW1XaWR0aCAtIHRoaXMud2lkdGgpIC8gMik7XG4gICAgfVxuICAgIC8vc2V0dXAgaW5pdGFsIHRyYW5zZm9ybVxuICAgIHRoaXMuX3NldFRyYW5zZm9ybSgpO1xuICAgIC8vbmVlZCB0byBiaW5kIHRoaXMgZXZlbnQgaGFuZGxlciBoZXJlIGFzIHdlIGFyZSBhbHdheXMgZ29pbmcgdG8gbmVlZCB0byBiZSBsaXN0ZW5pbmdcbiAgICAvL2ZvciB0aGlzIGV2ZW50LCBpbiBvcmRlciB0byByZWFjdCB0byBjb250YWluZXIgdmlzaWJpbGl0eSBjaGFuZ2luZ1xuICAgIHRoaXMuX2hhbmRsZVZpc2libGVDaGlsZHJlbiA9IHRoaXMuX2hhbmRsZVZpc2libGVDaGlsZHJlbkguYmluZCh0aGlzKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzcGFyay52aXNpYmxlLWNoaWxkcmVuJywgdGhpcy5faGFuZGxlVmlzaWJsZUNoaWxkcmVuLCB0cnVlKTtcbiAgICBpZiAoIXRoaXMuX3JhZkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX3JhZkhhbmRsZXIgPSB0aGlzLl9yYWZIYW5kbGVySC5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICAvL25lZWQgdG8gYWxzbyBsaXN0ZW4gdG8gcmVzaXplIGV2ZW50cywgZXZlbiBpZiB3ZSBkb24ndCBoYXZlIGl0ZW1zIG92ZXJmbG93aW5nXG4gICAgaWYgKCF0aGlzLnJlc2l6ZUgpIHtcbiAgICAgIHRoaXMucmVzaXplSCA9ICgwLCBfZGVib3VuY2UyLmRlZmF1bHQpKHRoaXMuX3Jlc2l6ZS5iaW5kKHRoaXMpLCAxMDApO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplSCk7XG4gICAgfVxuICAgIC8vaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IGluaXQnZCBldmVudCBsaXN0ZXJlcnMsIGFuZCB3ZSBoYXZlIGl0ZW1zIG92ZXJmbG93aW5nXG4gICAgaWYgKHRoaXMudG90YWxJdGVtV2lkdGggPiB0aGlzLndpZHRoKSB7XG4gICAgICBpZiAoIXRoaXMudG91Y2hzdGFydEgpIHtcbiAgICAgICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ25vc2Nyb2xsJyk7XG4gICAgICAgIHRoaXMuX3NldHVwTGlzdGVuZXJzKCk7XG4gICAgICAgIC8vY2VudGVyIHRoZSBmaXJzdCBpdGVtXG4gICAgICAgIHRoaXMuX2FkZFRyYW5zZm9ybSgtdGhpcy5pdGVtc1swXS5jdXJyZW50UG9zaXRpb24oKSArIHRoaXMud2lkdGggLyAyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy9pZiB3ZSBkb24ndCBoYXZlIG92ZXJmbG93aW5nIGl0ZW1zLCB0aGVuIGRpc2FibGUgc2Nyb2xsaW5nIGFuZCByZW1vdmUgbGlzdGVuZXJzXG4gICAgZWxzZSB7XG4gICAgICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKHRoaXMuZWwsICdub3Njcm9sbCcpO1xuICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICAvL3NldCB0aGUgbmV3IHNlbGVjdGVkIGl0ZW1cbiAgICB0aGlzLl91cGRhdGVTZWxlY3RlZCgpO1xuICAgIC8vZmluYWxseSwgZGlzcGxheSB0aGUgZWxlbWVudFxuICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKHRoaXMuZWwsICdyZWFkeScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZWFycyBkb3duIHRoZSBjb21wb25lbnQsIHJlbW92ZXMgbGlzdGVuZXJzLCBhbmQgY29uZGl0aW9uYWxseSBkZWxldGUgdGhlIERPTSBlbGVtZW50XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbGVhdmVFbGVtZW50IEZhbHNleSB2YWx1ZSB3aWxsIHJlbW92ZSB0aGUgRE9NIGVsZW1lbnQgYXMgd2VsbCBhcyB0aGUgY29tcG9uZW50IGluc3RhbmNlXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShsZWF2ZUVsZW1lbnQpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemVIKTtcbiAgICBkZWxldGUgdGhpcy5yZXNpemVIO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NwYXJrLnZpc2libGUtY2hpbGRyZW4nLCB0aGlzLl9oYW5kbGVWaXNpYmxlQ2hpbGRyZW4sIHRydWUpO1xuICAgIGRlbGV0ZSB0aGlzLl9oYW5kbGVWaXNpYmxlQ2hpbGRyZW47XG4gICAgX0Jhc2VDb21wb25lbnQucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMsIGxlYXZlRWxlbWVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhdXNlL3VucGF1c2UgdGhlIGF1dG9BZHZhbmNlIGZlYXR1cmVcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX3BhdXNlID0gZnVuY3Rpb24gX3BhdXNlKCkge1xuICAgIGlmICh0aGlzLnBhdXNlKSB7XG4gICAgICBkZWxldGUgdGhpcy5tb3ZlcztcbiAgICAgIHRoaXMuYXV0b0FkdmFuY2UgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2F1dG9BZHZhbmNlKCk7XG4gICAgICB9LmJpbmQodGhpcyksIHRoaXMub3B0cy5hdXRvQWR2YW5jZSAqIDEwMDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yYWZDYW5jZWwoKTtcbiAgICAgIGlmICghdGhpcy5vcHRzLnNtb290aFNjcm9sbCB8fCB0aGlzLm9wdHMuc21vb3RoU2Nyb2xsQ2VudGVySXRlbXMpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsVG8odGhpcy5fc2VsZWN0ZWRJdGVtKCkpO1xuICAgICAgfVxuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmF1dG9BZHZhbmNlKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmF1dG9BZHZhbmNlO1xuICAgIH1cbiAgICB0aGlzLl9zZXRQYXVzZSghdGhpcy5wYXVzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIHRvZ2dsZXMgdGhlIHBhdXNlIGNsYXNzIG9uIHRoZSBlbGVtZW50XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYiBUcnV0aHkgdmFsdWUgd2lsbCBnaXZlIHRoZSBlbGVtZW50IHRoZSBwYXVzZSBjbGFzc1xuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fc2V0UGF1c2UgPSBmdW5jdGlvbiBfc2V0UGF1c2UoYikge1xuICAgIGlmICh0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMucGF1c2UgPSB0eXBlb2YgdGhpcy5wYXVzZSA9PT0gJ3VuZGVmaW5lZCcgPyBmYWxzZSA6IHRoaXMucGF1c2U7XG4gICAgICByZXR1cm4gdGhpcy5wYXVzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGIpIHtcbiAgICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ3BhdXNlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KSh0aGlzLmVsLCAncGF1c2UnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGF1c2UgPSBiO1xuICAgICAgcmV0dXJuIHRoaXMucGF1c2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBmdW5jdGlvbiBjYWxsZWQgYnkgd2luZG93LnNldFRpbWVvdXQsIHdpbGwgY2hlY2sgZmlyc3QgdG8gc2VlIGlmIGVsZW1lbnQgaXMgaW4gdXNlIGJlZm9yZSB0cmlnZ2VyaW5nIGEgc2xpZGUgYWR2YW5jZVxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fYXV0b0FkdmFuY2UgPSBmdW5jdGlvbiBfYXV0b0FkdmFuY2UoKSB7XG4gICAgaWYgKCF0aGlzLm1vdmVzICYmICF0aGlzLl9sYXN0c3RhcnQgJiYgIXRoaXMucGF1c2VkKSB7XG4gICAgICB0aGlzLl9yYWZDYW5jZWwoKTtcbiAgICAgIHZhciBhID0gdGhpcy5pdGVtcy5pbmRleE9mKHRoaXMuX3NlbGVjdGVkSXRlbSgpKTtcbiAgICAgIHRoaXMuX3Njcm9sbFRvSXRlbSA9IHRydWU7XG4gICAgICB0aGlzLl9zY3JvbGxUbyh0aGlzLml0ZW1zW2EgPT09IHRoaXMuaXRlbXMubGVuZ3RoIC0gMSA/IDAgOiBhICsgMV0pO1xuICAgICAgdGhpcy5hdXRvQWR2YW5jZSA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYXV0b0FkdmFuY2UoKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgdGhpcy5vcHRzLmF1dG9BZHZhbmNlICogMTAwMCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBpbml0YWxpemUgYW5kIGJpbmQgZXZlbiBsaXN0ZW5lcnNcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX3NldHVwTGlzdGVuZXJzID0gZnVuY3Rpb24gX3NldHVwTGlzdGVuZXJzKCkge1xuICAgIHRoaXMudG91Y2hzdGFydEggPSB0aGlzLl90b3VjaHN0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMudG91Y2hzdGFydEgpO1xuICAgIHRoaXMudG91Y2htb3ZlSCA9IHRoaXMuX3RvdWNobW92ZS5iaW5kKHRoaXMpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLnRvdWNobW92ZUgpO1xuICAgIHRoaXMudG91Y2hlbmRIID0gdGhpcy5fdG91Y2hlbmQuYmluZCh0aGlzKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLnRvdWNoZW5kSCk7XG4gICAgdGhpcy5tb3VzZWRvd25IID0gdGhpcy5fbW91c2Vkb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZWRvd25IKTtcbiAgICB0aGlzLm1vdXNlbW92ZUggPSB0aGlzLl9tb3VzZW1vdmUuYmluZCh0aGlzKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5tb3VzZW1vdmVIKTtcbiAgICB0aGlzLm1vdXNldXBIID0gdGhpcy5fbW91c2V1cC5iaW5kKHRoaXMpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5tb3VzZXVwSCk7XG4gICAgdGhpcy5mb3J3YXJkSCA9IHRoaXMuX2ZvcndhcmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmZvcndhcmRlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5mb3J3YXJkSCk7XG4gICAgdGhpcy5iYWNrSCA9IHRoaXMuX2JhY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLmJhY2tlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5iYWNrSCk7XG4gICAgdGhpcy5jbGlja0ggPSB0aGlzLl9jbGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNsaWNrSCk7XG4gICAgdGhpcy5fZm9jdXNIYW5kbGVyID0gdGhpcy5fc2Nyb2xsVG9DbGlja2VkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9mb2N1c0hhbmRsZXIsIHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIG5vbi1lc3NlbnRpYWwgZXZlbnQgbGlzdGVuZXJzLCBjYWxsZWQgd2hlbiB0ZWFyaW5nIGRvd24gdGhlIGNvbXBvbmVudCwgb3Igb3VyIGNvbnRlbnRcbiAgICogZG9lcyBub3QgZXhjZWVkIHRoZSB3aWR0aCBvZiBvdXIgZWxlbWVudFxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fcmVtb3ZlTGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlbW92ZUxpc3RlbmVycygpIHtcbiAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLnRvdWNoc3RhcnRIKTtcbiAgICBkZWxldGUgdGhpcy50b3VjaHN0YXJ0SDtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy50b3VjaG1vdmVIKTtcbiAgICBkZWxldGUgdGhpcy50b3VjaG1vdmVIO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMudG91Y2hlbmRIKTtcbiAgICBkZWxldGUgdGhpcy50b3VjaGVuZEg7XG4gICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bkgpO1xuICAgIGRlbGV0ZSB0aGlzLm1vdXNlZG93bkg7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2Vtb3ZlSCk7XG4gICAgZGVsZXRlIHRoaXMubW91c2Vtb3ZlSDtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMubW91c2V1cEgpO1xuICAgIGRlbGV0ZSB0aGlzLm1vdXNldXBIO1xuICAgIHRoaXMuZm9yd2FyZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmZvcndhcmRIKTtcbiAgICBkZWxldGUgdGhpcy5mb3J3YXJkSDtcbiAgICB0aGlzLmJhY2tlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5iYWNrSCk7XG4gICAgZGVsZXRlIHRoaXMuYmFja0g7XG4gICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuY2xpY2tIKTtcbiAgICBkZWxldGUgdGhpcy5jbGlja0g7XG4gICAgdGhpcy5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9mb2N1c0hhbmRsZXIsIHRydWUpO1xuICAgIGRlbGV0ZSB0aGlzLl9mb2N1c0hhbmRsZXI7XG4gICAgaWYgKHRoaXMucGF1c2VFbCkge1xuICAgICAgdGhpcy5wYXVzZUVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5wYXVzZUgpO1xuICAgICAgZGVsZXRlIHRoaXMucGF1c2VIO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgdGhlIHNwYXJrLnZpc2libGUtY2hpbGRyZW4gZXZlbnQsIGp1c3QgY2FsbCB0aGUgY2hhbmdlIGZ1bmN0aW9uIHRvIGhhbmRsZSBhbnlcbiAgICogdmlzaWJpbGl0eSBvciBzaXppbmcgY2hhbmdlc1xuICAgKiBAcGFyYW0ge0V2ZW50fSBlIFRoZSBzcGFyay52aXNpYmxlLWNoaWxkcmVuIGV2ZW50XG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9oYW5kbGVWaXNpYmxlQ2hpbGRyZW5IID0gZnVuY3Rpb24gX2hhbmRsZVZpc2libGVDaGlsZHJlbkgoZSkge1xuICAgIGlmIChlLnRhcmdldC5jb250YWlucyh0aGlzLmVsKSkge1xuICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoYW5nZSgpO1xuICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcndhcmQgYnV0dG9uIGNsaWNrIGhhbmRsZXIgdHJpZ2dlcnMgYSBzY3JvbGxUbyB0byB0aGUgXCJuZXh0XCIgZWxlbWVudFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIFRoZSBjbGljayBldmVudFxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fZm9yd2FyZCA9IGZ1bmN0aW9uIF9mb3J3YXJkKGUpIHtcbiAgICB2YXIgcyA9IHRoaXMuaXRlbXMuaW5kZXhPZih0aGlzLl9zZWxlY3RlZEl0ZW0oKSk7XG4gICAgcysrO1xuICAgIGlmIChzID4gdGhpcy5pdGVtcy5sZW5ndGggLSAxKSB7XG4gICAgICBpZiAodGhpcy5vcHRzLndyYXBJdGVtcykge1xuICAgICAgICBzID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlIHRoaXMubW92ZXM7XG4gICAgdmFyIGEgPSB0aGlzLl9zdGFydGluZ1ZlbG9jaXR5O1xuICAgIGEgPSBhIDwgLXRoaXMub3B0cy5zdGFydGluZ1ZlbG9jaXR5ID8gYSA6IC10aGlzLm9wdHMuc3RhcnRpbmdWZWxvY2l0eTtcbiAgICB0aGlzLl9yYWZDYW5jZWwoKTtcbiAgICB0aGlzLl9zY3JvbGxUb0l0ZW0gPSB0cnVlO1xuICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMuaXRlbXNbc10sIGEpO1xuICAgIGlmIChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBCYWNrIGJ1dHRvbiBjbGljayBoYW5kbGVyIHRyaWdnZXJzIGEgc2Nyb2xsVG8gdG8gdGhlIFwicHJldmlvdXNcIiBlbGVtZW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgVGhlIGNsaWNrIGV2ZW50XG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9iYWNrID0gZnVuY3Rpb24gX2JhY2soZSkge1xuICAgIHZhciBzID0gdGhpcy5pdGVtcy5pbmRleE9mKHRoaXMuX3NlbGVjdGVkSXRlbSgpKTtcbiAgICBzLS07XG4gICAgaWYgKHMgPCAwKSB7XG4gICAgICBpZiAodGhpcy5vcHRzLndyYXBJdGVtcykge1xuICAgICAgICBzID0gdGhpcy5pdGVtcy5sZW5ndGggLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUgdGhpcy5tb3ZlcztcbiAgICB2YXIgYSA9IHRoaXMuX3N0YXJ0aW5nVmVsb2NpdHk7XG4gICAgYSA9IGEgPiB0aGlzLm9wdHMuc3RhcnRpbmdWZWxvY2l0eSA/IGEgOiB0aGlzLm9wdHMuc3RhcnRpbmdWZWxvY2l0eTtcbiAgICB0aGlzLl9yYWZDYW5jZWwoKTtcbiAgICB0aGlzLl9zY3JvbGxUb0l0ZW0gPSB0cnVlO1xuICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMuaXRlbXNbc10sIGEpO1xuICAgIGlmIChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNb3ZlIHN0YXJ0IGhhbmRsZXIsIGhhbmRsZXMgYm90aCB0b3VjaHN0YXJ0IGFuZCBtb3VzZWRvd24gZXZlbnRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBzdGFydCBldmVudFxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fbW92ZXN0YXJ0ID0gZnVuY3Rpb24gX21vdmVzdGFydChlKSB7XG4gICAgdGhpcy5fcmFmQ2FuY2VsKCk7XG4gICAgdGhpcy5tb3ZlcyA9IFtdO1xuICAgIHRoaXMubW92ZXMucHVzaChlKTtcbiAgfTtcblxuICAvKipcbiAgICogTW92ZSBoYW5kbGVyLCBoYW5kbGVzIGludGVybmFsIG1vdmUgZXZlbnQgb2JqZWN0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgbW92ZSBldmVudFxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uIF9tb3ZlKGUpIHtcbiAgICBpZiAodGhpcy5tb3ZlcyAmJiB0aGlzLm1vdmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMuX2FkZFRyYW5zZm9ybShlLnBhZ2VYIC0gdGhpcy5tb3Zlc1t0aGlzLm1vdmVzLmxlbmd0aCAtIDFdLnBhZ2VYKTtcbiAgICAgIHRoaXMubW92ZXMucHVzaChlKTtcbiAgICAgIGUucHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5tb3ZlcyAmJiB0aGlzLm1vdmVzWzBdKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyh0aGlzLm1vdmVzWzBdLnBhZ2VYIC0gZS5wYWdlWCkgPiBNYXRoLmFicyh0aGlzLm1vdmVzWzBdLnBhZ2VZIC0gZS5wYWdlWSkgJiYgTWF0aC5hYnModGhpcy5tb3Zlc1swXS5wYWdlWCAtIGUucGFnZVgpID4gNSAmJiBlLmNhbmNlbGFibGUpIHtcbiAgICAgICAgICB0aGlzLl9hZGRUcmFuc2Zvcm0oZS5wYWdlWCAtIHRoaXMubW92ZXNbMF0ucGFnZVgpO1xuICAgICAgICAgIHRoaXMubW92ZXMucHVzaChlKTtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5tb3Zlc1swXS5wYWdlWCAtIGUucGFnZVgpID4gNSkge1xuICAgICAgICAgICAgdGhpcy5tb3Zlc1swXSA9IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZS50eXBlID09PSAndG91Y2hlbmQnIHx8IGUudHlwZSA9PT0gJ21vdXNldXAnKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1vdmVzO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTW92ZSBlbmQgaGFuZGxlciwgaGFuZGxlcyBib3RoIHRvdWNoZW5kIGFuZCBtb3VzZXVwIGV2ZW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgbW92ZWVuZCBldmVudFxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fbW92ZWVuZCA9IGZ1bmN0aW9uIF9tb3ZlZW5kKGUpIHtcbiAgICB0aGlzLl9tb3ZlKGUpO1xuICAgIGlmICghdGhpcy5vcHRzLnNtb290aFNjcm9sbCkge1xuICAgICAgdGhpcy5fc2V0dGxlKHRoaXMubW92ZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbnRlcmlhU2Nyb2xsKHRoaXMubW92ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVzaXplIGV2ZW50IGhhbmRsZXIsIGNhbGxzIGNoYW5nZSB0byBoYW5kbGUgYW55IGVsZW1lbnQgZGltZW5zaW9uIGNoYW5nZXNcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX3Jlc2l6ZSA9IGZ1bmN0aW9uIF9yZXNpemUoKSB7XG4gICAgdGhpcy5jaGFuZ2UoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGluZyB0aGUgY2hhbmdlIGZ1bmN0aW9uIHdpbGwgaGFuZGxlIHVwZGF0aW5nIHRoZSBlbGVtZW50IHRvIHRha2UgaW50byBhY2NvdW50XG4gICAqIGFueSBzdHlsaW5nLCBzaXppbmcsIG9yIHZpc2liaWxpdHkgY2hhbmdlcywgYW5kIHRoZSBhZGRpdGlvbiBvciByZW1vdmFsIG9mIGFueSBjYXJvdXNlbEl0ZW1zXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmNoYW5nZSA9IGZ1bmN0aW9uIGNoYW5nZSgpIHtcbiAgICB2YXIgZGltcyA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGRpbXMud2lkdGggIT09IHRoaXMud2lkdGggfHwgZGltcy5oZWlnaHQgIT09IHRoaXMuaGVpZ2h0KSB7XG4gICAgICBpZiAodGhpcy5hdXRvQWR2YW5jZSkge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuYXV0b0FkdmFuY2UpO1xuICAgICAgICBkZWxldGUgdGhpcy5hdXRvQWR2YW5jZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JhZkNhbmNlbCgpO1xuICAgICAgdmFyIGMgPSB0aGlzLl9zZWxlY3RlZEl0ZW0oKTtcbiAgICAgIHRoaXMuX3NldFRyYW5zZm9ybSgwKTtcbiAgICAgIHRoaXMuX3NldFRyYW5zZm9ybUl0ZW1zKDApO1xuICAgICAgdGhpcy5faW5pdCh0aGlzLmVsKTtcbiAgICAgIGlmICh0aGlzLml0ZW1zLmluZGV4T2YoYy5lbC5zcGFya2Nhcm91c2VsaXRlbSkgPiAtMSAmJiB0aGlzLnRvdGFsSXRlbVdpZHRoID4gdGhpcy53aWR0aCkge1xuICAgICAgICBpZiAodGhpcy5vcHRzLndyYXBJdGVtcykge1xuICAgICAgICAgIHRoaXMuX2FkZFRyYW5zZm9ybSgtdGhpcy50b3RhbEl0ZW1XaWR0aCArICgtYy5lbC5zcGFya2Nhcm91c2VsaXRlbS5jdXJyZW50UG9zaXRpb24oKSArIHRoaXMud2lkdGggLyAyKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fYWRkVHJhbnNmb3JtKC1jLmVsLnNwYXJrY2Fyb3VzZWxpdGVtLmN1cnJlbnRQb3NpdGlvbigpICsgdGhpcy53aWR0aCAvIDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGNvbXBvbmVudCB0byB1c2UgYSBuZXcgZWxlbWVudCBvciByZXBhcnNlIGZyb21cbiAgICogdGhlIGV4aXN0aW5nIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgT3B0aW9uYWxcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGVsKSB7XG5cbiAgICBlbCA9IGVsIHx8IHRoaXMuZWw7XG5cbiAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemVIKTtcbiAgICBkZWxldGUgdGhpcy5yZXNpemVIO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NwYXJrLnZpc2libGUtY2hpbGRyZW4nLCB0aGlzLl9oYW5kbGVWaXNpYmxlQ2hpbGRyZW4sIHRydWUpO1xuICAgIGRlbGV0ZSB0aGlzLl9oYW5kbGVWaXNpYmxlQ2hpbGRyZW47XG4gICAgdGhpcy5faW5pdChlbCk7XG5cbiAgICB0aGlzLmNoYW5nZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRvdWNoc3RhcnQgZXZlbnQgaGFuZGxlciwgcGFzc2VzIG5lY2Vzc2FyeSBkYXRhIHBvaW50cyB0byB0aGUgbW92ZXN0YXJ0IGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSB0b3VjaHN0YXJ0IGV2ZW50XG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl90b3VjaHN0YXJ0ID0gZnVuY3Rpb24gX3RvdWNoc3RhcnQoZSkge1xuICAgIHZhciBhID0ge1xuICAgICAgJ3R5cGUnOiBlLnR5cGUsXG4gICAgICAncGFnZVgnOiBlLnRvdWNoZXNbMF0ucGFnZVgsXG4gICAgICAncGFnZVknOiBlLnRvdWNoZXNbMF0ucGFnZVksXG4gICAgICAndGltZVN0YW1wJzogZS50aW1lU3RhbXBcbiAgICB9O1xuICAgIHRoaXMuX21vdmVzdGFydChhKTtcbiAgfTtcblxuICAvKipcbiAgICogVG91Y2htb3ZlIGV2ZW50IGhhbmRsZXIsIHBhc3NlcyBuZWNlc3NhcnkgZGF0YSBwb2ludHMgdG8gdGhlIG1vdmUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIHRvdWNobW92ZSBldmVudFxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fdG91Y2htb3ZlID0gZnVuY3Rpb24gX3RvdWNobW92ZShlKSB7XG4gICAgdmFyIGEgPSB7XG4gICAgICAndHlwZSc6IGUudHlwZSxcbiAgICAgICdwYWdlWCc6IGUudG91Y2hlc1swXS5wYWdlWCxcbiAgICAgICdwYWdlWSc6IGUudG91Y2hlc1swXS5wYWdlWSxcbiAgICAgICd0aW1lU3RhbXAnOiBlLnRpbWVTdGFtcCxcbiAgICAgICdjYW5jZWxhYmxlJzogZS5jYW5jZWxhYmxlXG4gICAgfTtcbiAgICB0aGlzLl9tb3ZlKGEpO1xuICAgIGlmIChhLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUb3VjaGVuZCBldmVudCBoYW5kbGVyLCBwYXNzZXMgbmVjZXNzYXJ5IGRhdGEgcG9pbnRzIHRvIHRoZSBtb3ZlZW5kIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSB0b3VjaGVuZCBldmVudFxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fdG91Y2hlbmQgPSBmdW5jdGlvbiBfdG91Y2hlbmQoZSkge1xuICAgIGlmICh0aGlzLm1vdmVzICYmIHRoaXMubW92ZXMubGVuZ3RoID4gMiAmJiBlLmNhbmNlbGFibGUpIHtcbiAgICAgIHZhciBhID0ge1xuICAgICAgICAndHlwZSc6IGUudHlwZSxcbiAgICAgICAgJ3BhZ2VYJzogdGhpcy5tb3Zlc1t0aGlzLm1vdmVzLmxlbmd0aCAtIDFdLnBhZ2VYLFxuICAgICAgICAncGFnZVknOiB0aGlzLm1vdmVzW3RoaXMubW92ZXMubGVuZ3RoIC0gMV0ucGFnZVksXG4gICAgICAgICd0aW1lU3RhbXAnOiBlLnRpbWVTdGFtcFxuICAgICAgfTtcbiAgICAgIHRoaXMuX21vdmVlbmQoYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLm1vdmVzO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTW91c2Vkb3duIGV2ZW50IGhhbmRsZXIsIHBhc3NlcyBuZWNlc3NhcnkgZGF0YSBwb2ludHMgdG8gdGhlIG1vdmVzdGFydCBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgbW91c2Vkb3duIGV2ZW50XG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9tb3VzZWRvd24gPSBmdW5jdGlvbiBfbW91c2Vkb3duKGUpIHtcbiAgICBpZiAoZS5idXR0b24gIT09IDApIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICB0aGlzLmlzTW91c2VEb3duID0gdHJ1ZTtcbiAgICB2YXIgYSA9IHtcbiAgICAgICd0eXBlJzogZS50eXBlLFxuICAgICAgJ3BhZ2VYJzogZS5wYWdlWCxcbiAgICAgICdwYWdlWSc6IGUucGFnZVksXG4gICAgICAndGltZVN0YW1wJzogZS50aW1lU3RhbXBcbiAgICB9O1xuICAgIHRoaXMuX21vdmVzdGFydChhKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vdXNlbW92ZSBldmVudCBoYW5kbGVyLCBwYXNzZXMgbmVjZXNzYXJ5IGRhdGEgcG9pbnRzIHRvIHRoZSBtb3ZlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBtb3VzZW1vdmUgZXZlbnRcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX21vdXNlbW92ZSA9IGZ1bmN0aW9uIF9tb3VzZW1vdmUoZSkge1xuICAgIGlmICh0aGlzLmlzTW91c2VEb3duKSB7XG4gICAgICB2YXIgYSA9IHtcbiAgICAgICAgJ3R5cGUnOiBlLnR5cGUsXG4gICAgICAgICdwYWdlWCc6IGUuY2xpZW50WCxcbiAgICAgICAgJ3BhZ2VZJzogZS5jbGllbnRZLFxuICAgICAgICAndGltZVN0YW1wJzogZS50aW1lU3RhbXAsXG4gICAgICAgIC8vdGhpcyB3YXMgY2hhbmdlZCB0byBjb3JyZWN0IGFuIGlzc3VlIGluIHNhZmFyaSAtIGl0IGRvZXNuJ3QgcmVwb3J0IGNhbmNlbGFibGUgY29ycmVjdGx5XG4gICAgICAgICdjYW5jZWxhYmxlJzogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHRoaXMuX21vdmUoYSk7XG4gICAgICBpZiAoYS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNb3VzZXVwIGV2ZW50IGhhbmRsZXIsIHBhc3NlcyBuZWNlc3NhcnkgZGF0YSBwb2ludHMgdG8gdGhlIG1vdmVlbmQgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIG1vdXNldXAgZXZlbnRcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX21vdXNldXAgPSBmdW5jdGlvbiBfbW91c2V1cChlKSB7XG4gICAgaWYgKHRoaXMubW92ZXMgJiYgdGhpcy5tb3Zlcy5sZW5ndGggPiAyKSB7XG4gICAgICB2YXIgYSA9IHtcbiAgICAgICAgJ3R5cGUnOiBlLnR5cGUsXG4gICAgICAgICdwYWdlWCc6IGUucGFnZVgsXG4gICAgICAgICdwYWdlWSc6IGUucGFnZVksXG4gICAgICAgICd0aW1lU3RhbXAnOiBlLnRpbWVTdGFtcFxuICAgICAgfTtcbiAgICAgIHRoaXMuX21vdmVlbmQoYSk7XG4gICAgICB0aGlzLm1vdXNlVXBIYW5kbGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMubW92ZXM7XG4gICAgICB0aGlzLl9zY3JvbGxUb0NsaWNrZWQoZSk7XG4gICAgfVxuICAgIHRoaXMuaXNNb3VzZURvd24gPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xpY2sgZXZlbnQgaGFuZGxlclxuICAgKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgY2xpY2sgZXZlbnRcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX2NsaWNrID0gZnVuY3Rpb24gX2NsaWNrKGUpIHtcbiAgICAvL2lmIHdlIGFyZSBhbHJlYWR5IHRyYWNraW5nIG1vdmVzLCB0aGVuIHRoaXMgd2lsbCBiZSBoYW5kbGVkIGJ5IHRoZSBtb3VzZWVuZCBldmVudCBoYW5kbGVyIGFuZCB3ZSBzaG91bGQgcHJldmVudCB0aGUgZGVmYXVsdCBhY3Rpb25cbiAgICBpZiAodGhpcy5tb3Zlcykge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICAvL2lmIGl0IGhhcyBhbHJlYWR5IGJlZW4gaGFuZGxlZCBieSBtb3VzZXVwIGhhbmRsZXIsIHByZXZlbnQgdGhlIGFjdGlvblxuICAgIGlmICh0aGlzLm1vdXNlVXBIYW5kbGVkKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIC8vcmVzZXQgb3VyIGhhbmRsZWQgc3RhdGVcbiAgICBkZWxldGUgdGhpcy5tb3VzZVVwSGFuZGxlZDtcbiAgICAvL2NoZWNraW5nIGJvdGggdGhpcy5tb3ZlcyBhbmQgdGhpcy5tb3VzZVVwSGFuZGxlZCBlbnN1cmVzIHdlIGNhcHR1cmUgZXZlbnRzIGNvcnJlY3RseSBpbiBhbGwgYnJvd3NlcnMsIHdoZXJlIHRoZSBvcmRlciBvZiB0aGUgbW91c2V1cC9jbGljayBldmVudHMgY2FuIHZhcnlcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSB1c2VyJ3MgcmVjZW50IGN1cnNvci9maW5nZXIgdmVsb2NpdHlcbiAgICogQHBhcmFtIHtBcnJheX0gbW92ZXMgVGhlIGFycmF5IG9mIGN1cnNvciBwb3NpdGlvbnNcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX3ZlbG9jaXR5ID0gZnVuY3Rpb24gX3ZlbG9jaXR5KG1vdmVzKSB7XG4gICAgdmFyIGF2ZyA9IDA7XG4gICAgdmFyIG0gPSBNYXRoLm1pbig2LCBtb3Zlcy5sZW5ndGggLSAxKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IG07IGkrKykge1xuICAgICAgaWYgKG1vdmVzW21vdmVzLmxlbmd0aCAtIGldLnRpbWVTdGFtcCA9PT0gbW92ZXNbbW92ZXMubGVuZ3RoIC0gaSAtIDFdLnRpbWVTdGFtcCkge1xuICAgICAgICBhdmcgKz0gYXZnIC8gaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF2ZyArPSAxMCAqIChtb3Zlc1ttb3Zlcy5sZW5ndGggLSBpXS5wYWdlWCAtIG1vdmVzW21vdmVzLmxlbmd0aCAtIGkgLSAxXS5wYWdlWCkgLyAobW92ZXNbbW92ZXMubGVuZ3RoIC0gaV0udGltZVN0YW1wIC0gbW92ZXNbbW92ZXMubGVuZ3RoIC0gaSAtIDFdLnRpbWVTdGFtcCkgLyBtO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXZnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGNsaWNrIGV2ZW50cyBvbiBpdGVtcyBhbmQgZG90cywgc2Nyb2xsaW5nIHRvIHRoZSBjbGlja2VkIGl0ZW1cbiAgICogQHBhcmFtIHtFdmVudH0gZSBUaGUgY2xpY2sgZXZlbnRcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX3Njcm9sbFRvQ2xpY2tlZCA9IGZ1bmN0aW9uIF9zY3JvbGxUb0NsaWNrZWQoZSkge1xuICAgIHZhciB0YXIgPSBlLnRhcmdldDtcbiAgICBpZiAodGhpcy5lbC5jb250YWlucyh0YXIpKSB7XG4gICAgICB3aGlsZSAoIXRhci5zcGFya2Nhcm91c2VsKSB7XG4gICAgICAgIGlmICh0YXIuc3BhcmtjYXJvdXNlbGl0ZW0pIHtcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lck1hc2suc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgICAgZGVsZXRlIHRoaXMubW92ZXM7XG4gICAgICAgICAgdGhpcy5fcmFmQ2FuY2VsKCk7XG4gICAgICAgICAgdGhpcy5fc2Nyb2xsVG8odGFyLnNwYXJrY2Fyb3VzZWxpdGVtKTtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhci5zcGFya2Nhcm91c2VsaXRlbWRvdCkge1xuICAgICAgICAgIHRoaXMuY29udGFpbmVyTWFzay5zY3JvbGxMZWZ0ID0gMDtcbiAgICAgICAgICBkZWxldGUgdGhpcy5tb3ZlcztcbiAgICAgICAgICB0aGlzLl9yYWZDYW5jZWwoKTtcbiAgICAgICAgICB2YXIgdiA9IHRhci5zcGFya2Nhcm91c2VsaXRlbWRvdC5vcmRlciA8IHRoaXMuX3NlbGVjdGVkSXRlbSgpLm9yZGVyID8gdGhpcy5vcHRzLnN0YXJ0aW5nVmVsb2NpdHkgOiAtdGhpcy5vcHRzLnN0YXJ0aW5nVmVsb2NpdHk7XG4gICAgICAgICAgdGhpcy5fc2Nyb2xsVG8odGFyLnNwYXJrY2Fyb3VzZWxpdGVtZG90LCB2KTtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGFyID0gdGFyLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTY3JvbGwgdG8gdGhlIGNhcm91c2VsSXRlbSwgd2l0aCBzcGVjaWZpZWQgc3RhcnRpbmdWZWxvY2l0eSwgYXV0byBkZXRlcm1pbmVzIGRlZmF1bHQgdmVsb2NpdHkgaWYgbm90IHNwZWNpZmllZFxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgY2Fyb3VzZWxJdGVtIHRvIHNjcm9sbCB0b1xuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRpbmdWZWxvY2l0eSBUaGUgc3RhcnRpbmdWZWxvY2l0eSBvZiB0aGUgc2Nyb2xsIGFuaW1hdGlvblxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fc2Nyb2xsVG8gPSBmdW5jdGlvbiBfc2Nyb2xsVG8oaXRlbSwgc3RhcnRpbmdWZWxvY2l0eSkge1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLndpZHRoIC8gMjtcbiAgICB2YXIgY3VycmVudFBvc2l0aW9uID0gaXRlbS5jdXJyZW50UG9zaXRpb24oKTtcbiAgICBpZiAoIXN0YXJ0aW5nVmVsb2NpdHkpIHtcbiAgICAgIHN0YXJ0aW5nVmVsb2NpdHkgPSBvZmZzZXQgLSBpdGVtLmN1cnJlbnRQb3NpdGlvbigpID4gMCA/IHRoaXMub3B0cy5zdGFydGluZ1ZlbG9jaXR5IDogLXRoaXMub3B0cy5zdGFydGluZ1ZlbG9jaXR5O1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRzLndyYXBJdGVtcykge1xuICAgICAgaWYgKHN0YXJ0aW5nVmVsb2NpdHkgPiAwKSB7XG4gICAgICAgIC8vbGVmdFxuICAgICAgICBpZiAoY3VycmVudFBvc2l0aW9uID4gb2Zmc2V0KSB7XG4gICAgICAgICAgdGhpcy5fdG90YWxEaXN0YW5jZSA9IG9mZnNldCArIHRoaXMudG90YWxJdGVtV2lkdGggLSBjdXJyZW50UG9zaXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fdG90YWxEaXN0YW5jZSA9IG9mZnNldCAtIGN1cnJlbnRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9yaWdodFxuICAgICAgICBpZiAoY3VycmVudFBvc2l0aW9uIDwgb2Zmc2V0KSB7XG4gICAgICAgICAgdGhpcy5fdG90YWxEaXN0YW5jZSA9IC0odGhpcy50b3RhbEl0ZW1XaWR0aCArIGN1cnJlbnRQb3NpdGlvbiAtIG9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fdG90YWxEaXN0YW5jZSA9IG9mZnNldCAtIGN1cnJlbnRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90b3RhbERpc3RhbmNlID0gb2Zmc2V0IC0gY3VycmVudFBvc2l0aW9uO1xuICAgIH1cbiAgICB0aGlzLl9zdGFydGluZ1ZlbG9jaXR5ID0gc3RhcnRpbmdWZWxvY2l0eTtcbiAgICBkZWxldGUgdGhpcy5tb3ZlcztcbiAgICB0aGlzLl9zY3JvbGxUb0l0ZW0gPSB0cnVlO1xuICAgIHRoaXMuX3JhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fcmFmSGFuZGxlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIGFuaW1hdG9yIGZ1bmN0aW9uLCBpdCBleGFtaW5lcyB0aGUgb3B0aW9ucyBzZXQgb24gdGhlIGNhcm91c2VsIG9iamVjdFxuICAgKiBhbmQgc2VsZWN0aXZlbHkgYWRkcyB0cmFuc2Zvcm0gYW5kIHJlcXVlc3RzIGFkZHRpb25hbCBhbmltYXRpb24gZnJhbWVzIGlmIG5lY2VzYXJ5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0IFRoZSB0aW1lc3RhbXAgZm9yIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBmcmFtZVxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fcmFmSGFuZGxlckggPSBmdW5jdGlvbiBfcmFmSGFuZGxlckgodCkge1xuICAgIGlmICh0aGlzLm9wdHMuYXV0b0FkdmFuY2UgJiYgdGhpcy5hdXRvQWR2YW5jZSkge1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmF1dG9BZHZhbmNlKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmF1dG9BZHZhbmNlO1xuICAgIH1cbiAgICB2YXIgZnJhbWVzO1xuICAgIGlmICh0aGlzLm1vdmVzIHx8ICF0aGlzLl9zdGFydGluZ1ZlbG9jaXR5KSB7XG4gICAgICB0aGlzLl9yYWZDYW5jZWwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9sYXN0c3RhcnQpIHtcbiAgICAgIHRoaXMuX2xhc3RzdGFydCA9IHQ7XG4gICAgfVxuICAgIGlmICghdGhpcy5fcmVtYWluaW5nRGlzdGFuY2UpIHtcbiAgICAgIHRoaXMuX3JlbWFpbmluZ0Rpc3RhbmNlID0gdGhpcy5fdG90YWxEaXN0YW5jZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9sYXN0ZnJhbWUpIHtcbiAgICAgIHRoaXMuX2xhc3RmcmFtZSA9IHQ7XG4gICAgICBmcmFtZXMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFtZXMgPSAodCAtIHRoaXMuX2xhc3RmcmFtZSkgLyAoMSAvIDYwICogMTAwMCk7XG4gICAgfVxuICAgIHZhciBkID0gdGhpcy5fc3RhcnRpbmdWZWxvY2l0eSAqIGZyYW1lcztcbiAgICBpZiAodGhpcy5vcHRzLnNtb290aFNjcm9sbCAmJiAhdGhpcy5fc2Nyb2xsVG9JdGVtKSB7XG4gICAgICB0aGlzLl9hZGRUcmFuc2Zvcm0oZCk7XG4gICAgICB0aGlzLl9zdGFydGluZ1ZlbG9jaXR5ICo9IE1hdGgucG93KDAuOTcsIGZyYW1lcyk7XG4gICAgICBpZiAodGhpcy5vcHRzLnNtb290aFNjcm9sbENlbnRlckl0ZW1zICYmIE1hdGguYWJzKHRoaXMuX3N0YXJ0aW5nVmVsb2NpdHkpIDwgMSkge1xuICAgICAgICB0aGlzLl9zY3JvbGxUbyh0aGlzLl9zZWxlY3RlZEl0ZW0oKSk7XG4gICAgICB9XG4gICAgICBpZiAoTWF0aC5hYnModGhpcy5fc3RhcnRpbmdWZWxvY2l0eSkgPCAwLjUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXJ0aW5nVmVsb2NpdHkgPiAwICYmIHRoaXMudHJhbnNmb3JtLnggPiB0aGlzLnRvdGFsSXRlbVdpZHRoIC8gMiAtIHRoaXMuaXRlbXNbMF0ud2lkdGggLyAyIHx8IHRoaXMuX3N0YXJ0aW5nVmVsb2NpdHkgPCAwICYmIHRoaXMudHJhbnNmb3JtLnggPCAtKHRoaXMudG90YWxJdGVtV2lkdGggLyAyIC0gdGhpcy5pdGVtc1t0aGlzLml0ZW1zLmxlbmd0aCAtIDFdLndpZHRoIC8gMikpIHtcbiAgICAgICAgICB0aGlzLl9zY3JvbGxUb0l0ZW0gPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMuX3NlbGVjdGVkSXRlbSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yYWZDYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9yYWZIYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX3N0YXJ0aW5nVmVsb2NpdHkgPiAwKSB7XG4gICAgICAgIGlmIChkIDwgdGhpcy5fcmVtYWluaW5nRGlzdGFuY2UpIHtcbiAgICAgICAgICB0aGlzLl9hZGRUcmFuc2Zvcm0oZCk7XG4gICAgICAgICAgdGhpcy5fcmVtYWluaW5nRGlzdGFuY2UgLT0gZDtcbiAgICAgICAgICBpZiAodGhpcy5fcmVtYWluaW5nRGlzdGFuY2UgPiB0aGlzLl90b3RhbERpc3RhbmNlIC8gMikge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRpbmdWZWxvY2l0eSAqPSBNYXRoLnBvdygxLjE1LCBmcmFtZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydGluZ1ZlbG9jaXR5ICo9IE1hdGgucG93KDAuOSwgZnJhbWVzKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0aW5nVmVsb2NpdHkgPSB0aGlzLl9zdGFydGluZ1ZlbG9jaXR5ID4gMiA/IHRoaXMuX3N0YXJ0aW5nVmVsb2NpdHkgOiAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9yYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JhZkhhbmRsZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2FkZFRyYW5zZm9ybSh0aGlzLl9yZW1haW5pbmdEaXN0YW5jZSk7XG4gICAgICAgICAgdGhpcy5fcmFmQ2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkID4gdGhpcy5fcmVtYWluaW5nRGlzdGFuY2UpIHtcbiAgICAgICAgICB0aGlzLl9hZGRUcmFuc2Zvcm0oZCk7XG4gICAgICAgICAgdGhpcy5fcmVtYWluaW5nRGlzdGFuY2UgLT0gZDtcbiAgICAgICAgICBpZiAodGhpcy5fcmVtYWluaW5nRGlzdGFuY2UgPCB0aGlzLl90b3RhbERpc3RhbmNlIC8gMikge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRpbmdWZWxvY2l0eSAqPSBNYXRoLnBvdygxLjE1LCBmcmFtZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydGluZ1ZlbG9jaXR5ICo9IE1hdGgucG93KDAuOSwgZnJhbWVzKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0aW5nVmVsb2NpdHkgPSB0aGlzLl9zdGFydGluZ1ZlbG9jaXR5IDwgLTIgPyB0aGlzLl9zdGFydGluZ1ZlbG9jaXR5IDogLTI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3JhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fcmFmSGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fYWRkVHJhbnNmb3JtKHRoaXMuX3JlbWFpbmluZ0Rpc3RhbmNlKTtcbiAgICAgICAgICB0aGlzLl9yYWZDYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9sYXN0ZnJhbWUgPSB0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBhbmltYXRvciBjbGVhcmluZyBmdW5jdGlvblxuICAgKiBpdCBjbGVhcnMgdmFsdWVzIHVzZWQgZHVyaW5nIGFuaW1hdGlvbiwgYW5kIHNlbGVjdGl2ZWx5IGVuYWJsZXMgYXV0b0FkdmFuY2VcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX3JhZkNhbmNlbCA9IGZ1bmN0aW9uIF9yYWZDYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMub3B0cy5hdXRvQWR2YW5jZSAmJiAhdGhpcy5hdXRvQWR2YW5jZSAmJiAhdGhpcy5wYXVzZSkge1xuICAgICAgdGhpcy5hdXRvQWR2YW5jZSA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYXV0b0FkdmFuY2UoKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgdGhpcy5vcHRzLmF1dG9BZHZhbmNlICogMTAwMCk7XG4gICAgfVxuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yYWYpO1xuICAgIGRlbGV0ZSB0aGlzLl9zY3JvbGxUb0l0ZW07XG4gICAgZGVsZXRlIHRoaXMuX2xhc3RzdGFydDtcbiAgICBkZWxldGUgdGhpcy5fc3RhcnRpbmdWZWxvY2l0eTtcbiAgICBkZWxldGUgdGhpcy5fcmVtYWluaW5nRGlzdGFuY2U7XG4gICAgZGVsZXRlIHRoaXMuX3RvdGFsRGlzdGFuY2U7XG4gICAgZGVsZXRlIHRoaXMuX2xhc3RmcmFtZTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBjb21wdXRlcyB2YWx1ZXMgbmVjZXNzYXJ5IHRvIHN0YXJ0IGFuIGFuaW1hdGlvbiBmcmFtZSB3aGVuIHRoZSBjYXJvdXNlbCBpc1xuICAgKiBjb25maWd1cmVkIHRvIHVzZSBzbW9vdGhTY3JvbGxcbiAgICogQHBhcmFtIHtBcnJheX0gbW92ZXMgVGhlIGNhcHR1cmVkIG1vdmUgZXZlbnRzXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9pbnRlcmlhU2Nyb2xsID0gZnVuY3Rpb24gX2ludGVyaWFTY3JvbGwobW92ZXMpIHtcbiAgICBpZiAobW92ZXNbbW92ZXMubGVuZ3RoIC0gMV0udGltZVN0YW1wIC0gbW92ZXNbbW92ZXMubGVuZ3RoIC0gMl0udGltZVN0YW1wID4gMTAwIHx8IG1vdmVzLmxlbmd0aCA8IDMpIHtcbiAgICAgIGlmICh0aGlzLm9wdHMuc21vb3RoU2Nyb2xsQ2VudGVySXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbFRvKHRoaXMuX3NlbGVjdGVkSXRlbSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRpbmdWZWxvY2l0eSA9IHRoaXMuX3ZlbG9jaXR5KG1vdmVzKTtcbiAgICBkZWxldGUgdGhpcy5tb3ZlcztcbiAgICB0aGlzLl9yYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JhZkhhbmRsZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGRldGVybWluZXMgd2hpY2ggY2Fyb3VzZWwgaXRlbSBzaG91bGQgYmUgZm9jdXNlZCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgbW92ZXNcbiAgICogbWFkZSBieSB0aGUgdXNlclxuICAgKiBAcGFyYW0ge0FycmF5fSBtb3ZlcyBUaGUgY2FwdHVyZWQgbW92ZSBldmVudHNcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX3NldHRsZSA9IGZ1bmN0aW9uIF9zZXR0bGUobW92ZXMpIHtcbiAgICBpZiAobW92ZXMgJiYgbW92ZXMubGVuZ3RoID4gMykge1xuICAgICAgaWYgKG1vdmVzW21vdmVzLmxlbmd0aCAtIDFdLnRpbWVTdGFtcCAtIG1vdmVzW21vdmVzLmxlbmd0aCAtIDJdLnRpbWVTdGFtcCA+IDgwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxUbyh0aGlzLl9zZWxlY3RlZEl0ZW0oKSk7XG4gICAgICB9XG4gICAgICB2YXIgdjEgPSAxMCAqIChtb3Zlc1ttb3Zlcy5sZW5ndGggLSAzXS5wYWdlWCAtIG1vdmVzW21vdmVzLmxlbmd0aCAtIDRdLnBhZ2VYKSAvIChtb3Zlc1ttb3Zlcy5sZW5ndGggLSAzXS50aW1lU3RhbXAgLSBtb3Zlc1ttb3Zlcy5sZW5ndGggLSA0XS50aW1lU3RhbXApO1xuICAgICAgdmFyIHYyID0gMTAgKiAobW92ZXNbbW92ZXMubGVuZ3RoIC0gMl0ucGFnZVggLSBtb3Zlc1ttb3Zlcy5sZW5ndGggLSAzXS5wYWdlWCkgLyAobW92ZXNbbW92ZXMubGVuZ3RoIC0gMl0udGltZVN0YW1wIC0gbW92ZXNbbW92ZXMubGVuZ3RoIC0gM10udGltZVN0YW1wKTtcbiAgICAgIGlmIChNYXRoLmFicyh2MSkgPCBNYXRoLmFicyh2MikgfHwgTWF0aC5hYnModjIpID4gMC41ICYmIE1hdGguYWJzKHYyKSA+IDAuNSkge1xuICAgICAgICAvL3VzZXIgaXMgcHJvYmFibHkgdHJ5aW5nIHRvIGdvIHRvIG5leHQgb3IgcHJldiBpdGVtXG4gICAgICAgIHZhciBzID0gdGhpcy5pdGVtcy5pbmRleE9mKHRoaXMuX3NlbGVjdGVkSXRlbSgpKTtcbiAgICAgICAgaWYgKHYyID4gMCkge1xuICAgICAgICAgIC8vcHJldlxuICAgICAgICAgIGlmIChzID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG8odGhpcy5pdGVtc1tzIC0gMV0sIHYyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy53cmFwSXRlbXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG8odGhpcy5pdGVtc1t0aGlzLml0ZW1zLmxlbmd0aCAtIDFdLCB2Mik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxUbyh0aGlzLml0ZW1zWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9uZXh0XG4gICAgICAgICAgaWYgKHMgPCB0aGlzLml0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMuaXRlbXNbcyArIDFdLCB2Mik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMud3JhcEl0ZW1zKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMuaXRlbXNbMF0sIHYyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMuaXRlbXNbdGhpcy5pdGVtcy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWRJdGVtKCkuY3VycmVudFBvc2l0aW9uKCkgPiB0aGlzLndpZHRoIC8gMikge1xuICAgICAgICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMuX3NlbGVjdGVkSXRlbSgpLCAtdGhpcy5vcHRzLnN0YXJ0aW5nVmVsb2NpdHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMuX3NlbGVjdGVkSXRlbSgpLCB0aGlzLm9wdHMuc3RhcnRpbmdWZWxvY2l0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhlIHBvc2l0aW9uIG9mIGFsbCBjYXJvdXNlbEl0ZW1zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBwaXhlbCB2YWx1ZSB0byB0cmFuc2Zvcm1cbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX3RyYW5zZm9ybUl0ZW1zID0gZnVuY3Rpb24gX3RyYW5zZm9ybUl0ZW1zKHgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuaXRlbXNbaV0uYWRkVHJhbnNmb3JtKHgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgdHJhbnNmb3JtIHBvc2l0aW9uIG9mIGFsbCBjYXJvdXNlbEl0ZW1zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBwaXhlbCB2YWx1ZSB0byB0cmFuc2Zvcm1cbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX3NldFRyYW5zZm9ybUl0ZW1zID0gZnVuY3Rpb24gX3NldFRyYW5zZm9ybUl0ZW1zKHgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuaXRlbXNbaV0uc2V0VHJhbnNmb3JtKHgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkcyB0cmFuc2Zvcm0gdG8gdGhlIGNvbnRhaW5lciBlbGVtZW50LCBkb2VzIGNoZWNraW5nIGZvciBib3VuZHMgY29uZGl0aW9ucyBhbmRcbiAgICogd3JhcHMgaXRlbXMgaWYgbmVjZXNzYXJ5IGFuZCBjb25maWd1cmVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBwaXhlbCB2YWx1ZSB0byB0cmFuc2Zvcm1cbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX2FkZFRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9hZGRUcmFuc2Zvcm0oeCkge1xuICAgIHZhciBhO1xuICAgIGlmICgodGhpcy5vcHRzLnNtb290aFNjcm9sbENlbnRlckl0ZW1zIHx8ICF0aGlzLm9wdHMuc21vb3RoU2Nyb2xsKSAmJiAhdGhpcy5vcHRzLndyYXBJdGVtcyAmJiAhdGhpcy5vcHRzLmVkZ2VTY3JvbGwpIHtcbiAgICAgIHZhciBsID0gdGhpcy5pdGVtcy5pbmRleE9mKHRoaXMuc2VsZWN0ZWRJdGVtKTtcbiAgICAgIGlmIChsID09PSB0aGlzLml0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhpcy5fbGVmdGJvdW5kKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbGVmdGJvdW5kKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChsID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3JpZ2h0Ym91bmQodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yaWdodGJvdW5kKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbGVmdGJvdW5kKGZhbHNlKTtcbiAgICAgIHRoaXMuX3JpZ2h0Ym91bmQoZmFsc2UpO1xuICAgIH1cbiAgICBpZiAodGhpcy50cmFuc2Zvcm0ueCArIHggPCAwICYmIHggPCAwKSB7XG4gICAgICBpZiAodGhpcy5vcHRzLndyYXBJdGVtcykge1xuICAgICAgICAvL3dyYXAgaXRlbXMgdW50aWwgd2UgaGF2ZSBjb3ZlcmVkIHRoZSB2aXNpYmxlIGFyZWFcbiAgICAgICAgd2hpbGUgKHRoaXMudHJhbnNmb3JtLnggKyB4IDwgLSh0aGlzLnRvdGFsSXRlbVdpZHRoIC0gdGhpcy53aWR0aCkgLyAyICYmICh0aGlzLnRvdGFsSXRlbVdpZHRoIDwgdGhpcy53aWR0aCA/IHRoaXMudHJhbnNmb3JtLnggKyB4IDwgLXRoaXMudG90YWxJdGVtV2lkdGggLyAyIDogdHJ1ZSkpIHtcbiAgICAgICAgICBhID0gdGhpcy5pdGVtcy5zaGlmdCgpO1xuICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChhKTtcbiAgICAgICAgICBhLmFkZFRyYW5zZm9ybSh0aGlzLnRvdGFsSXRlbVdpZHRoKTtcbiAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1JdGVtcygtYS53aWR0aCk7XG4gICAgICAgICAgeCArPSBhLndpZHRoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL3RoZXJlIGlzIGEgMSBwaXhlbCBhZGp1c3RtZW50IHRvIGFjY291bnQgZm9yIHNvbWUgbWF0aCByb3VuZGluZ1xuICAgICAgICBpZiAodGhpcy5vcHRzLmVkZ2VTY3JvbGwgJiYgeCA8IDAgJiYgdGhpcy50cmFuc2Zvcm0ueCArIHggLSAxIDw9IC0odGhpcy50b3RhbEl0ZW1XaWR0aCAtIHRoaXMud2lkdGgpIC8gMikge1xuICAgICAgICAgIHRoaXMuX2xlZnRib3VuZCh0cnVlKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0VHJhbnNmb3JtKC0odGhpcy50b3RhbEl0ZW1XaWR0aCAtIHRoaXMud2lkdGgpIC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgLy9wcm9ncmVzc2l2ZWx5IHJlZHVjZSBzY3JvbGxpbmcgd2hlbiBubyBtb3JlIGl0ZW1zIHRvIHRoZSByaWdodFxuICAgICAgICBpZiAoeCA8IDAgJiYgdGhpcy50cmFuc2Zvcm0ueCArIHggPCAtKHRoaXMudG90YWxJdGVtV2lkdGggLyAyIC0gdGhpcy5pdGVtc1t0aGlzLml0ZW1zLmxlbmd0aCAtIDFdLndpZHRoIC8gMikpIHtcbiAgICAgICAgICB4ID0geCAqICgodGhpcy50b3RhbEl0ZW1XaWR0aCAvIDIgKyB0aGlzLml0ZW1zW3RoaXMuaXRlbXMubGVuZ3RoIC0gMV0ud2lkdGggLyAyICsgKHRoaXMudHJhbnNmb3JtLnggKyB4KSkgLyB0aGlzLml0ZW1zW3RoaXMuaXRlbXMubGVuZ3RoIC0gMV0ud2lkdGgpO1xuICAgICAgICAgIHggPSB4ID4gMCA/IDAgOiB4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fc2V0VHJhbnNmb3JtKHRoaXMudHJhbnNmb3JtLnggKyB4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMudHJhbnNmb3JtLnggKyB4ID4gMCAmJiB4ID4gMCkge1xuICAgICAgICBpZiAodGhpcy5vcHRzLndyYXBJdGVtcykge1xuICAgICAgICAgIC8vd3JhcCBpdGVtcyB1bnRpbCB3ZSBoYXZlIGNvdmVyZWQgdGhlIHZpc2libGUgYXJlYVxuICAgICAgICAgIHdoaWxlICh0aGlzLnRyYW5zZm9ybS54ICsgeCA+IC0odGhpcy53aWR0aCAtIHRoaXMudG90YWxJdGVtV2lkdGgpIC8gMiAmJiAodGhpcy50b3RhbEl0ZW1XaWR0aCA8IHRoaXMud2lkdGggPyB0aGlzLnRyYW5zZm9ybS54ICsgeCA+IHRoaXMudG90YWxJdGVtV2lkdGggLyAyIDogdHJ1ZSkpIHtcbiAgICAgICAgICAgIGEgPSB0aGlzLml0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5pdGVtcy51bnNoaWZ0KGEpO1xuICAgICAgICAgICAgYS5hZGRUcmFuc2Zvcm0oLXRoaXMudG90YWxJdGVtV2lkdGgpO1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtSXRlbXMoYS53aWR0aCk7XG4gICAgICAgICAgICB4IC09IGEud2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vdGhlcmUgaXMgYSAxIHBpeGVsIGFkanVzdG1lbnQgdG8gYWNjb3VudCBmb3Igc29tZSBtYXRoIHJvdW5kaW5nXG4gICAgICAgICAgaWYgKHRoaXMub3B0cy5lZGdlU2Nyb2xsICYmIHggPiAwICYmIHRoaXMudHJhbnNmb3JtLnggKyB4ICsgMSA+PSAodGhpcy50b3RhbEl0ZW1XaWR0aCAtIHRoaXMud2lkdGgpIC8gMikge1xuICAgICAgICAgICAgdGhpcy5fcmlnaHRib3VuZCh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRUcmFuc2Zvcm0oKHRoaXMudG90YWxJdGVtV2lkdGggLSB0aGlzLndpZHRoKSAvIDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL3Byb2dyZXNzaXZlbHkgcmVkdWNlIHNjcm9sbGluZyB3aGVuIG5vIG1vcmUgaXRlbXMgdG8gdGhlIGxlZnRcbiAgICAgICAgICBpZiAoeCA+IDAgJiYgdGhpcy50cmFuc2Zvcm0ueCArIHggPiB0aGlzLnRvdGFsSXRlbVdpZHRoIC8gMiAtIHRoaXMuaXRlbXNbMF0ud2lkdGggLyAyKSB7XG4gICAgICAgICAgICB4ID0geCAqICgodGhpcy50b3RhbEl0ZW1XaWR0aCAvIDIgKyB0aGlzLml0ZW1zWzBdLndpZHRoIC8gMiAtICh0aGlzLnRyYW5zZm9ybS54ICsgeCkpIC8gdGhpcy5pdGVtc1swXS53aWR0aCk7XG4gICAgICAgICAgICB4ID0geCA8IDAgPyAwIDogeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9zZXRUcmFuc2Zvcm0odGhpcy50cmFuc2Zvcm0ueCArIHgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgbGVmdGJvdW5kIGNsYXNzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYiBTZXQgb3IgdW5zZXQgdGhlIGxlZnRib3VuZCBjbGFzc1xuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fbGVmdGJvdW5kID0gZnVuY3Rpb24gX2xlZnRib3VuZChiKSB7XG4gICAgaWYgKHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5sZWZ0Ym91bmQgPSB0eXBlb2YgdGhpcy5sZWZ0Ym91bmQgPT09ICd1bmRlZmluZWQnID8gZmFsc2UgOiB0aGlzLmxlZnRib3VuZDtcbiAgICAgIHJldHVybiB0aGlzLmxlZnRib3VuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGIpIHtcbiAgICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ2xlZnRib3VuZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ2xlZnRib3VuZCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5sZWZ0Ym91bmQgPSBiO1xuICAgICAgcmV0dXJuIHRoaXMubGVmdGJvdW5kO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgcmlnaHRib3VuZCBjbGFzc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGIgU2V0IG9yIHVuc2V0IHRoZSByaWdodGJvdW5kIGNsYXNzXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9yaWdodGJvdW5kID0gZnVuY3Rpb24gX3JpZ2h0Ym91bmQoYikge1xuICAgIGlmICh0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMucmlnaHRib3VuZCA9IHR5cGVvZiB0aGlzLnJpZ2h0Ym91bmQgPT09ICd1bmRlZmluZWQnID8gZmFsc2UgOiB0aGlzLnJpZ2h0Ym91bmQ7XG4gICAgICByZXR1cm4gdGhpcy5yaWdodGJvdW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYikge1xuICAgICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLmVsLCAncmlnaHRib3VuZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ3JpZ2h0Ym91bmQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmlnaHRib3VuZCA9IGI7XG4gICAgICByZXR1cm4gdGhpcy5yaWdodGJvdW5kO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2VsZWN0ZWQgaXRlbSwgYnkgc2VlaW5nIHdoaWNoIGl0ZW0gaGFzIGl0cyBjZW50ZXIgY2xvc2VzdFxuICAgKiB0byB0aGUgY2VudGVyIG9mIHRoZSBjYXJvdXNlbFxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fdXBkYXRlU2VsZWN0ZWQgPSBmdW5jdGlvbiBfdXBkYXRlU2VsZWN0ZWQoKSB7XG4gICAgdmFyIHRhciA9IHRoaXMud2lkdGggLyAyO1xuICAgIHZhciBpID0gLTE7XG4gICAgdmFyIGEgPSAxO1xuICAgIHZhciBiID0gMDtcbiAgICB3aGlsZSAoYSA+IGIpIHtcbiAgICAgIGkrKztcbiAgICAgIGlmIChpID4gdGhpcy5pdGVtcy5sZW5ndGggLSAyKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYSA9IE1hdGguYWJzKHRhciAtIHRoaXMuaXRlbXNbaV0uY3VycmVudFBvc2l0aW9uKCkpO1xuICAgICAgYiA9IE1hdGguYWJzKHRhciAtIHRoaXMuaXRlbXNbaSArIDFdLmN1cnJlbnRQb3NpdGlvbigpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkSXRlbSh0aGlzLml0ZW1zW2ldKTtcbiAgfTtcblxuICAvKipcbiAgICogU3RvcmVzIHRoZSBzZWxlY3RlZCBpdGVtIGZvciB0aGUgY2Fyb3VzZWwsIGFuZCB1cGRhdGVzIHRoZSBwcmV2aW91c2x5XG4gICAqIHNlbGVjdGVkIGl0ZW0gYW5kIG5ld2x5IHNlbGVjdGVkIGl0ZW0gdG8gaGF2ZSB0aGUgY29ycmVjdCBzdGF0ZXNcbiAgICogQ29uZGl0aW9uYWxseSBzZXRzIHRoZSBsZWZ0Ym91bmQvcmlnaHRib3VuZCBzdGF0ZXMgZGVwZW5kaW5nIG9uIGNvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gT3B0aW9uYWw6IHRoZSBuZXcgaXRlbSBzZWxlY3QsIGlmIG9taXR0ZWQgaXQgd2lsbFxuICAgKiByZXR1cm4gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtLlxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fc2VsZWN0ZWRJdGVtID0gZnVuY3Rpb24gX3NlbGVjdGVkSXRlbShpdGVtKSB7XG4gICAgaWYgKCh0eXBlb2YgaXRlbSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoaXRlbSkpICE9PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkSXRlbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVTZWxlY3RlZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0uc2V0U2VsZWN0ZWQoZmFsc2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0gPSBpdGVtO1xuICAgICAgaWYgKCh0aGlzLm9wdHMuc21vb3RoU2Nyb2xsQ2VudGVySXRlbXMgfHwgIXRoaXMub3B0cy5zbW9vdGhTY3JvbGwpICYmICF0aGlzLm9wdHMud3JhcEl0ZW1zICYmICF0aGlzLm9wdHMuZWRnZVNjcm9sbCkge1xuICAgICAgICB2YXIgbCA9IHRoaXMuaXRlbXMuaW5kZXhPZih0aGlzLnNlbGVjdGVkSXRlbSk7XG4gICAgICAgIGlmIChsID09PSB0aGlzLml0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICB0aGlzLl9sZWZ0Ym91bmQodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fbGVmdGJvdW5kKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX3JpZ2h0Ym91bmQodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcmlnaHRib3VuZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtLnNldFNlbGVjdGVkKHRydWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgdHJhbnNmb3JtIGZvciB0aGUgY2Fyb3VzZWwgY29udGFpbmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBwaXhlbCB2YWx1ZSB0byB0cmFuc2Zvcm1cbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX3NldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9zZXRUcmFuc2Zvcm0oeCkge1xuICAgIHggPSB4ID8geCA6IDA7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSB7XG4gICAgICAneCc6IHhcbiAgICB9O1xuICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAoMCwgX3RyYW5zZm9ybTIuZGVmYXVsdCkoJ3RyYW5zbGF0ZTNkJywgeCArICdweCwgMHB4LCAwcHgnKSk7XG4gICAgdGhpcy5fdXBkYXRlU2VsZWN0ZWQoKTtcbiAgICByZXR1cm4geDtcbiAgfTtcblxuICByZXR1cm4gQ2Fyb3VzZWw7XG59KF9iYXNlMi5kZWZhdWx0KTtcblxuLyoqXG4gKiBEZWZhdWx0IHZhbHVlcyBmb3IgaW50ZXJuYWwgcHJvcGVydGllcyB3ZSB3aWxsIGJlIHNldHRpbmcuXG4gKiBUaGVzZSBhcmUgc2V0IG9uIGVhY2ggY29uc3RydWN0aW9uIHNvIHdlIGRvbid0IGxlYWsgcHJvcGVydGllc1xuICogaW50byB0aGUgcHJvdG90eXBlIGNoYWluLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG5cbkNhcm91c2VsLnByb3RvdHlwZS5kZWZhdWx0cyA9IHtcbiAgZWw6IG51bGxcbn07XG5cbi8qKlxuICogV2hpdGVsaXN0ZWQgcGFyYW1ldGVycyB3aGljaCBjYW4gYmUgc2V0IG9uIGNvbnN0cnVjdGlvbi5cbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuQ2Fyb3VzZWwucHJvdG90eXBlLl93aGl0ZWxpc3RlZFBhcmFtcyA9IFtdO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDYXJvdXNlbDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2Fyb3VzZWwuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAjIFRyYW5zZm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQXBwbHkgYSBjcm9zcy1icm93c2VyIHRyYW5zZm9ybSBzdHlsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogdHJhbnNmb3JtKCd0cmFuc2xhdGVYJywgJy0xMDBweCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBoZWxwZXJzL2Nzcy90cmFuc2Zvcm0uanNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgX2VhY2ggPSByZXF1aXJlKCcuLi91dGlsL2VhY2gnKTtcblxudmFyIF9lYWNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgcHJlZml4ZXMgPSBbJy13ZWJraXQtJywgJy1tb3otJywgJy1vLScsICctbXMtJywgJyddO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm0odHlwZSwgdmFsKSB7XG5cbiAgdmFyIHN0ciA9ICcnO1xuXG4gICgwLCBfZWFjaDIuZGVmYXVsdCkocHJlZml4ZXMsIGZ1bmN0aW9uIChwKSB7XG5cbiAgICBpZiAoKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0Jykge1xuICAgICAgc3RyICs9IHAgKyAndHJhbnNmb3JtOiAnO1xuXG4gICAgICBmb3IgKHZhciBqIGluIHZhbCkge1xuICAgICAgICBzdHIgKz0gaiArICcoJyArIHZhbFtqXSArICcpOyAnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gcCArICd0cmFuc2Zvcm06ICcgKyB0eXBlICsgJygnICsgdmFsICsgJyk7ICc7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gc3RyO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0cmFuc2Zvcm07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zZm9ybS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90cmltID0gcmVxdWlyZSgnLi4vdXRpbC90cmltJyk7XG5cbnZhciBfdHJpbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmltKTtcblxudmFyIF9oYXNDbGFzcyA9IHJlcXVpcmUoJy4vaGFzLWNsYXNzJyk7XG5cbnZhciBfaGFzQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzQ2xhc3MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqICMgQWRkIENsYXNzXG4gKiBBZGQgYSBjbGFzcyBvbiBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxBcnJheX0gZWwgQW4gZWxlbWVudCBvciBhcnJheSBvZiBlbGVtZW50cyB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7RWxlbWVudH1cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZG9tL2FkZC1jbGFzcy5qc1xuICovXG5cbnZhciB3cyA9IC9cXHMrLztcbnZhciBjbGVhbnVwID0gL1xcc3syLH0vZztcblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIG5hbWUpIHtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gKDAsIF90cmltMi5kZWZhdWx0KShuYW1lKS5zcGxpdCh3cyk7XG4gIH0gZWxzZSB7XG4gICAgbmFtZSA9IG5hbWUgaW5zdGFuY2VvZiBBcnJheSA/IG5hbWUgOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB9XG5cbiAgLy8gb3B0aW1pemUgZm9yIGJlc3QsIG1vc3QgY29tbW9uIGNhc2VcbiAgaWYgKG5hbWUubGVuZ3RoID09PSAxICYmIGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChuYW1lWzBdKSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKG5hbWVbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICB2YXIgdG9BZGQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IG5hbWUubGVuZ3RoO1xuICB2YXIgaXRlbSA9IHZvaWQgMDtcbiAgdmFyIGNsc05hbWUgPSB0eXBlb2YgZWwuY2xhc3NOYW1lID09PSAnc3RyaW5nJyA/IGVsLmNsYXNzTmFtZSA6IGVsLmdldEF0dHJpYnV0ZSA/IGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSA6ICcnO1xuXG4gIC8vIHNlZSBpZiB3ZSBoYXZlIGFueXRoaW5nIHRvIGFkZFxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGl0ZW0gPSBuYW1lW2ldO1xuICAgIGlmIChpdGVtICYmICEoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KShjbHNOYW1lLCBpdGVtKSkge1xuICAgICAgdG9BZGQucHVzaChpdGVtKTtcbiAgICB9XG4gIH1cblxuICBpZiAodG9BZGQubGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBlbC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbC5jbGFzc05hbWUgPSAoMCwgX3RyaW0yLmRlZmF1bHQpKChjbHNOYW1lICsgJyAnICsgdG9BZGQuam9pbignICcpKS5yZXBsYWNlKGNsZWFudXAsICcgJykpO1xuICAgIH0gZWxzZSBpZiAoZWwuc2V0QXR0cmlidXRlKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKDAsIF90cmltMi5kZWZhdWx0KSgoY2xzTmFtZSArICcgJyArIHRvQWRkLmpvaW4oJyAnKSkucmVwbGFjZShjbGVhbnVwLCAnICcpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBhZGRDbGFzcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkLWNsYXNzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbi8qKlxuICogIyBIYXMgQ2xhc3NcbiAqIFNlZSBpZiBhbiBlbGVtZW50IGhhcyBhIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZG9tL2hhcy1jbGFzcy5qc1xuICovXG5mdW5jdGlvbiBoYXNDbGFzcyhlbCwgbmFtZSkge1xuICB2YXIgY05hbWUgPSAoKHR5cGVvZiBlbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZWwpKSA9PT0gJ29iamVjdCcgPyBlbC5jbGFzc05hbWUgfHwgZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJyA6IGVsIHx8ICcnKS5yZXBsYWNlKC9bXFx0XFxyXFxuXFxmXS9nLCAnICcpO1xuICByZXR1cm4gKCcgJyArIGNOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIG5hbWUgKyAnICcpICE9PSAtMTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gaGFzQ2xhc3M7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhcy1jbGFzcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90cmltID0gcmVxdWlyZSgnLi4vdXRpbC90cmltJyk7XG5cbnZhciBfdHJpbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmltKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHdzID0gL1xccysvOyAvKipcbiAgICAgICAgICAgICAgICAgKiAjIFJlbW92ZSBDbGFzc1xuICAgICAgICAgICAgICAgICAqIFJlbW92ZSBhIGNsYXNzIG9uIGFuIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXl9IGVsIEFuIGVsZW1lbnQgb3IgYXJyYXkgb2YgZWxlbWVudHMgdG8gdXBkYXRlLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgaGVscGVycy9kb20vcmVtb3ZlLWNsYXNzLmpzXG4gICAgICAgICAgICAgICAgICovXG5cbnZhciBjbGVhbnVwID0gL1xcc3syLH0vZztcblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIG5hbWUpIHtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gKDAsIF90cmltMi5kZWZhdWx0KShuYW1lKS5zcGxpdCh3cyk7XG4gIH0gZWxzZSB7XG4gICAgbmFtZSA9IG5hbWUgaW5zdGFuY2VvZiBBcnJheSA/IG5hbWUgOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB9XG5cbiAgLy8gb3B0aW1pemUgZm9yIGJlc3QsIG1vc3QgY29tbW9uIGNhc2VcbiAgaWYgKG5hbWUubGVuZ3RoID09PSAxICYmIGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChuYW1lWzBdKSBlbC5jbGFzc0xpc3QucmVtb3ZlKG5hbWVbMF0pO1xuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIC8vIHN0b3JlIHR3byBjb3BpZXNcbiAgdmFyIGNsc05hbWUgPSAnICcgKyAodHlwZW9mIGVsLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycgPyBlbC5jbGFzc05hbWUgOiBlbC5nZXRBdHRyaWJ1dGUgPyBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgOiAnJykgKyAnICc7XG4gIHZhciByZXN1bHQgPSBjbHNOYW1lO1xuICB2YXIgY3VycmVudCA9IHZvaWQgMDtcbiAgdmFyIHN0YXJ0ID0gdm9pZCAwO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IG5hbWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY3VycmVudCA9IG5hbWVbaV07XG4gICAgc3RhcnQgPSBjdXJyZW50ID8gcmVzdWx0LmluZGV4T2YoJyAnICsgY3VycmVudCArICcgJykgOiAtMTtcbiAgICBpZiAoc3RhcnQgIT09IC0xKSB7XG4gICAgICBzdGFydCArPSAxO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIHN0YXJ0KSArIHJlc3VsdC5zbGljZShzdGFydCArIGN1cnJlbnQubGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICAvLyBvbmx5IHdyaXRlIGlmIG1vZGlmaWVkXG4gIGlmIChjbHNOYW1lICE9PSByZXN1bHQpIHtcbiAgICBpZiAodHlwZW9mIGVsLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVsLmNsYXNzTmFtZSA9ICgwLCBfdHJpbTIuZGVmYXVsdCkocmVzdWx0LnJlcGxhY2UoY2xlYW51cCwgJyAnKSk7XG4gICAgfSBlbHNlIGlmIChlbC5zZXRBdHRyaWJ1dGUpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoMCwgX3RyaW0yLmRlZmF1bHQpKHJlc3VsdC5yZXBsYWNlKGNsZWFudXAsICcgJykpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWw7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHJlbW92ZUNsYXNzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmUtY2xhc3MuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBEZWJvdW5jZVxuICogRGVib3VuY2UgYSBmdW5jdGlvbiBjYWxsXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICogQHBhcmFtIHtJbnRlZ2VyfSBkZWxheVxuICpcbiAqIEBtb2R1bGUgaGVscGVycy91dGlsL2RlYm91bmNlLmpzXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIGRlbGF5KSB7XG5cbiAgdmFyIHRpbWVyID0gdm9pZCAwO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgaWYgKHRpbWVyKSB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB0aW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSwgZGVsYXkpO1xuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBkZWJvdW5jZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJvdW5jZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBFYWNoXG4gKiBBcHBseSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGEgbGlzdCBvZiBhbnkga2luZDogQXJyYXksIE5vZGVMaXN0LCBIVE1MQ29sbGVjdGlvbiBvciBPYmplY3QuXG4gKlxuICogQHBhcmFtIHtBcnJheXxOb2RlTGlzdHxIVE1MQ29sbGVjdGlvbnxPYmplY3R9IGxpc3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKlxuICogQGV4YW1wbGVcbiAqIGVhY2goW10sIGNhbGxiYWNrKTtcbiAqIGVhY2goZWwuY2hpbGRyZW4sIGNhbGxiYWNrKTtcbiAqIGVhY2goZWwuY2hpbGROb2RlcywgY2FsbGJhY2spO1xuICogZWFjaCh7fSwgY2FsbGJhY2spO1xuICpcbiAqIEBtb2R1bGUgaGVscGVycy91dGlsL2VhY2guanNcbiAqL1xuZnVuY3Rpb24gZWFjaChsaXN0LCBjYikge1xuXG4gIGlmICghbGlzdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2UgYGVhY2hgIHdpdGhvdXQgYSBjYWxsYmFjayEnKTtcbiAgfVxuXG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuXG4gIC8vIE9iamVjdFxuICBpZiAobGVuID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGkgaW4gbGlzdCkge1xuICAgICAgaWYgKGkgIT09ICdwcm90b3R5cGUnICYmIGxpc3QuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgY2IoaSwgbGlzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIEFycmF5LWxpa2VcbiAgZWxzZSB7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNiKGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZWFjaDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWFjaC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBUcmltXG4gKiBUcmltIHdoaXRlc3BhY2Ugb24gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICpcbiAqIEBtb2R1bGUgaGVscGVycy91dGlsL3RyaW0uanNcbiAqL1xuXG52YXIgdHJpbVJFID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UodHJpbVJFLCAnJyk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHRyaW07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyaW0uanMubWFwXG4iXX0="}