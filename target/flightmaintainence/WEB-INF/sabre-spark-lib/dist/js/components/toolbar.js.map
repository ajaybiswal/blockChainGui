{"version":3,"sources":["js/dist/components/node_modules/browser-pack/_prelude.js","js/dist/components/js/dist/components/toolbar.js","js/dist/components/js/dist/helpers/dom/add-class.js","js/dist/components/js/dist/helpers/dom/has-class.js","js/dist/components/js/dist/helpers/dom/parse-attribute.js","js/dist/components/js/dist/helpers/dom/remove-class.js","js/dist/components/js/dist/helpers/util/debounce.js","js/dist/components/js/dist/helpers/util/trim.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"toolbar.js","sourcesContent":["(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _debounce = require('../helpers/util/debounce');\n\nvar _debounce2 = _interopRequireDefault(_debounce);\n\nvar _addClass = require('../helpers/dom/add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _hasClass = require('../helpers/dom/has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _removeClass = require('../helpers/dom/remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nvar _parseAttribute = require('../helpers/dom/parse-attribute');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * # Toolbar\n                                                                                                                                                           * Setup a responsive toolbar\n                                                                                                                                                           *\n                                                                                                                                                           * @example\n                                                                                                                                                           * new Toolbar(el);\n                                                                                                                                                           *\n                                                                                                                                                           * @module components/toolbar.js\n                                                                                                                                                           */\n\n\nvar Toolbar = function () {\n\n  /**\n   * Toolbar constructor.\n   * @param {Element} el\n   * @param {Object} params\n   */\n  function Toolbar(el) {\n    _classCallCheck(this, Toolbar);\n\n    if (!el) return;\n    this._init(el);\n  }\n\n  /**\n   * This function will update cached sizing when an element in the toolbar is changed\n   * or, when toolbar items are added or removed\n   */\n\n\n  Toolbar.prototype.change = function change() {\n    this._closeAll();\n    (0, _removeClass2.default)(this.el, ['ready', 'show-more', 'measured']);\n    var v = document.createDocumentFragment();\n    for (var i = 0; i < this.items.length; i++) {\n      v.appendChild(this.items[i].el);\n    }\n    this.visibleContainer.appendChild(v);\n    this._initItems();\n    (0, _addClass2.default)(this.el, 'measured');\n    this._calculateStyles();\n    (0, _addClass2.default)(this.el, 'ready');\n    return this;\n  };\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   */\n\n\n  Toolbar.prototype.update = function update(el) {\n\n    if (el) {\n      this.remove(true);\n      this._init(el);\n    } else {\n      this.change();\n    }\n\n    return this;\n  };\n\n  /**\n   * Remove the element from the DOM and prepare for garbage collection by dereferencing values.\n   * @param {Boolean} leaveElement Leave the element intact.\n   */\n\n\n  Toolbar.prototype.remove = function remove(leaveElement) {\n    this._removeListeners();\n    delete this.el.sparktoolbarcon;\n    delete this.showMoreButton.sparktoolbarshowmore;\n    for (var i = 0; i < this.items.length; i++) {\n      this.items[i].remove();\n    }\n    if (!leaveElement && this.el.parentNode) {\n      this.el.parentNode.removeChild(this.el);\n      this.el = undefined;\n    }\n    return this;\n  };\n\n  /**\n   * Setup a toolbarItem Instance to track the state of individual toolbar items\n   * @param {Element} parent Reference to parent toolbar\n   * @param {Element} el Node to initalize as toolbarItem\n   * @param {Number} order The original index of the item in list of toolbarItems (used for maintaining order when sorting)\n   */\n\n\n  Toolbar.prototype.toolbarItem = function toolbarItem(parent, el, order) {\n    //Setup and cache the values for this item\n    var a = {};\n    a.parent = parent;\n    a.el = el;\n    //cache the priority value present on the toolbar element if it is present, else default to 0\n    a.priority = a.el.attributes['data-priority'] ? a.el.attributes['data-priority'].value : 0;\n    a.order = a.el.attributes['data-order'] ? a.el.attributes['data-order'].value : order;\n    a.hasContent = a.el.querySelector('.spark-toolbar__item--content') ? true : false;\n    a.helper = a.el.querySelector('.spark-toolbar__item-helper');\n    a.label = a.el.attributes.label ? a.el.attributes.label.value : false;\n    a.closeOnClick = (0, _hasClass2.default)(a.el, 'spark-toolbar__item--close-more-on-click');\n    a.width = a.el.offsetWidth;\n    a.height = a.el.offsetHeight;\n    a.dropdown = el.querySelector('.spark-toolbar__item--content');\n    if (a.dropdown) {\n      a.dropdown.sparktoolbardropdown = true;\n    }\n    /**\n     * Call method to toggle the open state, optional param sets open state to value\n     * Can get current state by referencing a.toggleDropdown.open\n     * @param {Boolean} open Set state to this regardless of current state\n     */\n    a.toggleDropdown = function (open) {\n      var o = typeof open !== 'undefined' ? !open : a.toggleDropdown.open;\n      if (o) {\n        a.toggleDropdown.open = false;\n        (0, _removeClass2.default)(a.el, 'animate');\n        window.setTimeout(function () {\n          (0, _removeClass2.default)(a.el, 'open');\n        }, 100);\n      } else {\n        if (a.hasContent) {\n          a.toggleDropdown.open = true;\n          (0, _addClass2.default)(a.el, 'open');\n          a.positionDropdown();\n          var e = document.createEvent('Event');\n          e.initEvent('spark.visible-children', true, true);\n          a.dropdown.dispatchEvent(e);\n          window.setTimeout(function () {\n            (0, _addClass2.default)(a.el, 'animate');\n          }, 0);\n        } else {\n          a.parent._toggleShowMore(false);\n        }\n      }\n    };\n    /**\n     * Click handler for local element - determines to close element\n     * conditionally based on presence of spark-toolbar__item--close-on-click\n     * closes parent's more dropdown conditionally as well\n     * @param {Boolean} open Set state to this regardless of current state\n     */\n    a.handleClick = function (e) {\n\n      if ((0, _parseAttribute.boolean)(a.el, 'disabled')) {\n        e.preventDefault();\n        return;\n      }\n\n      if (!a.toggleDropdown.open) {\n        a.toggleDropdown(true);\n      } else {\n        if (e.target === a.el || e.target === a.helper) {\n          a.toggleDropdown();\n        } else {\n          var b = e.target;\n          while (b !== a.el) {\n            if ((0, _hasClass2.default)(b, 'spark-toolbar__item--close-on-click')) {\n              a.toggleDropdown(false);\n              //close the mode section, as event originated inside a close-on-click area\n              a.parent._toggleShowMore(false);\n              break;\n            }\n            b = b.parentElement;\n          }\n        }\n      }\n      //e.preventDefault();\n    };\n    //perform bounds checking on dropdown open to position dropdown inside visual area\n    //this is called each time a dropdown is opened, in case the state of the component has\n    //changed since initialization\n    a.positionDropdown = function () {\n      if (a.dropdown) {\n        a.dropdown.style.left = '';\n        a.dropdown.style.right = '';\n        var pos = a.dropdown.getBoundingClientRect();\n        var left = window.pageXOffset;\n        var right = window.pageXOffset + document.documentElement.clientWidth;\n        if (pos.right > right) {\n          a.dropdown.style.left = 'inherit';\n          a.dropdown.style.right = 0;\n        }\n        if (pos.left < left) {\n          a.dropdown.style.left = 0;\n          a.dropdown.style.right = 'inherit';\n        }\n      }\n    };\n    a.remove = function () {\n      if (a.el) {\n        delete a.el.sparktoolbar;\n      }\n      if (a.dropdown) {\n        delete a.dropdown.sparktoolbardropdown;\n      }\n    };\n    a.el.sparktoolbar = a;\n    return a;\n  };\n\n  /**\n   * Close any open items, and more dropdown\n   */\n\n\n  Toolbar.prototype._closeAll = function _closeAll() {\n    this._closeItems();\n    this._toggleShowMore(false);\n  };\n\n  /**\n   * Returns array of open toolbarItems\n   */\n\n\n  Toolbar.prototype._getOpenItems = function _getOpenItems() {\n    var a = [];\n    for (var i = 0; i < this.items.length; i++) {\n      if (this.items[i].toggleDropdown.open) {\n        a.push(this.items[i]);\n      }\n    }\n    return a;\n  };\n\n  /**\n   * Close any open items\n   * @param {Array} a Optional array of toolbarItems to close, defaults to all open items\n   */\n\n\n  Toolbar.prototype._closeItems = function _closeItems(a) {\n    a = typeof a === 'undefined' ? this._getOpenItems() : a;\n    for (var i = 0; i < a.length; i++) {\n      a[i].toggleDropdown(false);\n    }\n  };\n\n  /**\n   * Setup the toolbar element, cache properties, and initalize styling\n   * when complete, show toolbar\n   * @param {Element} el The node to initalize on\n   */\n\n\n  Toolbar.prototype._init = function _init(el) {\n    this.el = el;\n    //store a reference to this on the node to expedite event handling\n    this.el.sparktoolbarcon = this;\n    this.visibleContainer = this.el.querySelector('.spark-toolbar__container--visible');\n    this.hiddenContainer = this.el.querySelector('.spark-toolbar__container--hidden');\n    this.showMoreButton = this.el.querySelector('.spark-toolbar__show-more');\n    this.showMoreButton.sparktoolbarshowmore = true;\n    this.isOpen = false;\n    this.isFocus = false;\n    this._setupListeners();\n    this.el.style.width = '100%';\n    this._initItems();\n    (0, _addClass2.default)(this.el, 'measured');\n    this._calculateStyles();\n    this.tabindex = this.el.attributes.tabindex ? this.el.attributes.tabindex.value : 0;\n    (0, _addClass2.default)(this.el, 'ready');\n  };\n\n  Toolbar.prototype._initItems = function _initItems() {\n    var items = this.el.querySelectorAll('.spark-toolbar__item');\n    this.items = [];\n    for (var i = 0; i < items.length; i++) {\n      this.items[i] = new this.toolbarItem(this, items[i], i);\n    }\n  };\n\n  /**\n   * Setup event listeners for clicks and resize events\n   */\n\n\n  Toolbar.prototype._setupListeners = function _setupListeners() {\n    this._handleWindowClick = this._handleWindowClickH.bind(this);\n    document.addEventListener('click', this._handleWindowClick);\n    this._handleResize = (0, _debounce2.default)(this._handleResizeH.bind(this), 100);\n    window.addEventListener('resize', this._handleResize);\n    this._handleKeyDown = this._handleKeyDownH.bind(this);\n    this.el.addEventListener('keydown', this._handleKeyDown);\n    this._handleFocus = this._handleFocusH.bind(this);\n    document.addEventListener('focus', this._handleFocus, true);\n    this._handleBlur = this._handleBlurH.bind(this);\n    document.addEventListener('blur', this._handleBlur, true);\n    this._handleVisibleChildren = this._handleVisibleChildrenH.bind(this);\n    document.addEventListener('spark.visible-children', this._handleVisibleChildren, true);\n  };\n\n  /**\n   * Remove event listeners for clicks and resize events\n   */\n\n\n  Toolbar.prototype._removeListeners = function _removeListeners() {\n    document.removeEventListener('click', this._handleWindowClick);\n    window.removeEventListener('resize', this._handleResize);\n    this.el.removeEventListener('keydown', this._handleKeyDown);\n    document.removeEventListener('blur', this._handleBlur, true);\n    document.removeEventListener('focus', this._handleFocus, true);\n    document.removeEventListener('spark.visible-children', this._handleVisibleChildren, true);\n  };\n\n  /**\n   * reset our tab index when user focuses outside of element (gets immediately reset to -1 if focus is placed back inside element)\n   * @param {Event} e The FocusEvent\n   */\n\n\n  Toolbar.prototype._handleBlurH = function _handleBlurH(e) {\n    if (this.el.contains(e.target)) {\n      this.el.attributes.tabindex.value = this.tabindex;\n    }\n  };\n\n  /**\n   * focus handler, works in conjunction with blur handler to set correct tabindex value\n   * @param {Event} e The FocusEvent\n   */\n\n\n  Toolbar.prototype._handleFocusH = function _handleFocusH(e) {\n    //if we're not being focused, reset our tabindex so we are accessible again, and close anything open\n    if (!this.el.contains(e.target)) {\n      this._closeAll();\n      this.el.attributes.tabindex.value = this.tabindex;\n    } else {\n      //set our tabindex to -1 so the user can shift-tab out of our element\n      this.el.attributes.tabindex.value = -1;\n      if (e.target.sparktoolbarcon) {\n        this._focusLast();\n        return;\n      }\n      //handle focusing an item\n      if (e.target.sparktoolbar) {\n        e.target.sparktoolbar.el.focus();\n        return;\n      }\n      var a = e.target;\n      //harder case - look up the tree to find if we're focusing inside content\n      while (!a.sparktoolbarcon) {\n        if (a.sparktoolbar) {\n          break;\n        }\n        //if we are - give our parent element a tabindex so the user can refocus the menu using shift-tab\n        if (a.sparktoolbardropdown) {\n          this.el.attributes.tabindex.value = this.tabindex;\n          return;\n        }\n        a = a.parentElement;\n      }\n    }\n  };\n\n  /**\n   * reset our focus to the last menu item that was focused\n   */\n\n\n  Toolbar.prototype._focusLast = function _focusLast() {\n    if (!this._lastFocus) {\n      var a = this.visibleContainer.querySelector('.spark-toolbar__item') || this.hiddenContainer.querySelector('.spark-toolbar__item');\n      this._lastFocus = a.sparktoolbar;\n    }\n    if (this.hiddenContainer.contains(this._lastFocus.el)) {\n      this._toggleShowMore(true);\n    }\n    this._lastFocus.el.focus();\n  };\n\n  /**\n   * keydown handler, used for keyboard navigation\n   * @param {Event} e The KeyDown Event\n   */\n\n\n  Toolbar.prototype._handleKeyDownH = function _handleKeyDownH(e) {\n    var a = e.target;\n    //find the nearest toolbaritem\n    while (!a.sparktoolbarcon) {\n      if (a.sparktoolbar) {\n        break;\n      }\n      if (a.sparktoolbardropdown) {\n        return;\n      }\n      a = a.parentElement;\n    }\n    if (a.sparktoolbar) {\n      //handle keys\n      switch (e.keyCode) {\n        //left arrow\n        //up arrow\n        case 37:\n        case 38:\n          if (a.previousSibling && a.previousSibling.sparktoolbar) {\n            this._lastFocus = a.previousSibling.sparktoolbar;\n            a.previousSibling.focus();\n          } else {\n            if (this.visibleContainer.querySelector('.spark-toolbar__item') !== a.sparktoolbar.el) {\n              a = this.visibleContainer.querySelector('.spark-toolbar__item:last-of-type');\n              if (a) {\n                this._toggleShowMore(false);\n                this._lastFocus = a.sparktoolbar;\n                a.focus();\n              }\n            }\n          }\n          this._closeItems();\n          e.preventDefault();\n          break;\n        //right arrow\n        //down arrow\n        case 39:\n        case 40:\n          if (a.nextSibling && a.nextSibling.sparktoolbar) {\n            this._lastFocus = a.nextSibling.sparktoolbar;\n            a.nextSibling.focus();\n          } else {\n            if (this.hiddenContainer.querySelector('.spark-toolbar__item:last-of-type') !== a.sparktoolbar.el) {\n              a = this.hiddenContainer.querySelector('.spark-toolbar__item');\n              if (a) {\n                this._toggleShowMore(true);\n                this._lastFocus = a.sparktoolbar;\n                a.focus();\n              }\n            }\n          }\n          this._closeItems();\n          e.preventDefault();\n          break;\n        //spacebar\n        case 32:\n          e.preventDefault();\n          //we only want to toggle the toolbar if we are actually focused directly on it;\n          if (e.target.sparktoolbar) {\n            e.target.sparktoolbar.el.click();\n          }\n          break;\n        //enter\n        case 13:\n          //we only want to toggle the toolbar if we are actually focused directly on it;\n          if (e.target.sparktoolbar) {\n            e.target.sparktoolbar.el.click();\n          }\n          break;\n      }\n    }\n  };\n\n  /**\n   * Hanldes the spark.visible-children event to resize the component when it is made visible.\n   * @param {Event} e The spark.visible-children event\n   */\n\n\n  Toolbar.prototype._handleVisibleChildrenH = function _handleVisibleChildrenH(e) {\n    if (e.target.contains(this.el)) {\n      window.setTimeout(function () {\n        this.change();\n      }.bind(this), 0);\n    }\n  };\n\n  /**\n   * Event handler for click events, handles window clicks, control element clicks,\n   * and forwards events to toolbarItem click handlers as needed\n   * @param {Event} e The click event\n   */\n\n\n  Toolbar.prototype._handleWindowClickH = function _handleWindowClickH(e) {\n\n    if ((0, _parseAttribute.boolean)(e.target, 'disabled')) {\n      e.preventDefault();\n      return;\n    }\n\n    //Check to see if the click was outside of the toolbar\n    if (!this.el.contains(e.target)) {\n      this._closeItems();\n      this._toggleShowMore(false);\n    } else {\n      var a = e.target;\n      //traverse the dom node tree until we find an element that handles the event,\n      //or we reach the toolbar root node\n      if (a === this.visibleContainer || a === this.el) {\n        e.stopPropagation();\n        e.preventDefault();\n        return;\n      }\n      while (a !== this.el) {\n        if (a.sparktoolbar) {\n          var c = this._getOpenItems();\n          if (c.indexOf(a.sparktoolbar) >= 0) {\n            c.splice(c.indexOf(a.sparktoolbar), 1);\n          }\n          this._closeItems(c);\n          if (!this.hiddenContainer.contains(e.target)) {\n            this._toggleShowMore(false);\n          }\n          return a.sparktoolbar.handleClick(e);\n        }\n        if (a.sparktoolbarshowmore) {\n          this._closeItems();\n          this._toggleShowMore();\n          return;\n        }\n        a = a.parentElement;\n      }\n      this._closeAll();\n    }\n  };\n\n  /**\n   * Toggle the state of the show more dropdown, optional parameter overrides toggle and\n   * sets state to passed value\n   * @param {Boolean} open The new state of the show more dropdown\n   */\n\n\n  Toolbar.prototype._toggleShowMore = function _toggleShowMore(open) {\n    var o = typeof open !== 'undefined' ? !open : this.isOpen;\n    if (o) {\n      (0, _removeClass2.default)(this.el, 'animate');\n      window.setTimeout(function () {\n        (0, _removeClass2.default)(this.el, 'open');\n        this.isOpen = false;\n      }.bind(this), 100);\n    } else {\n      this.isOpen = true;\n      (0, _addClass2.default)(this.el, 'open');\n      this._positionShowMore();\n      window.setTimeout(function () {\n        (0, _addClass2.default)(this.el, 'animate');\n      }.bind(this), 0);\n    }\n  };\n\n  /**\n  * Do bounds checking on show-more dropdown when it is opened, and position it accordingly\n  */\n\n\n  Toolbar.prototype._positionShowMore = function _positionShowMore() {\n    this.hiddenContainer.style.right = '0px';\n    var pos = this.hiddenContainer.getBoundingClientRect();\n    var left = window.pageXOffset;\n    var right = window.pageXOffset + document.documentElement.clientWidth;\n    if (pos.right > right) {\n      this.hiddenContainer.style.right = 'calc(' + (pos.right - right) + 'px + 1rem)';\n    }\n    if (pos.left < left) {\n      this.hiddenContainer.style.right = 'calc(' + (pos.left - left) + 'px - 1rem)';\n    }\n  };\n\n  /**\n   * Resize event helper, closes items then triggers recalculation of styles\n   */\n\n\n  Toolbar.prototype._handleResizeH = function _handleResizeH() {\n    this._closeAll();\n    this._calculateStyles();\n  };\n\n  /**\n   * Reevaluates the available area of the toolbar and places toolbarItems into\n   * the hidden container, as necessary. Should not call with any specified value\n   * for showMore (used internally)\n   * @param {Boolean} showMore Used to conditionally evaluate styling when showMore area is used\n   */\n\n\n  Toolbar.prototype._calculateStyles = function _calculateStyles(showMore) {\n    this.el.style.width = '100%';\n    showMore = typeof showMore !== 'undefined' ? showMore : false;\n    if (!showMore) {\n      (0, _removeClass2.default)(this.el, 'show-more');\n    }\n    var visible = [];\n    var hidden = [];\n    var i;\n    //sort items by their priority to ensure higher-priority items are always placed\n    //into the visible area first\n    this.items.sort(this._prioritySort);\n    //get container width and start placing items into their containers\n    var visibleWidth = this.visibleContainer.clientWidth;\n    for (i = 0; i < this.items.length; i++) {\n      if (visibleWidth - this.items[i].width >= 0) {\n        visible.push(this.items[i]);\n        visibleWidth -= this.items[i].width;\n      } else {\n        if (!showMore) {\n          (0, _addClass2.default)(this.el, 'show-more');\n          return this._calculateStyles(true);\n        }\n        hidden.push(this.items[i]);\n      }\n    }\n    //sort items back into their original order before inserting them into the document\n    visible.sort(this._orderSort);\n    hidden.sort(this._orderSort);\n    var v = document.createDocumentFragment();\n    var h = document.createDocumentFragment();\n    for (i = 0; i < visible.length; i++) {\n      v.appendChild(visible[i].el);\n    }\n    for (i = 0; i < hidden.length; i++) {\n      h.appendChild(hidden[i].el);\n    }\n    this.visibleContainer.appendChild(v);\n    this.hiddenContainer.appendChild(h);\n    this.el.style.width = '';\n  };\n\n  /**\n   * Sorts toolbar items in descending order based on their priority value\n   */\n\n\n  Toolbar.prototype._prioritySort = function _prioritySort(l, r) {\n    return r.priority - l.priority;\n  };\n\n  /**\n   * Sorts toolbar items in ascending order based on their order value\n   */\n\n\n  Toolbar.prototype._orderSort = function _orderSort(l, r) {\n    return l.order - r.order;\n  };\n\n  return Toolbar;\n}();\n\nexports.default = Toolbar;\nmodule.exports = exports['default'];\n//# sourceMappingURL=toolbar.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * # Add Class\n * Add a class on an element.\n *\n * @param {Element|Array} el An element or array of elements to update.\n * @param {String} name\n * @return {Element}\n *\n * @module helpers/dom/add-class.js\n */\n\nvar ws = /\\s+/;\nvar cleanup = /\\s{2,}/g;\n\nfunction addClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) {\n      el.classList.add(name[0]);\n    }\n    return el;\n  }\n\n  var toAdd = [];\n  var i = 0;\n  var l = name.length;\n  var item = void 0;\n  var clsName = typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '';\n\n  // see if we have anything to add\n  for (; i < l; i++) {\n    item = name[i];\n    if (item && !(0, _hasClass2.default)(clsName, item)) {\n      toAdd.push(item);\n    }\n  }\n\n  if (toAdd.length) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = addClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=add-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * # Has Class\n * See if an element has a class.\n *\n * @param {Element|String} el\n * @param {String} name\n * @return {Boolean}\n *\n * @module helpers/dom/has-class.js\n */\nfunction hasClass(el, name) {\n  var cName = ((typeof el === 'undefined' ? 'undefined' : _typeof(el)) === 'object' ? el.className || el.getAttribute && el.getAttribute('class') || '' : el || '').replace(/[\\t\\r\\n\\f]/g, ' ');\n  return (' ' + cName + ' ').indexOf(' ' + name + ' ') !== -1;\n}\n\nexports.default = hasClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=has-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Parse DOM attributes\n * Given an element and an attribute name, parse that attribute\n * if it exists or return a default.\n *\n * @module helpers/dom/parse-attribute.js\n */\n\n/**\n * Get the boolean value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction boolean(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return val === 'true' || val === '' ? true : false;\n}\n\n/**\n * Get the numeric value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction number(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return parseInt(val, 10);\n}\n\n/**\n * Get the boolean value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction string(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return val;\n}\n\nexports.boolean = boolean;\nexports.number = number;\nexports.string = string;\n//# sourceMappingURL=parse-attribute.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ws = /\\s+/; /**\n                 * # Remove Class\n                 * Remove a class on an element.\n                 *\n                 * @param {Element|Array} el An element or array of elements to update.\n                 * @param {String} name\n                 * @return {Element}\n                 *\n                 * @module helpers/dom/remove-class.js\n                 */\n\nvar cleanup = /\\s{2,}/g;\n\nfunction removeClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) el.classList.remove(name[0]);\n    return el;\n  }\n\n  // store two copies\n  var clsName = ' ' + (typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '') + ' ';\n  var result = clsName;\n  var current = void 0;\n  var start = void 0;\n  for (var i = 0, l = name.length; i < l; i++) {\n    current = name[i];\n    start = current ? result.indexOf(' ' + current + ' ') : -1;\n    if (start !== -1) {\n      start += 1;\n      result = result.slice(0, start) + result.slice(start + current.length);\n    }\n  }\n\n  // only write if modified\n  if (clsName !== result) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)(result.replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)(result.replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = removeClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=remove-class.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Debounce\n * Debounce a function call\n *\n * @param {Function} func\n * @param {Integer} delay\n *\n * @module helpers/util/debounce.js\n */\nfunction debounce(func, delay) {\n\n  var timer = void 0;\n\n  return function () {\n    var args = arguments;\n    if (timer) window.clearTimeout(timer);\n    timer = window.setTimeout(function () {\n      func.apply(this, args);\n    }, delay);\n  };\n}\n\nexports.default = debounce;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=debounce.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Trim\n * Trim whitespace on a string.\n *\n * @param {String} str\n *\n * @module helpers/util/trim.js\n */\n\nvar trimRE = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\nfunction trim(str) {\n  return str.replace(trimRE, '');\n}\n\nexports.default = trim;\nmodule.exports = exports['default'];\n//# sourceMappingURL=trim.js.map\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9kaXN0L2NvbXBvbmVudHMvdG9vbGJhci5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vYWRkLWNsYXNzLmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS9oYXMtY2xhc3MuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL3BhcnNlLWF0dHJpYnV0ZS5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vcmVtb3ZlLWNsYXNzLmpzIiwianMvZGlzdC9oZWxwZXJzL3V0aWwvZGVib3VuY2UuanMiLCJqcy9kaXN0L2hlbHBlcnMvdXRpbC90cmltLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfXJldHVybiBlfSkoKSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9kZWJvdW5jZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdXRpbC9kZWJvdW5jZScpO1xuXG52YXIgX2RlYm91bmNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlYm91bmNlKTtcblxudmFyIF9hZGRDbGFzcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL2FkZC1jbGFzcycpO1xuXG52YXIgX2FkZENsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FkZENsYXNzKTtcblxudmFyIF9oYXNDbGFzcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL2hhcy1jbGFzcycpO1xuXG52YXIgX2hhc0NsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhc0NsYXNzKTtcblxudmFyIF9yZW1vdmVDbGFzcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL3JlbW92ZS1jbGFzcycpO1xuXG52YXIgX3JlbW92ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlbW92ZUNsYXNzKTtcblxudmFyIF9wYXJzZUF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL3BhcnNlLWF0dHJpYnV0ZScpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfSAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAjIFRvb2xiYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTZXR1cCBhIHJlc3BvbnNpdmUgdG9vbGJhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBuZXcgVG9vbGJhcihlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIGNvbXBvbmVudHMvdG9vbGJhci5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5cbnZhciBUb29sYmFyID0gZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBUb29sYmFyIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICovXG4gIGZ1bmN0aW9uIFRvb2xiYXIoZWwpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9vbGJhcik7XG5cbiAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgdGhpcy5faW5pdChlbCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHVwZGF0ZSBjYWNoZWQgc2l6aW5nIHdoZW4gYW4gZWxlbWVudCBpbiB0aGUgdG9vbGJhciBpcyBjaGFuZ2VkXG4gICAqIG9yLCB3aGVuIHRvb2xiYXIgaXRlbXMgYXJlIGFkZGVkIG9yIHJlbW92ZWRcbiAgICovXG5cblxuICBUb29sYmFyLnByb3RvdHlwZS5jaGFuZ2UgPSBmdW5jdGlvbiBjaGFuZ2UoKSB7XG4gICAgdGhpcy5fY2xvc2VBbGwoKTtcbiAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KSh0aGlzLmVsLCBbJ3JlYWR5JywgJ3Nob3ctbW9yZScsICdtZWFzdXJlZCddKTtcbiAgICB2YXIgdiA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHYuYXBwZW5kQ2hpbGQodGhpcy5pdGVtc1tpXS5lbCk7XG4gICAgfVxuICAgIHRoaXMudmlzaWJsZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh2KTtcbiAgICB0aGlzLl9pbml0SXRlbXMoKTtcbiAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLmVsLCAnbWVhc3VyZWQnKTtcbiAgICB0aGlzLl9jYWxjdWxhdGVTdHlsZXMoKTtcbiAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLmVsLCAncmVhZHknKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjb21wb25lbnQgdG8gdXNlIGEgbmV3IGVsZW1lbnQgb3IgcmVwYXJzZSBmcm9tXG4gICAqIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIE9wdGlvbmFsXG4gICAqL1xuXG5cbiAgVG9vbGJhci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGVsKSB7XG5cbiAgICBpZiAoZWwpIHtcbiAgICAgIHRoaXMucmVtb3ZlKHRydWUpO1xuICAgICAgdGhpcy5faW5pdChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hhbmdlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIHRoZSBET00gYW5kIHByZXBhcmUgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiBieSBkZXJlZmVyZW5jaW5nIHZhbHVlcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBsZWF2ZUVsZW1lbnQgTGVhdmUgdGhlIGVsZW1lbnQgaW50YWN0LlxuICAgKi9cblxuXG4gIFRvb2xiYXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShsZWF2ZUVsZW1lbnQpIHtcbiAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICBkZWxldGUgdGhpcy5lbC5zcGFya3Rvb2xiYXJjb247XG4gICAgZGVsZXRlIHRoaXMuc2hvd01vcmVCdXR0b24uc3Bhcmt0b29sYmFyc2hvd21vcmU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLml0ZW1zW2ldLnJlbW92ZSgpO1xuICAgIH1cbiAgICBpZiAoIWxlYXZlRWxlbWVudCAmJiB0aGlzLmVsLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgICAgIHRoaXMuZWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXR1cCBhIHRvb2xiYXJJdGVtIEluc3RhbmNlIHRvIHRyYWNrIHRoZSBzdGF0ZSBvZiBpbmRpdmlkdWFsIHRvb2xiYXIgaXRlbXNcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnQgUmVmZXJlbmNlIHRvIHBhcmVudCB0b29sYmFyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgTm9kZSB0byBpbml0YWxpemUgYXMgdG9vbGJhckl0ZW1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9yZGVyIFRoZSBvcmlnaW5hbCBpbmRleCBvZiB0aGUgaXRlbSBpbiBsaXN0IG9mIHRvb2xiYXJJdGVtcyAodXNlZCBmb3IgbWFpbnRhaW5pbmcgb3JkZXIgd2hlbiBzb3J0aW5nKVxuICAgKi9cblxuXG4gIFRvb2xiYXIucHJvdG90eXBlLnRvb2xiYXJJdGVtID0gZnVuY3Rpb24gdG9vbGJhckl0ZW0ocGFyZW50LCBlbCwgb3JkZXIpIHtcbiAgICAvL1NldHVwIGFuZCBjYWNoZSB0aGUgdmFsdWVzIGZvciB0aGlzIGl0ZW1cbiAgICB2YXIgYSA9IHt9O1xuICAgIGEucGFyZW50ID0gcGFyZW50O1xuICAgIGEuZWwgPSBlbDtcbiAgICAvL2NhY2hlIHRoZSBwcmlvcml0eSB2YWx1ZSBwcmVzZW50IG9uIHRoZSB0b29sYmFyIGVsZW1lbnQgaWYgaXQgaXMgcHJlc2VudCwgZWxzZSBkZWZhdWx0IHRvIDBcbiAgICBhLnByaW9yaXR5ID0gYS5lbC5hdHRyaWJ1dGVzWydkYXRhLXByaW9yaXR5J10gPyBhLmVsLmF0dHJpYnV0ZXNbJ2RhdGEtcHJpb3JpdHknXS52YWx1ZSA6IDA7XG4gICAgYS5vcmRlciA9IGEuZWwuYXR0cmlidXRlc1snZGF0YS1vcmRlciddID8gYS5lbC5hdHRyaWJ1dGVzWydkYXRhLW9yZGVyJ10udmFsdWUgOiBvcmRlcjtcbiAgICBhLmhhc0NvbnRlbnQgPSBhLmVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay10b29sYmFyX19pdGVtLS1jb250ZW50JykgPyB0cnVlIDogZmFsc2U7XG4gICAgYS5oZWxwZXIgPSBhLmVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay10b29sYmFyX19pdGVtLWhlbHBlcicpO1xuICAgIGEubGFiZWwgPSBhLmVsLmF0dHJpYnV0ZXMubGFiZWwgPyBhLmVsLmF0dHJpYnV0ZXMubGFiZWwudmFsdWUgOiBmYWxzZTtcbiAgICBhLmNsb3NlT25DbGljayA9ICgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKGEuZWwsICdzcGFyay10b29sYmFyX19pdGVtLS1jbG9zZS1tb3JlLW9uLWNsaWNrJyk7XG4gICAgYS53aWR0aCA9IGEuZWwub2Zmc2V0V2lkdGg7XG4gICAgYS5oZWlnaHQgPSBhLmVsLm9mZnNldEhlaWdodDtcbiAgICBhLmRyb3Bkb3duID0gZWwucXVlcnlTZWxlY3RvcignLnNwYXJrLXRvb2xiYXJfX2l0ZW0tLWNvbnRlbnQnKTtcbiAgICBpZiAoYS5kcm9wZG93bikge1xuICAgICAgYS5kcm9wZG93bi5zcGFya3Rvb2xiYXJkcm9wZG93biA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgbWV0aG9kIHRvIHRvZ2dsZSB0aGUgb3BlbiBzdGF0ZSwgb3B0aW9uYWwgcGFyYW0gc2V0cyBvcGVuIHN0YXRlIHRvIHZhbHVlXG4gICAgICogQ2FuIGdldCBjdXJyZW50IHN0YXRlIGJ5IHJlZmVyZW5jaW5nIGEudG9nZ2xlRHJvcGRvd24ub3BlblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3BlbiBTZXQgc3RhdGUgdG8gdGhpcyByZWdhcmRsZXNzIG9mIGN1cnJlbnQgc3RhdGVcbiAgICAgKi9cbiAgICBhLnRvZ2dsZURyb3Bkb3duID0gZnVuY3Rpb24gKG9wZW4pIHtcbiAgICAgIHZhciBvID0gdHlwZW9mIG9wZW4gIT09ICd1bmRlZmluZWQnID8gIW9wZW4gOiBhLnRvZ2dsZURyb3Bkb3duLm9wZW47XG4gICAgICBpZiAobykge1xuICAgICAgICBhLnRvZ2dsZURyb3Bkb3duLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkoYS5lbCwgJ2FuaW1hdGUnKTtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKGEuZWwsICdvcGVuJyk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYS5oYXNDb250ZW50KSB7XG4gICAgICAgICAgYS50b2dnbGVEcm9wZG93bi5vcGVuID0gdHJ1ZTtcbiAgICAgICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KShhLmVsLCAnb3BlbicpO1xuICAgICAgICAgIGEucG9zaXRpb25Ecm9wZG93bigpO1xuICAgICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgICAgZS5pbml0RXZlbnQoJ3NwYXJrLnZpc2libGUtY2hpbGRyZW4nLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBhLmRyb3Bkb3duLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkoYS5lbCwgJ2FuaW1hdGUnKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhLnBhcmVudC5fdG9nZ2xlU2hvd01vcmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGljayBoYW5kbGVyIGZvciBsb2NhbCBlbGVtZW50IC0gZGV0ZXJtaW5lcyB0byBjbG9zZSBlbGVtZW50XG4gICAgICogY29uZGl0aW9uYWxseSBiYXNlZCBvbiBwcmVzZW5jZSBvZiBzcGFyay10b29sYmFyX19pdGVtLS1jbG9zZS1vbi1jbGlja1xuICAgICAqIGNsb3NlcyBwYXJlbnQncyBtb3JlIGRyb3Bkb3duIGNvbmRpdGlvbmFsbHkgYXMgd2VsbFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3BlbiBTZXQgc3RhdGUgdG8gdGhpcyByZWdhcmRsZXNzIG9mIGN1cnJlbnQgc3RhdGVcbiAgICAgKi9cbiAgICBhLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKGUpIHtcblxuICAgICAgaWYgKCgwLCBfcGFyc2VBdHRyaWJ1dGUuYm9vbGVhbikoYS5lbCwgJ2Rpc2FibGVkJykpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghYS50b2dnbGVEcm9wZG93bi5vcGVuKSB7XG4gICAgICAgIGEudG9nZ2xlRHJvcGRvd24odHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGEuZWwgfHwgZS50YXJnZXQgPT09IGEuaGVscGVyKSB7XG4gICAgICAgICAgYS50b2dnbGVEcm9wZG93bigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBiID0gZS50YXJnZXQ7XG4gICAgICAgICAgd2hpbGUgKGIgIT09IGEuZWwpIHtcbiAgICAgICAgICAgIGlmICgoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KShiLCAnc3BhcmstdG9vbGJhcl9faXRlbS0tY2xvc2Utb24tY2xpY2snKSkge1xuICAgICAgICAgICAgICBhLnRvZ2dsZURyb3Bkb3duKGZhbHNlKTtcbiAgICAgICAgICAgICAgLy9jbG9zZSB0aGUgbW9kZSBzZWN0aW9uLCBhcyBldmVudCBvcmlnaW5hdGVkIGluc2lkZSBhIGNsb3NlLW9uLWNsaWNrIGFyZWFcbiAgICAgICAgICAgICAgYS5wYXJlbnQuX3RvZ2dsZVNob3dNb3JlKGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gYi5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9lLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICAvL3BlcmZvcm0gYm91bmRzIGNoZWNraW5nIG9uIGRyb3Bkb3duIG9wZW4gdG8gcG9zaXRpb24gZHJvcGRvd24gaW5zaWRlIHZpc3VhbCBhcmVhXG4gICAgLy90aGlzIGlzIGNhbGxlZCBlYWNoIHRpbWUgYSBkcm9wZG93biBpcyBvcGVuZWQsIGluIGNhc2UgdGhlIHN0YXRlIG9mIHRoZSBjb21wb25lbnQgaGFzXG4gICAgLy9jaGFuZ2VkIHNpbmNlIGluaXRpYWxpemF0aW9uXG4gICAgYS5wb3NpdGlvbkRyb3Bkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGEuZHJvcGRvd24pIHtcbiAgICAgICAgYS5kcm9wZG93bi5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgICAgIGEuZHJvcGRvd24uc3R5bGUucmlnaHQgPSAnJztcbiAgICAgICAgdmFyIHBvcyA9IGEuZHJvcGRvd24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBsZWZ0ID0gd2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgICAgICB2YXIgcmlnaHQgPSB3aW5kb3cucGFnZVhPZmZzZXQgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgIGlmIChwb3MucmlnaHQgPiByaWdodCkge1xuICAgICAgICAgIGEuZHJvcGRvd24uc3R5bGUubGVmdCA9ICdpbmhlcml0JztcbiAgICAgICAgICBhLmRyb3Bkb3duLnN0eWxlLnJpZ2h0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zLmxlZnQgPCBsZWZ0KSB7XG4gICAgICAgICAgYS5kcm9wZG93bi5zdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgICBhLmRyb3Bkb3duLnN0eWxlLnJpZ2h0ID0gJ2luaGVyaXQnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBhLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChhLmVsKSB7XG4gICAgICAgIGRlbGV0ZSBhLmVsLnNwYXJrdG9vbGJhcjtcbiAgICAgIH1cbiAgICAgIGlmIChhLmRyb3Bkb3duKSB7XG4gICAgICAgIGRlbGV0ZSBhLmRyb3Bkb3duLnNwYXJrdG9vbGJhcmRyb3Bkb3duO1xuICAgICAgfVxuICAgIH07XG4gICAgYS5lbC5zcGFya3Rvb2xiYXIgPSBhO1xuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbG9zZSBhbnkgb3BlbiBpdGVtcywgYW5kIG1vcmUgZHJvcGRvd25cbiAgICovXG5cblxuICBUb29sYmFyLnByb3RvdHlwZS5fY2xvc2VBbGwgPSBmdW5jdGlvbiBfY2xvc2VBbGwoKSB7XG4gICAgdGhpcy5fY2xvc2VJdGVtcygpO1xuICAgIHRoaXMuX3RvZ2dsZVNob3dNb3JlKGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhcnJheSBvZiBvcGVuIHRvb2xiYXJJdGVtc1xuICAgKi9cblxuXG4gIFRvb2xiYXIucHJvdG90eXBlLl9nZXRPcGVuSXRlbXMgPSBmdW5jdGlvbiBfZ2V0T3Blbkl0ZW1zKCkge1xuICAgIHZhciBhID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5pdGVtc1tpXS50b2dnbGVEcm9wZG93bi5vcGVuKSB7XG4gICAgICAgIGEucHVzaCh0aGlzLml0ZW1zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsb3NlIGFueSBvcGVuIGl0ZW1zXG4gICAqIEBwYXJhbSB7QXJyYXl9IGEgT3B0aW9uYWwgYXJyYXkgb2YgdG9vbGJhckl0ZW1zIHRvIGNsb3NlLCBkZWZhdWx0cyB0byBhbGwgb3BlbiBpdGVtc1xuICAgKi9cblxuXG4gIFRvb2xiYXIucHJvdG90eXBlLl9jbG9zZUl0ZW1zID0gZnVuY3Rpb24gX2Nsb3NlSXRlbXMoYSkge1xuICAgIGEgPSB0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLl9nZXRPcGVuSXRlbXMoKSA6IGE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhW2ldLnRvZ2dsZURyb3Bkb3duKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHVwIHRoZSB0b29sYmFyIGVsZW1lbnQsIGNhY2hlIHByb3BlcnRpZXMsIGFuZCBpbml0YWxpemUgc3R5bGluZ1xuICAgKiB3aGVuIGNvbXBsZXRlLCBzaG93IHRvb2xiYXJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBUaGUgbm9kZSB0byBpbml0YWxpemUgb25cbiAgICovXG5cblxuICBUb29sYmFyLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIF9pbml0KGVsKSB7XG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIC8vc3RvcmUgYSByZWZlcmVuY2UgdG8gdGhpcyBvbiB0aGUgbm9kZSB0byBleHBlZGl0ZSBldmVudCBoYW5kbGluZ1xuICAgIHRoaXMuZWwuc3Bhcmt0b29sYmFyY29uID0gdGhpcztcbiAgICB0aGlzLnZpc2libGVDb250YWluZXIgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay10b29sYmFyX19jb250YWluZXItLXZpc2libGUnKTtcbiAgICB0aGlzLmhpZGRlbkNvbnRhaW5lciA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnNwYXJrLXRvb2xiYXJfX2NvbnRhaW5lci0taGlkZGVuJyk7XG4gICAgdGhpcy5zaG93TW9yZUJ1dHRvbiA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnNwYXJrLXRvb2xiYXJfX3Nob3ctbW9yZScpO1xuICAgIHRoaXMuc2hvd01vcmVCdXR0b24uc3Bhcmt0b29sYmFyc2hvd21vcmUgPSB0cnVlO1xuICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgdGhpcy5pc0ZvY3VzID0gZmFsc2U7XG4gICAgdGhpcy5fc2V0dXBMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmVsLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHRoaXMuX2luaXRJdGVtcygpO1xuICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKHRoaXMuZWwsICdtZWFzdXJlZCcpO1xuICAgIHRoaXMuX2NhbGN1bGF0ZVN0eWxlcygpO1xuICAgIHRoaXMudGFiaW5kZXggPSB0aGlzLmVsLmF0dHJpYnV0ZXMudGFiaW5kZXggPyB0aGlzLmVsLmF0dHJpYnV0ZXMudGFiaW5kZXgudmFsdWUgOiAwO1xuICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKHRoaXMuZWwsICdyZWFkeScpO1xuICB9O1xuXG4gIFRvb2xiYXIucHJvdG90eXBlLl9pbml0SXRlbXMgPSBmdW5jdGlvbiBfaW5pdEl0ZW1zKCkge1xuICAgIHZhciBpdGVtcyA9IHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbCgnLnNwYXJrLXRvb2xiYXJfX2l0ZW0nKTtcbiAgICB0aGlzLml0ZW1zID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5pdGVtc1tpXSA9IG5ldyB0aGlzLnRvb2xiYXJJdGVtKHRoaXMsIGl0ZW1zW2ldLCBpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHVwIGV2ZW50IGxpc3RlbmVycyBmb3IgY2xpY2tzIGFuZCByZXNpemUgZXZlbnRzXG4gICAqL1xuXG5cbiAgVG9vbGJhci5wcm90b3R5cGUuX3NldHVwTGlzdGVuZXJzID0gZnVuY3Rpb24gX3NldHVwTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX2hhbmRsZVdpbmRvd0NsaWNrID0gdGhpcy5faGFuZGxlV2luZG93Q2xpY2tILmJpbmQodGhpcyk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVXaW5kb3dDbGljayk7XG4gICAgdGhpcy5faGFuZGxlUmVzaXplID0gKDAsIF9kZWJvdW5jZTIuZGVmYXVsdCkodGhpcy5faGFuZGxlUmVzaXplSC5iaW5kKHRoaXMpLCAxMDApO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9oYW5kbGVSZXNpemUpO1xuICAgIHRoaXMuX2hhbmRsZUtleURvd24gPSB0aGlzLl9oYW5kbGVLZXlEb3duSC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2hhbmRsZUtleURvd24pO1xuICAgIHRoaXMuX2hhbmRsZUZvY3VzID0gdGhpcy5faGFuZGxlRm9jdXNILmJpbmQodGhpcyk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9oYW5kbGVGb2N1cywgdHJ1ZSk7XG4gICAgdGhpcy5faGFuZGxlQmx1ciA9IHRoaXMuX2hhbmRsZUJsdXJILmJpbmQodGhpcyk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX2hhbmRsZUJsdXIsIHRydWUpO1xuICAgIHRoaXMuX2hhbmRsZVZpc2libGVDaGlsZHJlbiA9IHRoaXMuX2hhbmRsZVZpc2libGVDaGlsZHJlbkguYmluZCh0aGlzKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzcGFyay52aXNpYmxlLWNoaWxkcmVuJywgdGhpcy5faGFuZGxlVmlzaWJsZUNoaWxkcmVuLCB0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBmb3IgY2xpY2tzIGFuZCByZXNpemUgZXZlbnRzXG4gICAqL1xuXG5cbiAgVG9vbGJhci5wcm90b3R5cGUuX3JlbW92ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVXaW5kb3dDbGljayk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2hhbmRsZVJlc2l6ZSk7XG4gICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5faGFuZGxlS2V5RG93bik7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX2hhbmRsZUJsdXIsIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5faGFuZGxlRm9jdXMsIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NwYXJrLnZpc2libGUtY2hpbGRyZW4nLCB0aGlzLl9oYW5kbGVWaXNpYmxlQ2hpbGRyZW4sIHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiByZXNldCBvdXIgdGFiIGluZGV4IHdoZW4gdXNlciBmb2N1c2VzIG91dHNpZGUgb2YgZWxlbWVudCAoZ2V0cyBpbW1lZGlhdGVseSByZXNldCB0byAtMSBpZiBmb2N1cyBpcyBwbGFjZWQgYmFjayBpbnNpZGUgZWxlbWVudClcbiAgICogQHBhcmFtIHtFdmVudH0gZSBUaGUgRm9jdXNFdmVudFxuICAgKi9cblxuXG4gIFRvb2xiYXIucHJvdG90eXBlLl9oYW5kbGVCbHVySCA9IGZ1bmN0aW9uIF9oYW5kbGVCbHVySChlKSB7XG4gICAgaWYgKHRoaXMuZWwuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICB0aGlzLmVsLmF0dHJpYnV0ZXMudGFiaW5kZXgudmFsdWUgPSB0aGlzLnRhYmluZGV4O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogZm9jdXMgaGFuZGxlciwgd29ya3MgaW4gY29uanVuY3Rpb24gd2l0aCBibHVyIGhhbmRsZXIgdG8gc2V0IGNvcnJlY3QgdGFiaW5kZXggdmFsdWVcbiAgICogQHBhcmFtIHtFdmVudH0gZSBUaGUgRm9jdXNFdmVudFxuICAgKi9cblxuXG4gIFRvb2xiYXIucHJvdG90eXBlLl9oYW5kbGVGb2N1c0ggPSBmdW5jdGlvbiBfaGFuZGxlRm9jdXNIKGUpIHtcbiAgICAvL2lmIHdlJ3JlIG5vdCBiZWluZyBmb2N1c2VkLCByZXNldCBvdXIgdGFiaW5kZXggc28gd2UgYXJlIGFjY2Vzc2libGUgYWdhaW4sIGFuZCBjbG9zZSBhbnl0aGluZyBvcGVuXG4gICAgaWYgKCF0aGlzLmVsLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgdGhpcy5fY2xvc2VBbGwoKTtcbiAgICAgIHRoaXMuZWwuYXR0cmlidXRlcy50YWJpbmRleC52YWx1ZSA9IHRoaXMudGFiaW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vc2V0IG91ciB0YWJpbmRleCB0byAtMSBzbyB0aGUgdXNlciBjYW4gc2hpZnQtdGFiIG91dCBvZiBvdXIgZWxlbWVudFxuICAgICAgdGhpcy5lbC5hdHRyaWJ1dGVzLnRhYmluZGV4LnZhbHVlID0gLTE7XG4gICAgICBpZiAoZS50YXJnZXQuc3Bhcmt0b29sYmFyY29uKSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzTGFzdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvL2hhbmRsZSBmb2N1c2luZyBhbiBpdGVtXG4gICAgICBpZiAoZS50YXJnZXQuc3Bhcmt0b29sYmFyKSB7XG4gICAgICAgIGUudGFyZ2V0LnNwYXJrdG9vbGJhci5lbC5mb2N1cygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYSA9IGUudGFyZ2V0O1xuICAgICAgLy9oYXJkZXIgY2FzZSAtIGxvb2sgdXAgdGhlIHRyZWUgdG8gZmluZCBpZiB3ZSdyZSBmb2N1c2luZyBpbnNpZGUgY29udGVudFxuICAgICAgd2hpbGUgKCFhLnNwYXJrdG9vbGJhcmNvbikge1xuICAgICAgICBpZiAoYS5zcGFya3Rvb2xiYXIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL2lmIHdlIGFyZSAtIGdpdmUgb3VyIHBhcmVudCBlbGVtZW50IGEgdGFiaW5kZXggc28gdGhlIHVzZXIgY2FuIHJlZm9jdXMgdGhlIG1lbnUgdXNpbmcgc2hpZnQtdGFiXG4gICAgICAgIGlmIChhLnNwYXJrdG9vbGJhcmRyb3Bkb3duKSB7XG4gICAgICAgICAgdGhpcy5lbC5hdHRyaWJ1dGVzLnRhYmluZGV4LnZhbHVlID0gdGhpcy50YWJpbmRleDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGEucGFyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIHJlc2V0IG91ciBmb2N1cyB0byB0aGUgbGFzdCBtZW51IGl0ZW0gdGhhdCB3YXMgZm9jdXNlZFxuICAgKi9cblxuXG4gIFRvb2xiYXIucHJvdG90eXBlLl9mb2N1c0xhc3QgPSBmdW5jdGlvbiBfZm9jdXNMYXN0KCkge1xuICAgIGlmICghdGhpcy5fbGFzdEZvY3VzKSB7XG4gICAgICB2YXIgYSA9IHRoaXMudmlzaWJsZUNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuc3BhcmstdG9vbGJhcl9faXRlbScpIHx8IHRoaXMuaGlkZGVuQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay10b29sYmFyX19pdGVtJyk7XG4gICAgICB0aGlzLl9sYXN0Rm9jdXMgPSBhLnNwYXJrdG9vbGJhcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGlkZGVuQ29udGFpbmVyLmNvbnRhaW5zKHRoaXMuX2xhc3RGb2N1cy5lbCkpIHtcbiAgICAgIHRoaXMuX3RvZ2dsZVNob3dNb3JlKHRydWUpO1xuICAgIH1cbiAgICB0aGlzLl9sYXN0Rm9jdXMuZWwuZm9jdXMoKTtcbiAgfTtcblxuICAvKipcbiAgICoga2V5ZG93biBoYW5kbGVyLCB1c2VkIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgVGhlIEtleURvd24gRXZlbnRcbiAgICovXG5cblxuICBUb29sYmFyLnByb3RvdHlwZS5faGFuZGxlS2V5RG93bkggPSBmdW5jdGlvbiBfaGFuZGxlS2V5RG93bkgoZSkge1xuICAgIHZhciBhID0gZS50YXJnZXQ7XG4gICAgLy9maW5kIHRoZSBuZWFyZXN0IHRvb2xiYXJpdGVtXG4gICAgd2hpbGUgKCFhLnNwYXJrdG9vbGJhcmNvbikge1xuICAgICAgaWYgKGEuc3Bhcmt0b29sYmFyKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGEuc3Bhcmt0b29sYmFyZHJvcGRvd24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYSA9IGEucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgaWYgKGEuc3Bhcmt0b29sYmFyKSB7XG4gICAgICAvL2hhbmRsZSBrZXlzXG4gICAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgICAvL2xlZnQgYXJyb3dcbiAgICAgICAgLy91cCBhcnJvd1xuICAgICAgICBjYXNlIDM3OlxuICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgIGlmIChhLnByZXZpb3VzU2libGluZyAmJiBhLnByZXZpb3VzU2libGluZy5zcGFya3Rvb2xiYXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RGb2N1cyA9IGEucHJldmlvdXNTaWJsaW5nLnNwYXJrdG9vbGJhcjtcbiAgICAgICAgICAgIGEucHJldmlvdXNTaWJsaW5nLmZvY3VzKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpc2libGVDb250YWluZXIucXVlcnlTZWxlY3RvcignLnNwYXJrLXRvb2xiYXJfX2l0ZW0nKSAhPT0gYS5zcGFya3Rvb2xiYXIuZWwpIHtcbiAgICAgICAgICAgICAgYSA9IHRoaXMudmlzaWJsZUNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuc3BhcmstdG9vbGJhcl9faXRlbTpsYXN0LW9mLXR5cGUnKTtcbiAgICAgICAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90b2dnbGVTaG93TW9yZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdEZvY3VzID0gYS5zcGFya3Rvb2xiYXI7XG4gICAgICAgICAgICAgICAgYS5mb2N1cygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2Nsb3NlSXRlbXMoKTtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vcmlnaHQgYXJyb3dcbiAgICAgICAgLy9kb3duIGFycm93XG4gICAgICAgIGNhc2UgMzk6XG4gICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgaWYgKGEubmV4dFNpYmxpbmcgJiYgYS5uZXh0U2libGluZy5zcGFya3Rvb2xiYXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RGb2N1cyA9IGEubmV4dFNpYmxpbmcuc3Bhcmt0b29sYmFyO1xuICAgICAgICAgICAgYS5uZXh0U2libGluZy5mb2N1cygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oaWRkZW5Db250YWluZXIucXVlcnlTZWxlY3RvcignLnNwYXJrLXRvb2xiYXJfX2l0ZW06bGFzdC1vZi10eXBlJykgIT09IGEuc3Bhcmt0b29sYmFyLmVsKSB7XG4gICAgICAgICAgICAgIGEgPSB0aGlzLmhpZGRlbkNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuc3BhcmstdG9vbGJhcl9faXRlbScpO1xuICAgICAgICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvZ2dsZVNob3dNb3JlKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RGb2N1cyA9IGEuc3Bhcmt0b29sYmFyO1xuICAgICAgICAgICAgICAgIGEuZm9jdXMoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jbG9zZUl0ZW1zKCk7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvL3NwYWNlYmFyXG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIC8vd2Ugb25seSB3YW50IHRvIHRvZ2dsZSB0aGUgdG9vbGJhciBpZiB3ZSBhcmUgYWN0dWFsbHkgZm9jdXNlZCBkaXJlY3RseSBvbiBpdDtcbiAgICAgICAgICBpZiAoZS50YXJnZXQuc3Bhcmt0b29sYmFyKSB7XG4gICAgICAgICAgICBlLnRhcmdldC5zcGFya3Rvb2xiYXIuZWwuY2xpY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vZW50ZXJcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAvL3dlIG9ubHkgd2FudCB0byB0b2dnbGUgdGhlIHRvb2xiYXIgaWYgd2UgYXJlIGFjdHVhbGx5IGZvY3VzZWQgZGlyZWN0bHkgb24gaXQ7XG4gICAgICAgICAgaWYgKGUudGFyZ2V0LnNwYXJrdG9vbGJhcikge1xuICAgICAgICAgICAgZS50YXJnZXQuc3Bhcmt0b29sYmFyLmVsLmNsaWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFubGRlcyB0aGUgc3BhcmsudmlzaWJsZS1jaGlsZHJlbiBldmVudCB0byByZXNpemUgdGhlIGNvbXBvbmVudCB3aGVuIGl0IGlzIG1hZGUgdmlzaWJsZS5cbiAgICogQHBhcmFtIHtFdmVudH0gZSBUaGUgc3BhcmsudmlzaWJsZS1jaGlsZHJlbiBldmVudFxuICAgKi9cblxuXG4gIFRvb2xiYXIucHJvdG90eXBlLl9oYW5kbGVWaXNpYmxlQ2hpbGRyZW5IID0gZnVuY3Rpb24gX2hhbmRsZVZpc2libGVDaGlsZHJlbkgoZSkge1xuICAgIGlmIChlLnRhcmdldC5jb250YWlucyh0aGlzLmVsKSkge1xuICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoYW5nZSgpO1xuICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIGNsaWNrIGV2ZW50cywgaGFuZGxlcyB3aW5kb3cgY2xpY2tzLCBjb250cm9sIGVsZW1lbnQgY2xpY2tzLFxuICAgKiBhbmQgZm9yd2FyZHMgZXZlbnRzIHRvIHRvb2xiYXJJdGVtIGNsaWNrIGhhbmRsZXJzIGFzIG5lZWRlZFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIFRoZSBjbGljayBldmVudFxuICAgKi9cblxuXG4gIFRvb2xiYXIucHJvdG90eXBlLl9oYW5kbGVXaW5kb3dDbGlja0ggPSBmdW5jdGlvbiBfaGFuZGxlV2luZG93Q2xpY2tIKGUpIHtcblxuICAgIGlmICgoMCwgX3BhcnNlQXR0cmlidXRlLmJvb2xlYW4pKGUudGFyZ2V0LCAnZGlzYWJsZWQnKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vQ2hlY2sgdG8gc2VlIGlmIHRoZSBjbGljayB3YXMgb3V0c2lkZSBvZiB0aGUgdG9vbGJhclxuICAgIGlmICghdGhpcy5lbC5jb250YWlucyhlLnRhcmdldCkpIHtcbiAgICAgIHRoaXMuX2Nsb3NlSXRlbXMoKTtcbiAgICAgIHRoaXMuX3RvZ2dsZVNob3dNb3JlKGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGEgPSBlLnRhcmdldDtcbiAgICAgIC8vdHJhdmVyc2UgdGhlIGRvbSBub2RlIHRyZWUgdW50aWwgd2UgZmluZCBhbiBlbGVtZW50IHRoYXQgaGFuZGxlcyB0aGUgZXZlbnQsXG4gICAgICAvL29yIHdlIHJlYWNoIHRoZSB0b29sYmFyIHJvb3Qgbm9kZVxuICAgICAgaWYgKGEgPT09IHRoaXMudmlzaWJsZUNvbnRhaW5lciB8fCBhID09PSB0aGlzLmVsKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGEgIT09IHRoaXMuZWwpIHtcbiAgICAgICAgaWYgKGEuc3Bhcmt0b29sYmFyKSB7XG4gICAgICAgICAgdmFyIGMgPSB0aGlzLl9nZXRPcGVuSXRlbXMoKTtcbiAgICAgICAgICBpZiAoYy5pbmRleE9mKGEuc3Bhcmt0b29sYmFyKSA+PSAwKSB7XG4gICAgICAgICAgICBjLnNwbGljZShjLmluZGV4T2YoYS5zcGFya3Rvb2xiYXIpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY2xvc2VJdGVtcyhjKTtcbiAgICAgICAgICBpZiAoIXRoaXMuaGlkZGVuQ29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlU2hvd01vcmUoZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYS5zcGFya3Rvb2xiYXIuaGFuZGxlQ2xpY2soZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEuc3Bhcmt0b29sYmFyc2hvd21vcmUpIHtcbiAgICAgICAgICB0aGlzLl9jbG9zZUl0ZW1zKCk7XG4gICAgICAgICAgdGhpcy5fdG9nZ2xlU2hvd01vcmUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGEucGFyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2Nsb3NlQWxsKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUb2dnbGUgdGhlIHN0YXRlIG9mIHRoZSBzaG93IG1vcmUgZHJvcGRvd24sIG9wdGlvbmFsIHBhcmFtZXRlciBvdmVycmlkZXMgdG9nZ2xlIGFuZFxuICAgKiBzZXRzIHN0YXRlIHRvIHBhc3NlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wZW4gVGhlIG5ldyBzdGF0ZSBvZiB0aGUgc2hvdyBtb3JlIGRyb3Bkb3duXG4gICAqL1xuXG5cbiAgVG9vbGJhci5wcm90b3R5cGUuX3RvZ2dsZVNob3dNb3JlID0gZnVuY3Rpb24gX3RvZ2dsZVNob3dNb3JlKG9wZW4pIHtcbiAgICB2YXIgbyA9IHR5cGVvZiBvcGVuICE9PSAndW5kZWZpbmVkJyA/ICFvcGVuIDogdGhpcy5pc09wZW47XG4gICAgaWYgKG8pIHtcbiAgICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKHRoaXMuZWwsICdhbmltYXRlJyk7XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKHRoaXMuZWwsICdvcGVuJyk7XG4gICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICB9LmJpbmQodGhpcyksIDEwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNPcGVuID0gdHJ1ZTtcbiAgICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKHRoaXMuZWwsICdvcGVuJyk7XG4gICAgICB0aGlzLl9wb3NpdGlvblNob3dNb3JlKCk7XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKHRoaXMuZWwsICdhbmltYXRlJyk7XG4gICAgICB9LmJpbmQodGhpcyksIDApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgKiBEbyBib3VuZHMgY2hlY2tpbmcgb24gc2hvdy1tb3JlIGRyb3Bkb3duIHdoZW4gaXQgaXMgb3BlbmVkLCBhbmQgcG9zaXRpb24gaXQgYWNjb3JkaW5nbHlcbiAgKi9cblxuXG4gIFRvb2xiYXIucHJvdG90eXBlLl9wb3NpdGlvblNob3dNb3JlID0gZnVuY3Rpb24gX3Bvc2l0aW9uU2hvd01vcmUoKSB7XG4gICAgdGhpcy5oaWRkZW5Db250YWluZXIuc3R5bGUucmlnaHQgPSAnMHB4JztcbiAgICB2YXIgcG9zID0gdGhpcy5oaWRkZW5Db250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIGxlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgdmFyIHJpZ2h0ID0gd2luZG93LnBhZ2VYT2Zmc2V0ICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIGlmIChwb3MucmlnaHQgPiByaWdodCkge1xuICAgICAgdGhpcy5oaWRkZW5Db250YWluZXIuc3R5bGUucmlnaHQgPSAnY2FsYygnICsgKHBvcy5yaWdodCAtIHJpZ2h0KSArICdweCArIDFyZW0pJztcbiAgICB9XG4gICAgaWYgKHBvcy5sZWZ0IDwgbGVmdCkge1xuICAgICAgdGhpcy5oaWRkZW5Db250YWluZXIuc3R5bGUucmlnaHQgPSAnY2FsYygnICsgKHBvcy5sZWZ0IC0gbGVmdCkgKyAncHggLSAxcmVtKSc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNpemUgZXZlbnQgaGVscGVyLCBjbG9zZXMgaXRlbXMgdGhlbiB0cmlnZ2VycyByZWNhbGN1bGF0aW9uIG9mIHN0eWxlc1xuICAgKi9cblxuXG4gIFRvb2xiYXIucHJvdG90eXBlLl9oYW5kbGVSZXNpemVIID0gZnVuY3Rpb24gX2hhbmRsZVJlc2l6ZUgoKSB7XG4gICAgdGhpcy5fY2xvc2VBbGwoKTtcbiAgICB0aGlzLl9jYWxjdWxhdGVTdHlsZXMoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVldmFsdWF0ZXMgdGhlIGF2YWlsYWJsZSBhcmVhIG9mIHRoZSB0b29sYmFyIGFuZCBwbGFjZXMgdG9vbGJhckl0ZW1zIGludG9cbiAgICogdGhlIGhpZGRlbiBjb250YWluZXIsIGFzIG5lY2Vzc2FyeS4gU2hvdWxkIG5vdCBjYWxsIHdpdGggYW55IHNwZWNpZmllZCB2YWx1ZVxuICAgKiBmb3Igc2hvd01vcmUgKHVzZWQgaW50ZXJuYWxseSlcbiAgICogQHBhcmFtIHtCb29sZWFufSBzaG93TW9yZSBVc2VkIHRvIGNvbmRpdGlvbmFsbHkgZXZhbHVhdGUgc3R5bGluZyB3aGVuIHNob3dNb3JlIGFyZWEgaXMgdXNlZFxuICAgKi9cblxuXG4gIFRvb2xiYXIucHJvdG90eXBlLl9jYWxjdWxhdGVTdHlsZXMgPSBmdW5jdGlvbiBfY2FsY3VsYXRlU3R5bGVzKHNob3dNb3JlKSB7XG4gICAgdGhpcy5lbC5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBzaG93TW9yZSA9IHR5cGVvZiBzaG93TW9yZSAhPT0gJ3VuZGVmaW5lZCcgPyBzaG93TW9yZSA6IGZhbHNlO1xuICAgIGlmICghc2hvd01vcmUpIHtcbiAgICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKHRoaXMuZWwsICdzaG93LW1vcmUnKTtcbiAgICB9XG4gICAgdmFyIHZpc2libGUgPSBbXTtcbiAgICB2YXIgaGlkZGVuID0gW107XG4gICAgdmFyIGk7XG4gICAgLy9zb3J0IGl0ZW1zIGJ5IHRoZWlyIHByaW9yaXR5IHRvIGVuc3VyZSBoaWdoZXItcHJpb3JpdHkgaXRlbXMgYXJlIGFsd2F5cyBwbGFjZWRcbiAgICAvL2ludG8gdGhlIHZpc2libGUgYXJlYSBmaXJzdFxuICAgIHRoaXMuaXRlbXMuc29ydCh0aGlzLl9wcmlvcml0eVNvcnQpO1xuICAgIC8vZ2V0IGNvbnRhaW5lciB3aWR0aCBhbmQgc3RhcnQgcGxhY2luZyBpdGVtcyBpbnRvIHRoZWlyIGNvbnRhaW5lcnNcbiAgICB2YXIgdmlzaWJsZVdpZHRoID0gdGhpcy52aXNpYmxlQ29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmlzaWJsZVdpZHRoIC0gdGhpcy5pdGVtc1tpXS53aWR0aCA+PSAwKSB7XG4gICAgICAgIHZpc2libGUucHVzaCh0aGlzLml0ZW1zW2ldKTtcbiAgICAgICAgdmlzaWJsZVdpZHRoIC09IHRoaXMuaXRlbXNbaV0ud2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXNob3dNb3JlKSB7XG4gICAgICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ3Nob3ctbW9yZScpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVTdHlsZXModHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZGVuLnB1c2godGhpcy5pdGVtc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vc29ydCBpdGVtcyBiYWNrIGludG8gdGhlaXIgb3JpZ2luYWwgb3JkZXIgYmVmb3JlIGluc2VydGluZyB0aGVtIGludG8gdGhlIGRvY3VtZW50XG4gICAgdmlzaWJsZS5zb3J0KHRoaXMuX29yZGVyU29ydCk7XG4gICAgaGlkZGVuLnNvcnQodGhpcy5fb3JkZXJTb3J0KTtcbiAgICB2YXIgdiA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICB2YXIgaCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmlzaWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgdi5hcHBlbmRDaGlsZCh2aXNpYmxlW2ldLmVsKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGhpZGRlbi5sZW5ndGg7IGkrKykge1xuICAgICAgaC5hcHBlbmRDaGlsZChoaWRkZW5baV0uZWwpO1xuICAgIH1cbiAgICB0aGlzLnZpc2libGVDb250YWluZXIuYXBwZW5kQ2hpbGQodik7XG4gICAgdGhpcy5oaWRkZW5Db250YWluZXIuYXBwZW5kQ2hpbGQoaCk7XG4gICAgdGhpcy5lbC5zdHlsZS53aWR0aCA9ICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTb3J0cyB0b29sYmFyIGl0ZW1zIGluIGRlc2NlbmRpbmcgb3JkZXIgYmFzZWQgb24gdGhlaXIgcHJpb3JpdHkgdmFsdWVcbiAgICovXG5cblxuICBUb29sYmFyLnByb3RvdHlwZS5fcHJpb3JpdHlTb3J0ID0gZnVuY3Rpb24gX3ByaW9yaXR5U29ydChsLCByKSB7XG4gICAgcmV0dXJuIHIucHJpb3JpdHkgLSBsLnByaW9yaXR5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBTb3J0cyB0b29sYmFyIGl0ZW1zIGluIGFzY2VuZGluZyBvcmRlciBiYXNlZCBvbiB0aGVpciBvcmRlciB2YWx1ZVxuICAgKi9cblxuXG4gIFRvb2xiYXIucHJvdG90eXBlLl9vcmRlclNvcnQgPSBmdW5jdGlvbiBfb3JkZXJTb3J0KGwsIHIpIHtcbiAgICByZXR1cm4gbC5vcmRlciAtIHIub3JkZXI7XG4gIH07XG5cbiAgcmV0dXJuIFRvb2xiYXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRvb2xiYXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvb2xiYXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHJpbSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJpbScpO1xuXG52YXIgX3RyaW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJpbSk7XG5cbnZhciBfaGFzQ2xhc3MgPSByZXF1aXJlKCcuL2hhcy1jbGFzcycpO1xuXG52YXIgX2hhc0NsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhc0NsYXNzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiAjIEFkZCBDbGFzc1xuICogQWRkIGEgY2xhc3Mgb24gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXl9IGVsIEFuIGVsZW1lbnQgb3IgYXJyYXkgb2YgZWxlbWVudHMgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL2RvbS9hZGQtY2xhc3MuanNcbiAqL1xuXG52YXIgd3MgPSAvXFxzKy87XG52YXIgY2xlYW51cCA9IC9cXHN7Mix9L2c7XG5cbmZ1bmN0aW9uIGFkZENsYXNzKGVsLCBuYW1lKSB7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgbmFtZSA9ICgwLCBfdHJpbTIuZGVmYXVsdCkobmFtZSkuc3BsaXQod3MpO1xuICB9IGVsc2Uge1xuICAgIG5hbWUgPSBuYW1lIGluc3RhbmNlb2YgQXJyYXkgPyBuYW1lIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgfVxuXG4gIC8vIG9wdGltaXplIGZvciBiZXN0LCBtb3N0IGNvbW1vbiBjYXNlXG4gIGlmIChuYW1lLmxlbmd0aCA9PT0gMSAmJiBlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAobmFtZVswXSkge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChuYW1lWzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgdmFyIHRvQWRkID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBuYW1lLmxlbmd0aDtcbiAgdmFyIGl0ZW0gPSB2b2lkIDA7XG4gIHZhciBjbHNOYW1lID0gdHlwZW9mIGVsLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycgPyBlbC5jbGFzc05hbWUgOiBlbC5nZXRBdHRyaWJ1dGUgPyBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgOiAnJztcblxuICAvLyBzZWUgaWYgd2UgaGF2ZSBhbnl0aGluZyB0byBhZGRcbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBpdGVtID0gbmFtZVtpXTtcbiAgICBpZiAoaXRlbSAmJiAhKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkoY2xzTmFtZSwgaXRlbSkpIHtcbiAgICAgIHRvQWRkLnB1c2goaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRvQWRkLmxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgZWwuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZWwuY2xhc3NOYW1lID0gKDAsIF90cmltMi5kZWZhdWx0KSgoY2xzTmFtZSArICcgJyArIHRvQWRkLmpvaW4oJyAnKSkucmVwbGFjZShjbGVhbnVwLCAnICcpKTtcbiAgICB9IGVsc2UgaWYgKGVsLnNldEF0dHJpYnV0ZSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsICgwLCBfdHJpbTIuZGVmYXVsdCkoKGNsc05hbWUgKyAnICcgKyB0b0FkZC5qb2luKCcgJykpLnJlcGxhY2UoY2xlYW51cCwgJyAnKSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbDtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gYWRkQ2xhc3M7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZC1jbGFzcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4vKipcbiAqICMgSGFzIENsYXNzXG4gKiBTZWUgaWYgYW4gZWxlbWVudCBoYXMgYSBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL2RvbS9oYXMtY2xhc3MuanNcbiAqL1xuZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIG5hbWUpIHtcbiAgdmFyIGNOYW1lID0gKCh0eXBlb2YgZWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGVsKSkgPT09ICdvYmplY3QnID8gZWwuY2xhc3NOYW1lIHx8IGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycgOiBlbCB8fCAnJykucmVwbGFjZSgvW1xcdFxcclxcblxcZl0vZywgJyAnKTtcbiAgcmV0dXJuICgnICcgKyBjTmFtZSArICcgJykuaW5kZXhPZignICcgKyBuYW1lICsgJyAnKSAhPT0gLTE7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGhhc0NsYXNzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXMtY2xhc3MuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgUGFyc2UgRE9NIGF0dHJpYnV0ZXNcbiAqIEdpdmVuIGFuIGVsZW1lbnQgYW5kIGFuIGF0dHJpYnV0ZSBuYW1lLCBwYXJzZSB0aGF0IGF0dHJpYnV0ZVxuICogaWYgaXQgZXhpc3RzIG9yIHJldHVybiBhIGRlZmF1bHQuXG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL2RvbS9wYXJzZS1hdHRyaWJ1dGUuanNcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgYm9vbGVhbiB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcbiAqIGZhbGxpbmcgYmFjayB0byB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGRlZlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYm9vbGVhbihlbCwgbmFtZSwgZGVmKSB7XG4gIHZhciB2YWwgPSBlbC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiBkZWY7XG4gIHJldHVybiB2YWwgPT09ICd0cnVlJyB8fCB2YWwgPT09ICcnID8gdHJ1ZSA6IGZhbHNlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbnVtZXJpYyB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcbiAqIGZhbGxpbmcgYmFjayB0byB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGRlZlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gbnVtYmVyKGVsLCBuYW1lLCBkZWYpIHtcbiAgdmFyIHZhbCA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuIGRlZjtcbiAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYm9vbGVhbiB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcbiAqIGZhbGxpbmcgYmFjayB0byB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGRlZlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc3RyaW5nKGVsLCBuYW1lLCBkZWYpIHtcbiAgdmFyIHZhbCA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuIGRlZjtcbiAgcmV0dXJuIHZhbDtcbn1cblxuZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhbjtcbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS1hdHRyaWJ1dGUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHJpbSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJpbScpO1xuXG52YXIgX3RyaW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJpbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciB3cyA9IC9cXHMrLzsgLyoqXG4gICAgICAgICAgICAgICAgICogIyBSZW1vdmUgQ2xhc3NcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmUgYSBjbGFzcyBvbiBhbiBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fEFycmF5fSBlbCBBbiBlbGVtZW50IG9yIGFycmF5IG9mIGVsZW1lbnRzIHRvIHVwZGF0ZS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIGhlbHBlcnMvZG9tL3JlbW92ZS1jbGFzcy5qc1xuICAgICAgICAgICAgICAgICAqL1xuXG52YXIgY2xlYW51cCA9IC9cXHN7Mix9L2c7XG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBuYW1lKSB7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgbmFtZSA9ICgwLCBfdHJpbTIuZGVmYXVsdCkobmFtZSkuc3BsaXQod3MpO1xuICB9IGVsc2Uge1xuICAgIG5hbWUgPSBuYW1lIGluc3RhbmNlb2YgQXJyYXkgPyBuYW1lIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgfVxuXG4gIC8vIG9wdGltaXplIGZvciBiZXN0LCBtb3N0IGNvbW1vbiBjYXNlXG4gIGlmIChuYW1lLmxlbmd0aCA9PT0gMSAmJiBlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAobmFtZVswXSkgZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lWzBdKTtcbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICAvLyBzdG9yZSB0d28gY29waWVzXG4gIHZhciBjbHNOYW1lID0gJyAnICsgKHR5cGVvZiBlbC5jbGFzc05hbWUgPT09ICdzdHJpbmcnID8gZWwuY2xhc3NOYW1lIDogZWwuZ2V0QXR0cmlidXRlID8gZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIDogJycpICsgJyAnO1xuICB2YXIgcmVzdWx0ID0gY2xzTmFtZTtcbiAgdmFyIGN1cnJlbnQgPSB2b2lkIDA7XG4gIHZhciBzdGFydCA9IHZvaWQgMDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBuYW1lLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGN1cnJlbnQgPSBuYW1lW2ldO1xuICAgIHN0YXJ0ID0gY3VycmVudCA/IHJlc3VsdC5pbmRleE9mKCcgJyArIGN1cnJlbnQgKyAnICcpIDogLTE7XG4gICAgaWYgKHN0YXJ0ICE9PSAtMSkge1xuICAgICAgc3RhcnQgKz0gMTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBzdGFydCkgKyByZXN1bHQuc2xpY2Uoc3RhcnQgKyBjdXJyZW50Lmxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgLy8gb25seSB3cml0ZSBpZiBtb2RpZmllZFxuICBpZiAoY2xzTmFtZSAhPT0gcmVzdWx0KSB7XG4gICAgaWYgKHR5cGVvZiBlbC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbC5jbGFzc05hbWUgPSAoMCwgX3RyaW0yLmRlZmF1bHQpKHJlc3VsdC5yZXBsYWNlKGNsZWFudXAsICcgJykpO1xuICAgIH0gZWxzZSBpZiAoZWwuc2V0QXR0cmlidXRlKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKDAsIF90cmltMi5kZWZhdWx0KShyZXN1bHQucmVwbGFjZShjbGVhbnVwLCAnICcpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSByZW1vdmVDbGFzcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZlLWNsYXNzLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgRGVib3VuY2VcbiAqIERlYm91bmNlIGEgZnVuY3Rpb24gY2FsbFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAqIEBwYXJhbSB7SW50ZWdlcn0gZGVsYXlcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdXRpbC9kZWJvdW5jZS5qc1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCBkZWxheSkge1xuXG4gIHZhciB0aW1lciA9IHZvaWQgMDtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIGlmICh0aW1lcikgd2luZG93LmNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgdGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0sIGRlbGF5KTtcbiAgfTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZGVib3VuY2U7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVib3VuY2UuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgVHJpbVxuICogVHJpbSB3aGl0ZXNwYWNlIG9uIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdXRpbC90cmltLmpzXG4gKi9cblxudmFyIHRyaW1SRSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHRyaW1SRSwgJycpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0cmltO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmltLmpzLm1hcFxuIl19"}