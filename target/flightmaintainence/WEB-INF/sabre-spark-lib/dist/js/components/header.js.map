{"version":3,"sources":["js/dist/components/node_modules/browser-pack/_prelude.js","js/dist/components/js/dist/components/base.js","js/dist/components/js/dist/components/header.js","js/dist/components/js/dist/components/menu.js","js/dist/components/js/dist/helpers/animation/height.js","js/dist/components/js/dist/helpers/css/transform.js","js/dist/components/js/dist/helpers/dom/add-class.js","js/dist/components/js/dist/helpers/dom/breakpoint.js","js/dist/components/js/dist/helpers/dom/has-class.js","js/dist/components/js/dist/helpers/dom/outer-height.js","js/dist/components/js/dist/helpers/dom/parse-attribute.js","js/dist/components/js/dist/helpers/dom/remove-class.js","js/dist/components/js/dist/helpers/dom/toggle-class.js","js/dist/components/js/dist/helpers/manipulation/append-children.js","js/dist/components/js/dist/helpers/manipulation/insert-before.js","js/dist/components/js/dist/helpers/manipulation/wrap-element.js","js/dist/components/js/dist/helpers/traversal/get-child.js","js/dist/components/js/dist/helpers/traversal/get-index.js","js/dist/components/js/dist/helpers/traversal/get-parent.js","js/dist/components/js/dist/helpers/traversal/get-parents.js","js/dist/components/js/dist/helpers/traversal/has-parent.js","js/dist/components/js/dist/helpers/traversal/matches.js","js/dist/components/js/dist/helpers/util/each.js","js/dist/components/js/dist/helpers/util/trim.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"header.js","sourcesContent":["(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _each = require('../helpers/util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * # Base Component\n                                                                                                                                                           * The base class for Spark JS components. This class should never be\n                                                                                                                                                           * instantiated directly.\n                                                                                                                                                           *\n                                                                                                                                                           * @param {Element} el\n                                                                                                                                                           * @param {Object} params\n                                                                                                                                                           *\n                                                                                                                                                           * @module components/base.js\n                                                                                                                                                           */\n\nvar noop = function noop() {};\n\nvar Base = function () {\n\n  /**\n   * Set parameters and cache elements.\n   */\n  function Base(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Base);\n\n    if (params.elRequired && !el) {\n      return;\n    }\n\n    this.setParams(this.defaults || {}, true);\n    this.setParams(params);\n    (this._cacheElements || noop).call(this, el, params);\n    (this._parseParams || noop).call(this);\n  }\n\n  /**\n   * Remove the component from the DOM and prepare for garbage collection by dereferencing values.\n   * @param {Boolean} leaveElement Leave the element intact.\n   */\n\n\n  Base.prototype.remove = function remove(leaveElement) {\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    if (!leaveElement && this.el && this.el.parentNode) {\n      this.el.parentNode.removeChild(this.el);\n    }\n\n    this.unsetParams(this.defaults);\n\n    return this;\n  };\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   * @param {Object} params Optional\n   */\n\n\n  Base.prototype.update = function update(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    (this._cacheElements || noop).call(this, el || this.el, params);\n    (this._parseParams || noop).call(this);\n\n    if (this._addEventListeners) {\n      this._addEventListeners();\n    }\n\n    return this;\n  };\n\n  /**\n   * Set a hash of parameters if they're whitelisted or we're told to force the set.\n   * This is used to set initial values as well as set passed parameters.\n   * @param {Object} params\n   * @param {Boolean} force Force setting even if the param is not whitelisted.\n   */\n\n\n  Base.prototype.setParams = function setParams(params, force) {\n    var _this = this;\n\n    (0, _each2.default)(params, function (k, v) {\n      if (_this._whitelistedParams.indexOf(k) !== -1 || force) {\n        _this[k] = v;\n      }\n    });\n\n    return this;\n  };\n\n  /**\n   * Unset all parameters.\n   * @param {Array|Object} keys\n   * @param {Object} scope The object to unset the params from. Defaults to `this`.\n   */\n\n\n  Base.prototype.unsetParams = function unsetParams(keys, scope) {\n\n    keys = keys instanceof Array ? keys : Object.keys(keys);\n    scope = scope || this;\n    (0, _each2.default)(keys, function (k) {\n      delete scope[k];\n    });\n\n    return this;\n  };\n\n  return Base;\n}();\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nBase.prototype._whitelistedParams = [];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nBase.prototype.defaults = {};\n\nexports.default = Base;\nmodule.exports = exports['default'];\n//# sourceMappingURL=base.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _base = require('./base');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _menu = require('./menu');\n\nvar _menu2 = _interopRequireDefault(_menu);\n\nvar _toggleClass = require('../helpers/dom/toggle-class');\n\nvar _toggleClass2 = _interopRequireDefault(_toggleClass);\n\nvar _addClass = require('../helpers/dom/add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _removeClass = require('../helpers/dom/remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nvar _hasClass = require('../helpers/dom/has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _getIndex = require('../helpers/traversal/get-index');\n\nvar _getIndex2 = _interopRequireDefault(_getIndex);\n\nvar _appendChildren = require('../helpers/manipulation/append-children');\n\nvar _appendChildren2 = _interopRequireDefault(_appendChildren);\n\nvar _insertBefore = require('../helpers/manipulation/insert-before');\n\nvar _insertBefore2 = _interopRequireDefault(_insertBefore);\n\nvar _breakpoint = require('../helpers/dom/breakpoint');\n\nvar _getParent = require('../helpers/traversal/get-parent');\n\nvar _getParent2 = _interopRequireDefault(_getParent);\n\nvar _getParents = require('../helpers/traversal/get-parents');\n\nvar _getParents2 = _interopRequireDefault(_getParents);\n\nvar _parseAttribute = require('../helpers/dom/parse-attribute');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * # Header\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * A primary page header/navigation.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @example\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * new Header(el, {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   // Optional. Alternate breakpoint values.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   breakpoints: {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *    xs: {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *      min: 0,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *      max: 639\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *    }\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *    // ...\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  }\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * });\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module components/header.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\nvar Header = function (_BaseComponent) {\n  _inherits(Header, _BaseComponent);\n\n  /**\n   * Header constructor.\n   * @param {Element} el\n   * @param {Object} params\n   */\n  function Header(el) {\n    var _this;\n\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Header);\n\n    params.elRequired = true;\n\n    if (!(_this = _possibleConstructorReturn(this, _BaseComponent.call(this, el, params)), _this)) {\n      return _possibleConstructorReturn(_this);\n    }\n\n    _this._bindEventListenerCallbacks();\n    _this._addEventListeners();\n    _this._determineInitialSize();\n    return _possibleConstructorReturn(_this);\n  }\n\n  /**\n   * Update the elements used.\n   * @param {Element} el Optional\n   */\n\n\n  Header.prototype.update = function update(el) {\n\n    this._removeEventListeners();\n    this._removePlaceholder();\n    this._cacheElements(el || this.el);\n    this._parseParams();\n    this._addEventListeners();\n    this._ensureActiveAtMoreSwapIndex();\n    this.checkFixed();\n\n    // Run on the next frame so sizes have updated\n    setTimeout(function () {\n      this._determineMenuSize();\n    }.bind(this), 0);\n\n    return this;\n  };\n\n  /**\n   * Check of we should be fixed.\n   */\n\n\n  Header.prototype.checkFixed = function checkFixed() {\n\n    if (!this.fixed) {\n      return this;\n    }\n\n    var scrollTop = window.pageYOffset !== undefined ? window.pageYOffset : window.document.body.scrollTop;\n    var isCondensed = scrollTop > this.fixedDistance;\n    (0, _toggleClass2.default)(this.el, 'spark-header--condensed', isCondensed);\n    (0, _toggleClass2.default)(document.body, 'spark-header-condensed', isCondensed);\n\n    return this;\n  };\n\n  /**\n   * Store a reference to the tabs list, each tab and each panel.\n   * Set which tab is active, or use the first.\n   * @param {Element} el\n   */\n\n\n  Header.prototype._cacheElements = function _cacheElements(el) {\n\n    this.el = el;\n    this.navEl = this.el.querySelector('.spark-header__nav');\n    this.menuEl = this.navEl && this.navEl.querySelector('.spark-header__menu');\n    this.listEl = this.menuEl && this.menuEl.querySelector('.spark-header__list');\n    this.toggleEl = this.el.querySelector('.spark-header__toggle');\n\n    // Create a new instance of the menu component\n    if (this.menuEl) {\n      this.menu = new _menu2.default(this.menuEl, {\n        onToggle: this._onToggleClickBound = this._onToggleClick.bind(this)\n      });\n    }\n\n    // The items in the list need to show/hide based on the width of the container.\n    // Cache these items so we can manipulate their display independent of what is\n    // currently in the DOM. Also, create the \"More\" dropdown which will be shown\n    // and hidden based on availabile space.\n    if (this.listEl && this.listEl.children.length) {\n      this.listEls = Array.prototype.slice.call(this.listEl.children, 0);\n      this._createListMore();\n    }\n\n    // Create a clone of the header which will NOT be affected by changes in breakpoint.\n    // This lets us continue to measure how many list elements will fit. Since we go to the\n    // \"condensed\" view when we are at the sm/xs breakpoint OR only one item will fit in the nav,\n    // we can't rely on breakpoints alone to determine what to show. Without a cloned placeholder\n    // it is impossible to continue to measure the available space once we show the condensed view.\n    if (this.listEl) {\n      this._createPlaceholder();\n    }\n  };\n\n  /**\n   * Parse parameters from the elements.\n   */\n\n\n  Header.prototype._parseParams = function _parseParams() {\n    this.fixed = this.fixed !== null ? this.fixed : (0, _hasClass2.default)(this.el, 'spark-header--fixed');\n    this.fixedDistance = this.fixedDistance !== null ? this.fixedDistance : (0, _parseAttribute.number)(this.el, 'data-fixed-distance', 10);\n  };\n\n  /**\n   * Create bound versions of event listener callbacks and store them.\n   * Otherwise we can't unbind from these events later because the\n   * function signatures won't match.\n   */\n\n\n  Header.prototype._bindEventListenerCallbacks = function _bindEventListenerCallbacks() {\n\n    this._determineInitialSizeBound = this._determineInitialSize.bind(this);\n    this._onResizeBound = this._onResize.bind(this);\n    this._onScrollBound = this._onScroll.bind(this);\n    this._onMoreClickBound = this._onMoreClick.bind(this);\n    this._onNavClickBound = this._onNavClick.bind(this);\n  };\n\n  /**\n   * Add event listeners for DOM events.\n   */\n\n\n  Header.prototype._addEventListeners = function _addEventListeners() {\n\n    if (!this.listEl) {\n      return;\n    }\n\n    window.addEventListener('resize', this._onResizeBound);\n    window.addEventListener('orientationchange', this._onResizeBound);\n\n    if (this.listMoreEl) {\n      this.listMoreListEl.addEventListener('click', this._onMoreClickBound);\n    }\n\n    if (this.toggleEl) {\n      this.toggleEl.addEventListener('click', this._onToggleClickBound);\n    }\n\n    if (this.navEl) {\n      this.navEl.addEventListener('click', this._onNavClickBound);\n    }\n\n    if (this.fixed) {\n      window.addEventListener('scroll', this._onScrollBound);\n    }\n  };\n\n  /**\n   * Remove event listeners for DOM events..\n   */\n\n\n  Header.prototype._removeEventListeners = function _removeEventListeners() {\n\n    if (!this.listEl) {\n      return;\n    }\n\n    window.removeEventListener('resize', this._onResizeBound);\n    window.removeEventListener('orientationchange', this._onResizeBound);\n\n    if (this.listMoreEl) {\n      this.listMoreListEl.removeEventListener('click', this._onMoreClickBound);\n    }\n\n    if (this.toggleEl) {\n      this.toggleEl.removeEventListener('click', this._onToggleClickBound);\n    }\n\n    if (this.navEl) {\n      this.navEl.removeEventListener('click', this._onNavClickBound);\n    }\n\n    if (this.fixed) {\n      window.removeEventListener('scroll', this._onScrollBound);\n    }\n  };\n\n  /**\n   * Get the current breakpoint for the header.\n   */\n\n\n  Header.prototype._getCurrentBreakpoint = function _getCurrentBreakpoint() {\n    this.lastBreakpoint = this.currentBreakpoint;\n    this.currentBreakpoint = (0, _breakpoint.get)(this.el.clientWidth, this.breakpoints);\n    this.el.setAttribute('data-breakpoint', this.currentBreakpoint);\n  };\n\n  /**\n   * Create a placeholder for the whole header so that we can keep track\n   * of the width of each child element regardless of whether or not we're\n   * condensed. Condensed styles do not apply to instances of the element\n   * with the placeholder class.\n   */\n\n\n  Header.prototype._createPlaceholder = function _createPlaceholder() {\n\n    var div = document.createElement('div');\n    div.innerHTML = this.navEl.outerHTML;\n\n    var el = div.children[0];\n    el.setAttribute('aria-hidden', true);\n\n    (0, _addClass2.default)(el, 'spark-header__placeholder');\n\n    this.el.appendChild(el);\n\n    // Cache the common elements\n    this.placeholder = {\n      el: el,\n      menuEl: el.querySelector('.spark-header__menu'),\n      listEl: el.querySelector('.spark-header__list')\n    };\n\n    // Add a copy of the \"more\" button to the list so we always know what size it would be\n    if (this.listMoreEl) {\n      this.placeholder.listEl.innerHTML += this.listMoreEl.outerHTML;\n      this.placeholder.listMoreEl = this.placeholder.listEl.querySelector('.spark-header__more');\n    }\n\n    this._disablePlaceholderLinkTab(el);\n  };\n\n  /**\n   * Remove the placeholder\n   */\n\n\n  Header.prototype._removePlaceholder = function _removePlaceholder() {\n\n    if (this.placeholder) {\n      this.placeholder.el.parentNode.removeChild(this.placeholder.el);\n      this.placeholder.menuEl.parentNode.removeChild(this.placeholder.menuEl);\n      this.placeholder.listEl.parentNode.removeChild(this.placeholder.listEl);\n    }\n\n    if (this.listMoreEl) {\n      this.placeholder.listMoreEl.parentNode.removeChild(this.placeholder.listMoreEl);\n    }\n  };\n\n  /**\n   * Disable tabbing for items in the placeholder.\n   * @param {Element} el\n   */\n\n\n  Header.prototype._disablePlaceholderLinkTab = function _disablePlaceholderLinkTab(el) {\n\n    // Set a negative tab index on each link in the placeholder\n    var links = el.querySelectorAll('.spark-menu__list-link, .spark-menu__list-expand');\n    var i = 0;\n    var len = links.length;\n\n    for (; i < len; i++) {\n      links.item(i).setAttribute('tabindex', -1);\n    }\n\n    // Set a negative tab index on each button in the placeholder\n    var buttons = el.querySelectorAll('button');\n    var k = 0;\n    len = buttons.length;\n\n    for (; k < len; k++) {\n      buttons.item(k).setAttribute('tabindex', -1);\n    }\n  };\n\n  /**\n   * Create a place to store overflow items of the list.\n   * Also add this item to the placeholder element so we always know\n   * which size it would be.\n   */\n\n\n  Header.prototype._createListMore = function _createListMore() {\n\n    var div = document.createElement('div');\n    div.innerHTML = '<li><a class=\"spark-menu__list-link spark-menu__ignore\" tabindex=\"0\" title=\"More Items\"><i class=\"spark-icon-menu-ellipsis-horizontal spark-icon--fill\"></i></a><ul class=\"spark-menu__list\"></ul></li>';\n\n    var li = div.children[0];\n    (0, _addClass2.default)(li, 'spark-menu__list-item spark-header__more');\n\n    this.listMoreEl = li;\n    this.listMoreListEl = li.querySelector('ul');\n  };\n\n  /**\n   * Determine the menu size..\n   */\n\n\n  Header.prototype._determineInitialSize = function _determineInitialSize() {\n    (0, _addClass2.default)(this.el, 'spark-header--visible');\n    this._ensureActiveAtMoreSwapIndex();\n    this._determineMenuSize();\n  };\n\n  /**\n   * Determine how many nav items can fit.\n   * @param {Boolean} isSwap Optional Is this a swapping event? If so, ignore redundancy checks.\n   */\n\n\n  Header.prototype._determineMenuSize = function _determineMenuSize(isSwap) {\n\n    // Don't do anything w/o primary nav.\n    if (!this.listEls || !this.listEls.length) {\n      return;\n    }\n\n    // If we're at the XS or SM breakpoint, don't worry about this stuff.\n    if (this._isMenuBreakpoint(['xs', 'sm'])) {\n      this._removeListMore();\n      return this._toggleCollapsed(true);\n    }\n\n    // Get the items to show and hide\n    var items = this._getItemsToShowAndHide();\n\n    // Add a class saying that the size has been determined. This removes the overflow:hidden\n    // so that dropdowns will appear.\n    (0, _addClass2.default)(this.el, 'spark-header--overflow-checked');\n\n    // If there are less than two elements to show and we have hidden elements, collapse the nav.\n    if (items.show.length < 2 && items.hide.length) {\n      this._removeListMore();\n      return this._toggleCollapsed(true);\n    }\n\n    // We aren't at the XS breakpoint and there aren't too few items to show, so disable collapsing\n    this._toggleCollapsed(false);\n\n    // If the number of children to hide is the same as those already hidden, stop.\n    if (items.hide.length === this.listMoreListEl.children.length && !isSwap) {\n\n      if (!items.hide.length) {\n        this._removeListMore();\n      }\n\n      return;\n    }\n\n    // Add the elements we're supposed to show before the \"more element\"\n    (0, _insertBefore2.default)(this.listEl, this.listMoreEl, items.show);\n\n    // If we have items to hide, append them to the more element\n    if (items.hide.length) {\n      (0, _appendChildren2.default)(this.listMoreListEl, items.hide);\n    }\n    // Otherwise, remove the more element\n    else {\n        this._removeListMore();\n      }\n  };\n\n  /**\n   * Listen for the ready state change and rerun the menu size determination.\n   */\n\n\n  Header.prototype._listenForReadyStateChange = function _listenForReadyStateChange() {\n\n    // Already loaded\n    if (document.readyState === 'complete' || document.readyState === 'loaded') {\n      return;\n    }\n\n    // Bound listener\n    var run = function () {\n      if (document.readyState === 'complete' || document.readyState === 'loaded') {\n        this._determineMenuSize();\n        document.removeEventListener('readystatechange', run);\n      }\n    }.bind(this);\n\n    // Only run once\n    document.addEventListener('readystatechange', run);\n  };\n\n  /**\n   * Check the primary nav breakpoint.\n   * @param {String|Array} name A string or array of string names of breakpoints to check for\n   */\n\n\n  Header.prototype._isMenuBreakpoint = function _isMenuBreakpoint(name) {\n    this._getCurrentBreakpoint();\n    return name instanceof Array ? name.indexOf(this.currentBreakpoint) !== -1 : this.currentBreakpoint === 'xs';\n  };\n\n  /**\n   * Get the items to show and hide.\n   * @return {Object}\n   */\n\n\n  Header.prototype._getItemsToShowAndHide = function _getItemsToShowAndHide() {\n\n    var width = this.placeholder.listEl.clientWidth;\n    var children = this.placeholder.listEl.children;\n    var i = 0;\n    var len = children.length;\n    var hideIndex = -1;\n\n    this._addListMore();\n\n    // Always include the width of the more button.\n    var childrenWidth = this.placeholder.listMoreEl.clientWidth || 0;\n\n    // Loop through the children until we hit a point where they don't fit anymore\n    for (; i < len && hideIndex === -1; i++) {\n      childrenWidth += children[i].clientWidth;\n      if (childrenWidth > width) {\n        hideIndex = i;\n      }\n    }\n\n    // Find all the children that fit and don't fit\n    var items = {\n      show: hideIndex !== -1 ? Array.prototype.slice.call(this.listEls, 0, hideIndex) : this.listEls,\n      hide: hideIndex !== -1 ? Array.prototype.slice.call(this.listEls, hideIndex) : []\n    };\n\n    // If we have an index to swap for the last \"show\" element, replace that element\n    if (this.moreSwapIndex > -1 && this.moreSwapIndex >= items.show.length) {\n\n      // Remove the last element from the show array\n      var toHide = items.show.splice(items.show.length - 1, 1)[0];\n\n      // Get the index to remove from the hide array. Account for the offset.\n      var toShowIndex = this.moreSwapIndex - hideIndex;\n\n      // Remove the desired element from the hide array\n      var toShow = items.hide.splice(toShowIndex, 1)[0];\n\n      // Add the toShow element to the end of the show array\n      items.show.push(toShow);\n\n      // Insert the toHide element into the hide array at the position of\n      // the element we just removed from the hide array.\n      items.hide.splice(toShowIndex, 0, toHide);\n    }\n\n    return items;\n  };\n\n  /**\n   * Ensure that any active item is set to the more swap index. This ensures\n   * that the active item is always visible on the screen.\n   */\n\n\n  Header.prototype._ensureActiveAtMoreSwapIndex = function _ensureActiveAtMoreSwapIndex() {\n\n    if (!this.listEls || !this.listEls.length) {\n      return;\n    }\n\n    var el = this.el.querySelector('[class*=\"list-item\"].active');\n    if (el) {\n      var parents = (0, _getParents2.default)(el, '.spark-menu__list-item', this.el);\n\n      if (parents && parents[parents.length - 1]) {\n        el = parents[parents.length - 1];\n      }\n\n      var index = (0, _getIndex2.default)(this.listEls, el);\n\n      if (index !== this.moreSwapIndex) {\n        this.moreSwapIndex = index;\n      }\n    }\n  };\n\n  /**\n   * Add a placeholder for overflow items to the list.\n   */\n\n\n  Header.prototype._addListMore = function _addListMore() {\n    if (this.listMoreEl.parentNode !== this.listEl) {\n      this.listEl.appendChild(this.listMoreEl);\n    }\n  };\n\n  /**\n   * Remove a placeholder for overflow items from the primary nav.\n   */\n\n\n  Header.prototype._removeListMore = function _removeListMore() {\n    if (this.listMoreEl.parentNode) {\n      this.listMoreEl.parentNode.removeChild(this.listMoreEl);\n    }\n  };\n\n  /**\n   * Reset the children of the primary navigation.\n   */\n\n\n  Header.prototype._resetMenuChildren = function _resetMenuChildren() {\n    this.moreSwapIndex = -1;\n    (0, _removeClass2.default)(this.el, 'spark-header--overflow-checked');\n    (0, _appendChildren2.default)(this.listEl, this.listEls);\n  };\n\n  /**\n   * Toggle the collapsed nav style.\n   * @param {Boolean} enable\n   */\n\n\n  Header.prototype._toggleCollapsed = function _toggleCollapsed(enable) {\n\n    // Same collapsed state is already set\n    if (enable === this.isCollapsed) {\n      return;\n    }\n\n    // Reset children and remove a special no-animate class to top-level items when we collapse\n    if (enable) {\n      this._enableTopLevelToggling();\n      this._resetMenuChildren();\n    } else {\n      if (this.menu) {\n        this.menu._removeAllCachedLists();\n      }\n      this._disableTopLevelToggling();\n    }\n\n    this.isCollapsed = enable;\n    (0, _toggleClass2.default)(this.el, 'spark-header--collapsed', enable);\n    (0, _toggleClass2.default)(this.el, 'spark-header--visible', !enable);\n  };\n\n  /**\n   * Enable toggling on top-level items.\n   */\n\n\n  Header.prototype._enableTopLevelToggling = function _enableTopLevelToggling() {\n\n    var i = 0;\n    var len = this.listEls.length;\n\n    for (; i < len; i++) {\n      (0, _removeClass2.default)(this.listEls[i], 'spark-no-animate');\n    }\n  };\n\n  /**\n   * Disable toggling on top-level items.\n   */\n\n\n  Header.prototype._disableTopLevelToggling = function _disableTopLevelToggling() {\n\n    var i = 0;\n    var len = this.listEls.length;\n\n    for (; i < len; i++) {\n      (0, _addClass2.default)(this.listEls[i], 'spark-no-animate');\n    }\n  };\n\n  /**\n   * When the window resizes, redetermine the size of the primary nav elements.\n   */\n\n\n  Header.prototype._onResize = function _onResize() {\n\n    // Ensure that any active item we may have is at the swap index\n    this._ensureActiveAtMoreSwapIndex();\n    this._determineMenuSize();\n\n    // If we are fixed, do the scroll check\n    if (this.fixed) {\n      this.checkFixed();\n    }\n  };\n\n  /**\n   * Check to see if the header should be fixed.\n   * @param {Object} e\n   */\n\n\n  Header.prototype._onScroll = function _onScroll() {\n    this.checkFixed();\n  };\n\n  /**\n   * When a link in the more list is clicked, swap it with the last element in the visible list.\n   * @param {Object} e\n   */\n\n\n  Header.prototype._onMoreClick = function _onMoreClick(e) {\n\n    // Don't do any swapping if we're in a collapsed state\n    if (this.isCollapsed) {\n      return;\n    }\n\n    // Get the index of the clicked element\n    var li = (0, _getParent2.default)(e.target, 'li', this.listMoreListEl);\n\n    // Save the index of the element to be swapped\n    this.moreSwapIndex = (0, _getIndex2.default)(this.listEls, li);\n\n    // Redetermine the primary nav size\n    this._determineMenuSize(true);\n  };\n\n  /**\n   * When the toggle is clicked, toggle the active state on the nav\n   * @param {Object} e\n   */\n\n\n  Header.prototype._onToggleClick = function _onToggleClick(e) {\n    e.preventDefault();\n    this.isActive = !this.isActive;\n    (0, _toggleClass2.default)(this.navEl, 'active', this.isActive);\n    this.menu._openActiveParents();\n  };\n\n  /**\n   * When the nav is clicked, set to inactive.\n   * @param {Object} e\n   */\n\n\n  Header.prototype._onNavClick = function _onNavClick(e) {\n    if (e.target === this.navEl && this.isCollapsed) {\n      this.isActive = !this.isActive;\n      (0, _removeClass2.default)(this.navEl, 'active');\n    }\n  };\n\n  return Header;\n}(_base2.default);\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nHeader.prototype._whitelistedParams = ['breakpoints', 'fixed', 'fixedDistance'];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nHeader.prototype.defaults = {\n  el: null,\n  fixed: null,\n  fixedDistance: null,\n  navEl: null,\n  menuEl: null,\n  listEl: null,\n  listEls: null,\n  listMoreEl: null,\n  listMoreListEl: null,\n  placeholder: null,\n  toggleEl: null,\n  lastBreakpoint: null,\n  currentBreakpoint: null,\n  isActive: false,\n  isCollapsed: null,\n  moreSwapIndex: -1,\n  menu: null,\n  breakpoints: null,\n  _onResizeBound: null,\n  _onScrollBound: null,\n  _onMoreClickBound: null,\n  _onToggleClickBound: null,\n  _onNavClickBound: null\n};\n\nexports.default = Header;\nmodule.exports = exports['default'];\n//# sourceMappingURL=header.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _base = require('./base');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _height = require('../helpers/animation/height');\n\nvar _height2 = _interopRequireDefault(_height);\n\nvar _transform = require('../helpers/css/transform');\n\nvar _transform2 = _interopRequireDefault(_transform);\n\nvar _addClass = require('../helpers/dom/add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _removeClass = require('../helpers/dom/remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nvar _hasClass = require('../helpers/dom/has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _hasParent = require('../helpers/traversal/has-parent');\n\nvar _hasParent2 = _interopRequireDefault(_hasParent);\n\nvar _getParent = require('../helpers/traversal/get-parent');\n\nvar _getParent2 = _interopRequireDefault(_getParent);\n\nvar _getParents = require('../helpers/traversal/get-parents');\n\nvar _getParents2 = _interopRequireDefault(_getParents);\n\nvar _getChild = require('../helpers/traversal/get-child');\n\nvar _getChild2 = _interopRequireDefault(_getChild);\n\nvar _wrapElement = require('../helpers/manipulation/wrap-element');\n\nvar _wrapElement2 = _interopRequireDefault(_wrapElement);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * # Menu\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @example\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * new Menu(el, {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   // Optional. Callback method for when the menu toggles.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   onToggle: function(){}\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * });\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module components/menu.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\nvar noop = function noop() {};\n\nvar Menu = function (_BaseComponent) {\n  _inherits(Menu, _BaseComponent);\n\n  /**\n   * Menu constructor.\n   * @param {Element} el\n   * @param {Object} params\n   */\n  function Menu(el) {\n    var _this;\n\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Menu);\n\n    params.elRequired = true;\n\n    if (!(_this = _possibleConstructorReturn(this, _BaseComponent.call(this, el, params)), _this)) {\n      return _possibleConstructorReturn(_this);\n    }\n\n    _this._bindEventListenerCallbacks();\n    _this._addEventListeners();\n    _this._checkAnimation();\n    return _possibleConstructorReturn(_this);\n  }\n\n  /**\n   * Store a reference to the tabs list, each tab and each panel.\n   * Set which tab is active, or use the first.\n   * @param {Element} el\n   */\n\n\n  Menu.prototype._cacheElements = function _cacheElements(el) {\n    this.el = el;\n    this.toggleEl = this.el.querySelector('.spark-menu__toggle');\n  };\n\n  /**\n   * Create bound versions of event listener callbacks and store them.\n   * Otherwise we can't unbind from these events later because the\n   * function signatures won't match.\n   */\n\n\n  Menu.prototype._bindEventListenerCallbacks = function _bindEventListenerCallbacks() {\n    this._onClickBound = this._onClick.bind(this);\n    this._onFocusBound = this._onFocus.bind(this);\n    this._onBlurBound = this._onBlur.bind(this);\n    this._onKeydownBound = this._onKeydown.bind(this);\n  };\n\n  /**\n   * Add event listeners for DOM events.\n   */\n\n\n  Menu.prototype._addEventListeners = function _addEventListeners() {\n    this.el.addEventListener('click', this._onClickBound);\n    this.el.addEventListener('focus', this._onFocusBound, true);\n    this.el.addEventListener('blur', this._onBlurBound, true);\n    this.el.addEventListener('keydown', this._onKeydownBound);\n  };\n\n  /**\n   * Remove event listeners for DOM events..\n   */\n\n\n  Menu.prototype._removeEventListeners = function _removeEventListeners() {\n    this.el.removeEventListener('click', this._onClickBound);\n    this.el.removeEventListener('focus', this._onFocusBound);\n    this.el.removeEventListener('blur', this._onBlurBound);\n    this.el.removeEventListener('keydown', this._onKeydownBound);\n  };\n\n  /**\n   * Toggle the open state of an item.\n   * @param {Element} item\n   */\n\n\n  Menu.prototype._toggleItem = function _toggleItem(item) {\n\n    if ((0, _hasClass2.default)(item, 'open')) {\n      this._closeItem(item);\n    } else {\n      this._openItem(item);\n    }\n  };\n\n  /**\n   * Toggle aria-checked state of the Expand/Collapse toggle carets\n   * @param {Element} item\n   */\n\n\n  Menu.prototype._toggleAriaCheckedState = function _toggleAriaCheckedState(item) {\n    if (item.hasAttribute('aria-checked')) {\n      var ariaState = item.getAttribute('aria-checked') === 'true';\n      item.setAttribute('aria-checked', String(!ariaState));\n    }\n  };\n\n  /**\n   * Check for a nested list and create the wrappers needed\n   * for animating the lists\n   *\n   */\n\n\n  Menu.prototype._checkAnimation = function _checkAnimation() {\n    if (this.el.querySelector('.spark-menu__list-next')) {\n      this.cachedList = this.cachedList || [];\n      this._createMenuAnimationWrapper();\n      this._animateListChange();\n    }\n  };\n\n  /**\n   * Create wrapper class to help with animation of sliding lists\n   *\n   */\n\n\n  Menu.prototype._createMenuAnimationWrapper = function _createMenuAnimationWrapper() {\n    if (this.wrapperEl) {\n      return;\n    }\n\n    var wrapperEl = document.createElement('div');\n    (0, _addClass2.default)(wrapperEl, 'spark-menu__animation-wrapper');\n    (0, _wrapElement2.default)(this.el.querySelector('.spark-menu__list'), wrapperEl);\n    this.wrapperEl = wrapperEl;\n  };\n\n  /**\n   * Animate the position of the animation wrapper. Optionally, do\n   * so immediately without waiting for an animation.\n   * @param {Boolean} noAnimate\n   */\n\n\n  Menu.prototype._animateListChange = function _animateListChange(noAnimate) {\n\n    if (noAnimate) {\n      (0, _addClass2.default)(this.wrapperEl, 'no-animate');\n    }\n\n    this.wrapperEl.setAttribute('style', (0, _transform2.default)('translateX', '-' + this.cachedList.length * 100 + '%'));\n\n    if (noAnimate) {\n      setTimeout(function () {\n        (0, _removeClass2.default)(this.wrapperEl, 'no-animate');\n      }.bind(this), 1);\n    }\n  };\n\n  /**\n   * Append list to menu element\n   * @param {Element} list\n   * @param {Boolean} noAnimate\n   */\n\n\n  Menu.prototype._appendList = function _appendList(item, noAnimate) {\n\n    // Create wrapper\n    this._createMenuAnimationWrapper();\n\n    var newList = item.cloneNode(true);\n    (0, _addClass2.default)(newList, 'nestedList');\n    newList.setAttribute('data-nested-list-id', newList.getAttribute('id'));\n    newList.removeAttribute('id');\n\n    if (this.wrapperEl) {\n      // Add child node to wrapper\n      this.wrapperEl.appendChild(newList);\n      // Add to cached Array to keep track of all added lists\n      this.cachedList.push(newList);\n      // Slide navigation\n      this._animateListChange(noAnimate);\n    }\n  };\n\n  /**\n   * Remove list to nav\n   *\n   */\n\n\n  Menu.prototype._removeLastList = function _removeLastList() {\n    // If there are any items to remove\n    if (this.cachedList.length) {\n      // Retrieve last item from list\n      var removeElement = this.cachedList.pop();\n      if (this.wrapperEl) {\n        // Slide navigation\n        this._animateListChange();\n      }\n      window.setTimeout(function () {\n        // Remove itself from DOM\n        removeElement.parentNode.removeChild(removeElement);\n      }, 250);\n    }\n  };\n\n  /**\n   * Remove all lists from panel menu\n   *\n   */\n\n\n  Menu.prototype._removeAllCachedLists = function _removeAllCachedLists() {\n    if (this.cachedList) {\n      // If there are any items to remove\n      while (this.cachedList.length) {\n        // While there are still items, remove them\n        this._removeLastList();\n      }\n    }\n  };\n\n  /**\n   * Finds and returns the next nested list\n   * @param {Object} item\n   * @return {Object}\n   */\n\n\n  Menu.prototype._getNextList = function _getNextList(item) {\n    return item.querySelector('.spark-menu__list-next') ? document.querySelector(item.querySelector('.spark-menu__list-next').getAttribute('data-menu')) : null;\n  };\n\n  /**\n   * Open an item by animating it.\n   * @param {Object} item\n   */\n\n\n  Menu.prototype._openItem = function _openItem(item) {\n\n    // Item is already open\n    if ((0, _hasClass2.default)(item, 'open')) {\n      return;\n    }\n\n    (0, _height2.default)({\n      el: item,\n      toggleEl: '.spark-menu__list'\n    });\n\n    (0, _addClass2.default)(item, 'open');\n  };\n\n  /**\n   * Close an item by animating it shut.\n   * @param {Object} item\n   */\n\n\n  Menu.prototype._closeItem = function _closeItem(item) {\n\n    // Item is already closed\n    if (!(0, _hasClass2.default)(item, 'open')) {\n      return;\n    }\n\n    (0, _height2.default)({\n      el: item,\n      toggleEl: '.spark-menu__list',\n      toggleValue: 'none',\n      action: 'collapse'\n    });\n\n    (0, _removeClass2.default)(item, 'open');\n  };\n\n  /**\n   * Make an item active.\n   * @param {Element} item\n   */\n\n\n  Menu.prototype._activateItem = function _activateItem(item) {\n\n    // Item is already active\n    if ((0, _hasClass2.default)(item, 'active')) {\n      return;\n    }\n\n    // Deactivate any active items\n    var parents = (0, _getParents2.default)(item, '.spark-menu__list', this.el);\n    this._deactivateItems(parents[parents.length - 1]);\n    this._deactivateItemSiblings(item);\n\n    // Add the active class\n    (0, _addClass2.default)(item, 'active');\n\n    // If there is a parent that is also a list item, open it.\n    this._activateItemParents(item, this.el);\n  };\n\n  /**\n   * Activate parent items.\n   * @param {Element} el\n   * @param {Element} limitEl\n   */\n\n\n  Menu.prototype._activateItemParents = function _activateItemParents(el, limitEl) {\n\n    var parents = (0, _getParents2.default)(el.parentNode, '[class*=\"list-item\"]', limitEl);\n\n    var i = 0;\n    var len = parents.length;\n\n    // Add the active class\n    for (; i < len; i++) {\n      this._openItem(parents[i]);\n      (0, _addClass2.default)(parents[i], 'child-active');\n    }\n  };\n\n  /**\n   * Deactivate items.\n   * @param {Element} el\n   */\n\n\n  Menu.prototype._deactivateItems = function _deactivateItems(el) {\n\n    var actives = el.querySelectorAll('[class*=\"list-item\"].active');\n    var i = 0;\n    var len = actives.length;\n\n    // Remove the active class\n    for (; i < len; i++) {\n      (0, _removeClass2.default)(actives.item(i), 'active');\n    }\n  };\n\n  /**\n   * Deactivate siblings items.\n   * @param {Element} el\n   */\n\n\n  Menu.prototype._deactivateItemSiblings = function _deactivateItemSiblings(el) {\n\n    var actives = el.parentNode.querySelectorAll('[class*=\"list-item\"].child-active');\n    var i = 0;\n    var len = actives.length;\n\n    // Remove the active class\n    for (; i < len; i++) {\n      (0, _removeClass2.default)(actives[i], 'child-active');\n      (0, _removeClass2.default)(actives[i], 'open');\n    }\n  };\n\n  /**\n   * Open the parents of the active item.\n   *\n   */\n\n\n  Menu.prototype._openActiveParents = function _openActiveParents() {\n\n    var activeItem = this.el.querySelector('.active');\n    if (activeItem) {\n      var parentItems = (0, _getParents2.default)(activeItem, '.spark-menu__list-item', this.el);\n      var itemLinks;\n      var nextList;\n\n      for (var i = parentItems.length - 1; i >= 0; i--) {\n        itemLinks = (0, _getChild2.default)(parentItems[i], '.spark-menu__list-links');\n        if (itemLinks && itemLinks.querySelector('.spark-menu__list-next')) {\n          nextList = this._getNextList(parentItems[i]);\n          if (nextList && !this._cachedListContainsID(nextList.getAttribute('id'))) {\n            this._appendList(nextList, true);\n          }\n        } else {\n          (0, _addClass2.default)(parentItems[i], 'open');\n        }\n      }\n    }\n  };\n\n  /**\n   * Check if the cached list contains a certain ID\n   * @param {String} id\n   * @return {Boolean}\n   */\n\n\n  Menu.prototype._cachedListContainsID = function _cachedListContainsID(id) {\n    var i = this.cachedList.length;\n    while (i--) {\n      if (this.cachedList[i].getAttribute('data-nested-list-id') === id) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * When an item is clicked, make it active. Determine if the click was on an expand\n   * button and open the list if so.\n   * @todo: It should be possible to opt out of this behavior.\n   * @param {Object} e\n   */\n\n\n  Menu.prototype._onClick = function _onClick(e) {\n\n    // Don't make forms active\n    if ((0, _getParent2.default)(e.target, 'form', this.el)) {\n      return;\n    }\n\n    // Toggle the visibility of the menu?\n    var toggle = e.target === this.toggleEl || (0, _hasParent2.default)(e.target, this.toggleEl);\n    if (toggle) {\n      return (this.onToggle || noop)(e, this);\n    }\n\n    // Is there a parent to open and an item?\n    var open = (0, _getParent2.default)(e.target, '.spark-menu__list-expand', this.el);\n    var item = (0, _getParent2.default)(e.target, '.spark-menu__list-item', this.el);\n\n    // If we have no item or have been told to ignore the item\n    if (!item || (0, _getParent2.default)(e.target, '.spark-menu__ignore', this.el)) {\n      return;\n    }\n    if (open) {\n      this._toggleAriaCheckedState(open);\n      return this._toggleItem(item);\n    }\n\n    // Check if we have a valid item and we aren't inside the expanded header\n    if (item && !(0, _hasParent2.default)(e.target, document.querySelector('.spark-header--visible'))) {\n\n      var next = this._getNextList(item);\n\n      if (next && (0, _hasClass2.default)(e.target, 'spark-menu__list-next')) {\n        // Active item\n        this._activateItem(item);\n        this._appendList(next);\n        return;\n      }\n\n      var back = (0, _getParent2.default)(e.target, '.spark-menu__list-back', item);\n\n      if (back && (0, _hasClass2.default)(e.target, 'spark-menu__list-back')) {\n        this._removeLastList();\n        return;\n      }\n    }\n\n    // Active item\n    this._activateItem(item);\n  };\n\n  /**\n   * When the space or enter key is pressed on a focused item, make it active.\n   * Determine if the click was on an expand button or link and open the list if so.\n   * @todo: It should be possible to opt out of this behavior.\n   * @param {Object} e\n   */\n\n\n  Menu.prototype._onKeydown = function _onKeydown(e) {\n    var code = e.keyCode || e.which;\n\n    // Don't make forms active\n    if ((0, _getParent2.default)(e.target, 'form', this.el)) {\n      return;\n    }\n\n    // Toggle the visibility of the menu?\n    var toggle = e.target === this.toggleEl || (0, _hasParent2.default)(e.target, this.toggleEl);\n    if (toggle) {\n      return (this.onToggle || noop)(e, this);\n    }\n\n    // Is there a parent to open and an item?\n    var open = (0, _getParent2.default)(e.target, '.spark-menu__list-expand', this.el);\n    var item = (0, _getParent2.default)(e.target, '.spark-menu__list-item', this.el);\n\n    // If we have no item or have been told to ignore the item\n    if (!item || (0, _getParent2.default)(e.target, '.spark-menu__ignore', this.el)) {\n      return;\n    }\n    if (open) {\n      if (code === 32 || code === 13) {\n        e.preventDefault();\n        this._toggleAriaCheckedState(open);\n        return this._toggleItem(item);\n      }\n    }\n\n    // Check if we have a valid item and we aren't inside the expanded header\n    if (item && !(0, _hasParent2.default)(e.target, document.querySelector('.spark-header--visible'))) {\n\n      var next = this._getNextList(item);\n\n      if (next && (0, _hasClass2.default)(e.target, 'spark-menu__list-next')) {\n        if (code === 32 || code === 13) {\n          e.preventDefault();\n          // Active item\n          this._activateItem(item);\n          this._appendList(next);\n          return;\n        }\n      }\n\n      var back = (0, _getParent2.default)(e.target, '.spark-menu__list-back', item);\n\n      if (back && (0, _hasClass2.default)(e.target, 'spark-menu__list-back')) {\n        if (code === 32 || code === 13) {\n          e.preventDefault();\n\n          this._removeLastList();\n          return;\n        }\n      }\n    }\n\n    if (code === 32 || code === 13) {\n      this._activateItem(item);\n    }\n  };\n\n  /**\n   * Keep track of when items have focus.\n   * @param {Object} e\n   */\n\n\n  Menu.prototype._onFocus = function _onFocus(e) {\n\n    var parent = e.target;\n    var lastParent = parent;\n\n    while (parent) {\n      parent = (0, _getParent2.default)(lastParent.parentNode, '.spark-menu__list-item', this.el);\n      if (!parent || parent === lastParent) break;\n      (0, _addClass2.default)(parent, 'has-focus');\n      lastParent = parent;\n    }\n  };\n\n  /**\n   * Keep track of when items lose focus.\n   * @param {Object} e\n   */\n\n\n  Menu.prototype._onBlur = function _onBlur(e) {\n\n    var parent = e.target;\n    var lastParent = parent;\n\n    while (parent) {\n      parent = (0, _getParent2.default)(lastParent.parentNode, '.spark-menu__list-item', this.el);\n      if (!parent || parent === lastParent) break;\n      (0, _removeClass2.default)(parent, 'has-focus');\n      lastParent = parent;\n    }\n  };\n\n  return Menu;\n}(_base2.default);\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nMenu.prototype._whitelistedParams = ['onToggle'];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nMenu.prototype.defaults = {\n  cachedList: null,\n  el: null,\n  toggleEl: null,\n  wrapperEl: null,\n  onToggle: null,\n  _onClickBound: null,\n  _onFocusBound: null,\n  _onBlurBound: null,\n  _onKeydownBound: null\n};\n\nexports.default = Menu;\nmodule.exports = exports['default'];\n//# sourceMappingURL=menu.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _outerHeight = require('../dom/outer-height');\n\nvar _outerHeight2 = _interopRequireDefault(_outerHeight);\n\nvar _addClass = require('../dom/add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _removeClass = require('../dom/remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nvar _hasClass = require('../dom/has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _toggleClass = require('../dom/toggle-class');\n\nvar _toggleClass2 = _interopRequireDefault(_toggleClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar noop = function noop() {}; /**\n                                * # Animate Height\n                                * Animate the height of an element since we can't do this w/ pure CSS. Sigh.\n                                *\n                                * @example\n                                * animateHeight({\n                                *   el: ...,\n                                *   toggleEl: ...,\n                                *   // Optional params\n                                *   action: 'collapse'|'expand',\n                                *   heightAnimationClass: 'spark-animate-height',\n                                *   opacityAnimationClass: 'spark-animate-opacity',\n                                *   toggleProperty: 'display'|'overflow'|'visibility',\n                                *   toggleValue: 'block'|'none'|'visible'|'hidden',\n                                *   animationDuration: 250\n                                * });\n                                *\n                                * @module helpers/animation/height.js\n                                */\n\nvar runningAnimations = {\n  els: [],\n  completeCallbacks: []\n};\n\n/**\n * Get the inverse toggle value\n * @param  {String} property\n * @param  {String} originalValue\n * @return {String}\n */\nfunction getInverseToggleValue(el, property, originalValue) {\n\n  // Get the value to toggle to for the given property\n  switch (property) {\n    case 'overflow':\n    case 'visibility':\n      return originalValue === 'visible' ? 'hidden' : 'visible';\n    default:\n      return originalValue === 'block' || originalValue === 'inline-block' ? 'none' : 'block';\n  }\n}\n\n/**\n * When an animation is complete, clean up and run the callback.\n * @param  {Object} params\n */\nfunction onComplete(params) {\n\n  // Reset toggle el visibility\n  if (params.toggleClassName) {\n    (0, _toggleClass2.default)(params.el, params.toggleClassName, !params.collapse);\n  } else {\n    params.toggleEl.style[params.toggleProperty] = '';\n  }\n\n  // Remove the height property\n  params.el.style.height = '';\n  params.toggleEl.style.height = '';\n  params.toggleEl.style.marginBottom = '';\n  params.toggleEl.style.marginTop = '';\n\n  // Remove the spark-animate-height class so the transitions no longer apply\n  (0, _removeClass2.default)(params.el, params.heightAnimationClass);\n  (0, _removeClass2.default)(params.toggleEl, params.heightAnimationClass);\n\n  // Run the callback\n  params.onComplete();\n\n  // Remove the element and callback from their respective arrays\n  var runningIndex = runningAnimations.els.indexOf(params.el);\n  runningAnimations.els.splice(runningIndex, 1);\n  runningAnimations.completeCallbacks.splice(runningIndex, 1);\n}\n\n/**\n * @param {Object} params\n */\nfunction animateHeight(params) {\n\n  params = params || {};\n\n  var el = params.el;\n\n  if (!el) {\n    return;\n  }\n\n  var collapse = params.action && params.action === 'collapse';\n  var heightAnimationClass = params.heightAnimationClass || 'spark-animate-height';\n\n  // Allow for elements to be passed or selector strings\n  var toggleEl = typeof params.toggleEl === 'string' ? el.querySelector(params.toggleEl) : params.toggleEl;\n\n  // No element to be switching with toggling so we can't determine the desired height to animate to.\n  if (!toggleEl || (0, _hasClass2.default)(el, 'spark-no-animate')) {\n    return;\n  }\n\n  var toggleClassName = params.toggleClass;\n\n  // The style property to use when toggling visibility\n  var toggleProperty = params.toggleProperty || 'display';\n  var toggleStyles = window.getComputedStyle(toggleEl);\n  var originalToggleValue = toggleStyles[toggleProperty];\n  var toggleValue = params.toggleValue || getInverseToggleValue(toggleProperty, originalToggleValue);\n\n  // If we are already animating, stop now.\n  var runningIndex = runningAnimations.els.indexOf(el);\n  if (runningIndex !== -1) {\n\n    var completeCallback = runningAnimations.completeCallbacks[runningIndex];\n    if (completeCallback) {\n      clearTimeout(completeCallback);\n    }\n\n    onComplete({\n      el: el,\n      toggleEl: toggleEl,\n      onComplete: params.onComplete || noop,\n      collapse: collapse,\n      toggleProperty: toggleProperty,\n      toggleClassName: toggleClassName,\n      toggleValue: toggleValue,\n      heightAnimationClass: heightAnimationClass\n    });\n  }\n\n  // Store the current height\n  var originalHeight = (0, _outerHeight2.default)(el);\n\n  // Toggle the visible property\n  if (toggleClassName) {\n    (0, _toggleClass2.default)(el, toggleClassName, !collapse);\n  } else {\n    toggleEl.style[toggleProperty] = toggleValue;\n  }\n\n  // When measuring the size for a collapse, we have to wait a tic for it to be\n  // accurate. Not sure why. Ugh.\n  if (collapse) {\n    setTimeout(runAnimation, 0);\n  } else {\n    runAnimation();\n  }\n\n  function runAnimation() {\n\n    // Now that the toggle el is taking up space, get the new height which we will be animating to\n    var targetElHeight = (0, _outerHeight2.default)(el);\n\n    // We need to store the original and target toggle element heights. They differ depending on\n    // whether we are going to expand or collapse.\n    var targetToggleElHeight = void 0;\n    var originalToggleElHeight = void 0;\n\n    // If we are collapsing, reset the toggle style and set it when we're done. Set the height so\n    // that we can animate down to 0 or up to the target height.\n    if (collapse) {\n\n      if (toggleClassName) {\n        (0, _removeClass2.default)(el, toggleClassName);\n      } else {\n        toggleEl.style[toggleProperty] = originalToggleValue;\n      }\n\n      originalToggleElHeight = (0, _outerHeight2.default)(toggleEl, toggleStyles);\n      targetToggleElHeight = 0;\n    } else {\n      targetToggleElHeight = (0, _outerHeight2.default)(toggleEl, toggleStyles);\n      originalToggleElHeight = 0;\n    }\n\n    // Set the original height\n    el.style.height = originalHeight + 'px';\n    toggleEl.style.height = originalToggleElHeight + 'px';\n    toggleEl.style.marginBottom = '0px';\n    toggleEl.style.marginTop = '0px';\n\n    // Add the spark-animate-height class which will setup the transition-property and duration\n    (0, _addClass2.default)(el, heightAnimationClass);\n    (0, _addClass2.default)(toggleEl, heightAnimationClass);\n\n    runningAnimations.els.push(el);\n\n    // We need to wait a tick to toggle the height or else the animation class won't function\n    setTimeout(function () {\n\n      // Set the height to the target height\n      el.style.height = targetElHeight + 'px';\n      toggleEl.style.height = targetToggleElHeight + 'px';\n\n      // Remove inline styles after the animation is complete\n      runningAnimations.completeCallbacks.push(setTimeout(function () {\n        onComplete({\n          el: el,\n          toggleEl: toggleEl,\n          onComplete: params.onComplete || noop,\n          collapse: collapse,\n          toggleProperty: toggleProperty,\n          toggleClassName: toggleClassName,\n          toggleValue: toggleValue,\n          heightAnimationClass: heightAnimationClass\n        });\n      }, params.animationDuration !== undefined ? params.animationDuration : 201));\n    }, 0);\n  }\n}\n\nexports.default = animateHeight;\nmodule.exports = exports['default'];\n//# sourceMappingURL=height.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /**\n                                                                                                                                                                                                                                                                               * # Transform\n                                                                                                                                                                                                                                                                               * Apply a cross-browser transform style.\n                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                               * @example\n                                                                                                                                                                                                                                                                               * transform('translateX', '-100px');\n                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                               * @param {String} type\n                                                                                                                                                                                                                                                                               * @param {String} val\n                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                               * @module helpers/css/transform.js\n                                                                                                                                                                                                                                                                               */\n\nvar _each = require('../util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar prefixes = ['-webkit-', '-moz-', '-o-', '-ms-', ''];\n\nfunction transform(type, val) {\n\n  var str = '';\n\n  (0, _each2.default)(prefixes, function (p) {\n\n    if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {\n      str += p + 'transform: ';\n\n      for (var j in val) {\n        str += j + '(' + val[j] + '); ';\n      }\n    } else {\n      str += p + 'transform: ' + type + '(' + val + '); ';\n    }\n  });\n\n  return str;\n}\n\nexports.default = transform;\nmodule.exports = exports['default'];\n//# sourceMappingURL=transform.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * # Add Class\n * Add a class on an element.\n *\n * @param {Element|Array} el An element or array of elements to update.\n * @param {String} name\n * @return {Element}\n *\n * @module helpers/dom/add-class.js\n */\n\nvar ws = /\\s+/;\nvar cleanup = /\\s{2,}/g;\n\nfunction addClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) {\n      el.classList.add(name[0]);\n    }\n    return el;\n  }\n\n  var toAdd = [];\n  var i = 0;\n  var l = name.length;\n  var item = void 0;\n  var clsName = typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '';\n\n  // see if we have anything to add\n  for (; i < l; i++) {\n    item = name[i];\n    if (item && !(0, _hasClass2.default)(clsName, item)) {\n      toAdd.push(item);\n    }\n  }\n\n  if (toAdd.length) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = addClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=add-class.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Breakpoint Helpers\n * Find the active breakpoint.\n *\n * @param {Number} width\n *\n * @module helpers/dom/breakpoint.js\n */\n\n/**\n * Breakpoints being used in the CSS.\n * @type {Object}\n */\nvar defaultBreakpoints = {\n  xs: {\n    min: 0,\n    max: 543\n  },\n  sm: {\n    min: 544,\n    max: 795\n  },\n  md: {\n    min: 796,\n    max: 1047\n  },\n  lg: {\n    min: 1048,\n    max: 1799\n  },\n  xl: {\n    min: 1800,\n    max: Infinity\n  }\n};\n\nfunction get(width, breakpoints) {\n\n  breakpoints = breakpoints || defaultBreakpoints;\n\n  var i = void 0;\n\n  for (i in breakpoints) {\n    if (width >= breakpoints[i].min && width <= breakpoints[i].max) {\n      return i;\n    }\n  }\n}\n\nexports.get = get;\n//# sourceMappingURL=breakpoint.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * # Has Class\n * See if an element has a class.\n *\n * @param {Element|String} el\n * @param {String} name\n * @return {Boolean}\n *\n * @module helpers/dom/has-class.js\n */\nfunction hasClass(el, name) {\n  var cName = ((typeof el === 'undefined' ? 'undefined' : _typeof(el)) === 'object' ? el.className || el.getAttribute && el.getAttribute('class') || '' : el || '').replace(/[\\t\\r\\n\\f]/g, ' ');\n  return (' ' + cName + ' ').indexOf(' ' + name + ' ') !== -1;\n}\n\nexports.default = hasClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=has-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _each = require('../util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar props = ['marginTop', 'marginBottom', 'borderTop', 'borderBottom']; /**\n                                                                         * # Outer Height\n                                                                         * Get the outer height of an element (including margin and border)\n                                                                         *\n                                                                         * @param {Element} el\n                                                                         * @param {Object} styles Optional Already have computed styles? Pass them in.\n                                                                         *\n                                                                         * @example\n                                                                         * outerHeight(el, computedStyles);\n                                                                         *\n                                                                         * @module helpers/outer-height.js\n                                                                         */\n\n\nfunction outerHeight(el, styles) {\n\n  styles = styles || window.getComputedStyle(el);\n\n  var height = el.clientHeight;\n\n  (0, _each2.default)(props, function (prop) {\n    height += parseInt(styles[prop] || 0, 10);\n  });\n\n  return height;\n}\n\nexports.default = outerHeight;\nmodule.exports = exports['default'];\n//# sourceMappingURL=outer-height.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Parse DOM attributes\n * Given an element and an attribute name, parse that attribute\n * if it exists or return a default.\n *\n * @module helpers/dom/parse-attribute.js\n */\n\n/**\n * Get the boolean value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction boolean(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return val === 'true' || val === '' ? true : false;\n}\n\n/**\n * Get the numeric value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction number(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return parseInt(val, 10);\n}\n\n/**\n * Get the boolean value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction string(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return val;\n}\n\nexports.boolean = boolean;\nexports.number = number;\nexports.string = string;\n//# sourceMappingURL=parse-attribute.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ws = /\\s+/; /**\n                 * # Remove Class\n                 * Remove a class on an element.\n                 *\n                 * @param {Element|Array} el An element or array of elements to update.\n                 * @param {String} name\n                 * @return {Element}\n                 *\n                 * @module helpers/dom/remove-class.js\n                 */\n\nvar cleanup = /\\s{2,}/g;\n\nfunction removeClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) el.classList.remove(name[0]);\n    return el;\n  }\n\n  // store two copies\n  var clsName = ' ' + (typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '') + ' ';\n  var result = clsName;\n  var current = void 0;\n  var start = void 0;\n  for (var i = 0, l = name.length; i < l; i++) {\n    current = name[i];\n    start = current ? result.indexOf(' ' + current + ' ') : -1;\n    if (start !== -1) {\n      start += 1;\n      result = result.slice(0, start) + result.slice(start + current.length);\n    }\n  }\n\n  // only write if modified\n  if (clsName !== result) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)(result.replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)(result.replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = removeClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=remove-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _addClass = require('./add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _removeClass = require('./remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toggleClass(el, name, enable) {\n\n  if (!el) {\n    return;\n  }\n\n  // If we're passed an array, toggle the class on each.\n  if (el instanceof NodeList || el instanceof Array) {\n\n    for (var i = 0, len = el.length; i < len; i++) {\n      toggleClass(el[i], name, enable);\n    }\n\n    return;\n  }\n\n  var action = void 0;\n  if (enable !== undefined) {\n    enable = typeof enable === 'function' ? enable.call(null, el) : enable;\n    action = enable ? 'add' : 'remove';\n  } else {\n    action = (0, _hasClass2.default)(el, name) ? 'remove' : 'add';\n  }\n\n  return (action === 'add' ? _addClass2.default : _removeClass2.default)(el, name);\n} /**\n   * # Toggle Class\n   * Toggle a class on an element given a condition.\n   *\n   * @param {Element|Array} el An element or array of elements to update.\n   * @param {String} name\n   * @param {Boolean} enable\n   * @return {Element}\n   *\n   * @module  helpers/dom/toggle-class.js\n   */\n\nexports.default = toggleClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=toggle-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _each = require('../util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction appendChildren(el, children, empty) {\n\n  empty = empty === undefined ? false : empty;\n\n  if (empty) {\n    el.textContent = '';\n  }\n\n  var domList = children instanceof window.HTMLCollection;\n\n  if (domList) {\n    while (children.length) {\n      el.appendChild(children[0]);\n    }\n  } else {\n    (0, _each2.default)(children, function (c) {\n      if (c) {\n        el.appendChild(c);\n      }\n    });\n  }\n} /**\n   * # Append Children\n   * Append an array of children to a node.\n   *\n   * @param {Element} el\n   * @param {Array} children\n   * @param {Boolean} empty Empty the node before adding children?\n   *\n   * @module helpers/manipulation/append-children.js\n   */\n\nexports.default = appendChildren;\nmodule.exports = exports['default'];\n//# sourceMappingURL=append-children.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _each = require('../util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction insertBefore(el, beforeEl, children) {\n  (0, _each2.default)(children, function (c) {\n    el.insertBefore(c, beforeEl);\n  });\n} /**\n   * # Insert Before\n   * Insert an array of elements before a node.\n   *\n   * @param {Element} el\n   * @param {Element} beforeEl\n   * @param {Array} children\n   *\n   * @module helpers/manipulation/insert-before.js\n   */\n\nexports.default = insertBefore;\nmodule.exports = exports['default'];\n//# sourceMappingURL=insert-before.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Wrap Element\n * Wrap an element with another element.\n *\n * @param {Element} el\n * @param {Element} wrapper\n * @return {Element}\n *\n * @module helpers/manipulation/wrap-element.js\n */\nfunction wrapElement(el, wrapper) {\n\n  wrapper = wrapper || document.createElement('div');\n\n  if (el.nextSibling) {\n    el.parentNode.insertBefore(wrapper, el.nextSibling);\n  } else {\n    el.parentNode.appendChild(wrapper);\n  }\n\n  return wrapper.appendChild(el);\n}\n\nexports.default = wrapElement;\nmodule.exports = exports['default'];\n//# sourceMappingURL=wrap-element.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _matches = require('./matches');\n\nvar _matches2 = _interopRequireDefault(_matches);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getChild(el, query) {\n\n  var i = 0;\n  var len = el.children.length;\n\n  for (; i < len; i++) {\n    if ((0, _matches2.default)(el.children[i], query)) {\n      return el.children[i];\n    }\n  }\n\n  return null;\n} /**\n   * # Get Child\n   * Get a child that matches the selector.\n   *\n   * @param {Element} el\n   * @param {String} query\n   * @return {Element|Null}\n   *\n   * @module helpers/traversal/get-child.js\n   */\n\nexports.default = getChild;\nmodule.exports = exports['default'];\n//# sourceMappingURL=get-child.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Get Index\n * Get the index of an element in a nodelist.\n *\n * @param {NodeList} els\n * @param {Node} el\n * @return {Number}\n *\n * @module helpers/traversal/get-index.js\n */\nfunction getIndex(els, el) {\n  return Array.prototype.indexOf.call(els, el);\n}\n\nexports.default = getIndex;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=get-index.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _matches = require('./matches');\n\nvar _matches2 = _interopRequireDefault(_matches);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getParent(parent, query, limitEl) {\n\n  limitEl = limitEl instanceof Array ? limitEl : [limitEl || document.body];\n\n  while (parent) {\n\n    if ((0, _matches2.default)(parent, query)) {\n      return parent;\n    }\n\n    if (limitEl.indexOf(parent) !== -1) {\n      return false;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return false;\n} /**\n   * # Get Parent\n   * See if an element has another element for a parent.\n   *\n   * @param {Element} parent\n   * @param {String} query\n   * @param {Array|Element} limitEl The last element we should check.\n   * @return {Boolean|Element}\n   *\n   * @module helpers/traversal/get-parent.js\n   */\n\nexports.default = getParent;\nmodule.exports = exports['default'];\n//# sourceMappingURL=get-parent.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getParent = require('./get-parent');\n\nvar _getParent2 = _interopRequireDefault(_getParent);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getParents(parent, query, limitEl) {\n\n  var list = [];\n\n  while (parent = (0, _getParent2.default)(parent.parentNode, query, limitEl)) {\n    list.push(parent);\n  }\n\n  return list;\n} /**\n   * # Get Parents\n   * See if an element has parents which match a query.\n   *\n   * @param {Element} parent\n   * @param {String} query\n   * @param {Element} limitEl The last element we should check.\n   * @return {Boolean|Array}\n   *\n   * @module helpers/traversal/get-parents.js\n   */\n\nexports.default = getParents;\nmodule.exports = exports['default'];\n//# sourceMappingURL=get-parents.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Has Parent\n * See if an element has another element for a parent.\n *\n * @param {Element} child\n * @param {Element} possibleParent\n * @return {Boolean}\n *\n * @module helpers/traversal/has-parent.js\n */\nfunction hasParent(child, possibleParent) {\n\n  var parent = child.parentNode;\n\n  while (parent) {\n\n    if (parent === possibleParent) {\n      return true;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return false;\n}\n\nexports.default = hasParent;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=has-parent.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Matches\n * See if an element matches a query selector.\n *\n * @param {Element} el\n * @param {String} query\n * @return {Boolean}\n *\n * @module helpers/traversal/matches.js\n */\nvar vendorMatch = typeof Element !== 'undefined' && (Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector);\n\nfunction matches(el, query) {\n\n  if (vendorMatch) return vendorMatch.call(el, query);\n\n  var nodes = el.parentNode ? el.parentNode.querySelectorAll(query) : [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i] === el) return true;\n  }\n\n  return false;\n}\n\nexports.default = matches;\nmodule.exports = exports['default'];\n//# sourceMappingURL=matches.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Each\n * Apply a callback function to a list of any kind: Array, NodeList, HTMLCollection or Object.\n *\n * @param {Array|NodeList|HTMLCollection|Object} list\n * @param {Function} cb\n *\n * @example\n * each([], callback);\n * each(el.children, callback);\n * each(el.childNodes, callback);\n * each({}, callback);\n *\n * @module helpers/util/each.js\n */\nfunction each(list, cb) {\n\n  if (!list) {\n    return;\n  }\n\n  if (typeof cb !== 'function') {\n    throw new Error('Cannot invoke `each` without a callback!');\n  }\n\n  var i = 0;\n  var len = list.length;\n\n  // Object\n  if (len === undefined) {\n    for (i in list) {\n      if (i !== 'prototype' && list.hasOwnProperty(i)) {\n        cb(i, list[i]);\n      }\n    }\n  }\n  // Array-like\n  else {\n      for (; i < len; i++) {\n        cb(list[i]);\n      }\n    }\n}\n\nexports.default = each;\nmodule.exports = exports['default'];\n//# sourceMappingURL=each.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Trim\n * Trim whitespace on a string.\n *\n * @param {String} str\n *\n * @module helpers/util/trim.js\n */\n\nvar trimRE = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\nfunction trim(str) {\n  return str.replace(trimRE, '');\n}\n\nexports.default = trim;\nmodule.exports = exports['default'];\n//# sourceMappingURL=trim.js.map\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9kaXN0L2NvbXBvbmVudHMvYmFzZS5qcyIsImpzL2Rpc3QvY29tcG9uZW50cy9oZWFkZXIuanMiLCJqcy9kaXN0L2NvbXBvbmVudHMvbWVudS5qcyIsImpzL2Rpc3QvaGVscGVycy9hbmltYXRpb24vaGVpZ2h0LmpzIiwianMvZGlzdC9oZWxwZXJzL2Nzcy90cmFuc2Zvcm0uanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL2FkZC1jbGFzcy5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vYnJlYWtwb2ludC5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vaGFzLWNsYXNzLmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS9vdXRlci1oZWlnaHQuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL3BhcnNlLWF0dHJpYnV0ZS5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vcmVtb3ZlLWNsYXNzLmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS90b2dnbGUtY2xhc3MuanMiLCJqcy9kaXN0L2hlbHBlcnMvbWFuaXB1bGF0aW9uL2FwcGVuZC1jaGlsZHJlbi5qcyIsImpzL2Rpc3QvaGVscGVycy9tYW5pcHVsYXRpb24vaW5zZXJ0LWJlZm9yZS5qcyIsImpzL2Rpc3QvaGVscGVycy9tYW5pcHVsYXRpb24vd3JhcC1lbGVtZW50LmpzIiwianMvZGlzdC9oZWxwZXJzL3RyYXZlcnNhbC9nZXQtY2hpbGQuanMiLCJqcy9kaXN0L2hlbHBlcnMvdHJhdmVyc2FsL2dldC1pbmRleC5qcyIsImpzL2Rpc3QvaGVscGVycy90cmF2ZXJzYWwvZ2V0LXBhcmVudC5qcyIsImpzL2Rpc3QvaGVscGVycy90cmF2ZXJzYWwvZ2V0LXBhcmVudHMuanMiLCJqcy9kaXN0L2hlbHBlcnMvdHJhdmVyc2FsL2hhcy1wYXJlbnQuanMiLCJqcy9kaXN0L2hlbHBlcnMvdHJhdmVyc2FsL21hdGNoZXMuanMiLCJqcy9kaXN0L2hlbHBlcnMvdXRpbC9lYWNoLmpzIiwianMvZGlzdC9oZWxwZXJzL3V0aWwvdHJpbS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeHhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfXJldHVybiBlfSkoKSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9lYWNoID0gcmVxdWlyZSgnLi4vaGVscGVycy91dGlsL2VhY2gnKTtcblxudmFyIF9lYWNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfSAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAjIEJhc2UgQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGhlIGJhc2UgY2xhc3MgZm9yIFNwYXJrIEpTIGNvbXBvbmVudHMuIFRoaXMgY2xhc3Mgc2hvdWxkIG5ldmVyIGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgY29tcG9uZW50cy9iYXNlLmpzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG52YXIgQmFzZSA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogU2V0IHBhcmFtZXRlcnMgYW5kIGNhY2hlIGVsZW1lbnRzLlxuICAgKi9cbiAgZnVuY3Rpb24gQmFzZShlbCkge1xuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2UpO1xuXG4gICAgaWYgKHBhcmFtcy5lbFJlcXVpcmVkICYmICFlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2V0UGFyYW1zKHRoaXMuZGVmYXVsdHMgfHwge30sIHRydWUpO1xuICAgIHRoaXMuc2V0UGFyYW1zKHBhcmFtcyk7XG4gICAgKHRoaXMuX2NhY2hlRWxlbWVudHMgfHwgbm9vcCkuY2FsbCh0aGlzLCBlbCwgcGFyYW1zKTtcbiAgICAodGhpcy5fcGFyc2VQYXJhbXMgfHwgbm9vcCkuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGNvbXBvbmVudCBmcm9tIHRoZSBET00gYW5kIHByZXBhcmUgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiBieSBkZXJlZmVyZW5jaW5nIHZhbHVlcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBsZWF2ZUVsZW1lbnQgTGVhdmUgdGhlIGVsZW1lbnQgaW50YWN0LlxuICAgKi9cblxuXG4gIEJhc2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShsZWF2ZUVsZW1lbnQpIHtcblxuICAgIGlmICh0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycykge1xuICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBpZiAoIWxlYXZlRWxlbWVudCAmJiB0aGlzLmVsICYmIHRoaXMuZWwucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgIH1cblxuICAgIHRoaXMudW5zZXRQYXJhbXModGhpcy5kZWZhdWx0cyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjb21wb25lbnQgdG8gdXNlIGEgbmV3IGVsZW1lbnQgb3IgcmVwYXJzZSBmcm9tXG4gICAqIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIE9wdGlvbmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgT3B0aW9uYWxcbiAgICovXG5cblxuICBCYXNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZWwpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuXG4gICAgaWYgKHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgICh0aGlzLl9jYWNoZUVsZW1lbnRzIHx8IG5vb3ApLmNhbGwodGhpcywgZWwgfHwgdGhpcy5lbCwgcGFyYW1zKTtcbiAgICAodGhpcy5fcGFyc2VQYXJhbXMgfHwgbm9vcCkuY2FsbCh0aGlzKTtcblxuICAgIGlmICh0aGlzLl9hZGRFdmVudExpc3RlbmVycykge1xuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgaGFzaCBvZiBwYXJhbWV0ZXJzIGlmIHRoZXkncmUgd2hpdGVsaXN0ZWQgb3Igd2UncmUgdG9sZCB0byBmb3JjZSB0aGUgc2V0LlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gc2V0IGluaXRpYWwgdmFsdWVzIGFzIHdlbGwgYXMgc2V0IHBhc3NlZCBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2UgRm9yY2Ugc2V0dGluZyBldmVuIGlmIHRoZSBwYXJhbSBpcyBub3Qgd2hpdGVsaXN0ZWQuXG4gICAqL1xuXG5cbiAgQmFzZS5wcm90b3R5cGUuc2V0UGFyYW1zID0gZnVuY3Rpb24gc2V0UGFyYW1zKHBhcmFtcywgZm9yY2UpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgKDAsIF9lYWNoMi5kZWZhdWx0KShwYXJhbXMsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICBpZiAoX3RoaXMuX3doaXRlbGlzdGVkUGFyYW1zLmluZGV4T2YoaykgIT09IC0xIHx8IGZvcmNlKSB7XG4gICAgICAgIF90aGlzW2tdID0gdjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbnNldCBhbGwgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGtleXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFRoZSBvYmplY3QgdG8gdW5zZXQgdGhlIHBhcmFtcyBmcm9tLiBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAqL1xuXG5cbiAgQmFzZS5wcm90b3R5cGUudW5zZXRQYXJhbXMgPSBmdW5jdGlvbiB1bnNldFBhcmFtcyhrZXlzLCBzY29wZSkge1xuXG4gICAga2V5cyA9IGtleXMgaW5zdGFuY2VvZiBBcnJheSA/IGtleXMgOiBPYmplY3Qua2V5cyhrZXlzKTtcbiAgICBzY29wZSA9IHNjb3BlIHx8IHRoaXM7XG4gICAgKDAsIF9lYWNoMi5kZWZhdWx0KShrZXlzLCBmdW5jdGlvbiAoaykge1xuICAgICAgZGVsZXRlIHNjb3BlW2tdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIEJhc2U7XG59KCk7XG5cbi8qKlxuICogV2hpdGVsaXN0ZWQgcGFyYW1ldGVycyB3aGljaCBjYW4gYmUgc2V0IG9uIGNvbnN0cnVjdGlvbi5cbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuXG5cbkJhc2UucHJvdG90eXBlLl93aGl0ZWxpc3RlZFBhcmFtcyA9IFtdO1xuXG4vKipcbiAqIERlZmF1bHQgdmFsdWVzIGZvciBpbnRlcm5hbCBwcm9wZXJ0aWVzIHdlIHdpbGwgYmUgc2V0dGluZy5cbiAqIFRoZXNlIGFyZSBzZXQgb24gZWFjaCBjb25zdHJ1Y3Rpb24gc28gd2UgZG9uJ3QgbGVhayBwcm9wZXJ0aWVzXG4gKiBpbnRvIHRoZSBwcm90b3R5cGUgY2hhaW4uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5CYXNlLnByb3RvdHlwZS5kZWZhdWx0cyA9IHt9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2Jhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcblxudmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xuXG52YXIgX21lbnUgPSByZXF1aXJlKCcuL21lbnUnKTtcblxudmFyIF9tZW51MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lbnUpO1xuXG52YXIgX3RvZ2dsZUNsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vdG9nZ2xlLWNsYXNzJyk7XG5cbnZhciBfdG9nZ2xlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9nZ2xlQ2xhc3MpO1xuXG52YXIgX2FkZENsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vYWRkLWNsYXNzJyk7XG5cbnZhciBfYWRkQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWRkQ2xhc3MpO1xuXG52YXIgX3JlbW92ZUNsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vcmVtb3ZlLWNsYXNzJyk7XG5cbnZhciBfcmVtb3ZlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVtb3ZlQ2xhc3MpO1xuXG52YXIgX2hhc0NsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vaGFzLWNsYXNzJyk7XG5cbnZhciBfaGFzQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzQ2xhc3MpO1xuXG52YXIgX2dldEluZGV4ID0gcmVxdWlyZSgnLi4vaGVscGVycy90cmF2ZXJzYWwvZ2V0LWluZGV4Jyk7XG5cbnZhciBfZ2V0SW5kZXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SW5kZXgpO1xuXG52YXIgX2FwcGVuZENoaWxkcmVuID0gcmVxdWlyZSgnLi4vaGVscGVycy9tYW5pcHVsYXRpb24vYXBwZW5kLWNoaWxkcmVuJyk7XG5cbnZhciBfYXBwZW5kQ2hpbGRyZW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXBwZW5kQ2hpbGRyZW4pO1xuXG52YXIgX2luc2VydEJlZm9yZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvbWFuaXB1bGF0aW9uL2luc2VydC1iZWZvcmUnKTtcblxudmFyIF9pbnNlcnRCZWZvcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5zZXJ0QmVmb3JlKTtcblxudmFyIF9icmVha3BvaW50ID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vYnJlYWtwb2ludCcpO1xuXG52YXIgX2dldFBhcmVudCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdHJhdmVyc2FsL2dldC1wYXJlbnQnKTtcblxudmFyIF9nZXRQYXJlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UGFyZW50KTtcblxudmFyIF9nZXRQYXJlbnRzID0gcmVxdWlyZSgnLi4vaGVscGVycy90cmF2ZXJzYWwvZ2V0LXBhcmVudHMnKTtcblxudmFyIF9nZXRQYXJlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFBhcmVudHMpO1xuXG52YXIgX3BhcnNlQXR0cmlidXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vcGFyc2UtYXR0cmlidXRlJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAjIEhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQSBwcmltYXJ5IHBhZ2UgaGVhZGVyL25hdmlnYXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG5ldyBIZWFkZXIoZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgLy8gT3B0aW9uYWwuIEFsdGVybmF0ZSBicmVha3BvaW50IHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgYnJlYWtwb2ludHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIHhzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIG1pbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgbWF4OiA2MzlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgY29tcG9uZW50cy9oZWFkZXIuanNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5cbnZhciBIZWFkZXIgPSBmdW5jdGlvbiAoX0Jhc2VDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEhlYWRlciwgX0Jhc2VDb21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBIZWFkZXIgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgKi9cbiAgZnVuY3Rpb24gSGVhZGVyKGVsKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGVhZGVyKTtcblxuICAgIHBhcmFtcy5lbFJlcXVpcmVkID0gdHJ1ZTtcblxuICAgIGlmICghKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Jhc2VDb21wb25lbnQuY2FsbCh0aGlzLCBlbCwgcGFyYW1zKSksIF90aGlzKSkge1xuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgICB9XG5cbiAgICBfdGhpcy5fYmluZEV2ZW50TGlzdGVuZXJDYWxsYmFja3MoKTtcbiAgICBfdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICBfdGhpcy5fZGV0ZXJtaW5lSW5pdGlhbFNpemUoKTtcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZWxlbWVudHMgdXNlZC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBPcHRpb25hbFxuICAgKi9cblxuXG4gIEhlYWRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGVsKSB7XG5cbiAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuX3JlbW92ZVBsYWNlaG9sZGVyKCk7XG4gICAgdGhpcy5fY2FjaGVFbGVtZW50cyhlbCB8fCB0aGlzLmVsKTtcbiAgICB0aGlzLl9wYXJzZVBhcmFtcygpO1xuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fZW5zdXJlQWN0aXZlQXRNb3JlU3dhcEluZGV4KCk7XG4gICAgdGhpcy5jaGVja0ZpeGVkKCk7XG5cbiAgICAvLyBSdW4gb24gdGhlIG5leHQgZnJhbWUgc28gc2l6ZXMgaGF2ZSB1cGRhdGVkXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9kZXRlcm1pbmVNZW51U2l6ZSgpO1xuICAgIH0uYmluZCh0aGlzKSwgMCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgb2Ygd2Ugc2hvdWxkIGJlIGZpeGVkLlxuICAgKi9cblxuXG4gIEhlYWRlci5wcm90b3R5cGUuY2hlY2tGaXhlZCA9IGZ1bmN0aW9uIGNoZWNrRml4ZWQoKSB7XG5cbiAgICBpZiAoIXRoaXMuZml4ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgIT09IHVuZGVmaW5lZCA/IHdpbmRvdy5wYWdlWU9mZnNldCA6IHdpbmRvdy5kb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcbiAgICB2YXIgaXNDb25kZW5zZWQgPSBzY3JvbGxUb3AgPiB0aGlzLmZpeGVkRGlzdGFuY2U7XG4gICAgKDAsIF90b2dnbGVDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ3NwYXJrLWhlYWRlci0tY29uZGVuc2VkJywgaXNDb25kZW5zZWQpO1xuICAgICgwLCBfdG9nZ2xlQ2xhc3MyLmRlZmF1bHQpKGRvY3VtZW50LmJvZHksICdzcGFyay1oZWFkZXItY29uZGVuc2VkJywgaXNDb25kZW5zZWQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSB0YWJzIGxpc3QsIGVhY2ggdGFiIGFuZCBlYWNoIHBhbmVsLlxuICAgKiBTZXQgd2hpY2ggdGFiIGlzIGFjdGl2ZSwgb3IgdXNlIHRoZSBmaXJzdC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKi9cblxuXG4gIEhlYWRlci5wcm90b3R5cGUuX2NhY2hlRWxlbWVudHMgPSBmdW5jdGlvbiBfY2FjaGVFbGVtZW50cyhlbCkge1xuXG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMubmF2RWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1oZWFkZXJfX25hdicpO1xuICAgIHRoaXMubWVudUVsID0gdGhpcy5uYXZFbCAmJiB0aGlzLm5hdkVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1oZWFkZXJfX21lbnUnKTtcbiAgICB0aGlzLmxpc3RFbCA9IHRoaXMubWVudUVsICYmIHRoaXMubWVudUVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1oZWFkZXJfX2xpc3QnKTtcbiAgICB0aGlzLnRvZ2dsZUVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuc3BhcmstaGVhZGVyX190b2dnbGUnKTtcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgbWVudSBjb21wb25lbnRcbiAgICBpZiAodGhpcy5tZW51RWwpIHtcbiAgICAgIHRoaXMubWVudSA9IG5ldyBfbWVudTIuZGVmYXVsdCh0aGlzLm1lbnVFbCwge1xuICAgICAgICBvblRvZ2dsZTogdGhpcy5fb25Ub2dnbGVDbGlja0JvdW5kID0gdGhpcy5fb25Ub2dnbGVDbGljay5iaW5kKHRoaXMpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBUaGUgaXRlbXMgaW4gdGhlIGxpc3QgbmVlZCB0byBzaG93L2hpZGUgYmFzZWQgb24gdGhlIHdpZHRoIG9mIHRoZSBjb250YWluZXIuXG4gICAgLy8gQ2FjaGUgdGhlc2UgaXRlbXMgc28gd2UgY2FuIG1hbmlwdWxhdGUgdGhlaXIgZGlzcGxheSBpbmRlcGVuZGVudCBvZiB3aGF0IGlzXG4gICAgLy8gY3VycmVudGx5IGluIHRoZSBET00uIEFsc28sIGNyZWF0ZSB0aGUgXCJNb3JlXCIgZHJvcGRvd24gd2hpY2ggd2lsbCBiZSBzaG93blxuICAgIC8vIGFuZCBoaWRkZW4gYmFzZWQgb24gYXZhaWxhYmlsZSBzcGFjZS5cbiAgICBpZiAodGhpcy5saXN0RWwgJiYgdGhpcy5saXN0RWwuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB0aGlzLmxpc3RFbHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmxpc3RFbC5jaGlsZHJlbiwgMCk7XG4gICAgICB0aGlzLl9jcmVhdGVMaXN0TW9yZSgpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIGNsb25lIG9mIHRoZSBoZWFkZXIgd2hpY2ggd2lsbCBOT1QgYmUgYWZmZWN0ZWQgYnkgY2hhbmdlcyBpbiBicmVha3BvaW50LlxuICAgIC8vIFRoaXMgbGV0cyB1cyBjb250aW51ZSB0byBtZWFzdXJlIGhvdyBtYW55IGxpc3QgZWxlbWVudHMgd2lsbCBmaXQuIFNpbmNlIHdlIGdvIHRvIHRoZVxuICAgIC8vIFwiY29uZGVuc2VkXCIgdmlldyB3aGVuIHdlIGFyZSBhdCB0aGUgc20veHMgYnJlYWtwb2ludCBPUiBvbmx5IG9uZSBpdGVtIHdpbGwgZml0IGluIHRoZSBuYXYsXG4gICAgLy8gd2UgY2FuJ3QgcmVseSBvbiBicmVha3BvaW50cyBhbG9uZSB0byBkZXRlcm1pbmUgd2hhdCB0byBzaG93LiBXaXRob3V0IGEgY2xvbmVkIHBsYWNlaG9sZGVyXG4gICAgLy8gaXQgaXMgaW1wb3NzaWJsZSB0byBjb250aW51ZSB0byBtZWFzdXJlIHRoZSBhdmFpbGFibGUgc3BhY2Ugb25jZSB3ZSBzaG93IHRoZSBjb25kZW5zZWQgdmlldy5cbiAgICBpZiAodGhpcy5saXN0RWwpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBsYWNlaG9sZGVyKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBwYXJhbWV0ZXJzIGZyb20gdGhlIGVsZW1lbnRzLlxuICAgKi9cblxuXG4gIEhlYWRlci5wcm90b3R5cGUuX3BhcnNlUGFyYW1zID0gZnVuY3Rpb24gX3BhcnNlUGFyYW1zKCkge1xuICAgIHRoaXMuZml4ZWQgPSB0aGlzLmZpeGVkICE9PSBudWxsID8gdGhpcy5maXhlZCA6ICgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKHRoaXMuZWwsICdzcGFyay1oZWFkZXItLWZpeGVkJyk7XG4gICAgdGhpcy5maXhlZERpc3RhbmNlID0gdGhpcy5maXhlZERpc3RhbmNlICE9PSBudWxsID8gdGhpcy5maXhlZERpc3RhbmNlIDogKDAsIF9wYXJzZUF0dHJpYnV0ZS5udW1iZXIpKHRoaXMuZWwsICdkYXRhLWZpeGVkLWRpc3RhbmNlJywgMTApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYm91bmQgdmVyc2lvbnMgb2YgZXZlbnQgbGlzdGVuZXIgY2FsbGJhY2tzIGFuZCBzdG9yZSB0aGVtLlxuICAgKiBPdGhlcndpc2Ugd2UgY2FuJ3QgdW5iaW5kIGZyb20gdGhlc2UgZXZlbnRzIGxhdGVyIGJlY2F1c2UgdGhlXG4gICAqIGZ1bmN0aW9uIHNpZ25hdHVyZXMgd29uJ3QgbWF0Y2guXG4gICAqL1xuXG5cbiAgSGVhZGVyLnByb3RvdHlwZS5fYmluZEV2ZW50TGlzdGVuZXJDYWxsYmFja3MgPSBmdW5jdGlvbiBfYmluZEV2ZW50TGlzdGVuZXJDYWxsYmFja3MoKSB7XG5cbiAgICB0aGlzLl9kZXRlcm1pbmVJbml0aWFsU2l6ZUJvdW5kID0gdGhpcy5fZGV0ZXJtaW5lSW5pdGlhbFNpemUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblJlc2l6ZUJvdW5kID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblNjcm9sbEJvdW5kID0gdGhpcy5fb25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbk1vcmVDbGlja0JvdW5kID0gdGhpcy5fb25Nb3JlQ2xpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbk5hdkNsaWNrQm91bmQgPSB0aGlzLl9vbk5hdkNsaWNrLmJpbmQodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBldmVudCBsaXN0ZW5lcnMgZm9yIERPTSBldmVudHMuXG4gICAqL1xuXG5cbiAgSGVhZGVyLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG5cbiAgICBpZiAoIXRoaXMubGlzdEVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplQm91bmQpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMuX29uUmVzaXplQm91bmQpO1xuXG4gICAgaWYgKHRoaXMubGlzdE1vcmVFbCkge1xuICAgICAgdGhpcy5saXN0TW9yZUxpc3RFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uTW9yZUNsaWNrQm91bmQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRvZ2dsZUVsKSB7XG4gICAgICB0aGlzLnRvZ2dsZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25Ub2dnbGVDbGlja0JvdW5kKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5uYXZFbCkge1xuICAgICAgdGhpcy5uYXZFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uTmF2Q2xpY2tCb3VuZCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZml4ZWQpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbEJvdW5kKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgZm9yIERPTSBldmVudHMuLlxuICAgKi9cblxuXG4gIEhlYWRlci5wcm90b3R5cGUuX3JlbW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuXG4gICAgaWYgKCF0aGlzLmxpc3RFbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZUJvdW5kKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCB0aGlzLl9vblJlc2l6ZUJvdW5kKTtcblxuICAgIGlmICh0aGlzLmxpc3RNb3JlRWwpIHtcbiAgICAgIHRoaXMubGlzdE1vcmVMaXN0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbk1vcmVDbGlja0JvdW5kKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b2dnbGVFbCkge1xuICAgICAgdGhpcy50b2dnbGVFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uVG9nZ2xlQ2xpY2tCb3VuZCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmF2RWwpIHtcbiAgICAgIHRoaXMubmF2RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbk5hdkNsaWNrQm91bmQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpeGVkKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fb25TY3JvbGxCb3VuZCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgYnJlYWtwb2ludCBmb3IgdGhlIGhlYWRlci5cbiAgICovXG5cblxuICBIZWFkZXIucHJvdG90eXBlLl9nZXRDdXJyZW50QnJlYWtwb2ludCA9IGZ1bmN0aW9uIF9nZXRDdXJyZW50QnJlYWtwb2ludCgpIHtcbiAgICB0aGlzLmxhc3RCcmVha3BvaW50ID0gdGhpcy5jdXJyZW50QnJlYWtwb2ludDtcbiAgICB0aGlzLmN1cnJlbnRCcmVha3BvaW50ID0gKDAsIF9icmVha3BvaW50LmdldCkodGhpcy5lbC5jbGllbnRXaWR0aCwgdGhpcy5icmVha3BvaW50cyk7XG4gICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYnJlYWtwb2ludCcsIHRoaXMuY3VycmVudEJyZWFrcG9pbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwbGFjZWhvbGRlciBmb3IgdGhlIHdob2xlIGhlYWRlciBzbyB0aGF0IHdlIGNhbiBrZWVwIHRyYWNrXG4gICAqIG9mIHRoZSB3aWR0aCBvZiBlYWNoIGNoaWxkIGVsZW1lbnQgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIG9yIG5vdCB3ZSdyZVxuICAgKiBjb25kZW5zZWQuIENvbmRlbnNlZCBzdHlsZXMgZG8gbm90IGFwcGx5IHRvIGluc3RhbmNlcyBvZiB0aGUgZWxlbWVudFxuICAgKiB3aXRoIHRoZSBwbGFjZWhvbGRlciBjbGFzcy5cbiAgICovXG5cblxuICBIZWFkZXIucHJvdG90eXBlLl9jcmVhdGVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIF9jcmVhdGVQbGFjZWhvbGRlcigpIHtcblxuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuaW5uZXJIVE1MID0gdGhpcy5uYXZFbC5vdXRlckhUTUw7XG5cbiAgICB2YXIgZWwgPSBkaXYuY2hpbGRyZW5bMF07XG4gICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuXG4gICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkoZWwsICdzcGFyay1oZWFkZXJfX3BsYWNlaG9sZGVyJyk7XG5cbiAgICB0aGlzLmVsLmFwcGVuZENoaWxkKGVsKTtcblxuICAgIC8vIENhY2hlIHRoZSBjb21tb24gZWxlbWVudHNcbiAgICB0aGlzLnBsYWNlaG9sZGVyID0ge1xuICAgICAgZWw6IGVsLFxuICAgICAgbWVudUVsOiBlbC5xdWVyeVNlbGVjdG9yKCcuc3BhcmstaGVhZGVyX19tZW51JyksXG4gICAgICBsaXN0RWw6IGVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1oZWFkZXJfX2xpc3QnKVxuICAgIH07XG5cbiAgICAvLyBBZGQgYSBjb3B5IG9mIHRoZSBcIm1vcmVcIiBidXR0b24gdG8gdGhlIGxpc3Qgc28gd2UgYWx3YXlzIGtub3cgd2hhdCBzaXplIGl0IHdvdWxkIGJlXG4gICAgaWYgKHRoaXMubGlzdE1vcmVFbCkge1xuICAgICAgdGhpcy5wbGFjZWhvbGRlci5saXN0RWwuaW5uZXJIVE1MICs9IHRoaXMubGlzdE1vcmVFbC5vdXRlckhUTUw7XG4gICAgICB0aGlzLnBsYWNlaG9sZGVyLmxpc3RNb3JlRWwgPSB0aGlzLnBsYWNlaG9sZGVyLmxpc3RFbC5xdWVyeVNlbGVjdG9yKCcuc3BhcmstaGVhZGVyX19tb3JlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGlzYWJsZVBsYWNlaG9sZGVyTGlua1RhYihlbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgcGxhY2Vob2xkZXJcbiAgICovXG5cblxuICBIZWFkZXIucHJvdG90eXBlLl9yZW1vdmVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIF9yZW1vdmVQbGFjZWhvbGRlcigpIHtcblxuICAgIGlmICh0aGlzLnBsYWNlaG9sZGVyKSB7XG4gICAgICB0aGlzLnBsYWNlaG9sZGVyLmVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wbGFjZWhvbGRlci5lbCk7XG4gICAgICB0aGlzLnBsYWNlaG9sZGVyLm1lbnVFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucGxhY2Vob2xkZXIubWVudUVsKTtcbiAgICAgIHRoaXMucGxhY2Vob2xkZXIubGlzdEVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wbGFjZWhvbGRlci5saXN0RWwpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxpc3RNb3JlRWwpIHtcbiAgICAgIHRoaXMucGxhY2Vob2xkZXIubGlzdE1vcmVFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucGxhY2Vob2xkZXIubGlzdE1vcmVFbCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRhYmJpbmcgZm9yIGl0ZW1zIGluIHRoZSBwbGFjZWhvbGRlci5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKi9cblxuXG4gIEhlYWRlci5wcm90b3R5cGUuX2Rpc2FibGVQbGFjZWhvbGRlckxpbmtUYWIgPSBmdW5jdGlvbiBfZGlzYWJsZVBsYWNlaG9sZGVyTGlua1RhYihlbCkge1xuXG4gICAgLy8gU2V0IGEgbmVnYXRpdmUgdGFiIGluZGV4IG9uIGVhY2ggbGluayBpbiB0aGUgcGxhY2Vob2xkZXJcbiAgICB2YXIgbGlua3MgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCcuc3BhcmstbWVudV9fbGlzdC1saW5rLCAuc3BhcmstbWVudV9fbGlzdC1leHBhbmQnKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGxpbmtzLmxlbmd0aDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxpbmtzLml0ZW0oaSkuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIC0xKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgYSBuZWdhdGl2ZSB0YWIgaW5kZXggb24gZWFjaCBidXR0b24gaW4gdGhlIHBsYWNlaG9sZGVyXG4gICAgdmFyIGJ1dHRvbnMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCdidXR0b24nKTtcbiAgICB2YXIgayA9IDA7XG4gICAgbGVuID0gYnV0dG9ucy5sZW5ndGg7XG5cbiAgICBmb3IgKDsgayA8IGxlbjsgaysrKSB7XG4gICAgICBidXR0b25zLml0ZW0oaykuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIC0xKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHBsYWNlIHRvIHN0b3JlIG92ZXJmbG93IGl0ZW1zIG9mIHRoZSBsaXN0LlxuICAgKiBBbHNvIGFkZCB0aGlzIGl0ZW0gdG8gdGhlIHBsYWNlaG9sZGVyIGVsZW1lbnQgc28gd2UgYWx3YXlzIGtub3dcbiAgICogd2hpY2ggc2l6ZSBpdCB3b3VsZCBiZS5cbiAgICovXG5cblxuICBIZWFkZXIucHJvdG90eXBlLl9jcmVhdGVMaXN0TW9yZSA9IGZ1bmN0aW9uIF9jcmVhdGVMaXN0TW9yZSgpIHtcblxuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuaW5uZXJIVE1MID0gJzxsaT48YSBjbGFzcz1cInNwYXJrLW1lbnVfX2xpc3QtbGluayBzcGFyay1tZW51X19pZ25vcmVcIiB0YWJpbmRleD1cIjBcIiB0aXRsZT1cIk1vcmUgSXRlbXNcIj48aSBjbGFzcz1cInNwYXJrLWljb24tbWVudS1lbGxpcHNpcy1ob3Jpem9udGFsIHNwYXJrLWljb24tLWZpbGxcIj48L2k+PC9hPjx1bCBjbGFzcz1cInNwYXJrLW1lbnVfX2xpc3RcIj48L3VsPjwvbGk+JztcblxuICAgIHZhciBsaSA9IGRpdi5jaGlsZHJlblswXTtcbiAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KShsaSwgJ3NwYXJrLW1lbnVfX2xpc3QtaXRlbSBzcGFyay1oZWFkZXJfX21vcmUnKTtcblxuICAgIHRoaXMubGlzdE1vcmVFbCA9IGxpO1xuICAgIHRoaXMubGlzdE1vcmVMaXN0RWwgPSBsaS5xdWVyeVNlbGVjdG9yKCd1bCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIG1lbnUgc2l6ZS4uXG4gICAqL1xuXG5cbiAgSGVhZGVyLnByb3RvdHlwZS5fZGV0ZXJtaW5lSW5pdGlhbFNpemUgPSBmdW5jdGlvbiBfZGV0ZXJtaW5lSW5pdGlhbFNpemUoKSB7XG4gICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ3NwYXJrLWhlYWRlci0tdmlzaWJsZScpO1xuICAgIHRoaXMuX2Vuc3VyZUFjdGl2ZUF0TW9yZVN3YXBJbmRleCgpO1xuICAgIHRoaXMuX2RldGVybWluZU1lbnVTaXplKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBob3cgbWFueSBuYXYgaXRlbXMgY2FuIGZpdC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1N3YXAgT3B0aW9uYWwgSXMgdGhpcyBhIHN3YXBwaW5nIGV2ZW50PyBJZiBzbywgaWdub3JlIHJlZHVuZGFuY3kgY2hlY2tzLlxuICAgKi9cblxuXG4gIEhlYWRlci5wcm90b3R5cGUuX2RldGVybWluZU1lbnVTaXplID0gZnVuY3Rpb24gX2RldGVybWluZU1lbnVTaXplKGlzU3dhcCkge1xuXG4gICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgdy9vIHByaW1hcnkgbmF2LlxuICAgIGlmICghdGhpcy5saXN0RWxzIHx8ICF0aGlzLmxpc3RFbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgYXQgdGhlIFhTIG9yIFNNIGJyZWFrcG9pbnQsIGRvbid0IHdvcnJ5IGFib3V0IHRoaXMgc3R1ZmYuXG4gICAgaWYgKHRoaXMuX2lzTWVudUJyZWFrcG9pbnQoWyd4cycsICdzbSddKSkge1xuICAgICAgdGhpcy5fcmVtb3ZlTGlzdE1vcmUoKTtcbiAgICAgIHJldHVybiB0aGlzLl90b2dnbGVDb2xsYXBzZWQodHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBpdGVtcyB0byBzaG93IGFuZCBoaWRlXG4gICAgdmFyIGl0ZW1zID0gdGhpcy5fZ2V0SXRlbXNUb1Nob3dBbmRIaWRlKCk7XG5cbiAgICAvLyBBZGQgYSBjbGFzcyBzYXlpbmcgdGhhdCB0aGUgc2l6ZSBoYXMgYmVlbiBkZXRlcm1pbmVkLiBUaGlzIHJlbW92ZXMgdGhlIG92ZXJmbG93OmhpZGRlblxuICAgIC8vIHNvIHRoYXQgZHJvcGRvd25zIHdpbGwgYXBwZWFyLlxuICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKHRoaXMuZWwsICdzcGFyay1oZWFkZXItLW92ZXJmbG93LWNoZWNrZWQnKTtcblxuICAgIC8vIElmIHRoZXJlIGFyZSBsZXNzIHRoYW4gdHdvIGVsZW1lbnRzIHRvIHNob3cgYW5kIHdlIGhhdmUgaGlkZGVuIGVsZW1lbnRzLCBjb2xsYXBzZSB0aGUgbmF2LlxuICAgIGlmIChpdGVtcy5zaG93Lmxlbmd0aCA8IDIgJiYgaXRlbXMuaGlkZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RNb3JlKCk7XG4gICAgICByZXR1cm4gdGhpcy5fdG9nZ2xlQ29sbGFwc2VkKHRydWUpO1xuICAgIH1cblxuICAgIC8vIFdlIGFyZW4ndCBhdCB0aGUgWFMgYnJlYWtwb2ludCBhbmQgdGhlcmUgYXJlbid0IHRvbyBmZXcgaXRlbXMgdG8gc2hvdywgc28gZGlzYWJsZSBjb2xsYXBzaW5nXG4gICAgdGhpcy5fdG9nZ2xlQ29sbGFwc2VkKGZhbHNlKTtcblxuICAgIC8vIElmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdG8gaGlkZSBpcyB0aGUgc2FtZSBhcyB0aG9zZSBhbHJlYWR5IGhpZGRlbiwgc3RvcC5cbiAgICBpZiAoaXRlbXMuaGlkZS5sZW5ndGggPT09IHRoaXMubGlzdE1vcmVMaXN0RWwuY2hpbGRyZW4ubGVuZ3RoICYmICFpc1N3YXApIHtcblxuICAgICAgaWYgKCFpdGVtcy5oaWRlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVMaXN0TW9yZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBlbGVtZW50cyB3ZSdyZSBzdXBwb3NlZCB0byBzaG93IGJlZm9yZSB0aGUgXCJtb3JlIGVsZW1lbnRcIlxuICAgICgwLCBfaW5zZXJ0QmVmb3JlMi5kZWZhdWx0KSh0aGlzLmxpc3RFbCwgdGhpcy5saXN0TW9yZUVsLCBpdGVtcy5zaG93KTtcblxuICAgIC8vIElmIHdlIGhhdmUgaXRlbXMgdG8gaGlkZSwgYXBwZW5kIHRoZW0gdG8gdGhlIG1vcmUgZWxlbWVudFxuICAgIGlmIChpdGVtcy5oaWRlLmxlbmd0aCkge1xuICAgICAgKDAsIF9hcHBlbmRDaGlsZHJlbjIuZGVmYXVsdCkodGhpcy5saXN0TW9yZUxpc3RFbCwgaXRlbXMuaGlkZSk7XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSwgcmVtb3ZlIHRoZSBtb3JlIGVsZW1lbnRcbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdE1vcmUoKTtcbiAgICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTGlzdGVuIGZvciB0aGUgcmVhZHkgc3RhdGUgY2hhbmdlIGFuZCByZXJ1biB0aGUgbWVudSBzaXplIGRldGVybWluYXRpb24uXG4gICAqL1xuXG5cbiAgSGVhZGVyLnByb3RvdHlwZS5fbGlzdGVuRm9yUmVhZHlTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uIF9saXN0ZW5Gb3JSZWFkeVN0YXRlQ2hhbmdlKCkge1xuXG4gICAgLy8gQWxyZWFkeSBsb2FkZWRcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGVkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEJvdW5kIGxpc3RlbmVyXG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkZWQnKSB7XG4gICAgICAgIHRoaXMuX2RldGVybWluZU1lbnVTaXplKCk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlYWR5c3RhdGVjaGFuZ2UnLCBydW4pO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIC8vIE9ubHkgcnVuIG9uY2VcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgcnVuKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgdGhlIHByaW1hcnkgbmF2IGJyZWFrcG9pbnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBuYW1lIEEgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZyBuYW1lcyBvZiBicmVha3BvaW50cyB0byBjaGVjayBmb3JcbiAgICovXG5cblxuICBIZWFkZXIucHJvdG90eXBlLl9pc01lbnVCcmVha3BvaW50ID0gZnVuY3Rpb24gX2lzTWVudUJyZWFrcG9pbnQobmFtZSkge1xuICAgIHRoaXMuX2dldEN1cnJlbnRCcmVha3BvaW50KCk7XG4gICAgcmV0dXJuIG5hbWUgaW5zdGFuY2VvZiBBcnJheSA/IG5hbWUuaW5kZXhPZih0aGlzLmN1cnJlbnRCcmVha3BvaW50KSAhPT0gLTEgOiB0aGlzLmN1cnJlbnRCcmVha3BvaW50ID09PSAneHMnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGl0ZW1zIHRvIHNob3cgYW5kIGhpZGUuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cblxuICBIZWFkZXIucHJvdG90eXBlLl9nZXRJdGVtc1RvU2hvd0FuZEhpZGUgPSBmdW5jdGlvbiBfZ2V0SXRlbXNUb1Nob3dBbmRIaWRlKCkge1xuXG4gICAgdmFyIHdpZHRoID0gdGhpcy5wbGFjZWhvbGRlci5saXN0RWwuY2xpZW50V2lkdGg7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wbGFjZWhvbGRlci5saXN0RWwuY2hpbGRyZW47XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgdmFyIGhpZGVJbmRleCA9IC0xO1xuXG4gICAgdGhpcy5fYWRkTGlzdE1vcmUoKTtcblxuICAgIC8vIEFsd2F5cyBpbmNsdWRlIHRoZSB3aWR0aCBvZiB0aGUgbW9yZSBidXR0b24uXG4gICAgdmFyIGNoaWxkcmVuV2lkdGggPSB0aGlzLnBsYWNlaG9sZGVyLmxpc3RNb3JlRWwuY2xpZW50V2lkdGggfHwgMDtcblxuICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgY2hpbGRyZW4gdW50aWwgd2UgaGl0IGEgcG9pbnQgd2hlcmUgdGhleSBkb24ndCBmaXQgYW55bW9yZVxuICAgIGZvciAoOyBpIDwgbGVuICYmIGhpZGVJbmRleCA9PT0gLTE7IGkrKykge1xuICAgICAgY2hpbGRyZW5XaWR0aCArPSBjaGlsZHJlbltpXS5jbGllbnRXaWR0aDtcbiAgICAgIGlmIChjaGlsZHJlbldpZHRoID4gd2lkdGgpIHtcbiAgICAgICAgaGlkZUluZGV4ID0gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaW5kIGFsbCB0aGUgY2hpbGRyZW4gdGhhdCBmaXQgYW5kIGRvbid0IGZpdFxuICAgIHZhciBpdGVtcyA9IHtcbiAgICAgIHNob3c6IGhpZGVJbmRleCAhPT0gLTEgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmxpc3RFbHMsIDAsIGhpZGVJbmRleCkgOiB0aGlzLmxpc3RFbHMsXG4gICAgICBoaWRlOiBoaWRlSW5kZXggIT09IC0xID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5saXN0RWxzLCBoaWRlSW5kZXgpIDogW11cbiAgICB9O1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhbiBpbmRleCB0byBzd2FwIGZvciB0aGUgbGFzdCBcInNob3dcIiBlbGVtZW50LCByZXBsYWNlIHRoYXQgZWxlbWVudFxuICAgIGlmICh0aGlzLm1vcmVTd2FwSW5kZXggPiAtMSAmJiB0aGlzLm1vcmVTd2FwSW5kZXggPj0gaXRlbXMuc2hvdy5sZW5ndGgpIHtcblxuICAgICAgLy8gUmVtb3ZlIHRoZSBsYXN0IGVsZW1lbnQgZnJvbSB0aGUgc2hvdyBhcnJheVxuICAgICAgdmFyIHRvSGlkZSA9IGl0ZW1zLnNob3cuc3BsaWNlKGl0ZW1zLnNob3cubGVuZ3RoIC0gMSwgMSlbMF07XG5cbiAgICAgIC8vIEdldCB0aGUgaW5kZXggdG8gcmVtb3ZlIGZyb20gdGhlIGhpZGUgYXJyYXkuIEFjY291bnQgZm9yIHRoZSBvZmZzZXQuXG4gICAgICB2YXIgdG9TaG93SW5kZXggPSB0aGlzLm1vcmVTd2FwSW5kZXggLSBoaWRlSW5kZXg7XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgZGVzaXJlZCBlbGVtZW50IGZyb20gdGhlIGhpZGUgYXJyYXlcbiAgICAgIHZhciB0b1Nob3cgPSBpdGVtcy5oaWRlLnNwbGljZSh0b1Nob3dJbmRleCwgMSlbMF07XG5cbiAgICAgIC8vIEFkZCB0aGUgdG9TaG93IGVsZW1lbnQgdG8gdGhlIGVuZCBvZiB0aGUgc2hvdyBhcnJheVxuICAgICAgaXRlbXMuc2hvdy5wdXNoKHRvU2hvdyk7XG5cbiAgICAgIC8vIEluc2VydCB0aGUgdG9IaWRlIGVsZW1lbnQgaW50byB0aGUgaGlkZSBhcnJheSBhdCB0aGUgcG9zaXRpb24gb2ZcbiAgICAgIC8vIHRoZSBlbGVtZW50IHdlIGp1c3QgcmVtb3ZlZCBmcm9tIHRoZSBoaWRlIGFycmF5LlxuICAgICAgaXRlbXMuaGlkZS5zcGxpY2UodG9TaG93SW5kZXgsIDAsIHRvSGlkZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbnN1cmUgdGhhdCBhbnkgYWN0aXZlIGl0ZW0gaXMgc2V0IHRvIHRoZSBtb3JlIHN3YXAgaW5kZXguIFRoaXMgZW5zdXJlc1xuICAgKiB0aGF0IHRoZSBhY3RpdmUgaXRlbSBpcyBhbHdheXMgdmlzaWJsZSBvbiB0aGUgc2NyZWVuLlxuICAgKi9cblxuXG4gIEhlYWRlci5wcm90b3R5cGUuX2Vuc3VyZUFjdGl2ZUF0TW9yZVN3YXBJbmRleCA9IGZ1bmN0aW9uIF9lbnN1cmVBY3RpdmVBdE1vcmVTd2FwSW5kZXgoKSB7XG5cbiAgICBpZiAoIXRoaXMubGlzdEVscyB8fCAhdGhpcy5saXN0RWxzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignW2NsYXNzKj1cImxpc3QtaXRlbVwiXS5hY3RpdmUnKTtcbiAgICBpZiAoZWwpIHtcbiAgICAgIHZhciBwYXJlbnRzID0gKDAsIF9nZXRQYXJlbnRzMi5kZWZhdWx0KShlbCwgJy5zcGFyay1tZW51X19saXN0LWl0ZW0nLCB0aGlzLmVsKTtcblxuICAgICAgaWYgKHBhcmVudHMgJiYgcGFyZW50c1twYXJlbnRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIGVsID0gcGFyZW50c1twYXJlbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXggPSAoMCwgX2dldEluZGV4Mi5kZWZhdWx0KSh0aGlzLmxpc3RFbHMsIGVsKTtcblxuICAgICAgaWYgKGluZGV4ICE9PSB0aGlzLm1vcmVTd2FwSW5kZXgpIHtcbiAgICAgICAgdGhpcy5tb3JlU3dhcEluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBwbGFjZWhvbGRlciBmb3Igb3ZlcmZsb3cgaXRlbXMgdG8gdGhlIGxpc3QuXG4gICAqL1xuXG5cbiAgSGVhZGVyLnByb3RvdHlwZS5fYWRkTGlzdE1vcmUgPSBmdW5jdGlvbiBfYWRkTGlzdE1vcmUoKSB7XG4gICAgaWYgKHRoaXMubGlzdE1vcmVFbC5wYXJlbnROb2RlICE9PSB0aGlzLmxpc3RFbCkge1xuICAgICAgdGhpcy5saXN0RWwuYXBwZW5kQ2hpbGQodGhpcy5saXN0TW9yZUVsKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHBsYWNlaG9sZGVyIGZvciBvdmVyZmxvdyBpdGVtcyBmcm9tIHRoZSBwcmltYXJ5IG5hdi5cbiAgICovXG5cblxuICBIZWFkZXIucHJvdG90eXBlLl9yZW1vdmVMaXN0TW9yZSA9IGZ1bmN0aW9uIF9yZW1vdmVMaXN0TW9yZSgpIHtcbiAgICBpZiAodGhpcy5saXN0TW9yZUVsLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMubGlzdE1vcmVFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubGlzdE1vcmVFbCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgY2hpbGRyZW4gb2YgdGhlIHByaW1hcnkgbmF2aWdhdGlvbi5cbiAgICovXG5cblxuICBIZWFkZXIucHJvdG90eXBlLl9yZXNldE1lbnVDaGlsZHJlbiA9IGZ1bmN0aW9uIF9yZXNldE1lbnVDaGlsZHJlbigpIHtcbiAgICB0aGlzLm1vcmVTd2FwSW5kZXggPSAtMTtcbiAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KSh0aGlzLmVsLCAnc3BhcmstaGVhZGVyLS1vdmVyZmxvdy1jaGVja2VkJyk7XG4gICAgKDAsIF9hcHBlbmRDaGlsZHJlbjIuZGVmYXVsdCkodGhpcy5saXN0RWwsIHRoaXMubGlzdEVscyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSB0aGUgY29sbGFwc2VkIG5hdiBzdHlsZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVcbiAgICovXG5cblxuICBIZWFkZXIucHJvdG90eXBlLl90b2dnbGVDb2xsYXBzZWQgPSBmdW5jdGlvbiBfdG9nZ2xlQ29sbGFwc2VkKGVuYWJsZSkge1xuXG4gICAgLy8gU2FtZSBjb2xsYXBzZWQgc3RhdGUgaXMgYWxyZWFkeSBzZXRcbiAgICBpZiAoZW5hYmxlID09PSB0aGlzLmlzQ29sbGFwc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgY2hpbGRyZW4gYW5kIHJlbW92ZSBhIHNwZWNpYWwgbm8tYW5pbWF0ZSBjbGFzcyB0byB0b3AtbGV2ZWwgaXRlbXMgd2hlbiB3ZSBjb2xsYXBzZVxuICAgIGlmIChlbmFibGUpIHtcbiAgICAgIHRoaXMuX2VuYWJsZVRvcExldmVsVG9nZ2xpbmcoKTtcbiAgICAgIHRoaXMuX3Jlc2V0TWVudUNoaWxkcmVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLm1lbnUpIHtcbiAgICAgICAgdGhpcy5tZW51Ll9yZW1vdmVBbGxDYWNoZWRMaXN0cygpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZGlzYWJsZVRvcExldmVsVG9nZ2xpbmcoKTtcbiAgICB9XG5cbiAgICB0aGlzLmlzQ29sbGFwc2VkID0gZW5hYmxlO1xuICAgICgwLCBfdG9nZ2xlQ2xhc3MyLmRlZmF1bHQpKHRoaXMuZWwsICdzcGFyay1oZWFkZXItLWNvbGxhcHNlZCcsIGVuYWJsZSk7XG4gICAgKDAsIF90b2dnbGVDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ3NwYXJrLWhlYWRlci0tdmlzaWJsZScsICFlbmFibGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgdG9nZ2xpbmcgb24gdG9wLWxldmVsIGl0ZW1zLlxuICAgKi9cblxuXG4gIEhlYWRlci5wcm90b3R5cGUuX2VuYWJsZVRvcExldmVsVG9nZ2xpbmcgPSBmdW5jdGlvbiBfZW5hYmxlVG9wTGV2ZWxUb2dnbGluZygpIHtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGhpcy5saXN0RWxzLmxlbmd0aDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKHRoaXMubGlzdEVsc1tpXSwgJ3NwYXJrLW5vLWFuaW1hdGUnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc2FibGUgdG9nZ2xpbmcgb24gdG9wLWxldmVsIGl0ZW1zLlxuICAgKi9cblxuXG4gIEhlYWRlci5wcm90b3R5cGUuX2Rpc2FibGVUb3BMZXZlbFRvZ2dsaW5nID0gZnVuY3Rpb24gX2Rpc2FibGVUb3BMZXZlbFRvZ2dsaW5nKCkge1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0aGlzLmxpc3RFbHMubGVuZ3RoO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5saXN0RWxzW2ldLCAnc3Bhcmstbm8tYW5pbWF0ZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgd2luZG93IHJlc2l6ZXMsIHJlZGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSBwcmltYXJ5IG5hdiBlbGVtZW50cy5cbiAgICovXG5cblxuICBIZWFkZXIucHJvdG90eXBlLl9vblJlc2l6ZSA9IGZ1bmN0aW9uIF9vblJlc2l6ZSgpIHtcblxuICAgIC8vIEVuc3VyZSB0aGF0IGFueSBhY3RpdmUgaXRlbSB3ZSBtYXkgaGF2ZSBpcyBhdCB0aGUgc3dhcCBpbmRleFxuICAgIHRoaXMuX2Vuc3VyZUFjdGl2ZUF0TW9yZVN3YXBJbmRleCgpO1xuICAgIHRoaXMuX2RldGVybWluZU1lbnVTaXplKCk7XG5cbiAgICAvLyBJZiB3ZSBhcmUgZml4ZWQsIGRvIHRoZSBzY3JvbGwgY2hlY2tcbiAgICBpZiAodGhpcy5maXhlZCkge1xuICAgICAgdGhpcy5jaGVja0ZpeGVkKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayB0byBzZWUgaWYgdGhlIGhlYWRlciBzaG91bGQgYmUgZml4ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgSGVhZGVyLnByb3RvdHlwZS5fb25TY3JvbGwgPSBmdW5jdGlvbiBfb25TY3JvbGwoKSB7XG4gICAgdGhpcy5jaGVja0ZpeGVkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gYSBsaW5rIGluIHRoZSBtb3JlIGxpc3QgaXMgY2xpY2tlZCwgc3dhcCBpdCB3aXRoIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIHZpc2libGUgbGlzdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICovXG5cblxuICBIZWFkZXIucHJvdG90eXBlLl9vbk1vcmVDbGljayA9IGZ1bmN0aW9uIF9vbk1vcmVDbGljayhlKSB7XG5cbiAgICAvLyBEb24ndCBkbyBhbnkgc3dhcHBpbmcgaWYgd2UncmUgaW4gYSBjb2xsYXBzZWQgc3RhdGVcbiAgICBpZiAodGhpcy5pc0NvbGxhcHNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGNsaWNrZWQgZWxlbWVudFxuICAgIHZhciBsaSA9ICgwLCBfZ2V0UGFyZW50Mi5kZWZhdWx0KShlLnRhcmdldCwgJ2xpJywgdGhpcy5saXN0TW9yZUxpc3RFbCk7XG5cbiAgICAvLyBTYXZlIHRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byBiZSBzd2FwcGVkXG4gICAgdGhpcy5tb3JlU3dhcEluZGV4ID0gKDAsIF9nZXRJbmRleDIuZGVmYXVsdCkodGhpcy5saXN0RWxzLCBsaSk7XG5cbiAgICAvLyBSZWRldGVybWluZSB0aGUgcHJpbWFyeSBuYXYgc2l6ZVxuICAgIHRoaXMuX2RldGVybWluZU1lbnVTaXplKHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSB0b2dnbGUgaXMgY2xpY2tlZCwgdG9nZ2xlIHRoZSBhY3RpdmUgc3RhdGUgb24gdGhlIG5hdlxuICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgKi9cblxuXG4gIEhlYWRlci5wcm90b3R5cGUuX29uVG9nZ2xlQ2xpY2sgPSBmdW5jdGlvbiBfb25Ub2dnbGVDbGljayhlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuaXNBY3RpdmUgPSAhdGhpcy5pc0FjdGl2ZTtcbiAgICAoMCwgX3RvZ2dsZUNsYXNzMi5kZWZhdWx0KSh0aGlzLm5hdkVsLCAnYWN0aXZlJywgdGhpcy5pc0FjdGl2ZSk7XG4gICAgdGhpcy5tZW51Ll9vcGVuQWN0aXZlUGFyZW50cygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBuYXYgaXMgY2xpY2tlZCwgc2V0IHRvIGluYWN0aXZlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgKi9cblxuXG4gIEhlYWRlci5wcm90b3R5cGUuX29uTmF2Q2xpY2sgPSBmdW5jdGlvbiBfb25OYXZDbGljayhlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSB0aGlzLm5hdkVsICYmIHRoaXMuaXNDb2xsYXBzZWQpIHtcbiAgICAgIHRoaXMuaXNBY3RpdmUgPSAhdGhpcy5pc0FjdGl2ZTtcbiAgICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKHRoaXMubmF2RWwsICdhY3RpdmUnKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEhlYWRlcjtcbn0oX2Jhc2UyLmRlZmF1bHQpO1xuXG4vKipcbiAqIFdoaXRlbGlzdGVkIHBhcmFtZXRlcnMgd2hpY2ggY2FuIGJlIHNldCBvbiBjb25zdHJ1Y3Rpb24uXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cblxuXG5IZWFkZXIucHJvdG90eXBlLl93aGl0ZWxpc3RlZFBhcmFtcyA9IFsnYnJlYWtwb2ludHMnLCAnZml4ZWQnLCAnZml4ZWREaXN0YW5jZSddO1xuXG4vKipcbiAqIERlZmF1bHQgdmFsdWVzIGZvciBpbnRlcm5hbCBwcm9wZXJ0aWVzIHdlIHdpbGwgYmUgc2V0dGluZy5cbiAqIFRoZXNlIGFyZSBzZXQgb24gZWFjaCBjb25zdHJ1Y3Rpb24gc28gd2UgZG9uJ3QgbGVhayBwcm9wZXJ0aWVzXG4gKiBpbnRvIHRoZSBwcm90b3R5cGUgY2hhaW4uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5IZWFkZXIucHJvdG90eXBlLmRlZmF1bHRzID0ge1xuICBlbDogbnVsbCxcbiAgZml4ZWQ6IG51bGwsXG4gIGZpeGVkRGlzdGFuY2U6IG51bGwsXG4gIG5hdkVsOiBudWxsLFxuICBtZW51RWw6IG51bGwsXG4gIGxpc3RFbDogbnVsbCxcbiAgbGlzdEVsczogbnVsbCxcbiAgbGlzdE1vcmVFbDogbnVsbCxcbiAgbGlzdE1vcmVMaXN0RWw6IG51bGwsXG4gIHBsYWNlaG9sZGVyOiBudWxsLFxuICB0b2dnbGVFbDogbnVsbCxcbiAgbGFzdEJyZWFrcG9pbnQ6IG51bGwsXG4gIGN1cnJlbnRCcmVha3BvaW50OiBudWxsLFxuICBpc0FjdGl2ZTogZmFsc2UsXG4gIGlzQ29sbGFwc2VkOiBudWxsLFxuICBtb3JlU3dhcEluZGV4OiAtMSxcbiAgbWVudTogbnVsbCxcbiAgYnJlYWtwb2ludHM6IG51bGwsXG4gIF9vblJlc2l6ZUJvdW5kOiBudWxsLFxuICBfb25TY3JvbGxCb3VuZDogbnVsbCxcbiAgX29uTW9yZUNsaWNrQm91bmQ6IG51bGwsXG4gIF9vblRvZ2dsZUNsaWNrQm91bmQ6IG51bGwsXG4gIF9vbk5hdkNsaWNrQm91bmQ6IG51bGxcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEhlYWRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZGVyLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2Jhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcblxudmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xuXG52YXIgX2hlaWdodCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvYW5pbWF0aW9uL2hlaWdodCcpO1xuXG52YXIgX2hlaWdodDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oZWlnaHQpO1xuXG52YXIgX3RyYW5zZm9ybSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY3NzL3RyYW5zZm9ybScpO1xuXG52YXIgX3RyYW5zZm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmFuc2Zvcm0pO1xuXG52YXIgX2FkZENsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vYWRkLWNsYXNzJyk7XG5cbnZhciBfYWRkQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWRkQ2xhc3MpO1xuXG52YXIgX3JlbW92ZUNsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vcmVtb3ZlLWNsYXNzJyk7XG5cbnZhciBfcmVtb3ZlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVtb3ZlQ2xhc3MpO1xuXG52YXIgX2hhc0NsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vaGFzLWNsYXNzJyk7XG5cbnZhciBfaGFzQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzQ2xhc3MpO1xuXG52YXIgX2hhc1BhcmVudCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdHJhdmVyc2FsL2hhcy1wYXJlbnQnKTtcblxudmFyIF9oYXNQYXJlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzUGFyZW50KTtcblxudmFyIF9nZXRQYXJlbnQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RyYXZlcnNhbC9nZXQtcGFyZW50Jyk7XG5cbnZhciBfZ2V0UGFyZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFBhcmVudCk7XG5cbnZhciBfZ2V0UGFyZW50cyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdHJhdmVyc2FsL2dldC1wYXJlbnRzJyk7XG5cbnZhciBfZ2V0UGFyZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQYXJlbnRzKTtcblxudmFyIF9nZXRDaGlsZCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdHJhdmVyc2FsL2dldC1jaGlsZCcpO1xuXG52YXIgX2dldENoaWxkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldENoaWxkKTtcblxudmFyIF93cmFwRWxlbWVudCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvbWFuaXB1bGF0aW9uL3dyYXAtZWxlbWVudCcpO1xuXG52YXIgX3dyYXBFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dyYXBFbGVtZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICMgTWVudVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBuZXcgTWVudShlbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAvLyBPcHRpb25hbC4gQ2FsbGJhY2sgbWV0aG9kIGZvciB3aGVuIHRoZSBtZW51IHRvZ2dsZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIG9uVG9nZ2xlOiBmdW5jdGlvbigpe31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgY29tcG9uZW50cy9tZW51LmpzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIE1lbnUgPSBmdW5jdGlvbiAoX0Jhc2VDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1lbnUsIF9CYXNlQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogTWVudSBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAqL1xuICBmdW5jdGlvbiBNZW51KGVsKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVudSk7XG5cbiAgICBwYXJhbXMuZWxSZXF1aXJlZCA9IHRydWU7XG5cbiAgICBpZiAoIShfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CYXNlQ29tcG9uZW50LmNhbGwodGhpcywgZWwsIHBhcmFtcykpLCBfdGhpcykpIHtcbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG4gICAgfVxuXG4gICAgX3RoaXMuX2JpbmRFdmVudExpc3RlbmVyQ2FsbGJhY2tzKCk7XG4gICAgX3RoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgX3RoaXMuX2NoZWNrQW5pbWF0aW9uKCk7XG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgdGFicyBsaXN0LCBlYWNoIHRhYiBhbmQgZWFjaCBwYW5lbC5cbiAgICogU2V0IHdoaWNoIHRhYiBpcyBhY3RpdmUsIG9yIHVzZSB0aGUgZmlyc3QuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5fY2FjaGVFbGVtZW50cyA9IGZ1bmN0aW9uIF9jYWNoZUVsZW1lbnRzKGVsKSB7XG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMudG9nZ2xlRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1tZW51X190b2dnbGUnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGJvdW5kIHZlcnNpb25zIG9mIGV2ZW50IGxpc3RlbmVyIGNhbGxiYWNrcyBhbmQgc3RvcmUgdGhlbS5cbiAgICogT3RoZXJ3aXNlIHdlIGNhbid0IHVuYmluZCBmcm9tIHRoZXNlIGV2ZW50cyBsYXRlciBiZWNhdXNlIHRoZVxuICAgKiBmdW5jdGlvbiBzaWduYXR1cmVzIHdvbid0IG1hdGNoLlxuICAgKi9cblxuXG4gIE1lbnUucHJvdG90eXBlLl9iaW5kRXZlbnRMaXN0ZW5lckNhbGxiYWNrcyA9IGZ1bmN0aW9uIF9iaW5kRXZlbnRMaXN0ZW5lckNhbGxiYWNrcygpIHtcbiAgICB0aGlzLl9vbkNsaWNrQm91bmQgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Gb2N1c0JvdW5kID0gdGhpcy5fb25Gb2N1cy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQmx1ckJvdW5kID0gdGhpcy5fb25CbHVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25LZXlkb3duQm91bmQgPSB0aGlzLl9vbktleWRvd24uYmluZCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGV2ZW50IGxpc3RlbmVycyBmb3IgRE9NIGV2ZW50cy5cbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2tCb3VuZCk7XG4gICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX29uRm9jdXNCb3VuZCwgdHJ1ZSk7XG4gICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fb25CbHVyQm91bmQsIHRydWUpO1xuICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5ZG93bkJvdW5kKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBmb3IgRE9NIGV2ZW50cy4uXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuX3JlbW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrQm91bmQpO1xuICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9vbkZvY3VzQm91bmQpO1xuICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX29uQmx1ckJvdW5kKTtcbiAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleWRvd25Cb3VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSB0aGUgb3BlbiBzdGF0ZSBvZiBhbiBpdGVtLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGl0ZW1cbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5fdG9nZ2xlSXRlbSA9IGZ1bmN0aW9uIF90b2dnbGVJdGVtKGl0ZW0pIHtcblxuICAgIGlmICgoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KShpdGVtLCAnb3BlbicpKSB7XG4gICAgICB0aGlzLl9jbG9zZUl0ZW0oaXRlbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29wZW5JdGVtKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVG9nZ2xlIGFyaWEtY2hlY2tlZCBzdGF0ZSBvZiB0aGUgRXhwYW5kL0NvbGxhcHNlIHRvZ2dsZSBjYXJldHNcbiAgICogQHBhcmFtIHtFbGVtZW50fSBpdGVtXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuX3RvZ2dsZUFyaWFDaGVja2VkU3RhdGUgPSBmdW5jdGlvbiBfdG9nZ2xlQXJpYUNoZWNrZWRTdGF0ZShpdGVtKSB7XG4gICAgaWYgKGl0ZW0uaGFzQXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnKSkge1xuICAgICAgdmFyIGFyaWFTdGF0ZSA9IGl0ZW0uZ2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnKSA9PT0gJ3RydWUnO1xuICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcsIFN0cmluZyghYXJpYVN0YXRlKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBmb3IgYSBuZXN0ZWQgbGlzdCBhbmQgY3JlYXRlIHRoZSB3cmFwcGVycyBuZWVkZWRcbiAgICogZm9yIGFuaW1hdGluZyB0aGUgbGlzdHNcbiAgICpcbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5fY2hlY2tBbmltYXRpb24gPSBmdW5jdGlvbiBfY2hlY2tBbmltYXRpb24oKSB7XG4gICAgaWYgKHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnNwYXJrLW1lbnVfX2xpc3QtbmV4dCcpKSB7XG4gICAgICB0aGlzLmNhY2hlZExpc3QgPSB0aGlzLmNhY2hlZExpc3QgfHwgW107XG4gICAgICB0aGlzLl9jcmVhdGVNZW51QW5pbWF0aW9uV3JhcHBlcigpO1xuICAgICAgdGhpcy5fYW5pbWF0ZUxpc3RDaGFuZ2UoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB3cmFwcGVyIGNsYXNzIHRvIGhlbHAgd2l0aCBhbmltYXRpb24gb2Ygc2xpZGluZyBsaXN0c1xuICAgKlxuICAgKi9cblxuXG4gIE1lbnUucHJvdG90eXBlLl9jcmVhdGVNZW51QW5pbWF0aW9uV3JhcHBlciA9IGZ1bmN0aW9uIF9jcmVhdGVNZW51QW5pbWF0aW9uV3JhcHBlcigpIHtcbiAgICBpZiAodGhpcy53cmFwcGVyRWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd3JhcHBlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkod3JhcHBlckVsLCAnc3BhcmstbWVudV9fYW5pbWF0aW9uLXdyYXBwZXInKTtcbiAgICAoMCwgX3dyYXBFbGVtZW50Mi5kZWZhdWx0KSh0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1tZW51X19saXN0JyksIHdyYXBwZXJFbCk7XG4gICAgdGhpcy53cmFwcGVyRWwgPSB3cmFwcGVyRWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFuaW1hdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBhbmltYXRpb24gd3JhcHBlci4gT3B0aW9uYWxseSwgZG9cbiAgICogc28gaW1tZWRpYXRlbHkgd2l0aG91dCB3YWl0aW5nIGZvciBhbiBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbm9BbmltYXRlXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuX2FuaW1hdGVMaXN0Q2hhbmdlID0gZnVuY3Rpb24gX2FuaW1hdGVMaXN0Q2hhbmdlKG5vQW5pbWF0ZSkge1xuXG4gICAgaWYgKG5vQW5pbWF0ZSkge1xuICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy53cmFwcGVyRWwsICduby1hbmltYXRlJyk7XG4gICAgfVxuXG4gICAgdGhpcy53cmFwcGVyRWwuc2V0QXR0cmlidXRlKCdzdHlsZScsICgwLCBfdHJhbnNmb3JtMi5kZWZhdWx0KSgndHJhbnNsYXRlWCcsICctJyArIHRoaXMuY2FjaGVkTGlzdC5sZW5ndGggKiAxMDAgKyAnJScpKTtcblxuICAgIGlmIChub0FuaW1hdGUpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KSh0aGlzLndyYXBwZXJFbCwgJ25vLWFuaW1hdGUnKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgMSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBlbmQgbGlzdCB0byBtZW51IGVsZW1lbnRcbiAgICogQHBhcmFtIHtFbGVtZW50fSBsaXN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbm9BbmltYXRlXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuX2FwcGVuZExpc3QgPSBmdW5jdGlvbiBfYXBwZW5kTGlzdChpdGVtLCBub0FuaW1hdGUpIHtcblxuICAgIC8vIENyZWF0ZSB3cmFwcGVyXG4gICAgdGhpcy5fY3JlYXRlTWVudUFuaW1hdGlvbldyYXBwZXIoKTtcblxuICAgIHZhciBuZXdMaXN0ID0gaXRlbS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkobmV3TGlzdCwgJ25lc3RlZExpc3QnKTtcbiAgICBuZXdMaXN0LnNldEF0dHJpYnV0ZSgnZGF0YS1uZXN0ZWQtbGlzdC1pZCcsIG5ld0xpc3QuZ2V0QXR0cmlidXRlKCdpZCcpKTtcbiAgICBuZXdMaXN0LnJlbW92ZUF0dHJpYnV0ZSgnaWQnKTtcblxuICAgIGlmICh0aGlzLndyYXBwZXJFbCkge1xuICAgICAgLy8gQWRkIGNoaWxkIG5vZGUgdG8gd3JhcHBlclxuICAgICAgdGhpcy53cmFwcGVyRWwuYXBwZW5kQ2hpbGQobmV3TGlzdCk7XG4gICAgICAvLyBBZGQgdG8gY2FjaGVkIEFycmF5IHRvIGtlZXAgdHJhY2sgb2YgYWxsIGFkZGVkIGxpc3RzXG4gICAgICB0aGlzLmNhY2hlZExpc3QucHVzaChuZXdMaXN0KTtcbiAgICAgIC8vIFNsaWRlIG5hdmlnYXRpb25cbiAgICAgIHRoaXMuX2FuaW1hdGVMaXN0Q2hhbmdlKG5vQW5pbWF0ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgbGlzdCB0byBuYXZcbiAgICpcbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5fcmVtb3ZlTGFzdExpc3QgPSBmdW5jdGlvbiBfcmVtb3ZlTGFzdExpc3QoKSB7XG4gICAgLy8gSWYgdGhlcmUgYXJlIGFueSBpdGVtcyB0byByZW1vdmVcbiAgICBpZiAodGhpcy5jYWNoZWRMaXN0Lmxlbmd0aCkge1xuICAgICAgLy8gUmV0cmlldmUgbGFzdCBpdGVtIGZyb20gbGlzdFxuICAgICAgdmFyIHJlbW92ZUVsZW1lbnQgPSB0aGlzLmNhY2hlZExpc3QucG9wKCk7XG4gICAgICBpZiAodGhpcy53cmFwcGVyRWwpIHtcbiAgICAgICAgLy8gU2xpZGUgbmF2aWdhdGlvblxuICAgICAgICB0aGlzLl9hbmltYXRlTGlzdENoYW5nZSgpO1xuICAgICAgfVxuICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBSZW1vdmUgaXRzZWxmIGZyb20gRE9NXG4gICAgICAgIHJlbW92ZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyZW1vdmVFbGVtZW50KTtcbiAgICAgIH0sIDI1MCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGxpc3RzIGZyb20gcGFuZWwgbWVudVxuICAgKlxuICAgKi9cblxuXG4gIE1lbnUucHJvdG90eXBlLl9yZW1vdmVBbGxDYWNoZWRMaXN0cyA9IGZ1bmN0aW9uIF9yZW1vdmVBbGxDYWNoZWRMaXN0cygpIHtcbiAgICBpZiAodGhpcy5jYWNoZWRMaXN0KSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgYW55IGl0ZW1zIHRvIHJlbW92ZVxuICAgICAgd2hpbGUgKHRoaXMuY2FjaGVkTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgLy8gV2hpbGUgdGhlcmUgYXJlIHN0aWxsIGl0ZW1zLCByZW1vdmUgdGhlbVxuICAgICAgICB0aGlzLl9yZW1vdmVMYXN0TGlzdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRmluZHMgYW5kIHJldHVybnMgdGhlIG5leHQgbmVzdGVkIGxpc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuXG4gIE1lbnUucHJvdG90eXBlLl9nZXROZXh0TGlzdCA9IGZ1bmN0aW9uIF9nZXROZXh0TGlzdChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0ucXVlcnlTZWxlY3RvcignLnNwYXJrLW1lbnVfX2xpc3QtbmV4dCcpID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihpdGVtLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1tZW51X19saXN0LW5leHQnKS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWVudScpKSA6IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIE9wZW4gYW4gaXRlbSBieSBhbmltYXRpbmcgaXQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuX29wZW5JdGVtID0gZnVuY3Rpb24gX29wZW5JdGVtKGl0ZW0pIHtcblxuICAgIC8vIEl0ZW0gaXMgYWxyZWFkeSBvcGVuXG4gICAgaWYgKCgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKGl0ZW0sICdvcGVuJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAoMCwgX2hlaWdodDIuZGVmYXVsdCkoe1xuICAgICAgZWw6IGl0ZW0sXG4gICAgICB0b2dnbGVFbDogJy5zcGFyay1tZW51X19saXN0J1xuICAgIH0pO1xuXG4gICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkoaXRlbSwgJ29wZW4nKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xvc2UgYW4gaXRlbSBieSBhbmltYXRpbmcgaXQgc2h1dC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5fY2xvc2VJdGVtID0gZnVuY3Rpb24gX2Nsb3NlSXRlbShpdGVtKSB7XG5cbiAgICAvLyBJdGVtIGlzIGFscmVhZHkgY2xvc2VkXG4gICAgaWYgKCEoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KShpdGVtLCAnb3BlbicpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgKDAsIF9oZWlnaHQyLmRlZmF1bHQpKHtcbiAgICAgIGVsOiBpdGVtLFxuICAgICAgdG9nZ2xlRWw6ICcuc3BhcmstbWVudV9fbGlzdCcsXG4gICAgICB0b2dnbGVWYWx1ZTogJ25vbmUnLFxuICAgICAgYWN0aW9uOiAnY29sbGFwc2UnXG4gICAgfSk7XG5cbiAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KShpdGVtLCAnb3BlbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlIGFuIGl0ZW0gYWN0aXZlLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGl0ZW1cbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5fYWN0aXZhdGVJdGVtID0gZnVuY3Rpb24gX2FjdGl2YXRlSXRlbShpdGVtKSB7XG5cbiAgICAvLyBJdGVtIGlzIGFscmVhZHkgYWN0aXZlXG4gICAgaWYgKCgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKGl0ZW0sICdhY3RpdmUnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERlYWN0aXZhdGUgYW55IGFjdGl2ZSBpdGVtc1xuICAgIHZhciBwYXJlbnRzID0gKDAsIF9nZXRQYXJlbnRzMi5kZWZhdWx0KShpdGVtLCAnLnNwYXJrLW1lbnVfX2xpc3QnLCB0aGlzLmVsKTtcbiAgICB0aGlzLl9kZWFjdGl2YXRlSXRlbXMocGFyZW50c1twYXJlbnRzLmxlbmd0aCAtIDFdKTtcbiAgICB0aGlzLl9kZWFjdGl2YXRlSXRlbVNpYmxpbmdzKGl0ZW0pO1xuXG4gICAgLy8gQWRkIHRoZSBhY3RpdmUgY2xhc3NcbiAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KShpdGVtLCAnYWN0aXZlJyk7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHBhcmVudCB0aGF0IGlzIGFsc28gYSBsaXN0IGl0ZW0sIG9wZW4gaXQuXG4gICAgdGhpcy5fYWN0aXZhdGVJdGVtUGFyZW50cyhpdGVtLCB0aGlzLmVsKTtcbiAgfTtcblxuICAvKipcbiAgICogQWN0aXZhdGUgcGFyZW50IGl0ZW1zLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbGltaXRFbFxuICAgKi9cblxuXG4gIE1lbnUucHJvdG90eXBlLl9hY3RpdmF0ZUl0ZW1QYXJlbnRzID0gZnVuY3Rpb24gX2FjdGl2YXRlSXRlbVBhcmVudHMoZWwsIGxpbWl0RWwpIHtcblxuICAgIHZhciBwYXJlbnRzID0gKDAsIF9nZXRQYXJlbnRzMi5kZWZhdWx0KShlbC5wYXJlbnROb2RlLCAnW2NsYXNzKj1cImxpc3QtaXRlbVwiXScsIGxpbWl0RWwpO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBwYXJlbnRzLmxlbmd0aDtcblxuICAgIC8vIEFkZCB0aGUgYWN0aXZlIGNsYXNzXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGhpcy5fb3Blbkl0ZW0ocGFyZW50c1tpXSk7XG4gICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KShwYXJlbnRzW2ldLCAnY2hpbGQtYWN0aXZlJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlIGl0ZW1zLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuX2RlYWN0aXZhdGVJdGVtcyA9IGZ1bmN0aW9uIF9kZWFjdGl2YXRlSXRlbXMoZWwpIHtcblxuICAgIHZhciBhY3RpdmVzID0gZWwucXVlcnlTZWxlY3RvckFsbCgnW2NsYXNzKj1cImxpc3QtaXRlbVwiXS5hY3RpdmUnKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGFjdGl2ZXMubGVuZ3RoO1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBhY3RpdmUgY2xhc3NcbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KShhY3RpdmVzLml0ZW0oaSksICdhY3RpdmUnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGUgc2libGluZ3MgaXRlbXMuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5fZGVhY3RpdmF0ZUl0ZW1TaWJsaW5ncyA9IGZ1bmN0aW9uIF9kZWFjdGl2YXRlSXRlbVNpYmxpbmdzKGVsKSB7XG5cbiAgICB2YXIgYWN0aXZlcyA9IGVsLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2NsYXNzKj1cImxpc3QtaXRlbVwiXS5jaGlsZC1hY3RpdmUnKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGFjdGl2ZXMubGVuZ3RoO1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBhY3RpdmUgY2xhc3NcbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KShhY3RpdmVzW2ldLCAnY2hpbGQtYWN0aXZlJyk7XG4gICAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KShhY3RpdmVzW2ldLCAnb3BlbicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogT3BlbiB0aGUgcGFyZW50cyBvZiB0aGUgYWN0aXZlIGl0ZW0uXG4gICAqXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuX29wZW5BY3RpdmVQYXJlbnRzID0gZnVuY3Rpb24gX29wZW5BY3RpdmVQYXJlbnRzKCkge1xuXG4gICAgdmFyIGFjdGl2ZUl0ZW0gPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5hY3RpdmUnKTtcbiAgICBpZiAoYWN0aXZlSXRlbSkge1xuICAgICAgdmFyIHBhcmVudEl0ZW1zID0gKDAsIF9nZXRQYXJlbnRzMi5kZWZhdWx0KShhY3RpdmVJdGVtLCAnLnNwYXJrLW1lbnVfX2xpc3QtaXRlbScsIHRoaXMuZWwpO1xuICAgICAgdmFyIGl0ZW1MaW5rcztcbiAgICAgIHZhciBuZXh0TGlzdDtcblxuICAgICAgZm9yICh2YXIgaSA9IHBhcmVudEl0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGl0ZW1MaW5rcyA9ICgwLCBfZ2V0Q2hpbGQyLmRlZmF1bHQpKHBhcmVudEl0ZW1zW2ldLCAnLnNwYXJrLW1lbnVfX2xpc3QtbGlua3MnKTtcbiAgICAgICAgaWYgKGl0ZW1MaW5rcyAmJiBpdGVtTGlua3MucXVlcnlTZWxlY3RvcignLnNwYXJrLW1lbnVfX2xpc3QtbmV4dCcpKSB7XG4gICAgICAgICAgbmV4dExpc3QgPSB0aGlzLl9nZXROZXh0TGlzdChwYXJlbnRJdGVtc1tpXSk7XG4gICAgICAgICAgaWYgKG5leHRMaXN0ICYmICF0aGlzLl9jYWNoZWRMaXN0Q29udGFpbnNJRChuZXh0TGlzdC5nZXRBdHRyaWJ1dGUoJ2lkJykpKSB7XG4gICAgICAgICAgICB0aGlzLl9hcHBlbmRMaXN0KG5leHRMaXN0LCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkocGFyZW50SXRlbXNbaV0sICdvcGVuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBjYWNoZWQgbGlzdCBjb250YWlucyBhIGNlcnRhaW4gSURcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuX2NhY2hlZExpc3RDb250YWluc0lEID0gZnVuY3Rpb24gX2NhY2hlZExpc3RDb250YWluc0lEKGlkKSB7XG4gICAgdmFyIGkgPSB0aGlzLmNhY2hlZExpc3QubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmICh0aGlzLmNhY2hlZExpc3RbaV0uZ2V0QXR0cmlidXRlKCdkYXRhLW5lc3RlZC1saXN0LWlkJykgPT09IGlkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gYW4gaXRlbSBpcyBjbGlja2VkLCBtYWtlIGl0IGFjdGl2ZS4gRGV0ZXJtaW5lIGlmIHRoZSBjbGljayB3YXMgb24gYW4gZXhwYW5kXG4gICAqIGJ1dHRvbiBhbmQgb3BlbiB0aGUgbGlzdCBpZiBzby5cbiAgICogQHRvZG86IEl0IHNob3VsZCBiZSBwb3NzaWJsZSB0byBvcHQgb3V0IG9mIHRoaXMgYmVoYXZpb3IuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuX29uQ2xpY2sgPSBmdW5jdGlvbiBfb25DbGljayhlKSB7XG5cbiAgICAvLyBEb24ndCBtYWtlIGZvcm1zIGFjdGl2ZVxuICAgIGlmICgoMCwgX2dldFBhcmVudDIuZGVmYXVsdCkoZS50YXJnZXQsICdmb3JtJywgdGhpcy5lbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUb2dnbGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIG1lbnU/XG4gICAgdmFyIHRvZ2dsZSA9IGUudGFyZ2V0ID09PSB0aGlzLnRvZ2dsZUVsIHx8ICgwLCBfaGFzUGFyZW50Mi5kZWZhdWx0KShlLnRhcmdldCwgdGhpcy50b2dnbGVFbCk7XG4gICAgaWYgKHRvZ2dsZSkge1xuICAgICAgcmV0dXJuICh0aGlzLm9uVG9nZ2xlIHx8IG5vb3ApKGUsIHRoaXMpO1xuICAgIH1cblxuICAgIC8vIElzIHRoZXJlIGEgcGFyZW50IHRvIG9wZW4gYW5kIGFuIGl0ZW0/XG4gICAgdmFyIG9wZW4gPSAoMCwgX2dldFBhcmVudDIuZGVmYXVsdCkoZS50YXJnZXQsICcuc3BhcmstbWVudV9fbGlzdC1leHBhbmQnLCB0aGlzLmVsKTtcbiAgICB2YXIgaXRlbSA9ICgwLCBfZ2V0UGFyZW50Mi5kZWZhdWx0KShlLnRhcmdldCwgJy5zcGFyay1tZW51X19saXN0LWl0ZW0nLCB0aGlzLmVsKTtcblxuICAgIC8vIElmIHdlIGhhdmUgbm8gaXRlbSBvciBoYXZlIGJlZW4gdG9sZCB0byBpZ25vcmUgdGhlIGl0ZW1cbiAgICBpZiAoIWl0ZW0gfHwgKDAsIF9nZXRQYXJlbnQyLmRlZmF1bHQpKGUudGFyZ2V0LCAnLnNwYXJrLW1lbnVfX2lnbm9yZScsIHRoaXMuZWwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcGVuKSB7XG4gICAgICB0aGlzLl90b2dnbGVBcmlhQ2hlY2tlZFN0YXRlKG9wZW4pO1xuICAgICAgcmV0dXJuIHRoaXMuX3RvZ2dsZUl0ZW0oaXRlbSk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhIHZhbGlkIGl0ZW0gYW5kIHdlIGFyZW4ndCBpbnNpZGUgdGhlIGV4cGFuZGVkIGhlYWRlclxuICAgIGlmIChpdGVtICYmICEoMCwgX2hhc1BhcmVudDIuZGVmYXVsdCkoZS50YXJnZXQsIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1oZWFkZXItLXZpc2libGUnKSkpIHtcblxuICAgICAgdmFyIG5leHQgPSB0aGlzLl9nZXROZXh0TGlzdChpdGVtKTtcblxuICAgICAgaWYgKG5leHQgJiYgKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkoZS50YXJnZXQsICdzcGFyay1tZW51X19saXN0LW5leHQnKSkge1xuICAgICAgICAvLyBBY3RpdmUgaXRlbVxuICAgICAgICB0aGlzLl9hY3RpdmF0ZUl0ZW0oaXRlbSk7XG4gICAgICAgIHRoaXMuX2FwcGVuZExpc3QobmV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGJhY2sgPSAoMCwgX2dldFBhcmVudDIuZGVmYXVsdCkoZS50YXJnZXQsICcuc3BhcmstbWVudV9fbGlzdC1iYWNrJywgaXRlbSk7XG5cbiAgICAgIGlmIChiYWNrICYmICgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKGUudGFyZ2V0LCAnc3BhcmstbWVudV9fbGlzdC1iYWNrJykpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGFzdExpc3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFjdGl2ZSBpdGVtXG4gICAgdGhpcy5fYWN0aXZhdGVJdGVtKGl0ZW0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBzcGFjZSBvciBlbnRlciBrZXkgaXMgcHJlc3NlZCBvbiBhIGZvY3VzZWQgaXRlbSwgbWFrZSBpdCBhY3RpdmUuXG4gICAqIERldGVybWluZSBpZiB0aGUgY2xpY2sgd2FzIG9uIGFuIGV4cGFuZCBidXR0b24gb3IgbGluayBhbmQgb3BlbiB0aGUgbGlzdCBpZiBzby5cbiAgICogQHRvZG86IEl0IHNob3VsZCBiZSBwb3NzaWJsZSB0byBvcHQgb3V0IG9mIHRoaXMgYmVoYXZpb3IuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuX29uS2V5ZG93biA9IGZ1bmN0aW9uIF9vbktleWRvd24oZSkge1xuICAgIHZhciBjb2RlID0gZS5rZXlDb2RlIHx8IGUud2hpY2g7XG5cbiAgICAvLyBEb24ndCBtYWtlIGZvcm1zIGFjdGl2ZVxuICAgIGlmICgoMCwgX2dldFBhcmVudDIuZGVmYXVsdCkoZS50YXJnZXQsICdmb3JtJywgdGhpcy5lbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUb2dnbGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIG1lbnU/XG4gICAgdmFyIHRvZ2dsZSA9IGUudGFyZ2V0ID09PSB0aGlzLnRvZ2dsZUVsIHx8ICgwLCBfaGFzUGFyZW50Mi5kZWZhdWx0KShlLnRhcmdldCwgdGhpcy50b2dnbGVFbCk7XG4gICAgaWYgKHRvZ2dsZSkge1xuICAgICAgcmV0dXJuICh0aGlzLm9uVG9nZ2xlIHx8IG5vb3ApKGUsIHRoaXMpO1xuICAgIH1cblxuICAgIC8vIElzIHRoZXJlIGEgcGFyZW50IHRvIG9wZW4gYW5kIGFuIGl0ZW0/XG4gICAgdmFyIG9wZW4gPSAoMCwgX2dldFBhcmVudDIuZGVmYXVsdCkoZS50YXJnZXQsICcuc3BhcmstbWVudV9fbGlzdC1leHBhbmQnLCB0aGlzLmVsKTtcbiAgICB2YXIgaXRlbSA9ICgwLCBfZ2V0UGFyZW50Mi5kZWZhdWx0KShlLnRhcmdldCwgJy5zcGFyay1tZW51X19saXN0LWl0ZW0nLCB0aGlzLmVsKTtcblxuICAgIC8vIElmIHdlIGhhdmUgbm8gaXRlbSBvciBoYXZlIGJlZW4gdG9sZCB0byBpZ25vcmUgdGhlIGl0ZW1cbiAgICBpZiAoIWl0ZW0gfHwgKDAsIF9nZXRQYXJlbnQyLmRlZmF1bHQpKGUudGFyZ2V0LCAnLnNwYXJrLW1lbnVfX2lnbm9yZScsIHRoaXMuZWwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcGVuKSB7XG4gICAgICBpZiAoY29kZSA9PT0gMzIgfHwgY29kZSA9PT0gMTMpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLl90b2dnbGVBcmlhQ2hlY2tlZFN0YXRlKG9wZW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9nZ2xlSXRlbShpdGVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGEgdmFsaWQgaXRlbSBhbmQgd2UgYXJlbid0IGluc2lkZSB0aGUgZXhwYW5kZWQgaGVhZGVyXG4gICAgaWYgKGl0ZW0gJiYgISgwLCBfaGFzUGFyZW50Mi5kZWZhdWx0KShlLnRhcmdldCwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNwYXJrLWhlYWRlci0tdmlzaWJsZScpKSkge1xuXG4gICAgICB2YXIgbmV4dCA9IHRoaXMuX2dldE5leHRMaXN0KGl0ZW0pO1xuXG4gICAgICBpZiAobmV4dCAmJiAoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KShlLnRhcmdldCwgJ3NwYXJrLW1lbnVfX2xpc3QtbmV4dCcpKSB7XG4gICAgICAgIGlmIChjb2RlID09PSAzMiB8fCBjb2RlID09PSAxMykge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAvLyBBY3RpdmUgaXRlbVxuICAgICAgICAgIHRoaXMuX2FjdGl2YXRlSXRlbShpdGVtKTtcbiAgICAgICAgICB0aGlzLl9hcHBlbmRMaXN0KG5leHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYmFjayA9ICgwLCBfZ2V0UGFyZW50Mi5kZWZhdWx0KShlLnRhcmdldCwgJy5zcGFyay1tZW51X19saXN0LWJhY2snLCBpdGVtKTtcblxuICAgICAgaWYgKGJhY2sgJiYgKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkoZS50YXJnZXQsICdzcGFyay1tZW51X19saXN0LWJhY2snKSkge1xuICAgICAgICBpZiAoY29kZSA9PT0gMzIgfHwgY29kZSA9PT0gMTMpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICB0aGlzLl9yZW1vdmVMYXN0TGlzdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSAzMiB8fCBjb2RlID09PSAxMykge1xuICAgICAgdGhpcy5fYWN0aXZhdGVJdGVtKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogS2VlcCB0cmFjayBvZiB3aGVuIGl0ZW1zIGhhdmUgZm9jdXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuX29uRm9jdXMgPSBmdW5jdGlvbiBfb25Gb2N1cyhlKSB7XG5cbiAgICB2YXIgcGFyZW50ID0gZS50YXJnZXQ7XG4gICAgdmFyIGxhc3RQYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSAoMCwgX2dldFBhcmVudDIuZGVmYXVsdCkobGFzdFBhcmVudC5wYXJlbnROb2RlLCAnLnNwYXJrLW1lbnVfX2xpc3QtaXRlbScsIHRoaXMuZWwpO1xuICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50ID09PSBsYXN0UGFyZW50KSBicmVhaztcbiAgICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKHBhcmVudCwgJ2hhcy1mb2N1cycpO1xuICAgICAgbGFzdFBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEtlZXAgdHJhY2sgb2Ygd2hlbiBpdGVtcyBsb3NlIGZvY3VzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgKi9cblxuXG4gIE1lbnUucHJvdG90eXBlLl9vbkJsdXIgPSBmdW5jdGlvbiBfb25CbHVyKGUpIHtcblxuICAgIHZhciBwYXJlbnQgPSBlLnRhcmdldDtcbiAgICB2YXIgbGFzdFBhcmVudCA9IHBhcmVudDtcblxuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9ICgwLCBfZ2V0UGFyZW50Mi5kZWZhdWx0KShsYXN0UGFyZW50LnBhcmVudE5vZGUsICcuc3BhcmstbWVudV9fbGlzdC1pdGVtJywgdGhpcy5lbCk7XG4gICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT09IGxhc3RQYXJlbnQpIGJyZWFrO1xuICAgICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkocGFyZW50LCAnaGFzLWZvY3VzJyk7XG4gICAgICBsYXN0UGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTWVudTtcbn0oX2Jhc2UyLmRlZmF1bHQpO1xuXG4vKipcbiAqIFdoaXRlbGlzdGVkIHBhcmFtZXRlcnMgd2hpY2ggY2FuIGJlIHNldCBvbiBjb25zdHJ1Y3Rpb24uXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cblxuXG5NZW51LnByb3RvdHlwZS5fd2hpdGVsaXN0ZWRQYXJhbXMgPSBbJ29uVG9nZ2xlJ107XG5cbi8qKlxuICogRGVmYXVsdCB2YWx1ZXMgZm9yIGludGVybmFsIHByb3BlcnRpZXMgd2Ugd2lsbCBiZSBzZXR0aW5nLlxuICogVGhlc2UgYXJlIHNldCBvbiBlYWNoIGNvbnN0cnVjdGlvbiBzbyB3ZSBkb24ndCBsZWFrIHByb3BlcnRpZXNcbiAqIGludG8gdGhlIHByb3RvdHlwZSBjaGFpbi5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbk1lbnUucHJvdG90eXBlLmRlZmF1bHRzID0ge1xuICBjYWNoZWRMaXN0OiBudWxsLFxuICBlbDogbnVsbCxcbiAgdG9nZ2xlRWw6IG51bGwsXG4gIHdyYXBwZXJFbDogbnVsbCxcbiAgb25Ub2dnbGU6IG51bGwsXG4gIF9vbkNsaWNrQm91bmQ6IG51bGwsXG4gIF9vbkZvY3VzQm91bmQ6IG51bGwsXG4gIF9vbkJsdXJCb3VuZDogbnVsbCxcbiAgX29uS2V5ZG93bkJvdW5kOiBudWxsXG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNZW51O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZW51LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX291dGVySGVpZ2h0ID0gcmVxdWlyZSgnLi4vZG9tL291dGVyLWhlaWdodCcpO1xuXG52YXIgX291dGVySGVpZ2h0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX291dGVySGVpZ2h0KTtcblxudmFyIF9hZGRDbGFzcyA9IHJlcXVpcmUoJy4uL2RvbS9hZGQtY2xhc3MnKTtcblxudmFyIF9hZGRDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hZGRDbGFzcyk7XG5cbnZhciBfcmVtb3ZlQ2xhc3MgPSByZXF1aXJlKCcuLi9kb20vcmVtb3ZlLWNsYXNzJyk7XG5cbnZhciBfcmVtb3ZlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVtb3ZlQ2xhc3MpO1xuXG52YXIgX2hhc0NsYXNzID0gcmVxdWlyZSgnLi4vZG9tL2hhcy1jbGFzcycpO1xuXG52YXIgX2hhc0NsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhc0NsYXNzKTtcblxudmFyIF90b2dnbGVDbGFzcyA9IHJlcXVpcmUoJy4uL2RvbS90b2dnbGUtY2xhc3MnKTtcblxudmFyIF90b2dnbGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b2dnbGVDbGFzcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9OyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAjIEFuaW1hdGUgSGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQW5pbWF0ZSB0aGUgaGVpZ2h0IG9mIGFuIGVsZW1lbnQgc2luY2Ugd2UgY2FuJ3QgZG8gdGhpcyB3LyBwdXJlIENTUy4gU2lnaC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogYW5pbWF0ZUhlaWdodCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICBlbDogLi4uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgdG9nZ2xlRWw6IC4uLixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIC8vIE9wdGlvbmFsIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgYWN0aW9uOiAnY29sbGFwc2UnfCdleHBhbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgaGVpZ2h0QW5pbWF0aW9uQ2xhc3M6ICdzcGFyay1hbmltYXRlLWhlaWdodCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICBvcGFjaXR5QW5pbWF0aW9uQ2xhc3M6ICdzcGFyay1hbmltYXRlLW9wYWNpdHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgdG9nZ2xlUHJvcGVydHk6ICdkaXNwbGF5J3wnb3ZlcmZsb3cnfCd2aXNpYmlsaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIHRvZ2dsZVZhbHVlOiAnYmxvY2snfCdub25lJ3wndmlzaWJsZSd8J2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICBhbmltYXRpb25EdXJhdGlvbjogMjUwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIGhlbHBlcnMvYW5pbWF0aW9uL2hlaWdodC5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgcnVubmluZ0FuaW1hdGlvbnMgPSB7XG4gIGVsczogW10sXG4gIGNvbXBsZXRlQ2FsbGJhY2tzOiBbXVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIGludmVyc2UgdG9nZ2xlIHZhbHVlXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0gIHtTdHJpbmd9IG9yaWdpbmFsVmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0SW52ZXJzZVRvZ2dsZVZhbHVlKGVsLCBwcm9wZXJ0eSwgb3JpZ2luYWxWYWx1ZSkge1xuXG4gIC8vIEdldCB0aGUgdmFsdWUgdG8gdG9nZ2xlIHRvIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHlcbiAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgIGNhc2UgJ292ZXJmbG93JzpcbiAgICBjYXNlICd2aXNpYmlsaXR5JzpcbiAgICAgIHJldHVybiBvcmlnaW5hbFZhbHVlID09PSAndmlzaWJsZScgPyAnaGlkZGVuJyA6ICd2aXNpYmxlJztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG9yaWdpbmFsVmFsdWUgPT09ICdibG9jaycgfHwgb3JpZ2luYWxWYWx1ZSA9PT0gJ2lubGluZS1ibG9jaycgPyAnbm9uZScgOiAnYmxvY2snO1xuICB9XG59XG5cbi8qKlxuICogV2hlbiBhbiBhbmltYXRpb24gaXMgY29tcGxldGUsIGNsZWFuIHVwIGFuZCBydW4gdGhlIGNhbGxiYWNrLlxuICogQHBhcmFtICB7T2JqZWN0fSBwYXJhbXNcbiAqL1xuZnVuY3Rpb24gb25Db21wbGV0ZShwYXJhbXMpIHtcblxuICAvLyBSZXNldCB0b2dnbGUgZWwgdmlzaWJpbGl0eVxuICBpZiAocGFyYW1zLnRvZ2dsZUNsYXNzTmFtZSkge1xuICAgICgwLCBfdG9nZ2xlQ2xhc3MyLmRlZmF1bHQpKHBhcmFtcy5lbCwgcGFyYW1zLnRvZ2dsZUNsYXNzTmFtZSwgIXBhcmFtcy5jb2xsYXBzZSk7XG4gIH0gZWxzZSB7XG4gICAgcGFyYW1zLnRvZ2dsZUVsLnN0eWxlW3BhcmFtcy50b2dnbGVQcm9wZXJ0eV0gPSAnJztcbiAgfVxuXG4gIC8vIFJlbW92ZSB0aGUgaGVpZ2h0IHByb3BlcnR5XG4gIHBhcmFtcy5lbC5zdHlsZS5oZWlnaHQgPSAnJztcbiAgcGFyYW1zLnRvZ2dsZUVsLnN0eWxlLmhlaWdodCA9ICcnO1xuICBwYXJhbXMudG9nZ2xlRWwuc3R5bGUubWFyZ2luQm90dG9tID0gJyc7XG4gIHBhcmFtcy50b2dnbGVFbC5zdHlsZS5tYXJnaW5Ub3AgPSAnJztcblxuICAvLyBSZW1vdmUgdGhlIHNwYXJrLWFuaW1hdGUtaGVpZ2h0IGNsYXNzIHNvIHRoZSB0cmFuc2l0aW9ucyBubyBsb25nZXIgYXBwbHlcbiAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkocGFyYW1zLmVsLCBwYXJhbXMuaGVpZ2h0QW5pbWF0aW9uQ2xhc3MpO1xuICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KShwYXJhbXMudG9nZ2xlRWwsIHBhcmFtcy5oZWlnaHRBbmltYXRpb25DbGFzcyk7XG5cbiAgLy8gUnVuIHRoZSBjYWxsYmFja1xuICBwYXJhbXMub25Db21wbGV0ZSgpO1xuXG4gIC8vIFJlbW92ZSB0aGUgZWxlbWVudCBhbmQgY2FsbGJhY2sgZnJvbSB0aGVpciByZXNwZWN0aXZlIGFycmF5c1xuICB2YXIgcnVubmluZ0luZGV4ID0gcnVubmluZ0FuaW1hdGlvbnMuZWxzLmluZGV4T2YocGFyYW1zLmVsKTtcbiAgcnVubmluZ0FuaW1hdGlvbnMuZWxzLnNwbGljZShydW5uaW5nSW5kZXgsIDEpO1xuICBydW5uaW5nQW5pbWF0aW9ucy5jb21wbGV0ZUNhbGxiYWNrcy5zcGxpY2UocnVubmluZ0luZGV4LCAxKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGVIZWlnaHQocGFyYW1zKSB7XG5cbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gIHZhciBlbCA9IHBhcmFtcy5lbDtcblxuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbGxhcHNlID0gcGFyYW1zLmFjdGlvbiAmJiBwYXJhbXMuYWN0aW9uID09PSAnY29sbGFwc2UnO1xuICB2YXIgaGVpZ2h0QW5pbWF0aW9uQ2xhc3MgPSBwYXJhbXMuaGVpZ2h0QW5pbWF0aW9uQ2xhc3MgfHwgJ3NwYXJrLWFuaW1hdGUtaGVpZ2h0JztcblxuICAvLyBBbGxvdyBmb3IgZWxlbWVudHMgdG8gYmUgcGFzc2VkIG9yIHNlbGVjdG9yIHN0cmluZ3NcbiAgdmFyIHRvZ2dsZUVsID0gdHlwZW9mIHBhcmFtcy50b2dnbGVFbCA9PT0gJ3N0cmluZycgPyBlbC5xdWVyeVNlbGVjdG9yKHBhcmFtcy50b2dnbGVFbCkgOiBwYXJhbXMudG9nZ2xlRWw7XG5cbiAgLy8gTm8gZWxlbWVudCB0byBiZSBzd2l0Y2hpbmcgd2l0aCB0b2dnbGluZyBzbyB3ZSBjYW4ndCBkZXRlcm1pbmUgdGhlIGRlc2lyZWQgaGVpZ2h0IHRvIGFuaW1hdGUgdG8uXG4gIGlmICghdG9nZ2xlRWwgfHwgKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkoZWwsICdzcGFyay1uby1hbmltYXRlJykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdG9nZ2xlQ2xhc3NOYW1lID0gcGFyYW1zLnRvZ2dsZUNsYXNzO1xuXG4gIC8vIFRoZSBzdHlsZSBwcm9wZXJ0eSB0byB1c2Ugd2hlbiB0b2dnbGluZyB2aXNpYmlsaXR5XG4gIHZhciB0b2dnbGVQcm9wZXJ0eSA9IHBhcmFtcy50b2dnbGVQcm9wZXJ0eSB8fCAnZGlzcGxheSc7XG4gIHZhciB0b2dnbGVTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0b2dnbGVFbCk7XG4gIHZhciBvcmlnaW5hbFRvZ2dsZVZhbHVlID0gdG9nZ2xlU3R5bGVzW3RvZ2dsZVByb3BlcnR5XTtcbiAgdmFyIHRvZ2dsZVZhbHVlID0gcGFyYW1zLnRvZ2dsZVZhbHVlIHx8IGdldEludmVyc2VUb2dnbGVWYWx1ZSh0b2dnbGVQcm9wZXJ0eSwgb3JpZ2luYWxUb2dnbGVWYWx1ZSk7XG5cbiAgLy8gSWYgd2UgYXJlIGFscmVhZHkgYW5pbWF0aW5nLCBzdG9wIG5vdy5cbiAgdmFyIHJ1bm5pbmdJbmRleCA9IHJ1bm5pbmdBbmltYXRpb25zLmVscy5pbmRleE9mKGVsKTtcbiAgaWYgKHJ1bm5pbmdJbmRleCAhPT0gLTEpIHtcblxuICAgIHZhciBjb21wbGV0ZUNhbGxiYWNrID0gcnVubmluZ0FuaW1hdGlvbnMuY29tcGxldGVDYWxsYmFja3NbcnVubmluZ0luZGV4XTtcbiAgICBpZiAoY29tcGxldGVDYWxsYmFjaykge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbXBsZXRlQ2FsbGJhY2spO1xuICAgIH1cblxuICAgIG9uQ29tcGxldGUoe1xuICAgICAgZWw6IGVsLFxuICAgICAgdG9nZ2xlRWw6IHRvZ2dsZUVsLFxuICAgICAgb25Db21wbGV0ZTogcGFyYW1zLm9uQ29tcGxldGUgfHwgbm9vcCxcbiAgICAgIGNvbGxhcHNlOiBjb2xsYXBzZSxcbiAgICAgIHRvZ2dsZVByb3BlcnR5OiB0b2dnbGVQcm9wZXJ0eSxcbiAgICAgIHRvZ2dsZUNsYXNzTmFtZTogdG9nZ2xlQ2xhc3NOYW1lLFxuICAgICAgdG9nZ2xlVmFsdWU6IHRvZ2dsZVZhbHVlLFxuICAgICAgaGVpZ2h0QW5pbWF0aW9uQ2xhc3M6IGhlaWdodEFuaW1hdGlvbkNsYXNzXG4gICAgfSk7XG4gIH1cblxuICAvLyBTdG9yZSB0aGUgY3VycmVudCBoZWlnaHRcbiAgdmFyIG9yaWdpbmFsSGVpZ2h0ID0gKDAsIF9vdXRlckhlaWdodDIuZGVmYXVsdCkoZWwpO1xuXG4gIC8vIFRvZ2dsZSB0aGUgdmlzaWJsZSBwcm9wZXJ0eVxuICBpZiAodG9nZ2xlQ2xhc3NOYW1lKSB7XG4gICAgKDAsIF90b2dnbGVDbGFzczIuZGVmYXVsdCkoZWwsIHRvZ2dsZUNsYXNzTmFtZSwgIWNvbGxhcHNlKTtcbiAgfSBlbHNlIHtcbiAgICB0b2dnbGVFbC5zdHlsZVt0b2dnbGVQcm9wZXJ0eV0gPSB0b2dnbGVWYWx1ZTtcbiAgfVxuXG4gIC8vIFdoZW4gbWVhc3VyaW5nIHRoZSBzaXplIGZvciBhIGNvbGxhcHNlLCB3ZSBoYXZlIHRvIHdhaXQgYSB0aWMgZm9yIGl0IHRvIGJlXG4gIC8vIGFjY3VyYXRlLiBOb3Qgc3VyZSB3aHkuIFVnaC5cbiAgaWYgKGNvbGxhcHNlKSB7XG4gICAgc2V0VGltZW91dChydW5BbmltYXRpb24sIDApO1xuICB9IGVsc2Uge1xuICAgIHJ1bkFuaW1hdGlvbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcnVuQW5pbWF0aW9uKCkge1xuXG4gICAgLy8gTm93IHRoYXQgdGhlIHRvZ2dsZSBlbCBpcyB0YWtpbmcgdXAgc3BhY2UsIGdldCB0aGUgbmV3IGhlaWdodCB3aGljaCB3ZSB3aWxsIGJlIGFuaW1hdGluZyB0b1xuICAgIHZhciB0YXJnZXRFbEhlaWdodCA9ICgwLCBfb3V0ZXJIZWlnaHQyLmRlZmF1bHQpKGVsKTtcblxuICAgIC8vIFdlIG5lZWQgdG8gc3RvcmUgdGhlIG9yaWdpbmFsIGFuZCB0YXJnZXQgdG9nZ2xlIGVsZW1lbnQgaGVpZ2h0cy4gVGhleSBkaWZmZXIgZGVwZW5kaW5nIG9uXG4gICAgLy8gd2hldGhlciB3ZSBhcmUgZ29pbmcgdG8gZXhwYW5kIG9yIGNvbGxhcHNlLlxuICAgIHZhciB0YXJnZXRUb2dnbGVFbEhlaWdodCA9IHZvaWQgMDtcbiAgICB2YXIgb3JpZ2luYWxUb2dnbGVFbEhlaWdodCA9IHZvaWQgMDtcblxuICAgIC8vIElmIHdlIGFyZSBjb2xsYXBzaW5nLCByZXNldCB0aGUgdG9nZ2xlIHN0eWxlIGFuZCBzZXQgaXQgd2hlbiB3ZSdyZSBkb25lLiBTZXQgdGhlIGhlaWdodCBzb1xuICAgIC8vIHRoYXQgd2UgY2FuIGFuaW1hdGUgZG93biB0byAwIG9yIHVwIHRvIHRoZSB0YXJnZXQgaGVpZ2h0LlxuICAgIGlmIChjb2xsYXBzZSkge1xuXG4gICAgICBpZiAodG9nZ2xlQ2xhc3NOYW1lKSB7XG4gICAgICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKGVsLCB0b2dnbGVDbGFzc05hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9nZ2xlRWwuc3R5bGVbdG9nZ2xlUHJvcGVydHldID0gb3JpZ2luYWxUb2dnbGVWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgb3JpZ2luYWxUb2dnbGVFbEhlaWdodCA9ICgwLCBfb3V0ZXJIZWlnaHQyLmRlZmF1bHQpKHRvZ2dsZUVsLCB0b2dnbGVTdHlsZXMpO1xuICAgICAgdGFyZ2V0VG9nZ2xlRWxIZWlnaHQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRUb2dnbGVFbEhlaWdodCA9ICgwLCBfb3V0ZXJIZWlnaHQyLmRlZmF1bHQpKHRvZ2dsZUVsLCB0b2dnbGVTdHlsZXMpO1xuICAgICAgb3JpZ2luYWxUb2dnbGVFbEhlaWdodCA9IDA7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBvcmlnaW5hbCBoZWlnaHRcbiAgICBlbC5zdHlsZS5oZWlnaHQgPSBvcmlnaW5hbEhlaWdodCArICdweCc7XG4gICAgdG9nZ2xlRWwuc3R5bGUuaGVpZ2h0ID0gb3JpZ2luYWxUb2dnbGVFbEhlaWdodCArICdweCc7XG4gICAgdG9nZ2xlRWwuc3R5bGUubWFyZ2luQm90dG9tID0gJzBweCc7XG4gICAgdG9nZ2xlRWwuc3R5bGUubWFyZ2luVG9wID0gJzBweCc7XG5cbiAgICAvLyBBZGQgdGhlIHNwYXJrLWFuaW1hdGUtaGVpZ2h0IGNsYXNzIHdoaWNoIHdpbGwgc2V0dXAgdGhlIHRyYW5zaXRpb24tcHJvcGVydHkgYW5kIGR1cmF0aW9uXG4gICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkoZWwsIGhlaWdodEFuaW1hdGlvbkNsYXNzKTtcbiAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0b2dnbGVFbCwgaGVpZ2h0QW5pbWF0aW9uQ2xhc3MpO1xuXG4gICAgcnVubmluZ0FuaW1hdGlvbnMuZWxzLnB1c2goZWwpO1xuXG4gICAgLy8gV2UgbmVlZCB0byB3YWl0IGEgdGljayB0byB0b2dnbGUgdGhlIGhlaWdodCBvciBlbHNlIHRoZSBhbmltYXRpb24gY2xhc3Mgd29uJ3QgZnVuY3Rpb25cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblxuICAgICAgLy8gU2V0IHRoZSBoZWlnaHQgdG8gdGhlIHRhcmdldCBoZWlnaHRcbiAgICAgIGVsLnN0eWxlLmhlaWdodCA9IHRhcmdldEVsSGVpZ2h0ICsgJ3B4JztcbiAgICAgIHRvZ2dsZUVsLnN0eWxlLmhlaWdodCA9IHRhcmdldFRvZ2dsZUVsSGVpZ2h0ICsgJ3B4JztcblxuICAgICAgLy8gUmVtb3ZlIGlubGluZSBzdHlsZXMgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZVxuICAgICAgcnVubmluZ0FuaW1hdGlvbnMuY29tcGxldGVDYWxsYmFja3MucHVzaChzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb25Db21wbGV0ZSh7XG4gICAgICAgICAgZWw6IGVsLFxuICAgICAgICAgIHRvZ2dsZUVsOiB0b2dnbGVFbCxcbiAgICAgICAgICBvbkNvbXBsZXRlOiBwYXJhbXMub25Db21wbGV0ZSB8fCBub29wLFxuICAgICAgICAgIGNvbGxhcHNlOiBjb2xsYXBzZSxcbiAgICAgICAgICB0b2dnbGVQcm9wZXJ0eTogdG9nZ2xlUHJvcGVydHksXG4gICAgICAgICAgdG9nZ2xlQ2xhc3NOYW1lOiB0b2dnbGVDbGFzc05hbWUsXG4gICAgICAgICAgdG9nZ2xlVmFsdWU6IHRvZ2dsZVZhbHVlLFxuICAgICAgICAgIGhlaWdodEFuaW1hdGlvbkNsYXNzOiBoZWlnaHRBbmltYXRpb25DbGFzc1xuICAgICAgICB9KTtcbiAgICAgIH0sIHBhcmFtcy5hbmltYXRpb25EdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gcGFyYW1zLmFuaW1hdGlvbkR1cmF0aW9uIDogMjAxKSk7XG4gICAgfSwgMCk7XG4gIH1cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gYW5pbWF0ZUhlaWdodDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVpZ2h0LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIyBUcmFuc2Zvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEFwcGx5IGEgY3Jvc3MtYnJvd3NlciB0cmFuc2Zvcm0gc3R5bGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRyYW5zZm9ybSgndHJhbnNsYXRlWCcsICctMTAwcHgnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgaGVscGVycy9jc3MvdHJhbnNmb3JtLmpzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxudmFyIF9lYWNoID0gcmVxdWlyZSgnLi4vdXRpbC9lYWNoJyk7XG5cbnZhciBfZWFjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHByZWZpeGVzID0gWyctd2Via2l0LScsICctbW96LScsICctby0nLCAnLW1zLScsICcnXTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtKHR5cGUsIHZhbCkge1xuXG4gIHZhciBzdHIgPSAnJztcblxuICAoMCwgX2VhY2gyLmRlZmF1bHQpKHByZWZpeGVzLCBmdW5jdGlvbiAocCkge1xuXG4gICAgaWYgKCh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHN0ciArPSBwICsgJ3RyYW5zZm9ybTogJztcblxuICAgICAgZm9yICh2YXIgaiBpbiB2YWwpIHtcbiAgICAgICAgc3RyICs9IGogKyAnKCcgKyB2YWxbal0gKyAnKTsgJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9IHAgKyAndHJhbnNmb3JtOiAnICsgdHlwZSArICcoJyArIHZhbCArICcpOyAnO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHJhbnNmb3JtO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2Zvcm0uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHJpbSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJpbScpO1xuXG52YXIgX3RyaW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJpbSk7XG5cbnZhciBfaGFzQ2xhc3MgPSByZXF1aXJlKCcuL2hhcy1jbGFzcycpO1xuXG52YXIgX2hhc0NsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhc0NsYXNzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiAjIEFkZCBDbGFzc1xuICogQWRkIGEgY2xhc3Mgb24gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXl9IGVsIEFuIGVsZW1lbnQgb3IgYXJyYXkgb2YgZWxlbWVudHMgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL2RvbS9hZGQtY2xhc3MuanNcbiAqL1xuXG52YXIgd3MgPSAvXFxzKy87XG52YXIgY2xlYW51cCA9IC9cXHN7Mix9L2c7XG5cbmZ1bmN0aW9uIGFkZENsYXNzKGVsLCBuYW1lKSB7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgbmFtZSA9ICgwLCBfdHJpbTIuZGVmYXVsdCkobmFtZSkuc3BsaXQod3MpO1xuICB9IGVsc2Uge1xuICAgIG5hbWUgPSBuYW1lIGluc3RhbmNlb2YgQXJyYXkgPyBuYW1lIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgfVxuXG4gIC8vIG9wdGltaXplIGZvciBiZXN0LCBtb3N0IGNvbW1vbiBjYXNlXG4gIGlmIChuYW1lLmxlbmd0aCA9PT0gMSAmJiBlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAobmFtZVswXSkge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChuYW1lWzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgdmFyIHRvQWRkID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBuYW1lLmxlbmd0aDtcbiAgdmFyIGl0ZW0gPSB2b2lkIDA7XG4gIHZhciBjbHNOYW1lID0gdHlwZW9mIGVsLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycgPyBlbC5jbGFzc05hbWUgOiBlbC5nZXRBdHRyaWJ1dGUgPyBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgOiAnJztcblxuICAvLyBzZWUgaWYgd2UgaGF2ZSBhbnl0aGluZyB0byBhZGRcbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBpdGVtID0gbmFtZVtpXTtcbiAgICBpZiAoaXRlbSAmJiAhKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkoY2xzTmFtZSwgaXRlbSkpIHtcbiAgICAgIHRvQWRkLnB1c2goaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRvQWRkLmxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgZWwuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZWwuY2xhc3NOYW1lID0gKDAsIF90cmltMi5kZWZhdWx0KSgoY2xzTmFtZSArICcgJyArIHRvQWRkLmpvaW4oJyAnKSkucmVwbGFjZShjbGVhbnVwLCAnICcpKTtcbiAgICB9IGVsc2UgaWYgKGVsLnNldEF0dHJpYnV0ZSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsICgwLCBfdHJpbTIuZGVmYXVsdCkoKGNsc05hbWUgKyAnICcgKyB0b0FkZC5qb2luKCcgJykpLnJlcGxhY2UoY2xlYW51cCwgJyAnKSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbDtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gYWRkQ2xhc3M7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZC1jbGFzcy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIEJyZWFrcG9pbnQgSGVscGVyc1xuICogRmluZCB0aGUgYWN0aXZlIGJyZWFrcG9pbnQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL2RvbS9icmVha3BvaW50LmpzXG4gKi9cblxuLyoqXG4gKiBCcmVha3BvaW50cyBiZWluZyB1c2VkIGluIHRoZSBDU1MuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgZGVmYXVsdEJyZWFrcG9pbnRzID0ge1xuICB4czoge1xuICAgIG1pbjogMCxcbiAgICBtYXg6IDU0M1xuICB9LFxuICBzbToge1xuICAgIG1pbjogNTQ0LFxuICAgIG1heDogNzk1XG4gIH0sXG4gIG1kOiB7XG4gICAgbWluOiA3OTYsXG4gICAgbWF4OiAxMDQ3XG4gIH0sXG4gIGxnOiB7XG4gICAgbWluOiAxMDQ4LFxuICAgIG1heDogMTc5OVxuICB9LFxuICB4bDoge1xuICAgIG1pbjogMTgwMCxcbiAgICBtYXg6IEluZmluaXR5XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldCh3aWR0aCwgYnJlYWtwb2ludHMpIHtcblxuICBicmVha3BvaW50cyA9IGJyZWFrcG9pbnRzIHx8IGRlZmF1bHRCcmVha3BvaW50cztcblxuICB2YXIgaSA9IHZvaWQgMDtcblxuICBmb3IgKGkgaW4gYnJlYWtwb2ludHMpIHtcbiAgICBpZiAod2lkdGggPj0gYnJlYWtwb2ludHNbaV0ubWluICYmIHdpZHRoIDw9IGJyZWFrcG9pbnRzW2ldLm1heCkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuZ2V0ID0gZ2V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJlYWtwb2ludC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4vKipcbiAqICMgSGFzIENsYXNzXG4gKiBTZWUgaWYgYW4gZWxlbWVudCBoYXMgYSBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL2RvbS9oYXMtY2xhc3MuanNcbiAqL1xuZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIG5hbWUpIHtcbiAgdmFyIGNOYW1lID0gKCh0eXBlb2YgZWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGVsKSkgPT09ICdvYmplY3QnID8gZWwuY2xhc3NOYW1lIHx8IGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycgOiBlbCB8fCAnJykucmVwbGFjZSgvW1xcdFxcclxcblxcZl0vZywgJyAnKTtcbiAgcmV0dXJuICgnICcgKyBjTmFtZSArICcgJykuaW5kZXhPZignICcgKyBuYW1lICsgJyAnKSAhPT0gLTE7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGhhc0NsYXNzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXMtY2xhc3MuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZWFjaCA9IHJlcXVpcmUoJy4uL3V0aWwvZWFjaCcpO1xuXG52YXIgX2VhY2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFjaCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBwcm9wcyA9IFsnbWFyZ2luVG9wJywgJ21hcmdpbkJvdHRvbScsICdib3JkZXJUb3AnLCAnYm9yZGVyQm90dG9tJ107IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIyBPdXRlciBIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEdldCB0aGUgb3V0ZXIgaGVpZ2h0IG9mIGFuIGVsZW1lbnQgKGluY2x1ZGluZyBtYXJnaW4gYW5kIGJvcmRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzIE9wdGlvbmFsIEFscmVhZHkgaGF2ZSBjb21wdXRlZCBzdHlsZXM/IFBhc3MgdGhlbSBpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogb3V0ZXJIZWlnaHQoZWwsIGNvbXB1dGVkU3R5bGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIGhlbHBlcnMvb3V0ZXItaGVpZ2h0LmpzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuXG5mdW5jdGlvbiBvdXRlckhlaWdodChlbCwgc3R5bGVzKSB7XG5cbiAgc3R5bGVzID0gc3R5bGVzIHx8IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcblxuICB2YXIgaGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuXG4gICgwLCBfZWFjaDIuZGVmYXVsdCkocHJvcHMsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgaGVpZ2h0ICs9IHBhcnNlSW50KHN0eWxlc1twcm9wXSB8fCAwLCAxMCk7XG4gIH0pO1xuXG4gIHJldHVybiBoZWlnaHQ7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG91dGVySGVpZ2h0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vdXRlci1oZWlnaHQuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgUGFyc2UgRE9NIGF0dHJpYnV0ZXNcbiAqIEdpdmVuIGFuIGVsZW1lbnQgYW5kIGFuIGF0dHJpYnV0ZSBuYW1lLCBwYXJzZSB0aGF0IGF0dHJpYnV0ZVxuICogaWYgaXQgZXhpc3RzIG9yIHJldHVybiBhIGRlZmF1bHQuXG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL2RvbS9wYXJzZS1hdHRyaWJ1dGUuanNcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgYm9vbGVhbiB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcbiAqIGZhbGxpbmcgYmFjayB0byB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGRlZlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYm9vbGVhbihlbCwgbmFtZSwgZGVmKSB7XG4gIHZhciB2YWwgPSBlbC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiBkZWY7XG4gIHJldHVybiB2YWwgPT09ICd0cnVlJyB8fCB2YWwgPT09ICcnID8gdHJ1ZSA6IGZhbHNlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbnVtZXJpYyB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcbiAqIGZhbGxpbmcgYmFjayB0byB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGRlZlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gbnVtYmVyKGVsLCBuYW1lLCBkZWYpIHtcbiAgdmFyIHZhbCA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuIGRlZjtcbiAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYm9vbGVhbiB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcbiAqIGZhbGxpbmcgYmFjayB0byB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGRlZlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc3RyaW5nKGVsLCBuYW1lLCBkZWYpIHtcbiAgdmFyIHZhbCA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuIGRlZjtcbiAgcmV0dXJuIHZhbDtcbn1cblxuZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhbjtcbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS1hdHRyaWJ1dGUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHJpbSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJpbScpO1xuXG52YXIgX3RyaW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJpbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciB3cyA9IC9cXHMrLzsgLyoqXG4gICAgICAgICAgICAgICAgICogIyBSZW1vdmUgQ2xhc3NcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmUgYSBjbGFzcyBvbiBhbiBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fEFycmF5fSBlbCBBbiBlbGVtZW50IG9yIGFycmF5IG9mIGVsZW1lbnRzIHRvIHVwZGF0ZS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIGhlbHBlcnMvZG9tL3JlbW92ZS1jbGFzcy5qc1xuICAgICAgICAgICAgICAgICAqL1xuXG52YXIgY2xlYW51cCA9IC9cXHN7Mix9L2c7XG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBuYW1lKSB7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgbmFtZSA9ICgwLCBfdHJpbTIuZGVmYXVsdCkobmFtZSkuc3BsaXQod3MpO1xuICB9IGVsc2Uge1xuICAgIG5hbWUgPSBuYW1lIGluc3RhbmNlb2YgQXJyYXkgPyBuYW1lIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgfVxuXG4gIC8vIG9wdGltaXplIGZvciBiZXN0LCBtb3N0IGNvbW1vbiBjYXNlXG4gIGlmIChuYW1lLmxlbmd0aCA9PT0gMSAmJiBlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAobmFtZVswXSkgZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lWzBdKTtcbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICAvLyBzdG9yZSB0d28gY29waWVzXG4gIHZhciBjbHNOYW1lID0gJyAnICsgKHR5cGVvZiBlbC5jbGFzc05hbWUgPT09ICdzdHJpbmcnID8gZWwuY2xhc3NOYW1lIDogZWwuZ2V0QXR0cmlidXRlID8gZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIDogJycpICsgJyAnO1xuICB2YXIgcmVzdWx0ID0gY2xzTmFtZTtcbiAgdmFyIGN1cnJlbnQgPSB2b2lkIDA7XG4gIHZhciBzdGFydCA9IHZvaWQgMDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBuYW1lLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGN1cnJlbnQgPSBuYW1lW2ldO1xuICAgIHN0YXJ0ID0gY3VycmVudCA/IHJlc3VsdC5pbmRleE9mKCcgJyArIGN1cnJlbnQgKyAnICcpIDogLTE7XG4gICAgaWYgKHN0YXJ0ICE9PSAtMSkge1xuICAgICAgc3RhcnQgKz0gMTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBzdGFydCkgKyByZXN1bHQuc2xpY2Uoc3RhcnQgKyBjdXJyZW50Lmxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgLy8gb25seSB3cml0ZSBpZiBtb2RpZmllZFxuICBpZiAoY2xzTmFtZSAhPT0gcmVzdWx0KSB7XG4gICAgaWYgKHR5cGVvZiBlbC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbC5jbGFzc05hbWUgPSAoMCwgX3RyaW0yLmRlZmF1bHQpKHJlc3VsdC5yZXBsYWNlKGNsZWFudXAsICcgJykpO1xuICAgIH0gZWxzZSBpZiAoZWwuc2V0QXR0cmlidXRlKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKDAsIF90cmltMi5kZWZhdWx0KShyZXN1bHQucmVwbGFjZShjbGVhbnVwLCAnICcpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSByZW1vdmVDbGFzcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZlLWNsYXNzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2hhc0NsYXNzID0gcmVxdWlyZSgnLi9oYXMtY2xhc3MnKTtcblxudmFyIF9oYXNDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYXNDbGFzcyk7XG5cbnZhciBfYWRkQ2xhc3MgPSByZXF1aXJlKCcuL2FkZC1jbGFzcycpO1xuXG52YXIgX2FkZENsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FkZENsYXNzKTtcblxudmFyIF9yZW1vdmVDbGFzcyA9IHJlcXVpcmUoJy4vcmVtb3ZlLWNsYXNzJyk7XG5cbnZhciBfcmVtb3ZlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVtb3ZlQ2xhc3MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB0b2dnbGVDbGFzcyhlbCwgbmFtZSwgZW5hYmxlKSB7XG5cbiAgaWYgKCFlbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIHdlJ3JlIHBhc3NlZCBhbiBhcnJheSwgdG9nZ2xlIHRoZSBjbGFzcyBvbiBlYWNoLlxuICBpZiAoZWwgaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCBlbCBpbnN0YW5jZW9mIEFycmF5KSB7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRvZ2dsZUNsYXNzKGVsW2ldLCBuYW1lLCBlbmFibGUpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBhY3Rpb24gPSB2b2lkIDA7XG4gIGlmIChlbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuYWJsZSA9IHR5cGVvZiBlbmFibGUgPT09ICdmdW5jdGlvbicgPyBlbmFibGUuY2FsbChudWxsLCBlbCkgOiBlbmFibGU7XG4gICAgYWN0aW9uID0gZW5hYmxlID8gJ2FkZCcgOiAncmVtb3ZlJztcbiAgfSBlbHNlIHtcbiAgICBhY3Rpb24gPSAoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KShlbCwgbmFtZSkgPyAncmVtb3ZlJyA6ICdhZGQnO1xuICB9XG5cbiAgcmV0dXJuIChhY3Rpb24gPT09ICdhZGQnID8gX2FkZENsYXNzMi5kZWZhdWx0IDogX3JlbW92ZUNsYXNzMi5kZWZhdWx0KShlbCwgbmFtZSk7XG59IC8qKlxuICAgKiAjIFRvZ2dsZSBDbGFzc1xuICAgKiBUb2dnbGUgYSBjbGFzcyBvbiBhbiBlbGVtZW50IGdpdmVuIGEgY29uZGl0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXl9IGVsIEFuIGVsZW1lbnQgb3IgYXJyYXkgb2YgZWxlbWVudHMgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZVxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKlxuICAgKiBAbW9kdWxlICBoZWxwZXJzL2RvbS90b2dnbGUtY2xhc3MuanNcbiAgICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IHRvZ2dsZUNsYXNzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2dnbGUtY2xhc3MuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZWFjaCA9IHJlcXVpcmUoJy4uL3V0aWwvZWFjaCcpO1xuXG52YXIgX2VhY2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFjaCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkcmVuKGVsLCBjaGlsZHJlbiwgZW1wdHkpIHtcblxuICBlbXB0eSA9IGVtcHR5ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGVtcHR5O1xuXG4gIGlmIChlbXB0eSkge1xuICAgIGVsLnRleHRDb250ZW50ID0gJyc7XG4gIH1cblxuICB2YXIgZG9tTGlzdCA9IGNoaWxkcmVuIGluc3RhbmNlb2Ygd2luZG93LkhUTUxDb2xsZWN0aW9uO1xuXG4gIGlmIChkb21MaXN0KSB7XG4gICAgd2hpbGUgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgZWwuYXBwZW5kQ2hpbGQoY2hpbGRyZW5bMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAoMCwgX2VhY2gyLmRlZmF1bHQpKGNoaWxkcmVuLCBmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMpIHtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0gLyoqXG4gICAqICMgQXBwZW5kIENoaWxkcmVuXG4gICAqIEFwcGVuZCBhbiBhcnJheSBvZiBjaGlsZHJlbiB0byBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtBcnJheX0gY2hpbGRyZW5cbiAgICogQHBhcmFtIHtCb29sZWFufSBlbXB0eSBFbXB0eSB0aGUgbm9kZSBiZWZvcmUgYWRkaW5nIGNoaWxkcmVuP1xuICAgKlxuICAgKiBAbW9kdWxlIGhlbHBlcnMvbWFuaXB1bGF0aW9uL2FwcGVuZC1jaGlsZHJlbi5qc1xuICAgKi9cblxuZXhwb3J0cy5kZWZhdWx0ID0gYXBwZW5kQ2hpbGRyZW47XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcGVuZC1jaGlsZHJlbi5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9lYWNoID0gcmVxdWlyZSgnLi4vdXRpbC9lYWNoJyk7XG5cbnZhciBfZWFjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKGVsLCBiZWZvcmVFbCwgY2hpbGRyZW4pIHtcbiAgKDAsIF9lYWNoMi5kZWZhdWx0KShjaGlsZHJlbiwgZnVuY3Rpb24gKGMpIHtcbiAgICBlbC5pbnNlcnRCZWZvcmUoYywgYmVmb3JlRWwpO1xuICB9KTtcbn0gLyoqXG4gICAqICMgSW5zZXJ0IEJlZm9yZVxuICAgKiBJbnNlcnQgYW4gYXJyYXkgb2YgZWxlbWVudHMgYmVmb3JlIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGJlZm9yZUVsXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNoaWxkcmVuXG4gICAqXG4gICAqIEBtb2R1bGUgaGVscGVycy9tYW5pcHVsYXRpb24vaW5zZXJ0LWJlZm9yZS5qc1xuICAgKi9cblxuZXhwb3J0cy5kZWZhdWx0ID0gaW5zZXJ0QmVmb3JlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnNlcnQtYmVmb3JlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIFdyYXAgRWxlbWVudFxuICogV3JhcCBhbiBlbGVtZW50IHdpdGggYW5vdGhlciBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gd3JhcHBlclxuICogQHJldHVybiB7RWxlbWVudH1cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvbWFuaXB1bGF0aW9uL3dyYXAtZWxlbWVudC5qc1xuICovXG5mdW5jdGlvbiB3cmFwRWxlbWVudChlbCwgd3JhcHBlcikge1xuXG4gIHdyYXBwZXIgPSB3cmFwcGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gIGlmIChlbC5uZXh0U2libGluZykge1xuICAgIGVsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHdyYXBwZXIsIGVsLm5leHRTaWJsaW5nKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuICB9XG5cbiAgcmV0dXJuIHdyYXBwZXIuYXBwZW5kQ2hpbGQoZWwpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB3cmFwRWxlbWVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3JhcC1lbGVtZW50LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21hdGNoZXMgPSByZXF1aXJlKCcuL21hdGNoZXMnKTtcblxudmFyIF9tYXRjaGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGNoZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXRDaGlsZChlbCwgcXVlcnkpIHtcblxuICB2YXIgaSA9IDA7XG4gIHZhciBsZW4gPSBlbC5jaGlsZHJlbi5sZW5ndGg7XG5cbiAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICgoMCwgX21hdGNoZXMyLmRlZmF1bHQpKGVsLmNoaWxkcmVuW2ldLCBxdWVyeSkpIHtcbiAgICAgIHJldHVybiBlbC5jaGlsZHJlbltpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0gLyoqXG4gICAqICMgR2V0IENoaWxkXG4gICAqIEdldCBhIGNoaWxkIHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5XG4gICAqIEByZXR1cm4ge0VsZW1lbnR8TnVsbH1cbiAgICpcbiAgICogQG1vZHVsZSBoZWxwZXJzL3RyYXZlcnNhbC9nZXQtY2hpbGQuanNcbiAgICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGdldENoaWxkO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtY2hpbGQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBHZXQgSW5kZXhcbiAqIEdldCB0aGUgaW5kZXggb2YgYW4gZWxlbWVudCBpbiBhIG5vZGVsaXN0LlxuICpcbiAqIEBwYXJhbSB7Tm9kZUxpc3R9IGVsc1xuICogQHBhcmFtIHtOb2RlfSBlbFxuICogQHJldHVybiB7TnVtYmVyfVxuICpcbiAqIEBtb2R1bGUgaGVscGVycy90cmF2ZXJzYWwvZ2V0LWluZGV4LmpzXG4gKi9cbmZ1bmN0aW9uIGdldEluZGV4KGVscywgZWwpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoZWxzLCBlbCk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGdldEluZGV4O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1pbmRleC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tYXRjaGVzID0gcmVxdWlyZSgnLi9tYXRjaGVzJyk7XG5cbnZhciBfbWF0Y2hlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRjaGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0UGFyZW50KHBhcmVudCwgcXVlcnksIGxpbWl0RWwpIHtcblxuICBsaW1pdEVsID0gbGltaXRFbCBpbnN0YW5jZW9mIEFycmF5ID8gbGltaXRFbCA6IFtsaW1pdEVsIHx8IGRvY3VtZW50LmJvZHldO1xuXG4gIHdoaWxlIChwYXJlbnQpIHtcblxuICAgIGlmICgoMCwgX21hdGNoZXMyLmRlZmF1bHQpKHBhcmVudCwgcXVlcnkpKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIGlmIChsaW1pdEVsLmluZGV4T2YocGFyZW50KSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLyoqXG4gICAqICMgR2V0IFBhcmVudFxuICAgKiBTZWUgaWYgYW4gZWxlbWVudCBoYXMgYW5vdGhlciBlbGVtZW50IGZvciBhIHBhcmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5XG4gICAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gbGltaXRFbCBUaGUgbGFzdCBlbGVtZW50IHdlIHNob3VsZCBjaGVjay5cbiAgICogQHJldHVybiB7Qm9vbGVhbnxFbGVtZW50fVxuICAgKlxuICAgKiBAbW9kdWxlIGhlbHBlcnMvdHJhdmVyc2FsL2dldC1wYXJlbnQuanNcbiAgICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGdldFBhcmVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXBhcmVudC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nZXRQYXJlbnQgPSByZXF1aXJlKCcuL2dldC1wYXJlbnQnKTtcblxudmFyIF9nZXRQYXJlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UGFyZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0UGFyZW50cyhwYXJlbnQsIHF1ZXJ5LCBsaW1pdEVsKSB7XG5cbiAgdmFyIGxpc3QgPSBbXTtcblxuICB3aGlsZSAocGFyZW50ID0gKDAsIF9nZXRQYXJlbnQyLmRlZmF1bHQpKHBhcmVudC5wYXJlbnROb2RlLCBxdWVyeSwgbGltaXRFbCkpIHtcbiAgICBsaXN0LnB1c2gocGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBsaXN0O1xufSAvKipcbiAgICogIyBHZXQgUGFyZW50c1xuICAgKiBTZWUgaWYgYW4gZWxlbWVudCBoYXMgcGFyZW50cyB3aGljaCBtYXRjaCBhIHF1ZXJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcXVlcnlcbiAgICogQHBhcmFtIHtFbGVtZW50fSBsaW1pdEVsIFRoZSBsYXN0IGVsZW1lbnQgd2Ugc2hvdWxkIGNoZWNrLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufEFycmF5fVxuICAgKlxuICAgKiBAbW9kdWxlIGhlbHBlcnMvdHJhdmVyc2FsL2dldC1wYXJlbnRzLmpzXG4gICAqL1xuXG5leHBvcnRzLmRlZmF1bHQgPSBnZXRQYXJlbnRzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtcGFyZW50cy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIEhhcyBQYXJlbnRcbiAqIFNlZSBpZiBhbiBlbGVtZW50IGhhcyBhbm90aGVyIGVsZW1lbnQgZm9yIGEgcGFyZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gY2hpbGRcbiAqIEBwYXJhbSB7RWxlbWVudH0gcG9zc2libGVQYXJlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL3RyYXZlcnNhbC9oYXMtcGFyZW50LmpzXG4gKi9cbmZ1bmN0aW9uIGhhc1BhcmVudChjaGlsZCwgcG9zc2libGVQYXJlbnQpIHtcblxuICB2YXIgcGFyZW50ID0gY2hpbGQucGFyZW50Tm9kZTtcblxuICB3aGlsZSAocGFyZW50KSB7XG5cbiAgICBpZiAocGFyZW50ID09PSBwb3NzaWJsZVBhcmVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGhhc1BhcmVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXMtcGFyZW50LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIE1hdGNoZXNcbiAqIFNlZSBpZiBhbiBlbGVtZW50IG1hdGNoZXMgYSBxdWVyeSBzZWxlY3Rvci5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL3RyYXZlcnNhbC9tYXRjaGVzLmpzXG4gKi9cbnZhciB2ZW5kb3JNYXRjaCA9IHR5cGVvZiBFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAoRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5vTWF0Y2hlc1NlbGVjdG9yKTtcblxuZnVuY3Rpb24gbWF0Y2hlcyhlbCwgcXVlcnkpIHtcblxuICBpZiAodmVuZG9yTWF0Y2gpIHJldHVybiB2ZW5kb3JNYXRjaC5jYWxsKGVsLCBxdWVyeSk7XG5cbiAgdmFyIG5vZGVzID0gZWwucGFyZW50Tm9kZSA/IGVsLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChxdWVyeSkgOiBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5vZGVzW2ldID09PSBlbCkgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG1hdGNoZXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGNoZXMuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgRWFjaFxuICogQXBwbHkgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBhIGxpc3Qgb2YgYW55IGtpbmQ6IEFycmF5LCBOb2RlTGlzdCwgSFRNTENvbGxlY3Rpb24gb3IgT2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8Tm9kZUxpc3R8SFRNTENvbGxlY3Rpb258T2JqZWN0fSBsaXN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICpcbiAqIEBleGFtcGxlXG4gKiBlYWNoKFtdLCBjYWxsYmFjayk7XG4gKiBlYWNoKGVsLmNoaWxkcmVuLCBjYWxsYmFjayk7XG4gKiBlYWNoKGVsLmNoaWxkTm9kZXMsIGNhbGxiYWNrKTtcbiAqIGVhY2goe30sIGNhbGxiYWNrKTtcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdXRpbC9lYWNoLmpzXG4gKi9cbmZ1bmN0aW9uIGVhY2gobGlzdCwgY2IpIHtcblxuICBpZiAoIWxpc3QpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52b2tlIGBlYWNoYCB3aXRob3V0IGEgY2FsbGJhY2shJyk7XG4gIH1cblxuICB2YXIgaSA9IDA7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcblxuICAvLyBPYmplY3RcbiAgaWYgKGxlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChpIGluIGxpc3QpIHtcbiAgICAgIGlmIChpICE9PSAncHJvdG90eXBlJyAmJiBsaXN0Lmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGNiKGksIGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBBcnJheS1saWtlXG4gIGVsc2Uge1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjYihsaXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGVhY2g7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVhY2guanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgVHJpbVxuICogVHJpbSB3aGl0ZXNwYWNlIG9uIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdXRpbC90cmltLmpzXG4gKi9cblxudmFyIHRyaW1SRSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHRyaW1SRSwgJycpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0cmltO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmltLmpzLm1hcFxuIl19"}