{"version":3,"sources":["helpers/position/affix.js"],"names":["Affix","params","el","targetEl","caretEl","anchorY","anchorX","isFixed","_addEventListeners","_insertEl","_setPosition","_updateDebounced","update","bind","remove","keepEl","_removeEl","_removeEventListeners","_onResizeBound","_onResize","_onScrollBound","_onScroll","window","addEventListener","removeEventListener","setAttribute","_getRootEl","appendChild","parentNode","removeChild","removeAttribute","style","setProperty","targetTop","top","targetLeft","left","targetWidth","offsetWidth","targetHeight","offsetHeight","elWidth","elHeight","docHeight","document","documentElement","docWidth","_calculatePosition","minX","minY","maxX","maxY","Math","max","elTop","elLeft","_positionCaret","extraLeft","extraTop","p","previousAttempts","previousChecks","finalCheck","indexOf","push","_getNewAnchorY","isOverlapping","_getNewAnchorX","width","height","repositionY","repositionX","underMin","caretPosition","caretDimensions","getBoundingClientRect","caretWidth","caretHeight","min","round","form","querySelector","getAttribute","body"],"mappings":"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","file":"affix.js","sourcesContent":["/**\n * # Affix\n * Affix one element to another.\n *\n * @example\n * new Affix({\n *   el: el,\n *   targetEl: el2,\n *   caretEl: el3,\n *   anchorY: 'top', // 'middle', 'bottom'\n *   anchorX: 'left', // 'center', 'right'\n * })\n *\n * @module helpers/position/affix.js\n */\n\nimport offset from '../dom/offset';\nimport boxPosition from './box-position';\nimport debounce from '../util/debounce';\n\nclass Affix {\n\n  /**\n   * Store the reference elements and position.\n   * @param  {Object} params\n   */\n  constructor(params = {}) {\n\n    this.el = params.el;\n    this.targetEl = params.targetEl;\n    this.caretEl = params.caretEl;\n    this.anchorY = params.anchorY || 'top';\n    this.anchorX = params.anchorX || 'center';\n    this.isFixed = params.isFixed || false;\n\n    this._addEventListeners();\n    this._insertEl();\n    this._setPosition();\n    this._updateDebounced = debounce(this.update.bind(this), 500);\n  }\n\n\n  /**\n   * Stop listening and clean up event listeners\n   * @param {Object} params Optional\n   * @return {Object} this\n   */\n  remove(params = {}) {\n    if (!params.keepEl) this._removeEl();\n    this._removeEventListeners();\n    return this;\n  }\n\n\n  /**\n   * Update the position.\n   * @return {Object} this\n   */\n  update() {\n    this._setPosition();\n    return this;\n  }\n\n\n  /**\n   * Listen for window resizes to update the position.\n   */\n  _addEventListeners() {\n    this._onResizeBound = this._onResize.bind(this);\n    this._onScrollBound = this._onScroll.bind(this);\n    window.addEventListener('resize', this._onResizeBound);\n    window.addEventListener('scroll', this._onScrollBound);\n  }\n\n\n  /**\n   * Remove event listeners\n   */\n  _removeEventListeners() {\n    window.removeEventListener('resize', this._onResizeBound);\n    window.removeEventListener('scroll', this._onScrollBound);\n  }\n\n\n  /**\n   * Insert the element into the DOM.\n   */\n  _insertEl() {\n    this.el.setAttribute('data-affixed', '');\n    this._getRootEl().appendChild(this.el);\n  }\n\n\n  /**\n   * Remove the element from the DOM.\n   */\n  _removeEl() {\n    this.el.parentNode.removeChild(this.el);\n    this.el.removeAttribute('data-affixed');\n  }\n\n\n  /**\n   * Set the position of the target element.\n   */\n  _setPosition() {\n\n    // Fixed position\n    this.el.style.setProperty('position', this.isFixed ? 'fixed' : 'absolute', 'important');\n\n    // Target element properties\n    let {top: targetTop, left: targetLeft} = offset(this.targetEl, this.isFixed);\n    let targetWidth = this.targetEl.offsetWidth;\n    let targetHeight = this.targetEl.offsetHeight;\n\n    // Element to affix properties\n    let elWidth = this.el.offsetWidth;\n    let elHeight = this.el.offsetHeight;\n\n    // Maxes\n    let docHeight = document.documentElement.offsetHeight;\n    let docWidth = document.documentElement.offsetWidth;\n\n    // Get the values\n    let {elTop, elLeft} = this._calculatePosition({\n      anchorX: this.anchorX,\n      anchorY: this.anchorY,\n      targetTop,\n      targetLeft,\n      elHeight,\n      elWidth,\n      targetHeight,\n      targetWidth,\n      minX: 0,\n      minY: 0,\n      maxX: docWidth - elWidth,\n      maxY: Math.max(docHeight - elHeight, 0)\n    });\n\n    // Position the caret\n    let {extraLeft, extraTop} = this._positionCaret({\n      elLeft,\n      elTop,\n      elWidth,\n      elHeight,\n      targetHeight,\n      targetWidth,\n      targetLeft,\n      targetTop\n    });\n\n    // Set the position\n    this.el.style.left = elLeft + extraLeft + 'px';\n    this.el.style.top = elTop + extraTop + 'px';\n  }\n\n\n  /**\n   * Get the proper top position for an anchor direction.\n   * @param  {Object} p\n   * @return {Object}\n   */\n  _calculatePosition(p) {\n\n    // Keep track of what we're trying to do here, so on subsequent, nested calls to this\n    // method we can see what has already been tried.\n    p.previousAttempts = (p.previousAttempts || 0) + 1;\n    p.previousChecks = p.previousChecks || [];\n\n    let finalCheck = p.previousAttempts > 3;\n    let top;\n    let left;\n\n    // Y-axis check\n    switch (p.anchorY) {\n      case 'bottom':\n        top = p.targetTop + p.targetHeight;\n        break;\n      case 'middle':\n        top = p.targetTop - ((p.elHeight - p.targetHeight) / 2);\n        break;\n      default:\n        top = p.targetTop - p.elHeight;\n        break;\n    }\n\n    // Under min\n    if (top < p.minY) {\n\n      if (!finalCheck && p.previousChecks.indexOf('overY') === -1) {\n        p.previousChecks.push('underY');\n        p.anchorY = this._getNewAnchorY(true, p.anchorY, p.anchorX);\n        return this._calculatePosition(p);\n      }\n      else {\n        top = p.minY;\n      }\n    }\n\n    // Don't check for being too tall because causing a vertical scroll\n    // bar down is okay and this saves us from some real positioning hell.\n    /*if (top > p.maxY) {\n\n      if (!finalCheck && p.previousChecks.indexOf('underY') === -1) {\n        p.previousChecks.push('overY');\n        p.anchorY = this._getNewAnchorY(false, p.anchorY, p.anchorX);\n        return this._calculatePosition(p);\n      }\n      // On a final check, bottom wins because at least we can scroll\n      else if (!(finalCheck && p.anchorY === 'bottom')) {\n        top = p.maxY;\n      }\n    }*/\n\n    // X-axis check\n    switch (p.anchorX) {\n      case 'right':\n        left = p.targetLeft + (p.anchorY !== 'middle' && !p.isOverlapping ? 0 : p.targetWidth);\n        break;\n      case 'center':\n        left = p.targetLeft - ((p.elWidth - p.targetWidth) / 2);\n        break;\n      default:\n        left = p.targetLeft - p.elWidth + (p.anchorY !== 'middle' ? p.targetWidth : 0);\n        break;\n    }\n\n    // Under min\n    if (left < p.minX) {\n\n      if (!finalCheck && p.previousChecks.indexOf('overX') === -1) {\n        p.previousChecks.push('underX');\n        p.anchorX = this._getNewAnchorX(true, p.anchorX, p.anchorY);\n        return this._calculatePosition(p);\n      }\n      else {\n        left = p.minX;\n      }\n    }\n\n    // Over max\n    if (left > p.maxX) {\n\n      if (!finalCheck && p.previousChecks.indexOf('underX') === -1) {\n        p.previousChecks.push('overX');\n        p.anchorX = this._getNewAnchorX(false, p.anchorX, p.anchorY);\n        return this._calculatePosition(p);\n      }\n      else {\n        left = p.maxX;\n      }\n    }\n\n    // One element is covering another. Try to fix that, but bail out after four tries.\n    if (boxPosition(\n      {width: p.elWidth, height: p.elHeight, left: left, top: top},\n      {width: p.targetWidth, height: p.targetHeight, left: p.targetLeft, top: p.targetTop}\n    ) === 'overlap') {\n\n      p.isOverlapping = true;\n\n      // Try Y\n      if (p.repositionY !== false) {\n\n        // Will start undefined, then true, then false. This limits us to entering\n        // this loop twice, once to try moving in each direction.\n        p.repositionY = !p.repositionY;\n\n        // First try to put above, then try to put below.\n        p.anchorY = this._getNewAnchorY(p.repositionY, 'middle', p.anchorX);\n\n        // Give us one more shot at positioning\n        p.previousAttempts--;\n\n        return this._calculatePosition(p);\n      }\n      // Try X\n      else if (p.repositionX !== false) {\n\n        // Will start undefined, then true, then false. This limits us to entering\n        // this loop twice, once to try moving in each direction.\n        p.repositionX = !p.repositionX;\n\n        // First try to put above, then try to put below.\n        p.anchorX = this._getNewAnchorX(p.repositionX, 'center', p.anchorY);\n\n        // Give us one more shot at positioning\n        p.previousAttempts--;\n\n        return this._calculatePosition(p);\n      }\n    }\n\n    return {elTop: top, elLeft: left, anchorX: p.anchorX, anchorY: p.anchorY};\n  }\n\n\n  /**\n   * Determine the new y-axis anchor\n   * @param  {Boolean} underMin Under the min?\n   * @param  {String} anchorY\n   * @param  {String} anchorX\n   * @return {String}\n   */\n  _getNewAnchorY(underMin, anchorY, anchorX) {\n\n    // If the x-axis is anchored in the center, skip\n    // trying to anchor to the middle because then we'd\n    // be overlaying the button.\n    if (anchorX === 'center' || anchorY === 'middle') {\n      return underMin ? 'bottom' : 'top';\n    }\n    else {\n      return 'middle';\n    }\n  }\n\n\n  /**\n   * Determine the new y-axis anchor\n   * @param  {Boolean} underMin Under the min?\n   * @param  {String} anchorY\n   * @param  {String} anchorX\n   * @return {String}\n   */\n  _getNewAnchorX(underMin, anchorX, anchorY) {\n\n    // If the y-axis is anchored in the center, skip\n    // trying to anchor to the middle because then we'd\n    // be overlaying the button.\n    if (anchorY === 'middle' || anchorX === 'center') {\n      return underMin ? 'left' : 'right';\n    }\n    else {\n      return 'center';\n    }\n  }\n\n\n  /**\n   * Set the position of the caret.\n   * @param {Object} p\n   * @return {Object}\n   */\n  _positionCaret(p = {}) {\n\n    if (!this.caretEl) return;\n\n    let caretPosition = boxPosition(\n      {width: p.elWidth, height: p.elHeight, left: p.elLeft, top: p.elTop},\n      {width: p.targetWidth, height: p.targetHeight, left: p.targetLeft, top: p.targetTop}\n    );\n\n    let caretDimensions = this.caretEl.getBoundingClientRect();\n    let caretWidth = caretDimensions.width;\n    let caretHeight = caretDimensions.height;\n    let left = Math.min(p.elWidth, Math.max(0, p.targetLeft - p.elLeft + (p.targetWidth / 2)));\n    let top = Math.min(p.elHeight, Math.max(0, p.targetTop - p.elTop + (p.targetHeight / 2)));\n\n    this.caretEl.style.left = Math.round(left) + 'px';\n    this.caretEl.style.top = Math.round(top) + 'px';\n\n    let extraLeft = 0;\n    let extraTop = 0;\n\n    this.caretEl.setAttribute('data-position', caretPosition);\n\n\n    switch (caretPosition) {\n      case 'above':\n        extraTop = -caretWidth / 2;\n        break;\n      case 'below':\n        extraTop = caretWidth / 2;\n        break;\n      case 'left':\n        extraLeft = -caretHeight / 2;\n        break;\n      default:\n        extraLeft = caretHeight / 2;\n        break;\n    }\n\n    return {\n      extraLeft: extraLeft,\n      extraTop: extraTop\n    };\n  }\n\n\n  /**\n   * Get the root element. Want to check if there's a top-level form for working\n   * with ASP .NET pages.\n   */\n  _getRootEl() {\n    let form = document.querySelector('body > form');\n    return form && form.getAttribute('data-affixed') === null ? form : document.body;\n  }\n\n\n  /**\n   * On resize, update the position.\n   */\n  _onResize() {\n    this.update();\n  }\n\n\n  /**\n   * When the window scrolls, ensure the proper position of the popover.\n   */\n  _onScroll() {\n    this._updateDebounced();\n  }\n}\n\nexport default Affix;\n"]}