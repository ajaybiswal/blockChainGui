{"version":3,"sources":["helpers/date/parse-format.js"],"names":["map","d","m","y","getValues","format","value","i","index","len","length","values","indexOf","name","parseInt","substr","create","getString","vals","str","parseDateFormat","f","toLowerCase","obj","parts","push"],"mappings":"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","file":"parse-format.js","sourcesContent":["/**\n * # Parse Date Format\n * Given a date format string, break it down into pieces.\n *\n * @example\n * parseDateFormat('MM-DD-YYYY');\n *\n * @module helpers/date/parse-format.js\n */\n\nimport padNumber from '../util/pad';\nimport dateHelper from './date';\n\n/**\n * Map characters to their special meanings.\n * @type {Object}\n */\nconst map = {\n  d: 'day',\n  m: 'month',\n  y: 'year',\n  '-': 'divider',\n  '/': 'divider',\n  ' ': 'space'\n};\n\n/**\n * Given a format and a string, get the day, month and year values from that string.\n * @param {Object} format\n * @return {Function}\n */\nfunction getValues(format) {\n\n  return function(value) {\n\n    let i = 0;\n    let index = 0;\n    let len = format.length;\n    let values = {};\n\n    // Loop through all format pieces\n    for (; i < len; i++) {\n\n      // Only worry about date values\n      if (['day', 'month', 'year'].indexOf(format[i].name) !== -1) {\n\n        // If the passed value doesn't contain a format piece, it's invalid.\n        if (value.length < index + format[i].length)\n          return;\n\n        values[format[i].name] = parseInt(value.substr(index, format[i].length), 10);\n      }\n      index += format[i].length;\n    }\n\n    return dateHelper.create(values);\n  };\n}\n\n/**\n * Create a formatted date string given an object of values.\n * @param {Object} format\n * @return {Function}\n */\nfunction getString(format) {\n\n  /**\n   * @param {Object} vals\n   * @return {String}\n   */\n  return function(vals) {\n\n    let i = 0;\n    let len = format.length;\n    let str = '';\n\n    for (; i < len; i++) {\n\n      // Numbers\n      if (vals[format[i].name]) {\n        str += padNumber(vals[format[i].name], format[i].length);\n      }\n      // Dividers\n      else {\n        str += format[i].value;\n      }\n    }\n\n    return str;\n  };\n}\n\n/**\n * @param {String} format\n * @return {Object}\n */\nfunction parseDateFormat(format) {\n\n  let f = format.toLowerCase();\n  let i = 0;\n  let len = f.length;\n\n  let obj = {\n    parts: []\n  };\n\n  for (; i < len; i++) {\n\n    // If there is a matching character mapping and the last part was of the same name, increment its length\n    // and add to its content.\n    if (map[f[i]] && obj.parts.length && obj.parts[obj.parts.length - 1].name === map[f[i]]) {\n      obj.parts[obj.parts.length - 1].length++;\n      obj.parts[obj.parts.length - 1].value += format[i];\n      continue;\n    }\n\n    obj.parts.push({\n      name: map[f[i]] ? map[f[i]] : '',\n      value: format[i],\n      length: 1\n    });\n  }\n\n  // Add a way to convert the parsed date into a regex-ish string that works with the Typeahead implementation.\n  obj.getValues = getValues(obj.parts);\n  obj.getString = getString(obj.parts);\n\n  return obj;\n}\n\nexport default parseDateFormat;\n"]}