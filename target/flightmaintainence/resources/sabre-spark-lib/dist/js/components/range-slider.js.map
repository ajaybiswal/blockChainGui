{"version":3,"sources":["js/dist/components/node_modules/browser-pack/_prelude.js","js/dist/components/js/dist/components/base.js","js/dist/components/js/dist/components/range-slider.js","js/dist/components/js/dist/helpers/animation/height.js","js/dist/components/js/dist/helpers/dom/add-class.js","js/dist/components/js/dist/helpers/dom/has-class.js","js/dist/components/js/dist/helpers/dom/make-element.js","js/dist/components/js/dist/helpers/dom/offset.js","js/dist/components/js/dist/helpers/dom/outer-height.js","js/dist/components/js/dist/helpers/dom/remove-class.js","js/dist/components/js/dist/helpers/dom/toggle-class.js","js/dist/components/js/dist/helpers/traversal/get-index.js","js/dist/components/js/dist/helpers/util/each.js","js/dist/components/js/dist/helpers/util/mixin.js","js/dist/components/js/dist/helpers/util/trim.js","js/dist/components/js/dist/mixins/messaging.js","js/dist/components/js/dist/mixins/validation.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"range-slider.js","sourcesContent":["(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _each = require('../helpers/util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * # Base Component\n                                                                                                                                                           * The base class for Spark JS components. This class should never be\n                                                                                                                                                           * instantiated directly.\n                                                                                                                                                           *\n                                                                                                                                                           * @param {Element} el\n                                                                                                                                                           * @param {Object} params\n                                                                                                                                                           *\n                                                                                                                                                           * @module components/base.js\n                                                                                                                                                           */\n\nvar noop = function noop() {};\n\nvar Base = function () {\n\n  /**\n   * Set parameters and cache elements.\n   */\n  function Base(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Base);\n\n    if (params.elRequired && !el) {\n      return;\n    }\n\n    this.setParams(this.defaults || {}, true);\n    this.setParams(params);\n    (this._cacheElements || noop).call(this, el, params);\n    (this._parseParams || noop).call(this);\n  }\n\n  /**\n   * Remove the component from the DOM and prepare for garbage collection by dereferencing values.\n   * @param {Boolean} leaveElement Leave the element intact.\n   */\n\n\n  Base.prototype.remove = function remove(leaveElement) {\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    if (!leaveElement && this.el && this.el.parentNode) {\n      this.el.parentNode.removeChild(this.el);\n    }\n\n    this.unsetParams(this.defaults);\n\n    return this;\n  };\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   * @param {Object} params Optional\n   */\n\n\n  Base.prototype.update = function update(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    (this._cacheElements || noop).call(this, el || this.el, params);\n    (this._parseParams || noop).call(this);\n\n    if (this._addEventListeners) {\n      this._addEventListeners();\n    }\n\n    return this;\n  };\n\n  /**\n   * Set a hash of parameters if they're whitelisted or we're told to force the set.\n   * This is used to set initial values as well as set passed parameters.\n   * @param {Object} params\n   * @param {Boolean} force Force setting even if the param is not whitelisted.\n   */\n\n\n  Base.prototype.setParams = function setParams(params, force) {\n    var _this = this;\n\n    (0, _each2.default)(params, function (k, v) {\n      if (_this._whitelistedParams.indexOf(k) !== -1 || force) {\n        _this[k] = v;\n      }\n    });\n\n    return this;\n  };\n\n  /**\n   * Unset all parameters.\n   * @param {Array|Object} keys\n   * @param {Object} scope The object to unset the params from. Defaults to `this`.\n   */\n\n\n  Base.prototype.unsetParams = function unsetParams(keys, scope) {\n\n    keys = keys instanceof Array ? keys : Object.keys(keys);\n    scope = scope || this;\n    (0, _each2.default)(keys, function (k) {\n      delete scope[k];\n    });\n\n    return this;\n  };\n\n  return Base;\n}();\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nBase.prototype._whitelistedParams = [];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nBase.prototype.defaults = {};\n\nexports.default = Base;\nmodule.exports = exports['default'];\n//# sourceMappingURL=base.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _base = require('./base');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _toggleClass = require('../helpers/dom/toggle-class');\n\nvar _toggleClass2 = _interopRequireDefault(_toggleClass);\n\nvar _offset = require('../helpers/dom/offset');\n\nvar _offset2 = _interopRequireDefault(_offset);\n\nvar _getIndex = require('../helpers/traversal/get-index');\n\nvar _getIndex2 = _interopRequireDefault(_getIndex);\n\nvar _messaging = require('../mixins/messaging');\n\nvar _messaging2 = _interopRequireDefault(_messaging);\n\nvar _mixin = require('../helpers/util/mixin');\n\nvar _mixin2 = _interopRequireDefault(_mixin);\n\nvar _validation = require('../mixins/validation');\n\nvar _validation2 = _interopRequireDefault(_validation);\n\nvar _makeElement = require('../helpers/dom/make-element');\n\nvar _makeElement2 = _interopRequireDefault(_makeElement);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * # RangeSlider\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * A dual slider for number inputs.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @todo : probably a lot of refactoring that could happen between this and slider.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @example\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * new RangeSlider(el, {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   // Optional. Slide along the x or y-axis?\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   isX: true,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   onChange: function(inst, index, value){},\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * });\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module components/range-slider.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\nvar noop = function noop() {};\n\nvar RangeSlider = function (_BaseComponent) {\n  _inherits(RangeSlider, _BaseComponent);\n\n  /**\n   * RangeSlider constructor.\n   * @param {Element} el\n   * @param {Object} params\n   */\n  function RangeSlider(el) {\n    var _this;\n\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, RangeSlider);\n\n    params.elRequired = true;\n\n    if (!(_this = _possibleConstructorReturn(this, _BaseComponent.call(this, el, params)), _this)) {\n      return _possibleConstructorReturn(_this);\n    }\n\n    _this._bindEventListenerCallbacks();\n    _this._addEventListeners();\n    _this._updateDisabledClasses();\n    return _possibleConstructorReturn(_this);\n  }\n\n  /**\n   * Start the slider moving.\n   * @param {Number} index The index of the handle or input element.\n   * @param {Number} position The position of the pointer.\n   * @param {String} type Optional Which type of events to listen for.\n   */\n\n\n  RangeSlider.prototype.start = function start(index, position, type) {\n\n    // Noop if we're disabled or an invalid index was passed\n    if (index < 0 || this.inputEls[index].getAttribute('disabled') !== null) {\n      return this;\n    }\n\n    this._addMoveEventListeners(type || 'mouse');\n    this._cacheSize();\n\n    this.isActive = this.isActive || [];\n    this.isActive[index] = true;\n\n    this.currentIndex = index;\n    this._updateActiveClasses(index);\n    this._updateDisabledClasses();\n    this._oldVal = this.values[index];\n    this.move(position);\n\n    return this;\n  };\n\n  /**\n   * Move the value to a given position\n   * @param {Number} position\n   * @param {Boolean} force Force the move Optional\n   */\n\n\n  RangeSlider.prototype.move = function move(position, force) {\n\n    // Noop if an invalid index was passed we haven't yet started dragging\n    if ((!position || !this.isActive || !this.isActive[this.currentIndex]) && !force) {\n      return this;\n    }\n\n    // Treat positions beyond the boundaries as the boundaries\n    if (this.isX) {\n\n      // Too far left\n      if (position < this.offsetLeft) {\n        position = this.offsetLeft;\n      }\n      // Too far right\n      else if (position > this.offsetLeft + this.width) {\n          position = this.offsetLeft + this.width;\n        }\n    } else {\n\n      // Too far top\n      if (position < this.offsetTop) {\n        position = this.offsetTop;\n      }\n      // Too far bottom\n      else if (position > this.offsetTop + this.height) {\n          position = this.offsetTop + this.height;\n        }\n    }\n\n    // The percentage of the new position relative to slider-container width or height.\n    var percentage = this.isX ? (position - this.offsetLeft) / (this.width - this.handleSize) : (position - this.offsetTop) / this.height;\n\n    // The value of the input as a percentage of the value range.\n    this.setValue(this.currentIndex, Math.round((percentage - this.handleSizePercentage / 2) * (this.highestMax - this.lowestMin)) + this.lowestMin);\n\n    return this;\n  };\n\n  /**\n   * Stop listening to movements.\n   * @param {Number} index Optional The index of the handle or input element.\n   * @param {String} type Optional Which type of events to listen for.\n   */\n\n\n  RangeSlider.prototype.stop = function stop(index, type) {\n\n    if (index !== null && index !== undefined && this.currentIndex !== index) {\n      return this;\n    }\n\n    this.isActive[this.currentIndex] = false;\n    this.lastIndex = this.currentIndex;\n\n    if (this._oldVal !== this.values[this.currentIndex]) {\n      (this.onChange || noop)(this.currentIndex, this.values[this.currentIndex], this);\n    }\n\n    this.currentIndex = null;\n    this._updateActiveClasses(index);\n    this._removeMoveEventListeners(type || 'mouse');\n\n    return this;\n  };\n\n  /**\n   * Set the value of the handle.\n   * @param {Number} index The index of the input element.\n   * @param {Number} value\n   */\n\n\n  RangeSlider.prototype.setValue = function setValue(index, value) {\n\n    // We don't have an input element at that index, so something went wrong.\n    if (!this.inputEls[index]) {\n      throw new Error('Cannot set value on a slider input element with an index of ' + index + '. That element does not exist.');\n    }\n\n    // Move in increments if we have a defined step size\n    if (this.steps[index]) {\n      value = value - value % this.steps[index];\n    }\n\n    this.values = this.values || [];\n\n    // Check bounds of the new value\n    if (value > this.maxes[index]) {\n      value = this.maxes[index];\n    } else if (value < this.mins[index]) {\n      value = this.mins[index];\n    }\n\n    // If there is an input that comes after this, make sure we aren't going beyond it\n    if (this.values[index + 1] !== undefined && value >= this.values[index + 1]) {\n      value = this.values[index + 1] - (this.steps[index] || 1);\n    }\n    // If there is an input that comes before this, make sure we aren't going below it\n    else if (this.values[index - 1] !== undefined && value <= this.values[index - 1]) {\n        value = this.values[index - 1] + (this.steps[index] || 1);\n      }\n\n    // If there is an onWillChange callback, run it. If it returns\n    // false, then this new value should be considered invalid.\n    if (typeof this.onWillChange === 'function') {\n      var change = this.onWillChange(index, value, this);\n      if (typeof change === 'number') {\n        value = change;\n      }\n    }\n\n    // Store value\n    this.values[index] = value;\n\n    // Update elements\n    this.inputEls[index].value = this.values[index];\n    this.handleEls[index].setAttribute('data-value', this.values[index]);\n    this.handleEls[index].setAttribute('aria-valuenow', this.values[index]);\n    this.handleEls[index].setAttribute('aria-valuetext', this.values[index]);\n\n    // Set the percentage\n    this.percentages = this.percentages || [];\n    this.percentages[index] = (this.values[index] - this.lowestMin) / (this.highestMax - this.lowestMin);\n\n    // Update the position of the handle\n    this._updateHandlePosition(index);\n\n    return this;\n  };\n\n  /**\n   * Get the value.\n   * @param {Number} index\n   * @return {Number}\n   */\n\n\n  RangeSlider.prototype.getValue = function getValue(index) {\n\n    // We don't have an input element at that index, so something went wrong.\n    if (!this.inputEls[index]) {\n      throw new Error('Cannot get value from a slider input element with an index of ' + index + '. That element does not exist.');\n    }\n\n    return this.values[index];\n  };\n\n  /**\n   * Clear the value.\n   * @param {Number} index\n   */\n\n\n  RangeSlider.prototype.clearValue = function clearValue(index) {\n    return this.setValue(index, 0);\n  };\n\n  /**\n   * Enable the input.\n   * @param {Number} index\n   */\n\n\n  RangeSlider.prototype.enable = function enable(index) {\n\n    // We don't have an input element at that index, so something went wrong.\n    if (!this.inputEls[index] || !this.handleEls[index]) {\n      throw new Error('Cannot get value from a slider input element with an index of ' + index + '. That element does not exist.');\n    }\n\n    this.inputEls[index].removeAttribute('disabled');\n    this.inputEls[index].removeAttribute('tabindex');\n    this.handleEls[index].removeAttribute('disabled');\n    this.handleEls[index].removeAttribute('tabindex');\n    this._updateDisabledClasses();\n\n    return this;\n  };\n\n  /**\n   * Disable the input.\n   * @param {Number} index\n   */\n\n\n  RangeSlider.prototype.disable = function disable(index) {\n\n    // We don't have an input element at that index, so something went wrong.\n    if (!this.inputEls[index] || !this.handleEls[index]) {\n      throw new Error('Cannot get value from a slider input element with an index of ' + index + '. That element does not exist.');\n    }\n\n    this.inputEls[index].setAttribute('disabled', '');\n    this.inputEls[index].setAttribute('tabindex', '-1');\n    this.handleEls[index].setAttribute('disabled', '');\n    this.handleEls[index].setAttribute('tabindex', '-1');\n    this._updateDisabledClasses();\n\n    return this;\n  };\n\n  /**\n   * Increment the value by the step size.\n   * @param {Boolean} useMultiplier Optional Increment by a multiplied version of the step\n   */\n\n\n  RangeSlider.prototype.increment = function increment(useMultiplier) {\n    return this.setValue(this.currentIndex, this.values[this.currentIndex] + this.steps[this.currentIndex] * (useMultiplier ? 10 : 1));\n  };\n\n  /**\n   * Decrement the value by the step size.\n   * @param {Boolean} useMultiplier Optional Increment by a multiplied version of the step\n   */\n\n\n  RangeSlider.prototype.decrement = function decrement(useMultiplier) {\n    return this.setValue(this.currentIndex, this.values[this.currentIndex] - this.steps[this.currentIndex] * (useMultiplier ? 10 : 1));\n  };\n\n  /**\n   * Remove the element from the DOM and prepare for garbage collection by dereferencing values.\n   * @param {Boolean} leaveElement Leave the element intact.\n   */\n\n\n  RangeSlider.prototype.remove = function remove(leaveElement) {\n    this._removeMoveEventListeners('touch');\n    this._removeMoveEventListeners('mouse');\n    this._removeMoveEventListeners('keyboard');\n    return _BaseComponent.prototype.remove.call(this, leaveElement);\n  };\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   */\n\n\n  RangeSlider.prototype.update = function update(el) {\n\n    this._removeEventListeners();\n    this._removeMoveEventListeners('touch');\n    this._removeMoveEventListeners('mouse');\n    this._removeMoveEventListeners('keyboard');\n\n    this._cacheElements(el);\n    this._addEventListeners();\n    this._updateDisabledClasses();\n\n    for (var i = 0; i < this.handleEls.length; i++) {\n      this._updateHandlePosition(i);\n    }\n\n    return this;\n  };\n\n  /**\n   * Store a reference to the whole slider, as well as the\n   * input element. Also, get some default values from the input\n   * element (min, max, steps).\n   * @param {Element} el\n   */\n\n\n  RangeSlider.prototype._cacheElements = function _cacheElements(el) {\n\n    this.el = el;\n    this.controlsEl = this.el.querySelector('.spark-slider__controls');\n    this.inputEls = this.el.querySelectorAll('input[type=\"number\"]');\n    this.handleEls = this.el.querySelectorAll('.spark-slider__handle');\n    this.trackEl = this.el.querySelector('.spark-slider__track');\n    this.trackFillEl = this.trackEl.querySelector('.spark-slider__track-fill');\n\n    this.messageEl = this.el.querySelector('.spark-slider__message') || (0, _makeElement2.default)('<span class=\"spark-slider__message\"></span>');\n\n    if (!this.inputEls || this.inputEls.length <= 1) {\n      throw new Error('Tried to create a slider instance without two number inputs.');\n    }\n\n    if (!this.handleEls || this.handleEls.length <= 1) {\n      throw new Error('Tried to create a slider instance without two handle buttons.');\n    }\n\n    var lowestMin = Infinity;\n    var highestMax = -Infinity;\n    var i = 0;\n    var len = this.inputEls.length;\n    var values = [];\n    this.mins = [];\n    this.maxes = [];\n    this.steps = [];\n\n    // Cache the size of the element so that we can properly set values on handles.\n    this._cacheSize();\n\n    // Set the minimum and max values for each element. Also set any predefined value.\n    for (; i < len; i++) {\n      var parsedMin = parseInt(this.inputEls[i].getAttribute('min'), 10);\n      this.mins[i] = parsedMin === 0 ? parsedMin : parsedMin || null; // Ternary operator to prevent null when we have actual 0 value\n\n      var parsedMax = parseInt(this.inputEls[i].getAttribute('max'), 10);\n      this.maxes[i] = parsedMax === 0 ? parsedMax : parsedMax || null; // Ternary operator to prevent null when we have actual 0 value\n\n      this.steps[i] = parseInt(this.inputEls[i].getAttribute('step'), 10) || 1;\n\n      if (this.mins[i] < lowestMin) {\n        lowestMin = this.mins[i];\n      }\n\n      if (this.maxes[i] > highestMax) {\n        highestMax = this.maxes[i];\n      }\n    }\n\n    this.lowestMin = lowestMin;\n    this.highestMax = highestMax;\n\n    i = 0;\n\n    // If we have a default value, set it.\n    for (; i < len; i++) {\n\n      values[i] = parseInt(this.inputEls[i].getAttribute('value'), 10);\n\n      // It's a number\n      if (!isNaN(values[i])) {\n        this.setValue(i, values[i]);\n      } else {\n\n        // Set as the minimum unless this is the last handle.\n        if (i + 1 === len) {\n          this.setValue(i, this.maxes[i] !== null ? this.maxes[i] : 0);\n        } else {\n          this.setValue(i, this.mins[i] !== null ? this.mins[i] : 0);\n        }\n      }\n    }\n  };\n\n  /**\n   * Save the element dimensions.\n   */\n\n\n  RangeSlider.prototype._cacheSize = function _cacheSize() {\n    this.width = this.trackEl.offsetWidth;\n    this.height = this.trackEl.offsetHeight;\n\n    this.handleSize = this.isX ? this.handleEls[0].offsetWidth : this.handleEls[0].offsetHeight;\n    this.handleSizePercentage = this.isX ? this.handleEls[0].offsetWidth / this.width : this.handleEls[0].offsetHeight / this.height;\n\n    var offset = (0, _offset2.default)(this.controlsEl);\n    this.offsetLeft = offset.left;\n    this.offsetTop = offset.top;\n  };\n\n  /**\n   * Set the position of the handle.\n   * @param {Number} index The index of the handle element to update.\n   */\n\n\n  RangeSlider.prototype._updateHandlePosition = function _updateHandlePosition(index) {\n    // Track and Track-Fill elements\n    var firstPercentage = this.percentages[0];\n    var lastPercentage = this.percentages[this.percentages.length - 1];\n    this.trackFillEl.setAttribute('style', 'width: ' + (lastPercentage - firstPercentage) * 100 + '%; left: ' + firstPercentage * 100 + '%;');\n\n    // Handle position\n    var handlePos = this.handleSize / 2 + (this.values[index] - this.lowestMin) * ((this.width - this.handleSize) / (this.highestMax - this.lowestMin));\n    var handlePosPercentage = handlePos / this.width * 100;\n    this.handleEls[index].setAttribute('style', 'left: ' + handlePosPercentage + '%;');\n  };\n\n  /**\n   * Update the active class on the handle.\n   * @param {Number} index The index of the handle element to update.\n   */\n\n\n  RangeSlider.prototype._updateActiveClasses = function _updateActiveClasses(index) {\n\n    (0, _toggleClass2.default)(this.handleEls, 'active', false);\n    (0, _toggleClass2.default)(this.handleEls[index], 'active', this.isActive[index]);\n\n    if (this.isActive.indexOf(true) !== -1) {\n      this.el.setAttribute('data-active-index', this.isActive.indexOf(true));\n    } else {\n      this.el.removeAttribute('data-active-index');\n    }\n  };\n\n  /**\n   * Update which handles are disabled.\n   */\n\n\n  RangeSlider.prototype._updateDisabledClasses = function _updateDisabledClasses() {\n\n    var disabledCount = 0;\n\n    for (var i = 0, len = this.inputEls.length; i < len; i++) {\n\n      if (this.inputEls[i].getAttribute('disabled') !== null) {\n        (0, _toggleClass2.default)(this.handleEls[i], 'disabled', true);\n        disabledCount++;\n      } else {\n        (0, _toggleClass2.default)(this.handleEls[i], 'disabled', false);\n      }\n    }\n\n    (0, _toggleClass2.default)(this.el, 'all-disabled', disabledCount === this.handleEls.length);\n  };\n\n  /**\n   * Create bound versions of event listener callbacks and store them.\n   * Otherwise we can't unbind from these events later because the\n   * function signatures won't match.\n   */\n\n\n  RangeSlider.prototype._bindEventListenerCallbacks = function _bindEventListenerCallbacks() {\n\n    this._onTouchStartBound = this._onTouchStart.bind(this);\n    this._onTouchMoveBound = this._onTouchMove.bind(this);\n    this._onTouchEndBound = this._onTouchEnd.bind(this);\n\n    this._onClickBound = this._onClick.bind(this);\n    this._onMouseDownBound = this._onMouseDown.bind(this);\n    this._onMouseMoveBound = this._onMouseMove.bind(this);\n    this._onMouseUpBound = this._onMouseUp.bind(this);\n\n    this._onFocusBound = this._onFocus.bind(this);\n    this._onKeydownBound = this._onKeydown.bind(this);\n    this._onBlurBound = this._onBlur.bind(this);\n\n    this._onChangeBound = this._onChange.bind(this);\n\n    this._onResizeBound = this._onResize.bind(this);\n\n    this._onVisibleChildrenBound = this._onVisibleChildren.bind(this);\n  };\n\n  /**\n   * Add event listeners for touchstart and mouse click.\n   */\n\n\n  RangeSlider.prototype._addEventListeners = function _addEventListeners() {\n\n    this.controlsEl.addEventListener('touchstart', this._onTouchStartBound);\n    this.controlsEl.addEventListener('mousedown', this._onMouseDownBound);\n\n    for (var i = 0, len = this.inputEls.length; i < len; i++) {\n      this.inputEls[i].addEventListener('change', this._onChangeBound);\n    }\n\n    for (var j = 0, len2 = this.handleEls.length; j < len2; j++) {\n      this.handleEls[j].addEventListener('focus', this._onFocusBound);\n      this.handleEls[j].addEventListener('click', this._onClickBound);\n    }\n\n    document.addEventListener('spark.visible-children', this._onVisibleChildrenBound, true);\n\n    window.addEventListener('resize', this._onResizeBound);\n    window.addEventListener('orientationchange', this._onResizeBound);\n  };\n\n  /**\n   * Remove event listeners for touchstart and mouse click.\n   */\n\n\n  RangeSlider.prototype._removeEventListeners = function _removeEventListeners() {\n\n    this.controlsEl.removeEventListener('touchstart', this._onTouchStartBound);\n    this.controlsEl.removeEventListener('mousedown', this._onMouseDownBound);\n\n    document.removeEventListener('spark.visible-children', this._onVisibleChildrenBound);\n\n    for (var i = 0, len = this.inputEls.length; i < len; i++) {\n      this.inputEls[i].removeEventListener('change', this._onChangeBound);\n    }\n\n    for (var j = 0, len2 = this.handleEls.length; i < len2; i++) {\n      this.handleEls[j].removeEventListener('focus', this._onFocusBound);\n      this.handleEls[j].removeEventListener('click', this._onClickBound);\n    }\n\n    window.removeEventListener('resize', this._onResizeBound);\n    window.removeEventListener('orientationchange', this._onResizeBound);\n  };\n\n  /**\n   * Add event listeners for touchmove, touchend, mousemove and mouseup.\n   * We add these to the window so that the user can move off of the element\n   * but keep dragging the slider handle. Otherwise it's really hard to\n   * use the slider unless it's massive.\n   * @param {String} type Which type of listeners to add\n   */\n\n\n  RangeSlider.prototype._addMoveEventListeners = function _addMoveEventListeners(type) {\n\n    // Only listen for events of the type we asked for.\n    switch (type) {\n      case 'mouse':\n        window.addEventListener('mousemove', this._onMouseMoveBound);\n        window.addEventListener('mouseout', this._onMouseOutBound);\n        window.addEventListener('mouseup', this._onMouseUpBound);\n        break;\n      case 'touch':\n        window.addEventListener('touchmove', this._onTouchMoveBound);\n        window.addEventListener('touchend', this._onTouchEndBound);\n        break;\n      case 'keyboard':\n        window.addEventListener('keydown', this._onKeydownBound);\n        for (var i = 0, len = this.handleEls.length; i < len; i++) {\n          this.handleEls[i].addEventListener('blur', this._onBlurBound);\n        }\n        break;\n    }\n  };\n\n  /**\n   * Remove event listeners for move events.\n   * @param {String} type Which type of listeners to add\n   */\n\n\n  RangeSlider.prototype._removeMoveEventListeners = function _removeMoveEventListeners(type) {\n\n    // Only unbind events of the type we asked for.\n    switch (type) {\n      case 'mouse':\n        window.removeEventListener('mousemove', this._onMouseMoveBound);\n        window.removeEventListener('mouseup', this._onMouseUpBound);\n        break;\n      case 'touch':\n        window.removeEventListener('touchmove', this._onTouchMoveBound);\n        window.removeEventListener('touchend', this._onTouchEndBound);\n        break;\n      case 'keyboard':\n        window.removeEventListener('keydown', this._onKeydownBound);\n        for (var i = 0, len = this.handleEls.length; i < len; i++) {\n          this.handleEls[i].removeEventListener('blur', this._onBlurBound);\n        }\n        break;\n    }\n  };\n\n  /**\n   * When the touch starts, start the slider.\n   * @param {Object} e\n   */\n\n\n  RangeSlider.prototype._onTouchStart = function _onTouchStart(e) {\n    this.start((0, _getIndex2.default)(this.handleEls, e.target), this.isX ? e.touches[0].pageX : e.touches[0].pageY, 'touch');\n  };\n\n  /**\n   * When the window fires a touchmove event, adjust our value accordingly\n   * @param {Object} e\n   */\n\n\n  RangeSlider.prototype._onTouchMove = function _onTouchMove(e) {\n\n    if (!this.isActive[this.currentIndex]) {\n      return;\n    }\n\n    e.preventDefault();\n\n    this.move(this.isX ? e.touches[0].pageX : e.touches[0].pageY);\n  };\n\n  /**\n   * When the window fires a touchend event, stop tracking touches\n   * @param {Object} e\n   */\n\n\n  RangeSlider.prototype._onTouchEnd = function _onTouchEnd(e) {\n\n    if (!this.isActive[this.currentIndex]) {\n      return;\n    }\n\n    e.preventDefault();\n\n    this.stop((0, _getIndex2.default)(this.handleEls, e.target), 'touch');\n  };\n\n  /**\n   * When the mouse presses down, start the slider.\n   * @param {Object} e\n   */\n\n\n  RangeSlider.prototype._onMouseDown = function _onMouseDown(e) {\n    this.start((0, _getIndex2.default)(this.handleEls, e.target), this.isX ? e.pageX : e.pageY, 'mouse');\n  };\n\n  /**\n   * When the window fires a mousemove event, adjust our value accordingly\n   * @param {Object} e\n   */\n\n\n  RangeSlider.prototype._onMouseMove = function _onMouseMove(e) {\n\n    if (!this.isActive[this.currentIndex]) {\n      return;\n    }\n\n    e.preventDefault();\n\n    this.move(this.isX ? e.pageX : e.pageY);\n  };\n\n  /**\n   * When the window fires a mouseup event, stop tracking\n   * @param {Object} e\n   */\n\n\n  RangeSlider.prototype._onMouseUp = function _onMouseUp() {\n\n    if (!this.isActive[this.currentIndex]) {\n      return;\n    }\n\n    this.stop(null, 'mouse');\n  };\n\n  /**\n   * Handle the spark.visible-children event\n   * @param {Object} e\n   */\n\n\n  RangeSlider.prototype._onVisibleChildren = function _onVisibleChildren(e) {\n    if (e.target.contains(this.el)) {\n      window.setTimeout(function () {\n        this._onResize();\n      }.bind(this), 0);\n    }\n  };\n\n  /**\n   * When the window resizes, cache size values for the slider.\n   * @param {Object} e\n   */\n\n\n  RangeSlider.prototype._onResize = function _onResize() {\n    this._cacheSize();\n    this._updateDisabledClasses();\n    for (var i = 0; i < this.handleEls.length; i++) {\n      this._updateHandlePosition(i);\n    }\n  };\n\n  /**\n   * When the element receives focus, start listening for keyboard events\n   * @param {Object} e\n   */\n\n\n  RangeSlider.prototype._onFocus = function _onFocus(e) {\n    this.start((0, _getIndex2.default)(this.handleEls, e.target), null, 'keyboard');\n  };\n\n  /**\n   * When a key is pressed, see if it's one of the Arrow, Page up, Page down, Home\n   * or End keys move the handle accordingly. If the shift key is pressed in combination\n   * with the arrow keys, we'll increment and decrement by bigger values.\n   * @param {Object} e\n   */\n\n\n  RangeSlider.prototype._onKeydown = function _onKeydown(e) {\n\n    if ((0, _getIndex2.default)(this.inputEls, e.target) !== -1) {\n      return;\n    }\n\n    if (e.keyCode === 39 || e.keyCode === 38) {\n      // Right or Up arrow\n      this.increment(e.shiftKey);\n    } else if (e.keyCode === 37 || e.keyCode === 40) {\n      // Left or down arrow\n      this.decrement(e.shiftKey);\n    } else if (e.keyCode === 33) {\n      // Page Up\n      this.increment(true);\n    } else if (e.keyCode === 34) {\n      // Page Down\n      this.decrement(true);\n    } else if (e.keyCode === 35) {\n      // End\n      this.setValue(this.max);\n    } else if (e.keyCode === 36) {\n      // Home\n      this.setValue(this.min);\n    }\n  };\n\n  /**\n   * When the element loses focus, stop listening for keyboard events\n   * @param {Object} e\n   */\n\n\n  RangeSlider.prototype._onBlur = function _onBlur(e) {\n    this.stop((0, _getIndex2.default)(this.handleEls, e.target), 'keyboard');\n  };\n\n  /**\n   * When the input value changes, set our interal value if it's not already our value.\n   * @param {Object} e\n   */\n\n\n  RangeSlider.prototype._onChange = function _onChange(e) {\n\n    var index = (0, _getIndex2.default)(this.inputEls, e.target);\n\n    this._updateDisabledClasses();\n\n    if (e.target.value !== this.values[index]) {\n      this.setValue(index, e.target.value);\n    }\n    (this.onChange || noop)(index, this.values[index], this);\n  };\n\n  /**\n   * Prevent click events on the button. This way we don't accidentally submit the form.\n   * @param {Object} e\n   */\n\n\n  RangeSlider.prototype._onClick = function _onClick(e) {\n    e.preventDefault();\n  };\n\n  return RangeSlider;\n}(_base2.default);\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nRangeSlider.prototype._whitelistedParams = ['isX', 'validate', 'onValidate', 'onChange', 'onWillChange'];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nRangeSlider.prototype.defaults = {\n  el: null,\n  messageEl: null,\n  controlsEl: null,\n  inputEls: null,\n  handleEls: null,\n  trackEl: null,\n  trackFillEl: null,\n  isActive: null,\n  isX: true,\n  onValidate: null,\n  onChange: null,\n  onWillChange: null,\n  position: 0,\n  width: 0,\n  height: 0,\n  mins: null,\n  maxes: null,\n  steps: null,\n  values: null,\n  percentages: null,\n  offsetLeft: 0,\n  offsetTop: 0,\n  handleSizePercentage: 0,\n  currentIndex: null,\n  lastIndex: null,\n  _oldVal: null,\n  _onTouchStartBound: null,\n  _onTouchMoveBound: null,\n  _onTouchEndBound: null,\n  _onMouseDownBound: null,\n  _onMouseMoveBound: null,\n  _onMouseUpBound: null,\n  _onMouseOutBound: null,\n  _onFocusBound: null,\n  _onKeydownBound: null,\n  _onBlurBound: null,\n  _onChangeBound: null,\n  _onResizeBound: null,\n  _onClickBound: null,\n  _onVisibleChildrenBound: null\n};\n\n(0, _mixin2.default)(RangeSlider.prototype, _messaging2.default, _validation2.default);\n\nexports.default = RangeSlider;\nmodule.exports = exports['default'];\n//# sourceMappingURL=range-slider.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _outerHeight = require('../dom/outer-height');\n\nvar _outerHeight2 = _interopRequireDefault(_outerHeight);\n\nvar _addClass = require('../dom/add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _removeClass = require('../dom/remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nvar _hasClass = require('../dom/has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _toggleClass = require('../dom/toggle-class');\n\nvar _toggleClass2 = _interopRequireDefault(_toggleClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar noop = function noop() {}; /**\n                                * # Animate Height\n                                * Animate the height of an element since we can't do this w/ pure CSS. Sigh.\n                                *\n                                * @example\n                                * animateHeight({\n                                *   el: ...,\n                                *   toggleEl: ...,\n                                *   // Optional params\n                                *   action: 'collapse'|'expand',\n                                *   heightAnimationClass: 'spark-animate-height',\n                                *   opacityAnimationClass: 'spark-animate-opacity',\n                                *   toggleProperty: 'display'|'overflow'|'visibility',\n                                *   toggleValue: 'block'|'none'|'visible'|'hidden',\n                                *   animationDuration: 250\n                                * });\n                                *\n                                * @module helpers/animation/height.js\n                                */\n\nvar runningAnimations = {\n  els: [],\n  completeCallbacks: []\n};\n\n/**\n * Get the inverse toggle value\n * @param  {String} property\n * @param  {String} originalValue\n * @return {String}\n */\nfunction getInverseToggleValue(el, property, originalValue) {\n\n  // Get the value to toggle to for the given property\n  switch (property) {\n    case 'overflow':\n    case 'visibility':\n      return originalValue === 'visible' ? 'hidden' : 'visible';\n    default:\n      return originalValue === 'block' || originalValue === 'inline-block' ? 'none' : 'block';\n  }\n}\n\n/**\n * When an animation is complete, clean up and run the callback.\n * @param  {Object} params\n */\nfunction onComplete(params) {\n\n  // Reset toggle el visibility\n  if (params.toggleClassName) {\n    (0, _toggleClass2.default)(params.el, params.toggleClassName, !params.collapse);\n  } else {\n    params.toggleEl.style[params.toggleProperty] = '';\n  }\n\n  // Remove the height property\n  params.el.style.height = '';\n  params.toggleEl.style.height = '';\n  params.toggleEl.style.marginBottom = '';\n  params.toggleEl.style.marginTop = '';\n\n  // Remove the spark-animate-height class so the transitions no longer apply\n  (0, _removeClass2.default)(params.el, params.heightAnimationClass);\n  (0, _removeClass2.default)(params.toggleEl, params.heightAnimationClass);\n\n  // Run the callback\n  params.onComplete();\n\n  // Remove the element and callback from their respective arrays\n  var runningIndex = runningAnimations.els.indexOf(params.el);\n  runningAnimations.els.splice(runningIndex, 1);\n  runningAnimations.completeCallbacks.splice(runningIndex, 1);\n}\n\n/**\n * @param {Object} params\n */\nfunction animateHeight(params) {\n\n  params = params || {};\n\n  var el = params.el;\n\n  if (!el) {\n    return;\n  }\n\n  var collapse = params.action && params.action === 'collapse';\n  var heightAnimationClass = params.heightAnimationClass || 'spark-animate-height';\n\n  // Allow for elements to be passed or selector strings\n  var toggleEl = typeof params.toggleEl === 'string' ? el.querySelector(params.toggleEl) : params.toggleEl;\n\n  // No element to be switching with toggling so we can't determine the desired height to animate to.\n  if (!toggleEl || (0, _hasClass2.default)(el, 'spark-no-animate')) {\n    return;\n  }\n\n  var toggleClassName = params.toggleClass;\n\n  // The style property to use when toggling visibility\n  var toggleProperty = params.toggleProperty || 'display';\n  var toggleStyles = window.getComputedStyle(toggleEl);\n  var originalToggleValue = toggleStyles[toggleProperty];\n  var toggleValue = params.toggleValue || getInverseToggleValue(toggleProperty, originalToggleValue);\n\n  // If we are already animating, stop now.\n  var runningIndex = runningAnimations.els.indexOf(el);\n  if (runningIndex !== -1) {\n\n    var completeCallback = runningAnimations.completeCallbacks[runningIndex];\n    if (completeCallback) {\n      clearTimeout(completeCallback);\n    }\n\n    onComplete({\n      el: el,\n      toggleEl: toggleEl,\n      onComplete: params.onComplete || noop,\n      collapse: collapse,\n      toggleProperty: toggleProperty,\n      toggleClassName: toggleClassName,\n      toggleValue: toggleValue,\n      heightAnimationClass: heightAnimationClass\n    });\n  }\n\n  // Store the current height\n  var originalHeight = (0, _outerHeight2.default)(el);\n\n  // Toggle the visible property\n  if (toggleClassName) {\n    (0, _toggleClass2.default)(el, toggleClassName, !collapse);\n  } else {\n    toggleEl.style[toggleProperty] = toggleValue;\n  }\n\n  // When measuring the size for a collapse, we have to wait a tic for it to be\n  // accurate. Not sure why. Ugh.\n  if (collapse) {\n    setTimeout(runAnimation, 0);\n  } else {\n    runAnimation();\n  }\n\n  function runAnimation() {\n\n    // Now that the toggle el is taking up space, get the new height which we will be animating to\n    var targetElHeight = (0, _outerHeight2.default)(el);\n\n    // We need to store the original and target toggle element heights. They differ depending on\n    // whether we are going to expand or collapse.\n    var targetToggleElHeight = void 0;\n    var originalToggleElHeight = void 0;\n\n    // If we are collapsing, reset the toggle style and set it when we're done. Set the height so\n    // that we can animate down to 0 or up to the target height.\n    if (collapse) {\n\n      if (toggleClassName) {\n        (0, _removeClass2.default)(el, toggleClassName);\n      } else {\n        toggleEl.style[toggleProperty] = originalToggleValue;\n      }\n\n      originalToggleElHeight = (0, _outerHeight2.default)(toggleEl, toggleStyles);\n      targetToggleElHeight = 0;\n    } else {\n      targetToggleElHeight = (0, _outerHeight2.default)(toggleEl, toggleStyles);\n      originalToggleElHeight = 0;\n    }\n\n    // Set the original height\n    el.style.height = originalHeight + 'px';\n    toggleEl.style.height = originalToggleElHeight + 'px';\n    toggleEl.style.marginBottom = '0px';\n    toggleEl.style.marginTop = '0px';\n\n    // Add the spark-animate-height class which will setup the transition-property and duration\n    (0, _addClass2.default)(el, heightAnimationClass);\n    (0, _addClass2.default)(toggleEl, heightAnimationClass);\n\n    runningAnimations.els.push(el);\n\n    // We need to wait a tick to toggle the height or else the animation class won't function\n    setTimeout(function () {\n\n      // Set the height to the target height\n      el.style.height = targetElHeight + 'px';\n      toggleEl.style.height = targetToggleElHeight + 'px';\n\n      // Remove inline styles after the animation is complete\n      runningAnimations.completeCallbacks.push(setTimeout(function () {\n        onComplete({\n          el: el,\n          toggleEl: toggleEl,\n          onComplete: params.onComplete || noop,\n          collapse: collapse,\n          toggleProperty: toggleProperty,\n          toggleClassName: toggleClassName,\n          toggleValue: toggleValue,\n          heightAnimationClass: heightAnimationClass\n        });\n      }, params.animationDuration !== undefined ? params.animationDuration : 201));\n    }, 0);\n  }\n}\n\nexports.default = animateHeight;\nmodule.exports = exports['default'];\n//# sourceMappingURL=height.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * # Add Class\n * Add a class on an element.\n *\n * @param {Element|Array} el An element or array of elements to update.\n * @param {String} name\n * @return {Element}\n *\n * @module helpers/dom/add-class.js\n */\n\nvar ws = /\\s+/;\nvar cleanup = /\\s{2,}/g;\n\nfunction addClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) {\n      el.classList.add(name[0]);\n    }\n    return el;\n  }\n\n  var toAdd = [];\n  var i = 0;\n  var l = name.length;\n  var item = void 0;\n  var clsName = typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '';\n\n  // see if we have anything to add\n  for (; i < l; i++) {\n    item = name[i];\n    if (item && !(0, _hasClass2.default)(clsName, item)) {\n      toAdd.push(item);\n    }\n  }\n\n  if (toAdd.length) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = addClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=add-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * # Has Class\n * See if an element has a class.\n *\n * @param {Element|String} el\n * @param {String} name\n * @return {Boolean}\n *\n * @module helpers/dom/has-class.js\n */\nfunction hasClass(el, name) {\n  var cName = ((typeof el === 'undefined' ? 'undefined' : _typeof(el)) === 'object' ? el.className || el.getAttribute && el.getAttribute('class') || '' : el || '').replace(/[\\t\\r\\n\\f]/g, ' ');\n  return (' ' + cName + ' ').indexOf(' ' + name + ' ') !== -1;\n}\n\nexports.default = hasClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=has-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (html) {\n\n  if (!html) {\n    throw new Error('Cannot create element with no HTML!');\n  }\n\n  var el = document.createElement('div');\n  el.innerHTML = html;\n  var el2 = el.children[0];\n  el2.parentNode.removeChild(el2);\n  return el2;\n};\n\nmodule.exports = exports['default']; /**\n                                      * # Make Element\n                                      * Make en element using a string of HTML.\n                                      *\n                                      * @example\n                                      * makeElement('<div></div>');\n                                      *\n                                      * @module helpers/make-element.js\n                                      *\n                                      * @param {String} html\n                                      * @return {Element}\n                                      */\n//# sourceMappingURL=make-element.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Offset Position\n * Get the offset position of the element.\n *\n * @param {Element} el\n * @param {Boolean} viewPortOffset The offset relative to the viewport, not page.\n * @return {Object}\n *\n * @module helpers/dom/offset.js\n */\nfunction offset(el, viewPortOffset) {\n\n  var rect = {\n    top: 0,\n    left: 0\n  };\n\n  // Native implementation\n  if (el.getBoundingClientRect) {\n\n    var bounding = el.getBoundingClientRect();\n    rect.left = bounding.left;\n    rect.top = bounding.top;\n\n    if (!viewPortOffset) {\n      rect.left += typeof window.scrollX !== 'undefined' ? window.scrollX : window.pageXOffset;\n      rect.top += typeof window.scrollY !== 'undefined' ? window.scrollY : window.pageYOffset;\n    }\n  } else {\n    var x = 0,\n        y = 0;\n    do {\n      x += el.offsetLeft - (!viewPortOffset ? el.scrollLeft : 0);\n      y += el.offsetTop - (!viewPortOffset ? el.scrollTop : 0);\n    } while (el = el.offsetParent);\n\n    rect.left = x;\n    rect.top = y;\n  }\n\n  return rect;\n}\n\nexports.default = offset;\nmodule.exports = exports['default'];\n//# sourceMappingURL=offset.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _each = require('../util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar props = ['marginTop', 'marginBottom', 'borderTop', 'borderBottom']; /**\n                                                                         * # Outer Height\n                                                                         * Get the outer height of an element (including margin and border)\n                                                                         *\n                                                                         * @param {Element} el\n                                                                         * @param {Object} styles Optional Already have computed styles? Pass them in.\n                                                                         *\n                                                                         * @example\n                                                                         * outerHeight(el, computedStyles);\n                                                                         *\n                                                                         * @module helpers/outer-height.js\n                                                                         */\n\n\nfunction outerHeight(el, styles) {\n\n  styles = styles || window.getComputedStyle(el);\n\n  var height = el.clientHeight;\n\n  (0, _each2.default)(props, function (prop) {\n    height += parseInt(styles[prop] || 0, 10);\n  });\n\n  return height;\n}\n\nexports.default = outerHeight;\nmodule.exports = exports['default'];\n//# sourceMappingURL=outer-height.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ws = /\\s+/; /**\n                 * # Remove Class\n                 * Remove a class on an element.\n                 *\n                 * @param {Element|Array} el An element or array of elements to update.\n                 * @param {String} name\n                 * @return {Element}\n                 *\n                 * @module helpers/dom/remove-class.js\n                 */\n\nvar cleanup = /\\s{2,}/g;\n\nfunction removeClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) el.classList.remove(name[0]);\n    return el;\n  }\n\n  // store two copies\n  var clsName = ' ' + (typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '') + ' ';\n  var result = clsName;\n  var current = void 0;\n  var start = void 0;\n  for (var i = 0, l = name.length; i < l; i++) {\n    current = name[i];\n    start = current ? result.indexOf(' ' + current + ' ') : -1;\n    if (start !== -1) {\n      start += 1;\n      result = result.slice(0, start) + result.slice(start + current.length);\n    }\n  }\n\n  // only write if modified\n  if (clsName !== result) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)(result.replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)(result.replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = removeClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=remove-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _addClass = require('./add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _removeClass = require('./remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toggleClass(el, name, enable) {\n\n  if (!el) {\n    return;\n  }\n\n  // If we're passed an array, toggle the class on each.\n  if (el instanceof NodeList || el instanceof Array) {\n\n    for (var i = 0, len = el.length; i < len; i++) {\n      toggleClass(el[i], name, enable);\n    }\n\n    return;\n  }\n\n  var action = void 0;\n  if (enable !== undefined) {\n    enable = typeof enable === 'function' ? enable.call(null, el) : enable;\n    action = enable ? 'add' : 'remove';\n  } else {\n    action = (0, _hasClass2.default)(el, name) ? 'remove' : 'add';\n  }\n\n  return (action === 'add' ? _addClass2.default : _removeClass2.default)(el, name);\n} /**\n   * # Toggle Class\n   * Toggle a class on an element given a condition.\n   *\n   * @param {Element|Array} el An element or array of elements to update.\n   * @param {String} name\n   * @param {Boolean} enable\n   * @return {Element}\n   *\n   * @module  helpers/dom/toggle-class.js\n   */\n\nexports.default = toggleClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=toggle-class.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Get Index\n * Get the index of an element in a nodelist.\n *\n * @param {NodeList} els\n * @param {Node} el\n * @return {Number}\n *\n * @module helpers/traversal/get-index.js\n */\nfunction getIndex(els, el) {\n  return Array.prototype.indexOf.call(els, el);\n}\n\nexports.default = getIndex;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=get-index.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Each\n * Apply a callback function to a list of any kind: Array, NodeList, HTMLCollection or Object.\n *\n * @param {Array|NodeList|HTMLCollection|Object} list\n * @param {Function} cb\n *\n * @example\n * each([], callback);\n * each(el.children, callback);\n * each(el.childNodes, callback);\n * each({}, callback);\n *\n * @module helpers/util/each.js\n */\nfunction each(list, cb) {\n\n  if (!list) {\n    return;\n  }\n\n  if (typeof cb !== 'function') {\n    throw new Error('Cannot invoke `each` without a callback!');\n  }\n\n  var i = 0;\n  var len = list.length;\n\n  // Object\n  if (len === undefined) {\n    for (i in list) {\n      if (i !== 'prototype' && list.hasOwnProperty(i)) {\n        cb(i, list[i]);\n      }\n    }\n  }\n  // Array-like\n  else {\n      for (; i < len; i++) {\n        cb(list[i]);\n      }\n    }\n}\n\nexports.default = each;\nmodule.exports = exports['default'];\n//# sourceMappingURL=each.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (proto) {\n  for (var _len = arguments.length, mixins = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    mixins[_key - 1] = arguments[_key];\n  }\n\n  (0, _each2.default)(mixins, function (mixin) {\n    for (var i in mixin) {\n      if (mixin.hasOwnProperty(i) && !proto[i]) proto[i] = mixin[i];\n    }\n  });\n};\n\nvar _each = require('./each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * # Mixin\n * Apply a mixin, or mixins, to an Object\n *\n * @example\n * mixin(proto, mix, mix2)\n *\n * @module helpers/util/mixin.js\n */\nmodule.exports = exports['default'];\n//# sourceMappingURL=mixin.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Trim\n * Trim whitespace on a string.\n *\n * @param {String} str\n *\n * @module helpers/util/trim.js\n */\n\nvar trimRE = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\nfunction trim(str) {\n  return str.replace(trimRE, '');\n}\n\nexports.default = trim;\nmodule.exports = exports['default'];\n//# sourceMappingURL=trim.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _height = require('../helpers/animation/height');\n\nvar _height2 = _interopRequireDefault(_height);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n\n  /**\n   * Set the error state.\n   * @param {String} message Optional\n   */\n  setError: function setError(message) {\n\n    // Animate down\n    if (!this._isMessageVisible()) {\n      this._showMessage();\n    }\n\n    this.clearWarning();\n    this.clearSuccess();\n\n    this.el.setAttribute('data-error', true);\n\n    if (message) {\n      this.setMessage(message);\n    }\n\n    return this;\n  },\n\n\n  /**\n   * Set the error state.\n   */\n  clearError: function clearError() {\n    this.el.removeAttribute('data-error', true);\n    return this;\n  },\n\n\n  /**\n   * Set the warning state.\n   * @param {String} message Optional\n   */\n  setWarning: function setWarning(message) {\n\n    // Animate down\n    if (!this._isMessageVisible()) {\n      this._showMessage();\n    }\n\n    this.clearError();\n    this.clearSuccess();\n\n    this.el.setAttribute('data-warning', true);\n\n    if (message) {\n      this.setMessage(message);\n    }\n\n    return this;\n  },\n\n\n  /**\n   * Set the error state.\n   */\n  clearWarning: function clearWarning() {\n    this.el.removeAttribute('data-warning', true);\n    return this;\n  },\n\n\n  /**\n   * Set the success state.\n   * @param {String} message Optional\n   */\n  setSuccess: function setSuccess(message) {\n\n    // Animate down\n    if (!this._isMessageVisible()) {\n      this._showMessage();\n    }\n\n    this.clearError();\n    this.clearWarning();\n\n    this.el.setAttribute('data-success', true);\n\n    if (message) {\n      this.setMessage(message);\n    }\n\n    return this;\n  },\n\n\n  /**\n   * Set the success state.\n   */\n  clearSuccess: function clearSuccess() {\n    this.el.removeAttribute('data-success', true);\n    return this;\n  },\n\n\n  /**\n   * Clear all messages.\n   */\n  clearMessages: function clearMessages() {\n    this._hideMessage(function () {\n      this.clearError();\n      this.clearWarning();\n      this.clearSuccess();\n    }.bind(this));\n    return this;\n  },\n\n\n  /**\n   * Set the message text.\n   * @param {String} message\n   */\n  setMessage: function setMessage(message) {\n    this.messageEl.innerHTML = message;\n    return this;\n  },\n\n\n  /**\n   * Show the message\n   */\n  _showMessage: function _showMessage() {\n\n    if (!this.messageEl.parentNode) {\n      this.el.appendChild(this.messageEl);\n    }\n\n    (0, _height2.default)({\n      el: this.el,\n      toggleEl: this.messageEl\n    });\n  },\n\n\n  /**\n   * Hide the message.\n   * @param {Function} callback\n   */\n  _hideMessage: function _hideMessage(callback) {\n\n    (0, _height2.default)({\n      el: this.el,\n      toggleEl: this.messageEl,\n      toggleValue: 'none',\n      action: 'collapse',\n      onComplete: callback\n    });\n  },\n\n\n  /**\n   * Is the message currently visible?\n   * @return {Boolean}\n   */\n  _isMessageVisible: function _isMessageVisible() {\n    return this.el.getAttribute('data-error') || this.el.getAttribute('data-warning') || this.el.getAttribute('data-success');\n  }\n}; /**\n    * # Messaging Mixin\n    * Add functionality for showing messages related to a form field.\n    *\n    * @example\n    * mixin(Component, messaging);\n    *\n    * @module mixin/messaging.js\n    */\n\nmodule.exports = exports['default'];\n//# sourceMappingURL=messaging.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Validation Mixin\n * Add functionality for validating a form field's value.\n *\n * @example\n * mixin(Component, validation);\n *\n * @module mixin/validation.js\n */\n\nexports.default = {\n\n  /**\n   * Default validate function. This can be overridden by passing a\n   * custom validate method as a parameter. This really only helps out\n   * of the box for text inputs.\n   */\n  validate: function validate() {\n\n    var validate = this.validatePattern;\n\n    // Nothing to validate.\n    if (!this.onValidate || !validate) {\n      return this;\n    }\n\n    var re = new RegExp(validate);\n\n    this.onValidate(re.test(this.getValue()), this.getValue(), this);\n\n    return this;\n  }\n};\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=validation.js.map\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9kaXN0L2NvbXBvbmVudHMvYmFzZS5qcyIsImpzL2Rpc3QvY29tcG9uZW50cy9yYW5nZS1zbGlkZXIuanMiLCJqcy9kaXN0L2hlbHBlcnMvYW5pbWF0aW9uL2hlaWdodC5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vYWRkLWNsYXNzLmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS9oYXMtY2xhc3MuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL21ha2UtZWxlbWVudC5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vb2Zmc2V0LmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS9vdXRlci1oZWlnaHQuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL3JlbW92ZS1jbGFzcy5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vdG9nZ2xlLWNsYXNzLmpzIiwianMvZGlzdC9oZWxwZXJzL3RyYXZlcnNhbC9nZXQtaW5kZXguanMiLCJqcy9kaXN0L2hlbHBlcnMvdXRpbC9lYWNoLmpzIiwianMvZGlzdC9oZWxwZXJzL3V0aWwvbWl4aW4uanMiLCJqcy9kaXN0L2hlbHBlcnMvdXRpbC90cmltLmpzIiwianMvZGlzdC9taXhpbnMvbWVzc2FnaW5nLmpzIiwianMvZGlzdC9taXhpbnMvdmFsaWRhdGlvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc31yZXR1cm4gZX0pKCkiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZWFjaCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdXRpbC9lYWNoJyk7XG5cbnZhciBfZWFjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIyBCYXNlIENvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoZSBiYXNlIGNsYXNzIGZvciBTcGFyayBKUyBjb21wb25lbnRzLiBUaGlzIGNsYXNzIHNob3VsZCBuZXZlciBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGluc3RhbnRpYXRlZCBkaXJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIGNvbXBvbmVudHMvYmFzZS5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIEJhc2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIFNldCBwYXJhbWV0ZXJzIGFuZCBjYWNoZSBlbGVtZW50cy5cbiAgICovXG4gIGZ1bmN0aW9uIEJhc2UoZWwpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlKTtcblxuICAgIGlmIChwYXJhbXMuZWxSZXF1aXJlZCAmJiAhZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldFBhcmFtcyh0aGlzLmRlZmF1bHRzIHx8IHt9LCB0cnVlKTtcbiAgICB0aGlzLnNldFBhcmFtcyhwYXJhbXMpO1xuICAgICh0aGlzLl9jYWNoZUVsZW1lbnRzIHx8IG5vb3ApLmNhbGwodGhpcywgZWwsIHBhcmFtcyk7XG4gICAgKHRoaXMuX3BhcnNlUGFyYW1zIHx8IG5vb3ApLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBjb21wb25lbnQgZnJvbSB0aGUgRE9NIGFuZCBwcmVwYXJlIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24gYnkgZGVyZWZlcmVuY2luZyB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbGVhdmVFbGVtZW50IExlYXZlIHRoZSBlbGVtZW50IGludGFjdC5cbiAgICovXG5cblxuICBCYXNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUobGVhdmVFbGVtZW50KSB7XG5cbiAgICBpZiAodGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgaWYgKCFsZWF2ZUVsZW1lbnQgJiYgdGhpcy5lbCAmJiB0aGlzLmVsLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgICB9XG5cbiAgICB0aGlzLnVuc2V0UGFyYW1zKHRoaXMuZGVmYXVsdHMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY29tcG9uZW50IHRvIHVzZSBhIG5ldyBlbGVtZW50IG9yIHJlcGFyc2UgZnJvbVxuICAgKiB0aGUgZXhpc3RpbmcgZWxlbWVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBPcHRpb25hbFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIE9wdGlvbmFsXG4gICAqL1xuXG5cbiAgQmFzZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGVsKSB7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cblxuICAgIGlmICh0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycykge1xuICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICAodGhpcy5fY2FjaGVFbGVtZW50cyB8fCBub29wKS5jYWxsKHRoaXMsIGVsIHx8IHRoaXMuZWwsIHBhcmFtcyk7XG4gICAgKHRoaXMuX3BhcnNlUGFyYW1zIHx8IG5vb3ApLmNhbGwodGhpcyk7XG5cbiAgICBpZiAodGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIGhhc2ggb2YgcGFyYW1ldGVycyBpZiB0aGV5J3JlIHdoaXRlbGlzdGVkIG9yIHdlJ3JlIHRvbGQgdG8gZm9yY2UgdGhlIHNldC5cbiAgICogVGhpcyBpcyB1c2VkIHRvIHNldCBpbml0aWFsIHZhbHVlcyBhcyB3ZWxsIGFzIHNldCBwYXNzZWQgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlIEZvcmNlIHNldHRpbmcgZXZlbiBpZiB0aGUgcGFyYW0gaXMgbm90IHdoaXRlbGlzdGVkLlxuICAgKi9cblxuXG4gIEJhc2UucHJvdG90eXBlLnNldFBhcmFtcyA9IGZ1bmN0aW9uIHNldFBhcmFtcyhwYXJhbXMsIGZvcmNlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICgwLCBfZWFjaDIuZGVmYXVsdCkocGFyYW1zLCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgaWYgKF90aGlzLl93aGl0ZWxpc3RlZFBhcmFtcy5pbmRleE9mKGspICE9PSAtMSB8fCBmb3JjZSkge1xuICAgICAgICBfdGhpc1trXSA9IHY7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVW5zZXQgYWxsIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSBUaGUgb2JqZWN0IHRvIHVuc2V0IHRoZSBwYXJhbXMgZnJvbS4gRGVmYXVsdHMgdG8gYHRoaXNgLlxuICAgKi9cblxuXG4gIEJhc2UucHJvdG90eXBlLnVuc2V0UGFyYW1zID0gZnVuY3Rpb24gdW5zZXRQYXJhbXMoa2V5cywgc2NvcGUpIHtcblxuICAgIGtleXMgPSBrZXlzIGluc3RhbmNlb2YgQXJyYXkgPyBrZXlzIDogT2JqZWN0LmtleXMoa2V5cyk7XG4gICAgc2NvcGUgPSBzY29wZSB8fCB0aGlzO1xuICAgICgwLCBfZWFjaDIuZGVmYXVsdCkoa2V5cywgZnVuY3Rpb24gKGspIHtcbiAgICAgIGRlbGV0ZSBzY29wZVtrXTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBCYXNlO1xufSgpO1xuXG4vKipcbiAqIFdoaXRlbGlzdGVkIHBhcmFtZXRlcnMgd2hpY2ggY2FuIGJlIHNldCBvbiBjb25zdHJ1Y3Rpb24uXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cblxuXG5CYXNlLnByb3RvdHlwZS5fd2hpdGVsaXN0ZWRQYXJhbXMgPSBbXTtcblxuLyoqXG4gKiBEZWZhdWx0IHZhbHVlcyBmb3IgaW50ZXJuYWwgcHJvcGVydGllcyB3ZSB3aWxsIGJlIHNldHRpbmcuXG4gKiBUaGVzZSBhcmUgc2V0IG9uIGVhY2ggY29uc3RydWN0aW9uIHNvIHdlIGRvbid0IGxlYWsgcHJvcGVydGllc1xuICogaW50byB0aGUgcHJvdG90eXBlIGNoYWluLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuQmFzZS5wcm90b3R5cGUuZGVmYXVsdHMgPSB7fTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQmFzZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9iYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5cbnZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcblxudmFyIF90b2dnbGVDbGFzcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL3RvZ2dsZS1jbGFzcycpO1xuXG52YXIgX3RvZ2dsZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvZ2dsZUNsYXNzKTtcblxudmFyIF9vZmZzZXQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbS9vZmZzZXQnKTtcblxudmFyIF9vZmZzZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2Zmc2V0KTtcblxudmFyIF9nZXRJbmRleCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdHJhdmVyc2FsL2dldC1pbmRleCcpO1xuXG52YXIgX2dldEluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEluZGV4KTtcblxudmFyIF9tZXNzYWdpbmcgPSByZXF1aXJlKCcuLi9taXhpbnMvbWVzc2FnaW5nJyk7XG5cbnZhciBfbWVzc2FnaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lc3NhZ2luZyk7XG5cbnZhciBfbWl4aW4gPSByZXF1aXJlKCcuLi9oZWxwZXJzL3V0aWwvbWl4aW4nKTtcblxudmFyIF9taXhpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9taXhpbik7XG5cbnZhciBfdmFsaWRhdGlvbiA9IHJlcXVpcmUoJy4uL21peGlucy92YWxpZGF0aW9uJyk7XG5cbnZhciBfdmFsaWRhdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92YWxpZGF0aW9uKTtcblxudmFyIF9tYWtlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL21ha2UtZWxlbWVudCcpO1xuXG52YXIgX21ha2VFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21ha2VFbGVtZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICMgUmFuZ2VTbGlkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEEgZHVhbCBzbGlkZXIgZm9yIG51bWJlciBpbnB1dHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdG9kbyA6IHByb2JhYmx5IGEgbG90IG9mIHJlZmFjdG9yaW5nIHRoYXQgY291bGQgaGFwcGVuIGJldHdlZW4gdGhpcyBhbmQgc2xpZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBuZXcgUmFuZ2VTbGlkZXIoZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgLy8gT3B0aW9uYWwuIFNsaWRlIGFsb25nIHRoZSB4IG9yIHktYXhpcz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgaXNYOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICBvbkNoYW5nZTogZnVuY3Rpb24oaW5zdCwgaW5kZXgsIHZhbHVlKXt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBjb21wb25lbnRzL3JhbmdlLXNsaWRlci5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbnZhciBSYW5nZVNsaWRlciA9IGZ1bmN0aW9uIChfQmFzZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUmFuZ2VTbGlkZXIsIF9CYXNlQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogUmFuZ2VTbGlkZXIgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgKi9cbiAgZnVuY3Rpb24gUmFuZ2VTbGlkZXIoZWwpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYW5nZVNsaWRlcik7XG5cbiAgICBwYXJhbXMuZWxSZXF1aXJlZCA9IHRydWU7XG5cbiAgICBpZiAoIShfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CYXNlQ29tcG9uZW50LmNhbGwodGhpcywgZWwsIHBhcmFtcykpLCBfdGhpcykpIHtcbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG4gICAgfVxuXG4gICAgX3RoaXMuX2JpbmRFdmVudExpc3RlbmVyQ2FsbGJhY2tzKCk7XG4gICAgX3RoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgX3RoaXMuX3VwZGF0ZURpc2FibGVkQ2xhc3NlcygpO1xuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdGhlIHNsaWRlciBtb3ZpbmcuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGhhbmRsZSBvciBpbnB1dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBPcHRpb25hbCBXaGljaCB0eXBlIG9mIGV2ZW50cyB0byBsaXN0ZW4gZm9yLlxuICAgKi9cblxuXG4gIFJhbmdlU2xpZGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KGluZGV4LCBwb3NpdGlvbiwgdHlwZSkge1xuXG4gICAgLy8gTm9vcCBpZiB3ZSdyZSBkaXNhYmxlZCBvciBhbiBpbnZhbGlkIGluZGV4IHdhcyBwYXNzZWRcbiAgICBpZiAoaW5kZXggPCAwIHx8IHRoaXMuaW5wdXRFbHNbaW5kZXhdLmdldEF0dHJpYnV0ZSgnZGlzYWJsZWQnKSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5fYWRkTW92ZUV2ZW50TGlzdGVuZXJzKHR5cGUgfHwgJ21vdXNlJyk7XG4gICAgdGhpcy5fY2FjaGVTaXplKCk7XG5cbiAgICB0aGlzLmlzQWN0aXZlID0gdGhpcy5pc0FjdGl2ZSB8fCBbXTtcbiAgICB0aGlzLmlzQWN0aXZlW2luZGV4XSA9IHRydWU7XG5cbiAgICB0aGlzLmN1cnJlbnRJbmRleCA9IGluZGV4O1xuICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZUNsYXNzZXMoaW5kZXgpO1xuICAgIHRoaXMuX3VwZGF0ZURpc2FibGVkQ2xhc3NlcygpO1xuICAgIHRoaXMuX29sZFZhbCA9IHRoaXMudmFsdWVzW2luZGV4XTtcbiAgICB0aGlzLm1vdmUocG9zaXRpb24pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIHZhbHVlIHRvIGEgZ2l2ZW4gcG9zaXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2UgRm9yY2UgdGhlIG1vdmUgT3B0aW9uYWxcbiAgICovXG5cblxuICBSYW5nZVNsaWRlci5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uIG1vdmUocG9zaXRpb24sIGZvcmNlKSB7XG5cbiAgICAvLyBOb29wIGlmIGFuIGludmFsaWQgaW5kZXggd2FzIHBhc3NlZCB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGRyYWdnaW5nXG4gICAgaWYgKCghcG9zaXRpb24gfHwgIXRoaXMuaXNBY3RpdmUgfHwgIXRoaXMuaXNBY3RpdmVbdGhpcy5jdXJyZW50SW5kZXhdKSAmJiAhZm9yY2UpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFRyZWF0IHBvc2l0aW9ucyBiZXlvbmQgdGhlIGJvdW5kYXJpZXMgYXMgdGhlIGJvdW5kYXJpZXNcbiAgICBpZiAodGhpcy5pc1gpIHtcblxuICAgICAgLy8gVG9vIGZhciBsZWZ0XG4gICAgICBpZiAocG9zaXRpb24gPCB0aGlzLm9mZnNldExlZnQpIHtcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLm9mZnNldExlZnQ7XG4gICAgICB9XG4gICAgICAvLyBUb28gZmFyIHJpZ2h0XG4gICAgICBlbHNlIGlmIChwb3NpdGlvbiA+IHRoaXMub2Zmc2V0TGVmdCArIHRoaXMud2lkdGgpIHtcbiAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMub2Zmc2V0TGVmdCArIHRoaXMud2lkdGg7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBUb28gZmFyIHRvcFxuICAgICAgaWYgKHBvc2l0aW9uIDwgdGhpcy5vZmZzZXRUb3ApIHtcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLm9mZnNldFRvcDtcbiAgICAgIH1cbiAgICAgIC8vIFRvbyBmYXIgYm90dG9tXG4gICAgICBlbHNlIGlmIChwb3NpdGlvbiA+IHRoaXMub2Zmc2V0VG9wICsgdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMub2Zmc2V0VG9wICsgdGhpcy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGUgcGVyY2VudGFnZSBvZiB0aGUgbmV3IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHNsaWRlci1jb250YWluZXIgd2lkdGggb3IgaGVpZ2h0LlxuICAgIHZhciBwZXJjZW50YWdlID0gdGhpcy5pc1ggPyAocG9zaXRpb24gLSB0aGlzLm9mZnNldExlZnQpIC8gKHRoaXMud2lkdGggLSB0aGlzLmhhbmRsZVNpemUpIDogKHBvc2l0aW9uIC0gdGhpcy5vZmZzZXRUb3ApIC8gdGhpcy5oZWlnaHQ7XG5cbiAgICAvLyBUaGUgdmFsdWUgb2YgdGhlIGlucHV0IGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgdmFsdWUgcmFuZ2UuXG4gICAgdGhpcy5zZXRWYWx1ZSh0aGlzLmN1cnJlbnRJbmRleCwgTWF0aC5yb3VuZCgocGVyY2VudGFnZSAtIHRoaXMuaGFuZGxlU2l6ZVBlcmNlbnRhZ2UgLyAyKSAqICh0aGlzLmhpZ2hlc3RNYXggLSB0aGlzLmxvd2VzdE1pbikpICsgdGhpcy5sb3dlc3RNaW4pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3AgbGlzdGVuaW5nIHRvIG1vdmVtZW50cy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IE9wdGlvbmFsIFRoZSBpbmRleCBvZiB0aGUgaGFuZGxlIG9yIGlucHV0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIE9wdGlvbmFsIFdoaWNoIHR5cGUgb2YgZXZlbnRzIHRvIGxpc3RlbiBmb3IuXG4gICAqL1xuXG5cbiAgUmFuZ2VTbGlkZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiBzdG9wKGluZGV4LCB0eXBlKSB7XG5cbiAgICBpZiAoaW5kZXggIT09IG51bGwgJiYgaW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLmN1cnJlbnRJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuaXNBY3RpdmVbdGhpcy5jdXJyZW50SW5kZXhdID0gZmFsc2U7XG4gICAgdGhpcy5sYXN0SW5kZXggPSB0aGlzLmN1cnJlbnRJbmRleDtcblxuICAgIGlmICh0aGlzLl9vbGRWYWwgIT09IHRoaXMudmFsdWVzW3RoaXMuY3VycmVudEluZGV4XSkge1xuICAgICAgKHRoaXMub25DaGFuZ2UgfHwgbm9vcCkodGhpcy5jdXJyZW50SW5kZXgsIHRoaXMudmFsdWVzW3RoaXMuY3VycmVudEluZGV4XSwgdGhpcyk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50SW5kZXggPSBudWxsO1xuICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZUNsYXNzZXMoaW5kZXgpO1xuICAgIHRoaXMuX3JlbW92ZU1vdmVFdmVudExpc3RlbmVycyh0eXBlIHx8ICdtb3VzZScpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIGhhbmRsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqL1xuXG5cbiAgUmFuZ2VTbGlkZXIucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWUoaW5kZXgsIHZhbHVlKSB7XG5cbiAgICAvLyBXZSBkb24ndCBoYXZlIGFuIGlucHV0IGVsZW1lbnQgYXQgdGhhdCBpbmRleCwgc28gc29tZXRoaW5nIHdlbnQgd3JvbmcuXG4gICAgaWYgKCF0aGlzLmlucHV0RWxzW2luZGV4XSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IHZhbHVlIG9uIGEgc2xpZGVyIGlucHV0IGVsZW1lbnQgd2l0aCBhbiBpbmRleCBvZiAnICsgaW5kZXggKyAnLiBUaGF0IGVsZW1lbnQgZG9lcyBub3QgZXhpc3QuJyk7XG4gICAgfVxuXG4gICAgLy8gTW92ZSBpbiBpbmNyZW1lbnRzIGlmIHdlIGhhdmUgYSBkZWZpbmVkIHN0ZXAgc2l6ZVxuICAgIGlmICh0aGlzLnN0ZXBzW2luZGV4XSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAtIHZhbHVlICUgdGhpcy5zdGVwc1tpbmRleF07XG4gICAgfVxuXG4gICAgdGhpcy52YWx1ZXMgPSB0aGlzLnZhbHVlcyB8fCBbXTtcblxuICAgIC8vIENoZWNrIGJvdW5kcyBvZiB0aGUgbmV3IHZhbHVlXG4gICAgaWYgKHZhbHVlID4gdGhpcy5tYXhlc1tpbmRleF0pIHtcbiAgICAgIHZhbHVlID0gdGhpcy5tYXhlc1tpbmRleF07XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA8IHRoaXMubWluc1tpbmRleF0pIHtcbiAgICAgIHZhbHVlID0gdGhpcy5taW5zW2luZGV4XTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBpbnB1dCB0aGF0IGNvbWVzIGFmdGVyIHRoaXMsIG1ha2Ugc3VyZSB3ZSBhcmVuJ3QgZ29pbmcgYmV5b25kIGl0XG4gICAgaWYgKHRoaXMudmFsdWVzW2luZGV4ICsgMV0gIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB0aGlzLnZhbHVlc1tpbmRleCArIDFdKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMudmFsdWVzW2luZGV4ICsgMV0gLSAodGhpcy5zdGVwc1tpbmRleF0gfHwgMSk7XG4gICAgfVxuICAgIC8vIElmIHRoZXJlIGlzIGFuIGlucHV0IHRoYXQgY29tZXMgYmVmb3JlIHRoaXMsIG1ha2Ugc3VyZSB3ZSBhcmVuJ3QgZ29pbmcgYmVsb3cgaXRcbiAgICBlbHNlIGlmICh0aGlzLnZhbHVlc1tpbmRleCAtIDFdICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPD0gdGhpcy52YWx1ZXNbaW5kZXggLSAxXSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMudmFsdWVzW2luZGV4IC0gMV0gKyAodGhpcy5zdGVwc1tpbmRleF0gfHwgMSk7XG4gICAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBvbldpbGxDaGFuZ2UgY2FsbGJhY2ssIHJ1biBpdC4gSWYgaXQgcmV0dXJuc1xuICAgIC8vIGZhbHNlLCB0aGVuIHRoaXMgbmV3IHZhbHVlIHNob3VsZCBiZSBjb25zaWRlcmVkIGludmFsaWQuXG4gICAgaWYgKHR5cGVvZiB0aGlzLm9uV2lsbENoYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNoYW5nZSA9IHRoaXMub25XaWxsQ2hhbmdlKGluZGV4LCB2YWx1ZSwgdGhpcyk7XG4gICAgICBpZiAodHlwZW9mIGNoYW5nZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFsdWUgPSBjaGFuZ2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RvcmUgdmFsdWVcbiAgICB0aGlzLnZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcblxuICAgIC8vIFVwZGF0ZSBlbGVtZW50c1xuICAgIHRoaXMuaW5wdXRFbHNbaW5kZXhdLnZhbHVlID0gdGhpcy52YWx1ZXNbaW5kZXhdO1xuICAgIHRoaXMuaGFuZGxlRWxzW2luZGV4XS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnLCB0aGlzLnZhbHVlc1tpbmRleF0pO1xuICAgIHRoaXMuaGFuZGxlRWxzW2luZGV4XS5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnLCB0aGlzLnZhbHVlc1tpbmRleF0pO1xuICAgIHRoaXMuaGFuZGxlRWxzW2luZGV4XS5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWV0ZXh0JywgdGhpcy52YWx1ZXNbaW5kZXhdKTtcblxuICAgIC8vIFNldCB0aGUgcGVyY2VudGFnZVxuICAgIHRoaXMucGVyY2VudGFnZXMgPSB0aGlzLnBlcmNlbnRhZ2VzIHx8IFtdO1xuICAgIHRoaXMucGVyY2VudGFnZXNbaW5kZXhdID0gKHRoaXMudmFsdWVzW2luZGV4XSAtIHRoaXMubG93ZXN0TWluKSAvICh0aGlzLmhpZ2hlc3RNYXggLSB0aGlzLmxvd2VzdE1pbik7XG5cbiAgICAvLyBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBoYW5kbGVcbiAgICB0aGlzLl91cGRhdGVIYW5kbGVQb3NpdGlvbihpbmRleCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG5cblxuICBSYW5nZVNsaWRlci5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZShpbmRleCkge1xuXG4gICAgLy8gV2UgZG9uJ3QgaGF2ZSBhbiBpbnB1dCBlbGVtZW50IGF0IHRoYXQgaW5kZXgsIHNvIHNvbWV0aGluZyB3ZW50IHdyb25nLlxuICAgIGlmICghdGhpcy5pbnB1dEVsc1tpbmRleF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGdldCB2YWx1ZSBmcm9tIGEgc2xpZGVyIGlucHV0IGVsZW1lbnQgd2l0aCBhbiBpbmRleCBvZiAnICsgaW5kZXggKyAnLiBUaGF0IGVsZW1lbnQgZG9lcyBub3QgZXhpc3QuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudmFsdWVzW2luZGV4XTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXIgdGhlIHZhbHVlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICovXG5cblxuICBSYW5nZVNsaWRlci5wcm90b3R5cGUuY2xlYXJWYWx1ZSA9IGZ1bmN0aW9uIGNsZWFyVmFsdWUoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRWYWx1ZShpbmRleCwgMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0aGUgaW5wdXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKi9cblxuXG4gIFJhbmdlU2xpZGVyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiBlbmFibGUoaW5kZXgpIHtcblxuICAgIC8vIFdlIGRvbid0IGhhdmUgYW4gaW5wdXQgZWxlbWVudCBhdCB0aGF0IGluZGV4LCBzbyBzb21ldGhpbmcgd2VudCB3cm9uZy5cbiAgICBpZiAoIXRoaXMuaW5wdXRFbHNbaW5kZXhdIHx8ICF0aGlzLmhhbmRsZUVsc1tpbmRleF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGdldCB2YWx1ZSBmcm9tIGEgc2xpZGVyIGlucHV0IGVsZW1lbnQgd2l0aCBhbiBpbmRleCBvZiAnICsgaW5kZXggKyAnLiBUaGF0IGVsZW1lbnQgZG9lcyBub3QgZXhpc3QuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5pbnB1dEVsc1tpbmRleF0ucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgIHRoaXMuaW5wdXRFbHNbaW5kZXhdLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICB0aGlzLmhhbmRsZUVsc1tpbmRleF0ucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgIHRoaXMuaGFuZGxlRWxzW2luZGV4XS5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgdGhpcy5fdXBkYXRlRGlzYWJsZWRDbGFzc2VzKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogRGlzYWJsZSB0aGUgaW5wdXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKi9cblxuXG4gIFJhbmdlU2xpZGVyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZShpbmRleCkge1xuXG4gICAgLy8gV2UgZG9uJ3QgaGF2ZSBhbiBpbnB1dCBlbGVtZW50IGF0IHRoYXQgaW5kZXgsIHNvIHNvbWV0aGluZyB3ZW50IHdyb25nLlxuICAgIGlmICghdGhpcy5pbnB1dEVsc1tpbmRleF0gfHwgIXRoaXMuaGFuZGxlRWxzW2luZGV4XSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZ2V0IHZhbHVlIGZyb20gYSBzbGlkZXIgaW5wdXQgZWxlbWVudCB3aXRoIGFuIGluZGV4IG9mICcgKyBpbmRleCArICcuIFRoYXQgZWxlbWVudCBkb2VzIG5vdCBleGlzdC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmlucHV0RWxzW2luZGV4XS5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJycpO1xuICAgIHRoaXMuaW5wdXRFbHNbaW5kZXhdLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICB0aGlzLmhhbmRsZUVsc1tpbmRleF0uc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICcnKTtcbiAgICB0aGlzLmhhbmRsZUVsc1tpbmRleF0uc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgIHRoaXMuX3VwZGF0ZURpc2FibGVkQ2xhc3NlcygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudCB0aGUgdmFsdWUgYnkgdGhlIHN0ZXAgc2l6ZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSB1c2VNdWx0aXBsaWVyIE9wdGlvbmFsIEluY3JlbWVudCBieSBhIG11bHRpcGxpZWQgdmVyc2lvbiBvZiB0aGUgc3RlcFxuICAgKi9cblxuXG4gIFJhbmdlU2xpZGVyLnByb3RvdHlwZS5pbmNyZW1lbnQgPSBmdW5jdGlvbiBpbmNyZW1lbnQodXNlTXVsdGlwbGllcikge1xuICAgIHJldHVybiB0aGlzLnNldFZhbHVlKHRoaXMuY3VycmVudEluZGV4LCB0aGlzLnZhbHVlc1t0aGlzLmN1cnJlbnRJbmRleF0gKyB0aGlzLnN0ZXBzW3RoaXMuY3VycmVudEluZGV4XSAqICh1c2VNdWx0aXBsaWVyID8gMTAgOiAxKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY3JlbWVudCB0aGUgdmFsdWUgYnkgdGhlIHN0ZXAgc2l6ZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSB1c2VNdWx0aXBsaWVyIE9wdGlvbmFsIEluY3JlbWVudCBieSBhIG11bHRpcGxpZWQgdmVyc2lvbiBvZiB0aGUgc3RlcFxuICAgKi9cblxuXG4gIFJhbmdlU2xpZGVyLnByb3RvdHlwZS5kZWNyZW1lbnQgPSBmdW5jdGlvbiBkZWNyZW1lbnQodXNlTXVsdGlwbGllcikge1xuICAgIHJldHVybiB0aGlzLnNldFZhbHVlKHRoaXMuY3VycmVudEluZGV4LCB0aGlzLnZhbHVlc1t0aGlzLmN1cnJlbnRJbmRleF0gLSB0aGlzLnN0ZXBzW3RoaXMuY3VycmVudEluZGV4XSAqICh1c2VNdWx0aXBsaWVyID8gMTAgOiAxKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIHRoZSBET00gYW5kIHByZXBhcmUgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiBieSBkZXJlZmVyZW5jaW5nIHZhbHVlcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBsZWF2ZUVsZW1lbnQgTGVhdmUgdGhlIGVsZW1lbnQgaW50YWN0LlxuICAgKi9cblxuXG4gIFJhbmdlU2xpZGVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUobGVhdmVFbGVtZW50KSB7XG4gICAgdGhpcy5fcmVtb3ZlTW92ZUV2ZW50TGlzdGVuZXJzKCd0b3VjaCcpO1xuICAgIHRoaXMuX3JlbW92ZU1vdmVFdmVudExpc3RlbmVycygnbW91c2UnKTtcbiAgICB0aGlzLl9yZW1vdmVNb3ZlRXZlbnRMaXN0ZW5lcnMoJ2tleWJvYXJkJyk7XG4gICAgcmV0dXJuIF9CYXNlQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLCBsZWF2ZUVsZW1lbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGNvbXBvbmVudCB0byB1c2UgYSBuZXcgZWxlbWVudCBvciByZXBhcnNlIGZyb21cbiAgICogdGhlIGV4aXN0aW5nIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgT3B0aW9uYWxcbiAgICovXG5cblxuICBSYW5nZVNsaWRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGVsKSB7XG5cbiAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuX3JlbW92ZU1vdmVFdmVudExpc3RlbmVycygndG91Y2gnKTtcbiAgICB0aGlzLl9yZW1vdmVNb3ZlRXZlbnRMaXN0ZW5lcnMoJ21vdXNlJyk7XG4gICAgdGhpcy5fcmVtb3ZlTW92ZUV2ZW50TGlzdGVuZXJzKCdrZXlib2FyZCcpO1xuXG4gICAgdGhpcy5fY2FjaGVFbGVtZW50cyhlbCk7XG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl91cGRhdGVEaXNhYmxlZENsYXNzZXMoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5oYW5kbGVFbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUhhbmRsZVBvc2l0aW9uKGkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgd2hvbGUgc2xpZGVyLCBhcyB3ZWxsIGFzIHRoZVxuICAgKiBpbnB1dCBlbGVtZW50LiBBbHNvLCBnZXQgc29tZSBkZWZhdWx0IHZhbHVlcyBmcm9tIHRoZSBpbnB1dFxuICAgKiBlbGVtZW50IChtaW4sIG1heCwgc3RlcHMpLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqL1xuXG5cbiAgUmFuZ2VTbGlkZXIucHJvdG90eXBlLl9jYWNoZUVsZW1lbnRzID0gZnVuY3Rpb24gX2NhY2hlRWxlbWVudHMoZWwpIHtcblxuICAgIHRoaXMuZWwgPSBlbDtcbiAgICB0aGlzLmNvbnRyb2xzRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1zbGlkZXJfX2NvbnRyb2xzJyk7XG4gICAgdGhpcy5pbnB1dEVscyA9IHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cIm51bWJlclwiXScpO1xuICAgIHRoaXMuaGFuZGxlRWxzID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKCcuc3Bhcmstc2xpZGVyX19oYW5kbGUnKTtcbiAgICB0aGlzLnRyYWNrRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1zbGlkZXJfX3RyYWNrJyk7XG4gICAgdGhpcy50cmFja0ZpbGxFbCA9IHRoaXMudHJhY2tFbC5xdWVyeVNlbGVjdG9yKCcuc3Bhcmstc2xpZGVyX190cmFjay1maWxsJyk7XG5cbiAgICB0aGlzLm1lc3NhZ2VFbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnNwYXJrLXNsaWRlcl9fbWVzc2FnZScpIHx8ICgwLCBfbWFrZUVsZW1lbnQyLmRlZmF1bHQpKCc8c3BhbiBjbGFzcz1cInNwYXJrLXNsaWRlcl9fbWVzc2FnZVwiPjwvc3Bhbj4nKTtcblxuICAgIGlmICghdGhpcy5pbnB1dEVscyB8fCB0aGlzLmlucHV0RWxzLmxlbmd0aCA8PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIGNyZWF0ZSBhIHNsaWRlciBpbnN0YW5jZSB3aXRob3V0IHR3byBudW1iZXIgaW5wdXRzLicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5oYW5kbGVFbHMgfHwgdGhpcy5oYW5kbGVFbHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgdG8gY3JlYXRlIGEgc2xpZGVyIGluc3RhbmNlIHdpdGhvdXQgdHdvIGhhbmRsZSBidXR0b25zLicpO1xuICAgIH1cblxuICAgIHZhciBsb3dlc3RNaW4gPSBJbmZpbml0eTtcbiAgICB2YXIgaGlnaGVzdE1heCA9IC1JbmZpbml0eTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHRoaXMuaW5wdXRFbHMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICB0aGlzLm1pbnMgPSBbXTtcbiAgICB0aGlzLm1heGVzID0gW107XG4gICAgdGhpcy5zdGVwcyA9IFtdO1xuXG4gICAgLy8gQ2FjaGUgdGhlIHNpemUgb2YgdGhlIGVsZW1lbnQgc28gdGhhdCB3ZSBjYW4gcHJvcGVybHkgc2V0IHZhbHVlcyBvbiBoYW5kbGVzLlxuICAgIHRoaXMuX2NhY2hlU2l6ZSgpO1xuXG4gICAgLy8gU2V0IHRoZSBtaW5pbXVtIGFuZCBtYXggdmFsdWVzIGZvciBlYWNoIGVsZW1lbnQuIEFsc28gc2V0IGFueSBwcmVkZWZpbmVkIHZhbHVlLlxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBwYXJzZWRNaW4gPSBwYXJzZUludCh0aGlzLmlucHV0RWxzW2ldLmdldEF0dHJpYnV0ZSgnbWluJyksIDEwKTtcbiAgICAgIHRoaXMubWluc1tpXSA9IHBhcnNlZE1pbiA9PT0gMCA/IHBhcnNlZE1pbiA6IHBhcnNlZE1pbiB8fCBudWxsOyAvLyBUZXJuYXJ5IG9wZXJhdG9yIHRvIHByZXZlbnQgbnVsbCB3aGVuIHdlIGhhdmUgYWN0dWFsIDAgdmFsdWVcblxuICAgICAgdmFyIHBhcnNlZE1heCA9IHBhcnNlSW50KHRoaXMuaW5wdXRFbHNbaV0uZ2V0QXR0cmlidXRlKCdtYXgnKSwgMTApO1xuICAgICAgdGhpcy5tYXhlc1tpXSA9IHBhcnNlZE1heCA9PT0gMCA/IHBhcnNlZE1heCA6IHBhcnNlZE1heCB8fCBudWxsOyAvLyBUZXJuYXJ5IG9wZXJhdG9yIHRvIHByZXZlbnQgbnVsbCB3aGVuIHdlIGhhdmUgYWN0dWFsIDAgdmFsdWVcblxuICAgICAgdGhpcy5zdGVwc1tpXSA9IHBhcnNlSW50KHRoaXMuaW5wdXRFbHNbaV0uZ2V0QXR0cmlidXRlKCdzdGVwJyksIDEwKSB8fCAxO1xuXG4gICAgICBpZiAodGhpcy5taW5zW2ldIDwgbG93ZXN0TWluKSB7XG4gICAgICAgIGxvd2VzdE1pbiA9IHRoaXMubWluc1tpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWF4ZXNbaV0gPiBoaWdoZXN0TWF4KSB7XG4gICAgICAgIGhpZ2hlc3RNYXggPSB0aGlzLm1heGVzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubG93ZXN0TWluID0gbG93ZXN0TWluO1xuICAgIHRoaXMuaGlnaGVzdE1heCA9IGhpZ2hlc3RNYXg7XG5cbiAgICBpID0gMDtcblxuICAgIC8vIElmIHdlIGhhdmUgYSBkZWZhdWx0IHZhbHVlLCBzZXQgaXQuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICB2YWx1ZXNbaV0gPSBwYXJzZUludCh0aGlzLmlucHV0RWxzW2ldLmdldEF0dHJpYnV0ZSgndmFsdWUnKSwgMTApO1xuXG4gICAgICAvLyBJdCdzIGEgbnVtYmVyXG4gICAgICBpZiAoIWlzTmFOKHZhbHVlc1tpXSkpIHtcbiAgICAgICAgdGhpcy5zZXRWYWx1ZShpLCB2YWx1ZXNbaV0pO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBTZXQgYXMgdGhlIG1pbmltdW0gdW5sZXNzIHRoaXMgaXMgdGhlIGxhc3QgaGFuZGxlLlxuICAgICAgICBpZiAoaSArIDEgPT09IGxlbikge1xuICAgICAgICAgIHRoaXMuc2V0VmFsdWUoaSwgdGhpcy5tYXhlc1tpXSAhPT0gbnVsbCA/IHRoaXMubWF4ZXNbaV0gOiAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNldFZhbHVlKGksIHRoaXMubWluc1tpXSAhPT0gbnVsbCA/IHRoaXMubWluc1tpXSA6IDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTYXZlIHRoZSBlbGVtZW50IGRpbWVuc2lvbnMuXG4gICAqL1xuXG5cbiAgUmFuZ2VTbGlkZXIucHJvdG90eXBlLl9jYWNoZVNpemUgPSBmdW5jdGlvbiBfY2FjaGVTaXplKCkge1xuICAgIHRoaXMud2lkdGggPSB0aGlzLnRyYWNrRWwub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLnRyYWNrRWwub2Zmc2V0SGVpZ2h0O1xuXG4gICAgdGhpcy5oYW5kbGVTaXplID0gdGhpcy5pc1ggPyB0aGlzLmhhbmRsZUVsc1swXS5vZmZzZXRXaWR0aCA6IHRoaXMuaGFuZGxlRWxzWzBdLm9mZnNldEhlaWdodDtcbiAgICB0aGlzLmhhbmRsZVNpemVQZXJjZW50YWdlID0gdGhpcy5pc1ggPyB0aGlzLmhhbmRsZUVsc1swXS5vZmZzZXRXaWR0aCAvIHRoaXMud2lkdGggOiB0aGlzLmhhbmRsZUVsc1swXS5vZmZzZXRIZWlnaHQgLyB0aGlzLmhlaWdodDtcblxuICAgIHZhciBvZmZzZXQgPSAoMCwgX29mZnNldDIuZGVmYXVsdCkodGhpcy5jb250cm9sc0VsKTtcbiAgICB0aGlzLm9mZnNldExlZnQgPSBvZmZzZXQubGVmdDtcbiAgICB0aGlzLm9mZnNldFRvcCA9IG9mZnNldC50b3A7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIGhhbmRsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgaGFuZGxlIGVsZW1lbnQgdG8gdXBkYXRlLlxuICAgKi9cblxuXG4gIFJhbmdlU2xpZGVyLnByb3RvdHlwZS5fdXBkYXRlSGFuZGxlUG9zaXRpb24gPSBmdW5jdGlvbiBfdXBkYXRlSGFuZGxlUG9zaXRpb24oaW5kZXgpIHtcbiAgICAvLyBUcmFjayBhbmQgVHJhY2stRmlsbCBlbGVtZW50c1xuICAgIHZhciBmaXJzdFBlcmNlbnRhZ2UgPSB0aGlzLnBlcmNlbnRhZ2VzWzBdO1xuICAgIHZhciBsYXN0UGVyY2VudGFnZSA9IHRoaXMucGVyY2VudGFnZXNbdGhpcy5wZXJjZW50YWdlcy5sZW5ndGggLSAxXTtcbiAgICB0aGlzLnRyYWNrRmlsbEVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnd2lkdGg6ICcgKyAobGFzdFBlcmNlbnRhZ2UgLSBmaXJzdFBlcmNlbnRhZ2UpICogMTAwICsgJyU7IGxlZnQ6ICcgKyBmaXJzdFBlcmNlbnRhZ2UgKiAxMDAgKyAnJTsnKTtcblxuICAgIC8vIEhhbmRsZSBwb3NpdGlvblxuICAgIHZhciBoYW5kbGVQb3MgPSB0aGlzLmhhbmRsZVNpemUgLyAyICsgKHRoaXMudmFsdWVzW2luZGV4XSAtIHRoaXMubG93ZXN0TWluKSAqICgodGhpcy53aWR0aCAtIHRoaXMuaGFuZGxlU2l6ZSkgLyAodGhpcy5oaWdoZXN0TWF4IC0gdGhpcy5sb3dlc3RNaW4pKTtcbiAgICB2YXIgaGFuZGxlUG9zUGVyY2VudGFnZSA9IGhhbmRsZVBvcyAvIHRoaXMud2lkdGggKiAxMDA7XG4gICAgdGhpcy5oYW5kbGVFbHNbaW5kZXhdLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnbGVmdDogJyArIGhhbmRsZVBvc1BlcmNlbnRhZ2UgKyAnJTsnKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBhY3RpdmUgY2xhc3Mgb24gdGhlIGhhbmRsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgaGFuZGxlIGVsZW1lbnQgdG8gdXBkYXRlLlxuICAgKi9cblxuXG4gIFJhbmdlU2xpZGVyLnByb3RvdHlwZS5fdXBkYXRlQWN0aXZlQ2xhc3NlcyA9IGZ1bmN0aW9uIF91cGRhdGVBY3RpdmVDbGFzc2VzKGluZGV4KSB7XG5cbiAgICAoMCwgX3RvZ2dsZUNsYXNzMi5kZWZhdWx0KSh0aGlzLmhhbmRsZUVscywgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAoMCwgX3RvZ2dsZUNsYXNzMi5kZWZhdWx0KSh0aGlzLmhhbmRsZUVsc1tpbmRleF0sICdhY3RpdmUnLCB0aGlzLmlzQWN0aXZlW2luZGV4XSk7XG5cbiAgICBpZiAodGhpcy5pc0FjdGl2ZS5pbmRleE9mKHRydWUpICE9PSAtMSkge1xuICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYWN0aXZlLWluZGV4JywgdGhpcy5pc0FjdGl2ZS5pbmRleE9mKHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtYWN0aXZlLWluZGV4Jyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgd2hpY2ggaGFuZGxlcyBhcmUgZGlzYWJsZWQuXG4gICAqL1xuXG5cbiAgUmFuZ2VTbGlkZXIucHJvdG90eXBlLl91cGRhdGVEaXNhYmxlZENsYXNzZXMgPSBmdW5jdGlvbiBfdXBkYXRlRGlzYWJsZWRDbGFzc2VzKCkge1xuXG4gICAgdmFyIGRpc2FibGVkQ291bnQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuaW5wdXRFbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgaWYgKHRoaXMuaW5wdXRFbHNbaV0uZ2V0QXR0cmlidXRlKCdkaXNhYmxlZCcpICE9PSBudWxsKSB7XG4gICAgICAgICgwLCBfdG9nZ2xlQ2xhc3MyLmRlZmF1bHQpKHRoaXMuaGFuZGxlRWxzW2ldLCAnZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgZGlzYWJsZWRDb3VudCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKDAsIF90b2dnbGVDbGFzczIuZGVmYXVsdCkodGhpcy5oYW5kbGVFbHNbaV0sICdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAoMCwgX3RvZ2dsZUNsYXNzMi5kZWZhdWx0KSh0aGlzLmVsLCAnYWxsLWRpc2FibGVkJywgZGlzYWJsZWRDb3VudCA9PT0gdGhpcy5oYW5kbGVFbHMubGVuZ3RoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGJvdW5kIHZlcnNpb25zIG9mIGV2ZW50IGxpc3RlbmVyIGNhbGxiYWNrcyBhbmQgc3RvcmUgdGhlbS5cbiAgICogT3RoZXJ3aXNlIHdlIGNhbid0IHVuYmluZCBmcm9tIHRoZXNlIGV2ZW50cyBsYXRlciBiZWNhdXNlIHRoZVxuICAgKiBmdW5jdGlvbiBzaWduYXR1cmVzIHdvbid0IG1hdGNoLlxuICAgKi9cblxuXG4gIFJhbmdlU2xpZGVyLnByb3RvdHlwZS5fYmluZEV2ZW50TGlzdGVuZXJDYWxsYmFja3MgPSBmdW5jdGlvbiBfYmluZEV2ZW50TGlzdGVuZXJDYWxsYmFja3MoKSB7XG5cbiAgICB0aGlzLl9vblRvdWNoU3RhcnRCb3VuZCA9IHRoaXMuX29uVG91Y2hTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uVG91Y2hNb3ZlQm91bmQgPSB0aGlzLl9vblRvdWNoTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uVG91Y2hFbmRCb3VuZCA9IHRoaXMuX29uVG91Y2hFbmQuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX29uQ2xpY2tCb3VuZCA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbk1vdXNlRG93bkJvdW5kID0gdGhpcy5fb25Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbk1vdXNlTW92ZUJvdW5kID0gdGhpcy5fb25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbk1vdXNlVXBCb3VuZCA9IHRoaXMuX29uTW91c2VVcC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fb25Gb2N1c0JvdW5kID0gdGhpcy5fb25Gb2N1cy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uS2V5ZG93bkJvdW5kID0gdGhpcy5fb25LZXlkb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25CbHVyQm91bmQgPSB0aGlzLl9vbkJsdXIuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX29uQ2hhbmdlQm91bmQgPSB0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fb25SZXNpemVCb3VuZCA9IHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9vblZpc2libGVDaGlsZHJlbkJvdW5kID0gdGhpcy5fb25WaXNpYmxlQ2hpbGRyZW4uYmluZCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGV2ZW50IGxpc3RlbmVycyBmb3IgdG91Y2hzdGFydCBhbmQgbW91c2UgY2xpY2suXG4gICAqL1xuXG5cbiAgUmFuZ2VTbGlkZXIucHJvdG90eXBlLl9hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIF9hZGRFdmVudExpc3RlbmVycygpIHtcblxuICAgIHRoaXMuY29udHJvbHNFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0Qm91bmQpO1xuICAgIHRoaXMuY29udHJvbHNFbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93bkJvdW5kKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmlucHV0RWxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLmlucHV0RWxzW2ldLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlQm91bmQpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwLCBsZW4yID0gdGhpcy5oYW5kbGVFbHMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICB0aGlzLmhhbmRsZUVsc1tqXS5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX29uRm9jdXNCb3VuZCk7XG4gICAgICB0aGlzLmhhbmRsZUVsc1tqXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2tCb3VuZCk7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc3BhcmsudmlzaWJsZS1jaGlsZHJlbicsIHRoaXMuX29uVmlzaWJsZUNoaWxkcmVuQm91bmQsIHRydWUpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplQm91bmQpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMuX29uUmVzaXplQm91bmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGZvciB0b3VjaHN0YXJ0IGFuZCBtb3VzZSBjbGljay5cbiAgICovXG5cblxuICBSYW5nZVNsaWRlci5wcm90b3R5cGUuX3JlbW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuXG4gICAgdGhpcy5jb250cm9sc0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnRCb3VuZCk7XG4gICAgdGhpcy5jb250cm9sc0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duQm91bmQpO1xuXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3BhcmsudmlzaWJsZS1jaGlsZHJlbicsIHRoaXMuX29uVmlzaWJsZUNoaWxkcmVuQm91bmQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuaW5wdXRFbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMuaW5wdXRFbHNbaV0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2VCb3VuZCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDAsIGxlbjIgPSB0aGlzLmhhbmRsZUVscy5sZW5ndGg7IGkgPCBsZW4yOyBpKyspIHtcbiAgICAgIHRoaXMuaGFuZGxlRWxzW2pdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fb25Gb2N1c0JvdW5kKTtcbiAgICAgIHRoaXMuaGFuZGxlRWxzW2pdLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGlja0JvdW5kKTtcbiAgICB9XG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemVCb3VuZCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgdGhpcy5fb25SZXNpemVCb3VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBldmVudCBsaXN0ZW5lcnMgZm9yIHRvdWNobW92ZSwgdG91Y2hlbmQsIG1vdXNlbW92ZSBhbmQgbW91c2V1cC5cbiAgICogV2UgYWRkIHRoZXNlIHRvIHRoZSB3aW5kb3cgc28gdGhhdCB0aGUgdXNlciBjYW4gbW92ZSBvZmYgb2YgdGhlIGVsZW1lbnRcbiAgICogYnV0IGtlZXAgZHJhZ2dpbmcgdGhlIHNsaWRlciBoYW5kbGUuIE90aGVyd2lzZSBpdCdzIHJlYWxseSBoYXJkIHRvXG4gICAqIHVzZSB0aGUgc2xpZGVyIHVubGVzcyBpdCdzIG1hc3NpdmUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFdoaWNoIHR5cGUgb2YgbGlzdGVuZXJzIHRvIGFkZFxuICAgKi9cblxuXG4gIFJhbmdlU2xpZGVyLnByb3RvdHlwZS5fYWRkTW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX2FkZE1vdmVFdmVudExpc3RlbmVycyh0eXBlKSB7XG5cbiAgICAvLyBPbmx5IGxpc3RlbiBmb3IgZXZlbnRzIG9mIHRoZSB0eXBlIHdlIGFza2VkIGZvci5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ21vdXNlJzpcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlQm91bmQpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLl9vbk1vdXNlT3V0Qm91bmQpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcEJvdW5kKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3VjaCc6XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZUJvdW5kKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZEJvdW5kKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdrZXlib2FyZCc6XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlkb3duQm91bmQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5oYW5kbGVFbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUVsc1tpXS5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fb25CbHVyQm91bmQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBmb3IgbW92ZSBldmVudHMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFdoaWNoIHR5cGUgb2YgbGlzdGVuZXJzIHRvIGFkZFxuICAgKi9cblxuXG4gIFJhbmdlU2xpZGVyLnByb3RvdHlwZS5fcmVtb3ZlTW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlbW92ZU1vdmVFdmVudExpc3RlbmVycyh0eXBlKSB7XG5cbiAgICAvLyBPbmx5IHVuYmluZCBldmVudHMgb2YgdGhlIHR5cGUgd2UgYXNrZWQgZm9yLlxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnbW91c2UnOlxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmVCb3VuZCk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwQm91bmQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvdWNoJzpcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlQm91bmQpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kQm91bmQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2tleWJvYXJkJzpcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleWRvd25Cb3VuZCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmhhbmRsZUVscy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHRoaXMuaGFuZGxlRWxzW2ldLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9vbkJsdXJCb3VuZCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSB0b3VjaCBzdGFydHMsIHN0YXJ0IHRoZSBzbGlkZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgUmFuZ2VTbGlkZXIucHJvdG90eXBlLl9vblRvdWNoU3RhcnQgPSBmdW5jdGlvbiBfb25Ub3VjaFN0YXJ0KGUpIHtcbiAgICB0aGlzLnN0YXJ0KCgwLCBfZ2V0SW5kZXgyLmRlZmF1bHQpKHRoaXMuaGFuZGxlRWxzLCBlLnRhcmdldCksIHRoaXMuaXNYID8gZS50b3VjaGVzWzBdLnBhZ2VYIDogZS50b3VjaGVzWzBdLnBhZ2VZLCAndG91Y2gnKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgd2luZG93IGZpcmVzIGEgdG91Y2htb3ZlIGV2ZW50LCBhZGp1c3Qgb3VyIHZhbHVlIGFjY29yZGluZ2x5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgUmFuZ2VTbGlkZXIucHJvdG90eXBlLl9vblRvdWNoTW92ZSA9IGZ1bmN0aW9uIF9vblRvdWNoTW92ZShlKSB7XG5cbiAgICBpZiAoIXRoaXMuaXNBY3RpdmVbdGhpcy5jdXJyZW50SW5kZXhdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdGhpcy5tb3ZlKHRoaXMuaXNYID8gZS50b3VjaGVzWzBdLnBhZ2VYIDogZS50b3VjaGVzWzBdLnBhZ2VZKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgd2luZG93IGZpcmVzIGEgdG91Y2hlbmQgZXZlbnQsIHN0b3AgdHJhY2tpbmcgdG91Y2hlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgKi9cblxuXG4gIFJhbmdlU2xpZGVyLnByb3RvdHlwZS5fb25Ub3VjaEVuZCA9IGZ1bmN0aW9uIF9vblRvdWNoRW5kKGUpIHtcblxuICAgIGlmICghdGhpcy5pc0FjdGl2ZVt0aGlzLmN1cnJlbnRJbmRleF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB0aGlzLnN0b3AoKDAsIF9nZXRJbmRleDIuZGVmYXVsdCkodGhpcy5oYW5kbGVFbHMsIGUudGFyZ2V0KSwgJ3RvdWNoJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIG1vdXNlIHByZXNzZXMgZG93biwgc3RhcnQgdGhlIHNsaWRlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICovXG5cblxuICBSYW5nZVNsaWRlci5wcm90b3R5cGUuX29uTW91c2VEb3duID0gZnVuY3Rpb24gX29uTW91c2VEb3duKGUpIHtcbiAgICB0aGlzLnN0YXJ0KCgwLCBfZ2V0SW5kZXgyLmRlZmF1bHQpKHRoaXMuaGFuZGxlRWxzLCBlLnRhcmdldCksIHRoaXMuaXNYID8gZS5wYWdlWCA6IGUucGFnZVksICdtb3VzZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSB3aW5kb3cgZmlyZXMgYSBtb3VzZW1vdmUgZXZlbnQsIGFkanVzdCBvdXIgdmFsdWUgYWNjb3JkaW5nbHlcbiAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICovXG5cblxuICBSYW5nZVNsaWRlci5wcm90b3R5cGUuX29uTW91c2VNb3ZlID0gZnVuY3Rpb24gX29uTW91c2VNb3ZlKGUpIHtcblxuICAgIGlmICghdGhpcy5pc0FjdGl2ZVt0aGlzLmN1cnJlbnRJbmRleF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB0aGlzLm1vdmUodGhpcy5pc1ggPyBlLnBhZ2VYIDogZS5wYWdlWSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHdpbmRvdyBmaXJlcyBhIG1vdXNldXAgZXZlbnQsIHN0b3AgdHJhY2tpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICovXG5cblxuICBSYW5nZVNsaWRlci5wcm90b3R5cGUuX29uTW91c2VVcCA9IGZ1bmN0aW9uIF9vbk1vdXNlVXAoKSB7XG5cbiAgICBpZiAoIXRoaXMuaXNBY3RpdmVbdGhpcy5jdXJyZW50SW5kZXhdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zdG9wKG51bGwsICdtb3VzZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgdGhlIHNwYXJrLnZpc2libGUtY2hpbGRyZW4gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICovXG5cblxuICBSYW5nZVNsaWRlci5wcm90b3R5cGUuX29uVmlzaWJsZUNoaWxkcmVuID0gZnVuY3Rpb24gX29uVmlzaWJsZUNoaWxkcmVuKGUpIHtcbiAgICBpZiAoZS50YXJnZXQuY29udGFpbnModGhpcy5lbCkpIHtcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fb25SZXNpemUoKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgMCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSB3aW5kb3cgcmVzaXplcywgY2FjaGUgc2l6ZSB2YWx1ZXMgZm9yIHRoZSBzbGlkZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgUmFuZ2VTbGlkZXIucHJvdG90eXBlLl9vblJlc2l6ZSA9IGZ1bmN0aW9uIF9vblJlc2l6ZSgpIHtcbiAgICB0aGlzLl9jYWNoZVNpemUoKTtcbiAgICB0aGlzLl91cGRhdGVEaXNhYmxlZENsYXNzZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaGFuZGxlRWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl91cGRhdGVIYW5kbGVQb3NpdGlvbihpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIGVsZW1lbnQgcmVjZWl2ZXMgZm9jdXMsIHN0YXJ0IGxpc3RlbmluZyBmb3Iga2V5Ym9hcmQgZXZlbnRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgUmFuZ2VTbGlkZXIucHJvdG90eXBlLl9vbkZvY3VzID0gZnVuY3Rpb24gX29uRm9jdXMoZSkge1xuICAgIHRoaXMuc3RhcnQoKDAsIF9nZXRJbmRleDIuZGVmYXVsdCkodGhpcy5oYW5kbGVFbHMsIGUudGFyZ2V0KSwgbnVsbCwgJ2tleWJvYXJkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gYSBrZXkgaXMgcHJlc3NlZCwgc2VlIGlmIGl0J3Mgb25lIG9mIHRoZSBBcnJvdywgUGFnZSB1cCwgUGFnZSBkb3duLCBIb21lXG4gICAqIG9yIEVuZCBrZXlzIG1vdmUgdGhlIGhhbmRsZSBhY2NvcmRpbmdseS4gSWYgdGhlIHNoaWZ0IGtleSBpcyBwcmVzc2VkIGluIGNvbWJpbmF0aW9uXG4gICAqIHdpdGggdGhlIGFycm93IGtleXMsIHdlJ2xsIGluY3JlbWVudCBhbmQgZGVjcmVtZW50IGJ5IGJpZ2dlciB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgUmFuZ2VTbGlkZXIucHJvdG90eXBlLl9vbktleWRvd24gPSBmdW5jdGlvbiBfb25LZXlkb3duKGUpIHtcblxuICAgIGlmICgoMCwgX2dldEluZGV4Mi5kZWZhdWx0KSh0aGlzLmlucHV0RWxzLCBlLnRhcmdldCkgIT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGUua2V5Q29kZSA9PT0gMzkgfHwgZS5rZXlDb2RlID09PSAzOCkge1xuICAgICAgLy8gUmlnaHQgb3IgVXAgYXJyb3dcbiAgICAgIHRoaXMuaW5jcmVtZW50KGUuc2hpZnRLZXkpO1xuICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09PSAzNyB8fCBlLmtleUNvZGUgPT09IDQwKSB7XG4gICAgICAvLyBMZWZ0IG9yIGRvd24gYXJyb3dcbiAgICAgIHRoaXMuZGVjcmVtZW50KGUuc2hpZnRLZXkpO1xuICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09PSAzMykge1xuICAgICAgLy8gUGFnZSBVcFxuICAgICAgdGhpcy5pbmNyZW1lbnQodHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT09IDM0KSB7XG4gICAgICAvLyBQYWdlIERvd25cbiAgICAgIHRoaXMuZGVjcmVtZW50KHRydWUpO1xuICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09PSAzNSkge1xuICAgICAgLy8gRW5kXG4gICAgICB0aGlzLnNldFZhbHVlKHRoaXMubWF4KTtcbiAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gMzYpIHtcbiAgICAgIC8vIEhvbWVcbiAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5taW4pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgZWxlbWVudCBsb3NlcyBmb2N1cywgc3RvcCBsaXN0ZW5pbmcgZm9yIGtleWJvYXJkIGV2ZW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgKi9cblxuXG4gIFJhbmdlU2xpZGVyLnByb3RvdHlwZS5fb25CbHVyID0gZnVuY3Rpb24gX29uQmx1cihlKSB7XG4gICAgdGhpcy5zdG9wKCgwLCBfZ2V0SW5kZXgyLmRlZmF1bHQpKHRoaXMuaGFuZGxlRWxzLCBlLnRhcmdldCksICdrZXlib2FyZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBpbnB1dCB2YWx1ZSBjaGFuZ2VzLCBzZXQgb3VyIGludGVyYWwgdmFsdWUgaWYgaXQncyBub3QgYWxyZWFkeSBvdXIgdmFsdWUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgUmFuZ2VTbGlkZXIucHJvdG90eXBlLl9vbkNoYW5nZSA9IGZ1bmN0aW9uIF9vbkNoYW5nZShlKSB7XG5cbiAgICB2YXIgaW5kZXggPSAoMCwgX2dldEluZGV4Mi5kZWZhdWx0KSh0aGlzLmlucHV0RWxzLCBlLnRhcmdldCk7XG5cbiAgICB0aGlzLl91cGRhdGVEaXNhYmxlZENsYXNzZXMoKTtcblxuICAgIGlmIChlLnRhcmdldC52YWx1ZSAhPT0gdGhpcy52YWx1ZXNbaW5kZXhdKSB7XG4gICAgICB0aGlzLnNldFZhbHVlKGluZGV4LCBlLnRhcmdldC52YWx1ZSk7XG4gICAgfVxuICAgICh0aGlzLm9uQ2hhbmdlIHx8IG5vb3ApKGluZGV4LCB0aGlzLnZhbHVlc1tpbmRleF0sIHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcmV2ZW50IGNsaWNrIGV2ZW50cyBvbiB0aGUgYnV0dG9uLiBUaGlzIHdheSB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc3VibWl0IHRoZSBmb3JtLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgKi9cblxuXG4gIFJhbmdlU2xpZGVyLnByb3RvdHlwZS5fb25DbGljayA9IGZ1bmN0aW9uIF9vbkNsaWNrKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgcmV0dXJuIFJhbmdlU2xpZGVyO1xufShfYmFzZTIuZGVmYXVsdCk7XG5cbi8qKlxuICogV2hpdGVsaXN0ZWQgcGFyYW1ldGVycyB3aGljaCBjYW4gYmUgc2V0IG9uIGNvbnN0cnVjdGlvbi5cbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuXG5cblJhbmdlU2xpZGVyLnByb3RvdHlwZS5fd2hpdGVsaXN0ZWRQYXJhbXMgPSBbJ2lzWCcsICd2YWxpZGF0ZScsICdvblZhbGlkYXRlJywgJ29uQ2hhbmdlJywgJ29uV2lsbENoYW5nZSddO1xuXG4vKipcbiAqIERlZmF1bHQgdmFsdWVzIGZvciBpbnRlcm5hbCBwcm9wZXJ0aWVzIHdlIHdpbGwgYmUgc2V0dGluZy5cbiAqIFRoZXNlIGFyZSBzZXQgb24gZWFjaCBjb25zdHJ1Y3Rpb24gc28gd2UgZG9uJ3QgbGVhayBwcm9wZXJ0aWVzXG4gKiBpbnRvIHRoZSBwcm90b3R5cGUgY2hhaW4uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5SYW5nZVNsaWRlci5wcm90b3R5cGUuZGVmYXVsdHMgPSB7XG4gIGVsOiBudWxsLFxuICBtZXNzYWdlRWw6IG51bGwsXG4gIGNvbnRyb2xzRWw6IG51bGwsXG4gIGlucHV0RWxzOiBudWxsLFxuICBoYW5kbGVFbHM6IG51bGwsXG4gIHRyYWNrRWw6IG51bGwsXG4gIHRyYWNrRmlsbEVsOiBudWxsLFxuICBpc0FjdGl2ZTogbnVsbCxcbiAgaXNYOiB0cnVlLFxuICBvblZhbGlkYXRlOiBudWxsLFxuICBvbkNoYW5nZTogbnVsbCxcbiAgb25XaWxsQ2hhbmdlOiBudWxsLFxuICBwb3NpdGlvbjogMCxcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMCxcbiAgbWluczogbnVsbCxcbiAgbWF4ZXM6IG51bGwsXG4gIHN0ZXBzOiBudWxsLFxuICB2YWx1ZXM6IG51bGwsXG4gIHBlcmNlbnRhZ2VzOiBudWxsLFxuICBvZmZzZXRMZWZ0OiAwLFxuICBvZmZzZXRUb3A6IDAsXG4gIGhhbmRsZVNpemVQZXJjZW50YWdlOiAwLFxuICBjdXJyZW50SW5kZXg6IG51bGwsXG4gIGxhc3RJbmRleDogbnVsbCxcbiAgX29sZFZhbDogbnVsbCxcbiAgX29uVG91Y2hTdGFydEJvdW5kOiBudWxsLFxuICBfb25Ub3VjaE1vdmVCb3VuZDogbnVsbCxcbiAgX29uVG91Y2hFbmRCb3VuZDogbnVsbCxcbiAgX29uTW91c2VEb3duQm91bmQ6IG51bGwsXG4gIF9vbk1vdXNlTW92ZUJvdW5kOiBudWxsLFxuICBfb25Nb3VzZVVwQm91bmQ6IG51bGwsXG4gIF9vbk1vdXNlT3V0Qm91bmQ6IG51bGwsXG4gIF9vbkZvY3VzQm91bmQ6IG51bGwsXG4gIF9vbktleWRvd25Cb3VuZDogbnVsbCxcbiAgX29uQmx1ckJvdW5kOiBudWxsLFxuICBfb25DaGFuZ2VCb3VuZDogbnVsbCxcbiAgX29uUmVzaXplQm91bmQ6IG51bGwsXG4gIF9vbkNsaWNrQm91bmQ6IG51bGwsXG4gIF9vblZpc2libGVDaGlsZHJlbkJvdW5kOiBudWxsXG59O1xuXG4oMCwgX21peGluMi5kZWZhdWx0KShSYW5nZVNsaWRlci5wcm90b3R5cGUsIF9tZXNzYWdpbmcyLmRlZmF1bHQsIF92YWxpZGF0aW9uMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUmFuZ2VTbGlkZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhbmdlLXNsaWRlci5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9vdXRlckhlaWdodCA9IHJlcXVpcmUoJy4uL2RvbS9vdXRlci1oZWlnaHQnKTtcblxudmFyIF9vdXRlckhlaWdodDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vdXRlckhlaWdodCk7XG5cbnZhciBfYWRkQ2xhc3MgPSByZXF1aXJlKCcuLi9kb20vYWRkLWNsYXNzJyk7XG5cbnZhciBfYWRkQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWRkQ2xhc3MpO1xuXG52YXIgX3JlbW92ZUNsYXNzID0gcmVxdWlyZSgnLi4vZG9tL3JlbW92ZS1jbGFzcycpO1xuXG52YXIgX3JlbW92ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlbW92ZUNsYXNzKTtcblxudmFyIF9oYXNDbGFzcyA9IHJlcXVpcmUoJy4uL2RvbS9oYXMtY2xhc3MnKTtcblxudmFyIF9oYXNDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYXNDbGFzcyk7XG5cbnZhciBfdG9nZ2xlQ2xhc3MgPSByZXF1aXJlKCcuLi9kb20vdG9nZ2xlLWNsYXNzJyk7XG5cbnZhciBfdG9nZ2xlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9nZ2xlQ2xhc3MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIyBBbmltYXRlIEhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEFuaW1hdGUgdGhlIGhlaWdodCBvZiBhbiBlbGVtZW50IHNpbmNlIHdlIGNhbid0IGRvIHRoaXMgdy8gcHVyZSBDU1MuIFNpZ2guXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGFuaW1hdGVIZWlnaHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgZWw6IC4uLixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIHRvZ2dsZUVsOiAuLi4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAvLyBPcHRpb25hbCBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIGFjdGlvbjogJ2NvbGxhcHNlJ3wnZXhwYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIGhlaWdodEFuaW1hdGlvbkNsYXNzOiAnc3BhcmstYW5pbWF0ZS1oZWlnaHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgb3BhY2l0eUFuaW1hdGlvbkNsYXNzOiAnc3BhcmstYW5pbWF0ZS1vcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIHRvZ2dsZVByb3BlcnR5OiAnZGlzcGxheSd8J292ZXJmbG93J3wndmlzaWJpbGl0eScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICB0b2dnbGVWYWx1ZTogJ2Jsb2NrJ3wnbm9uZSd8J3Zpc2libGUnfCdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgYW5pbWF0aW9uRHVyYXRpb246IDI1MFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBoZWxwZXJzL2FuaW1hdGlvbi9oZWlnaHQuanNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxudmFyIHJ1bm5pbmdBbmltYXRpb25zID0ge1xuICBlbHM6IFtdLFxuICBjb21wbGV0ZUNhbGxiYWNrczogW11cbn07XG5cbi8qKlxuICogR2V0IHRoZSBpbnZlcnNlIHRvZ2dsZSB2YWx1ZVxuICogQHBhcmFtICB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtICB7U3RyaW5nfSBvcmlnaW5hbFZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldEludmVyc2VUb2dnbGVWYWx1ZShlbCwgcHJvcGVydHksIG9yaWdpbmFsVmFsdWUpIHtcblxuICAvLyBHZXQgdGhlIHZhbHVlIHRvIHRvZ2dsZSB0byBmb3IgdGhlIGdpdmVuIHByb3BlcnR5XG4gIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICBjYXNlICdvdmVyZmxvdyc6XG4gICAgY2FzZSAndmlzaWJpbGl0eSc6XG4gICAgICByZXR1cm4gb3JpZ2luYWxWYWx1ZSA9PT0gJ3Zpc2libGUnID8gJ2hpZGRlbicgOiAndmlzaWJsZSc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBvcmlnaW5hbFZhbHVlID09PSAnYmxvY2snIHx8IG9yaWdpbmFsVmFsdWUgPT09ICdpbmxpbmUtYmxvY2snID8gJ25vbmUnIDogJ2Jsb2NrJztcbiAgfVxufVxuXG4vKipcbiAqIFdoZW4gYW4gYW5pbWF0aW9uIGlzIGNvbXBsZXRlLCBjbGVhbiB1cCBhbmQgcnVuIHRoZSBjYWxsYmFjay5cbiAqIEBwYXJhbSAge09iamVjdH0gcGFyYW1zXG4gKi9cbmZ1bmN0aW9uIG9uQ29tcGxldGUocGFyYW1zKSB7XG5cbiAgLy8gUmVzZXQgdG9nZ2xlIGVsIHZpc2liaWxpdHlcbiAgaWYgKHBhcmFtcy50b2dnbGVDbGFzc05hbWUpIHtcbiAgICAoMCwgX3RvZ2dsZUNsYXNzMi5kZWZhdWx0KShwYXJhbXMuZWwsIHBhcmFtcy50b2dnbGVDbGFzc05hbWUsICFwYXJhbXMuY29sbGFwc2UpO1xuICB9IGVsc2Uge1xuICAgIHBhcmFtcy50b2dnbGVFbC5zdHlsZVtwYXJhbXMudG9nZ2xlUHJvcGVydHldID0gJyc7XG4gIH1cblxuICAvLyBSZW1vdmUgdGhlIGhlaWdodCBwcm9wZXJ0eVxuICBwYXJhbXMuZWwuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gIHBhcmFtcy50b2dnbGVFbC5zdHlsZS5oZWlnaHQgPSAnJztcbiAgcGFyYW1zLnRvZ2dsZUVsLnN0eWxlLm1hcmdpbkJvdHRvbSA9ICcnO1xuICBwYXJhbXMudG9nZ2xlRWwuc3R5bGUubWFyZ2luVG9wID0gJyc7XG5cbiAgLy8gUmVtb3ZlIHRoZSBzcGFyay1hbmltYXRlLWhlaWdodCBjbGFzcyBzbyB0aGUgdHJhbnNpdGlvbnMgbm8gbG9uZ2VyIGFwcGx5XG4gICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKHBhcmFtcy5lbCwgcGFyYW1zLmhlaWdodEFuaW1hdGlvbkNsYXNzKTtcbiAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkocGFyYW1zLnRvZ2dsZUVsLCBwYXJhbXMuaGVpZ2h0QW5pbWF0aW9uQ2xhc3MpO1xuXG4gIC8vIFJ1biB0aGUgY2FsbGJhY2tcbiAgcGFyYW1zLm9uQ29tcGxldGUoKTtcblxuICAvLyBSZW1vdmUgdGhlIGVsZW1lbnQgYW5kIGNhbGxiYWNrIGZyb20gdGhlaXIgcmVzcGVjdGl2ZSBhcnJheXNcbiAgdmFyIHJ1bm5pbmdJbmRleCA9IHJ1bm5pbmdBbmltYXRpb25zLmVscy5pbmRleE9mKHBhcmFtcy5lbCk7XG4gIHJ1bm5pbmdBbmltYXRpb25zLmVscy5zcGxpY2UocnVubmluZ0luZGV4LCAxKTtcbiAgcnVubmluZ0FuaW1hdGlvbnMuY29tcGxldGVDYWxsYmFja3Muc3BsaWNlKHJ1bm5pbmdJbmRleCwgMSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICovXG5mdW5jdGlvbiBhbmltYXRlSGVpZ2h0KHBhcmFtcykge1xuXG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICB2YXIgZWwgPSBwYXJhbXMuZWw7XG5cbiAgaWYgKCFlbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb2xsYXBzZSA9IHBhcmFtcy5hY3Rpb24gJiYgcGFyYW1zLmFjdGlvbiA9PT0gJ2NvbGxhcHNlJztcbiAgdmFyIGhlaWdodEFuaW1hdGlvbkNsYXNzID0gcGFyYW1zLmhlaWdodEFuaW1hdGlvbkNsYXNzIHx8ICdzcGFyay1hbmltYXRlLWhlaWdodCc7XG5cbiAgLy8gQWxsb3cgZm9yIGVsZW1lbnRzIHRvIGJlIHBhc3NlZCBvciBzZWxlY3RvciBzdHJpbmdzXG4gIHZhciB0b2dnbGVFbCA9IHR5cGVvZiBwYXJhbXMudG9nZ2xlRWwgPT09ICdzdHJpbmcnID8gZWwucXVlcnlTZWxlY3RvcihwYXJhbXMudG9nZ2xlRWwpIDogcGFyYW1zLnRvZ2dsZUVsO1xuXG4gIC8vIE5vIGVsZW1lbnQgdG8gYmUgc3dpdGNoaW5nIHdpdGggdG9nZ2xpbmcgc28gd2UgY2FuJ3QgZGV0ZXJtaW5lIHRoZSBkZXNpcmVkIGhlaWdodCB0byBhbmltYXRlIHRvLlxuICBpZiAoIXRvZ2dsZUVsIHx8ICgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKGVsLCAnc3Bhcmstbm8tYW5pbWF0ZScpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRvZ2dsZUNsYXNzTmFtZSA9IHBhcmFtcy50b2dnbGVDbGFzcztcblxuICAvLyBUaGUgc3R5bGUgcHJvcGVydHkgdG8gdXNlIHdoZW4gdG9nZ2xpbmcgdmlzaWJpbGl0eVxuICB2YXIgdG9nZ2xlUHJvcGVydHkgPSBwYXJhbXMudG9nZ2xlUHJvcGVydHkgfHwgJ2Rpc3BsYXknO1xuICB2YXIgdG9nZ2xlU3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodG9nZ2xlRWwpO1xuICB2YXIgb3JpZ2luYWxUb2dnbGVWYWx1ZSA9IHRvZ2dsZVN0eWxlc1t0b2dnbGVQcm9wZXJ0eV07XG4gIHZhciB0b2dnbGVWYWx1ZSA9IHBhcmFtcy50b2dnbGVWYWx1ZSB8fCBnZXRJbnZlcnNlVG9nZ2xlVmFsdWUodG9nZ2xlUHJvcGVydHksIG9yaWdpbmFsVG9nZ2xlVmFsdWUpO1xuXG4gIC8vIElmIHdlIGFyZSBhbHJlYWR5IGFuaW1hdGluZywgc3RvcCBub3cuXG4gIHZhciBydW5uaW5nSW5kZXggPSBydW5uaW5nQW5pbWF0aW9ucy5lbHMuaW5kZXhPZihlbCk7XG4gIGlmIChydW5uaW5nSW5kZXggIT09IC0xKSB7XG5cbiAgICB2YXIgY29tcGxldGVDYWxsYmFjayA9IHJ1bm5pbmdBbmltYXRpb25zLmNvbXBsZXRlQ2FsbGJhY2tzW3J1bm5pbmdJbmRleF07XG4gICAgaWYgKGNvbXBsZXRlQ2FsbGJhY2spIHtcbiAgICAgIGNsZWFyVGltZW91dChjb21wbGV0ZUNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBvbkNvbXBsZXRlKHtcbiAgICAgIGVsOiBlbCxcbiAgICAgIHRvZ2dsZUVsOiB0b2dnbGVFbCxcbiAgICAgIG9uQ29tcGxldGU6IHBhcmFtcy5vbkNvbXBsZXRlIHx8IG5vb3AsXG4gICAgICBjb2xsYXBzZTogY29sbGFwc2UsXG4gICAgICB0b2dnbGVQcm9wZXJ0eTogdG9nZ2xlUHJvcGVydHksXG4gICAgICB0b2dnbGVDbGFzc05hbWU6IHRvZ2dsZUNsYXNzTmFtZSxcbiAgICAgIHRvZ2dsZVZhbHVlOiB0b2dnbGVWYWx1ZSxcbiAgICAgIGhlaWdodEFuaW1hdGlvbkNsYXNzOiBoZWlnaHRBbmltYXRpb25DbGFzc1xuICAgIH0pO1xuICB9XG5cbiAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgaGVpZ2h0XG4gIHZhciBvcmlnaW5hbEhlaWdodCA9ICgwLCBfb3V0ZXJIZWlnaHQyLmRlZmF1bHQpKGVsKTtcblxuICAvLyBUb2dnbGUgdGhlIHZpc2libGUgcHJvcGVydHlcbiAgaWYgKHRvZ2dsZUNsYXNzTmFtZSkge1xuICAgICgwLCBfdG9nZ2xlQ2xhc3MyLmRlZmF1bHQpKGVsLCB0b2dnbGVDbGFzc05hbWUsICFjb2xsYXBzZSk7XG4gIH0gZWxzZSB7XG4gICAgdG9nZ2xlRWwuc3R5bGVbdG9nZ2xlUHJvcGVydHldID0gdG9nZ2xlVmFsdWU7XG4gIH1cblxuICAvLyBXaGVuIG1lYXN1cmluZyB0aGUgc2l6ZSBmb3IgYSBjb2xsYXBzZSwgd2UgaGF2ZSB0byB3YWl0IGEgdGljIGZvciBpdCB0byBiZVxuICAvLyBhY2N1cmF0ZS4gTm90IHN1cmUgd2h5LiBVZ2guXG4gIGlmIChjb2xsYXBzZSkge1xuICAgIHNldFRpbWVvdXQocnVuQW5pbWF0aW9uLCAwKTtcbiAgfSBlbHNlIHtcbiAgICBydW5BbmltYXRpb24oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1bkFuaW1hdGlvbigpIHtcblxuICAgIC8vIE5vdyB0aGF0IHRoZSB0b2dnbGUgZWwgaXMgdGFraW5nIHVwIHNwYWNlLCBnZXQgdGhlIG5ldyBoZWlnaHQgd2hpY2ggd2Ugd2lsbCBiZSBhbmltYXRpbmcgdG9cbiAgICB2YXIgdGFyZ2V0RWxIZWlnaHQgPSAoMCwgX291dGVySGVpZ2h0Mi5kZWZhdWx0KShlbCk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIHN0b3JlIHRoZSBvcmlnaW5hbCBhbmQgdGFyZ2V0IHRvZ2dsZSBlbGVtZW50IGhlaWdodHMuIFRoZXkgZGlmZmVyIGRlcGVuZGluZyBvblxuICAgIC8vIHdoZXRoZXIgd2UgYXJlIGdvaW5nIHRvIGV4cGFuZCBvciBjb2xsYXBzZS5cbiAgICB2YXIgdGFyZ2V0VG9nZ2xlRWxIZWlnaHQgPSB2b2lkIDA7XG4gICAgdmFyIG9yaWdpbmFsVG9nZ2xlRWxIZWlnaHQgPSB2b2lkIDA7XG5cbiAgICAvLyBJZiB3ZSBhcmUgY29sbGFwc2luZywgcmVzZXQgdGhlIHRvZ2dsZSBzdHlsZSBhbmQgc2V0IGl0IHdoZW4gd2UncmUgZG9uZS4gU2V0IHRoZSBoZWlnaHQgc29cbiAgICAvLyB0aGF0IHdlIGNhbiBhbmltYXRlIGRvd24gdG8gMCBvciB1cCB0byB0aGUgdGFyZ2V0IGhlaWdodC5cbiAgICBpZiAoY29sbGFwc2UpIHtcblxuICAgICAgaWYgKHRvZ2dsZUNsYXNzTmFtZSkge1xuICAgICAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KShlbCwgdG9nZ2xlQ2xhc3NOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvZ2dsZUVsLnN0eWxlW3RvZ2dsZVByb3BlcnR5XSA9IG9yaWdpbmFsVG9nZ2xlVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIG9yaWdpbmFsVG9nZ2xlRWxIZWlnaHQgPSAoMCwgX291dGVySGVpZ2h0Mi5kZWZhdWx0KSh0b2dnbGVFbCwgdG9nZ2xlU3R5bGVzKTtcbiAgICAgIHRhcmdldFRvZ2dsZUVsSGVpZ2h0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0VG9nZ2xlRWxIZWlnaHQgPSAoMCwgX291dGVySGVpZ2h0Mi5kZWZhdWx0KSh0b2dnbGVFbCwgdG9nZ2xlU3R5bGVzKTtcbiAgICAgIG9yaWdpbmFsVG9nZ2xlRWxIZWlnaHQgPSAwO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgb3JpZ2luYWwgaGVpZ2h0XG4gICAgZWwuc3R5bGUuaGVpZ2h0ID0gb3JpZ2luYWxIZWlnaHQgKyAncHgnO1xuICAgIHRvZ2dsZUVsLnN0eWxlLmhlaWdodCA9IG9yaWdpbmFsVG9nZ2xlRWxIZWlnaHQgKyAncHgnO1xuICAgIHRvZ2dsZUVsLnN0eWxlLm1hcmdpbkJvdHRvbSA9ICcwcHgnO1xuICAgIHRvZ2dsZUVsLnN0eWxlLm1hcmdpblRvcCA9ICcwcHgnO1xuXG4gICAgLy8gQWRkIHRoZSBzcGFyay1hbmltYXRlLWhlaWdodCBjbGFzcyB3aGljaCB3aWxsIHNldHVwIHRoZSB0cmFuc2l0aW9uLXByb3BlcnR5IGFuZCBkdXJhdGlvblxuICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKGVsLCBoZWlnaHRBbmltYXRpb25DbGFzcyk7XG4gICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodG9nZ2xlRWwsIGhlaWdodEFuaW1hdGlvbkNsYXNzKTtcblxuICAgIHJ1bm5pbmdBbmltYXRpb25zLmVscy5wdXNoKGVsKTtcblxuICAgIC8vIFdlIG5lZWQgdG8gd2FpdCBhIHRpY2sgdG8gdG9nZ2xlIHRoZSBoZWlnaHQgb3IgZWxzZSB0aGUgYW5pbWF0aW9uIGNsYXNzIHdvbid0IGZ1bmN0aW9uXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cbiAgICAgIC8vIFNldCB0aGUgaGVpZ2h0IHRvIHRoZSB0YXJnZXQgaGVpZ2h0XG4gICAgICBlbC5zdHlsZS5oZWlnaHQgPSB0YXJnZXRFbEhlaWdodCArICdweCc7XG4gICAgICB0b2dnbGVFbC5zdHlsZS5oZWlnaHQgPSB0YXJnZXRUb2dnbGVFbEhlaWdodCArICdweCc7XG5cbiAgICAgIC8vIFJlbW92ZSBpbmxpbmUgc3R5bGVzIGFmdGVyIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGVcbiAgICAgIHJ1bm5pbmdBbmltYXRpb25zLmNvbXBsZXRlQ2FsbGJhY2tzLnB1c2goc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uQ29tcGxldGUoe1xuICAgICAgICAgIGVsOiBlbCxcbiAgICAgICAgICB0b2dnbGVFbDogdG9nZ2xlRWwsXG4gICAgICAgICAgb25Db21wbGV0ZTogcGFyYW1zLm9uQ29tcGxldGUgfHwgbm9vcCxcbiAgICAgICAgICBjb2xsYXBzZTogY29sbGFwc2UsXG4gICAgICAgICAgdG9nZ2xlUHJvcGVydHk6IHRvZ2dsZVByb3BlcnR5LFxuICAgICAgICAgIHRvZ2dsZUNsYXNzTmFtZTogdG9nZ2xlQ2xhc3NOYW1lLFxuICAgICAgICAgIHRvZ2dsZVZhbHVlOiB0b2dnbGVWYWx1ZSxcbiAgICAgICAgICBoZWlnaHRBbmltYXRpb25DbGFzczogaGVpZ2h0QW5pbWF0aW9uQ2xhc3NcbiAgICAgICAgfSk7XG4gICAgICB9LCBwYXJhbXMuYW5pbWF0aW9uRHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IHBhcmFtcy5hbmltYXRpb25EdXJhdGlvbiA6IDIwMSkpO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGFuaW1hdGVIZWlnaHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlaWdodC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90cmltID0gcmVxdWlyZSgnLi4vdXRpbC90cmltJyk7XG5cbnZhciBfdHJpbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmltKTtcblxudmFyIF9oYXNDbGFzcyA9IHJlcXVpcmUoJy4vaGFzLWNsYXNzJyk7XG5cbnZhciBfaGFzQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzQ2xhc3MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqICMgQWRkIENsYXNzXG4gKiBBZGQgYSBjbGFzcyBvbiBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxBcnJheX0gZWwgQW4gZWxlbWVudCBvciBhcnJheSBvZiBlbGVtZW50cyB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7RWxlbWVudH1cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZG9tL2FkZC1jbGFzcy5qc1xuICovXG5cbnZhciB3cyA9IC9cXHMrLztcbnZhciBjbGVhbnVwID0gL1xcc3syLH0vZztcblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIG5hbWUpIHtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gKDAsIF90cmltMi5kZWZhdWx0KShuYW1lKS5zcGxpdCh3cyk7XG4gIH0gZWxzZSB7XG4gICAgbmFtZSA9IG5hbWUgaW5zdGFuY2VvZiBBcnJheSA/IG5hbWUgOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB9XG5cbiAgLy8gb3B0aW1pemUgZm9yIGJlc3QsIG1vc3QgY29tbW9uIGNhc2VcbiAgaWYgKG5hbWUubGVuZ3RoID09PSAxICYmIGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChuYW1lWzBdKSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKG5hbWVbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICB2YXIgdG9BZGQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IG5hbWUubGVuZ3RoO1xuICB2YXIgaXRlbSA9IHZvaWQgMDtcbiAgdmFyIGNsc05hbWUgPSB0eXBlb2YgZWwuY2xhc3NOYW1lID09PSAnc3RyaW5nJyA/IGVsLmNsYXNzTmFtZSA6IGVsLmdldEF0dHJpYnV0ZSA/IGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSA6ICcnO1xuXG4gIC8vIHNlZSBpZiB3ZSBoYXZlIGFueXRoaW5nIHRvIGFkZFxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGl0ZW0gPSBuYW1lW2ldO1xuICAgIGlmIChpdGVtICYmICEoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KShjbHNOYW1lLCBpdGVtKSkge1xuICAgICAgdG9BZGQucHVzaChpdGVtKTtcbiAgICB9XG4gIH1cblxuICBpZiAodG9BZGQubGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBlbC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbC5jbGFzc05hbWUgPSAoMCwgX3RyaW0yLmRlZmF1bHQpKChjbHNOYW1lICsgJyAnICsgdG9BZGQuam9pbignICcpKS5yZXBsYWNlKGNsZWFudXAsICcgJykpO1xuICAgIH0gZWxzZSBpZiAoZWwuc2V0QXR0cmlidXRlKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKDAsIF90cmltMi5kZWZhdWx0KSgoY2xzTmFtZSArICcgJyArIHRvQWRkLmpvaW4oJyAnKSkucmVwbGFjZShjbGVhbnVwLCAnICcpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBhZGRDbGFzcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkLWNsYXNzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbi8qKlxuICogIyBIYXMgQ2xhc3NcbiAqIFNlZSBpZiBhbiBlbGVtZW50IGhhcyBhIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZG9tL2hhcy1jbGFzcy5qc1xuICovXG5mdW5jdGlvbiBoYXNDbGFzcyhlbCwgbmFtZSkge1xuICB2YXIgY05hbWUgPSAoKHR5cGVvZiBlbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZWwpKSA9PT0gJ29iamVjdCcgPyBlbC5jbGFzc05hbWUgfHwgZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJyA6IGVsIHx8ICcnKS5yZXBsYWNlKC9bXFx0XFxyXFxuXFxmXS9nLCAnICcpO1xuICByZXR1cm4gKCcgJyArIGNOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIG5hbWUgKyAnICcpICE9PSAtMTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gaGFzQ2xhc3M7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhcy1jbGFzcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGh0bWwpIHtcblxuICBpZiAoIWh0bWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgZWxlbWVudCB3aXRoIG5vIEhUTUwhJyk7XG4gIH1cblxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZWwuaW5uZXJIVE1MID0gaHRtbDtcbiAgdmFyIGVsMiA9IGVsLmNoaWxkcmVuWzBdO1xuICBlbDIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbDIpO1xuICByZXR1cm4gZWwyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICMgTWFrZSBFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTWFrZSBlbiBlbGVtZW50IHVzaW5nIGEgc3RyaW5nIG9mIEhUTUwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG1ha2VFbGVtZW50KCc8ZGl2PjwvZGl2PicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBoZWxwZXJzL21ha2UtZWxlbWVudC5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1lbGVtZW50LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIE9mZnNldCBQb3NpdGlvblxuICogR2V0IHRoZSBvZmZzZXQgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtCb29sZWFufSB2aWV3UG9ydE9mZnNldCBUaGUgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCwgbm90IHBhZ2UuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL2RvbS9vZmZzZXQuanNcbiAqL1xuZnVuY3Rpb24gb2Zmc2V0KGVsLCB2aWV3UG9ydE9mZnNldCkge1xuXG4gIHZhciByZWN0ID0ge1xuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG5cbiAgLy8gTmF0aXZlIGltcGxlbWVudGF0aW9uXG4gIGlmIChlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcblxuICAgIHZhciBib3VuZGluZyA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJlY3QubGVmdCA9IGJvdW5kaW5nLmxlZnQ7XG4gICAgcmVjdC50b3AgPSBib3VuZGluZy50b3A7XG5cbiAgICBpZiAoIXZpZXdQb3J0T2Zmc2V0KSB7XG4gICAgICByZWN0LmxlZnQgKz0gdHlwZW9mIHdpbmRvdy5zY3JvbGxYICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5zY3JvbGxYIDogd2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgICAgcmVjdC50b3AgKz0gdHlwZW9mIHdpbmRvdy5zY3JvbGxZICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5zY3JvbGxZIDogd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgeCA9IDAsXG4gICAgICAgIHkgPSAwO1xuICAgIGRvIHtcbiAgICAgIHggKz0gZWwub2Zmc2V0TGVmdCAtICghdmlld1BvcnRPZmZzZXQgPyBlbC5zY3JvbGxMZWZ0IDogMCk7XG4gICAgICB5ICs9IGVsLm9mZnNldFRvcCAtICghdmlld1BvcnRPZmZzZXQgPyBlbC5zY3JvbGxUb3AgOiAwKTtcbiAgICB9IHdoaWxlIChlbCA9IGVsLm9mZnNldFBhcmVudCk7XG5cbiAgICByZWN0LmxlZnQgPSB4O1xuICAgIHJlY3QudG9wID0geTtcbiAgfVxuXG4gIHJldHVybiByZWN0O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBvZmZzZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9mZnNldC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9lYWNoID0gcmVxdWlyZSgnLi4vdXRpbC9lYWNoJyk7XG5cbnZhciBfZWFjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHByb3BzID0gWydtYXJnaW5Ub3AnLCAnbWFyZ2luQm90dG9tJywgJ2JvcmRlclRvcCcsICdib3JkZXJCb3R0b20nXTsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAjIE91dGVyIEhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogR2V0IHRoZSBvdXRlciBoZWlnaHQgb2YgYW4gZWxlbWVudCAoaW5jbHVkaW5nIG1hcmdpbiBhbmQgYm9yZGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZXMgT3B0aW9uYWwgQWxyZWFkeSBoYXZlIGNvbXB1dGVkIHN0eWxlcz8gUGFzcyB0aGVtIGluLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBvdXRlckhlaWdodChlbCwgY29tcHV0ZWRTdHlsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgaGVscGVycy9vdXRlci1oZWlnaHQuanNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5cbmZ1bmN0aW9uIG91dGVySGVpZ2h0KGVsLCBzdHlsZXMpIHtcblxuICBzdHlsZXMgPSBzdHlsZXMgfHwgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuXG4gIHZhciBoZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQ7XG5cbiAgKDAsIF9lYWNoMi5kZWZhdWx0KShwcm9wcywgZnVuY3Rpb24gKHByb3ApIHtcbiAgICBoZWlnaHQgKz0gcGFyc2VJbnQoc3R5bGVzW3Byb3BdIHx8IDAsIDEwKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhlaWdodDtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gb3V0ZXJIZWlnaHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW91dGVyLWhlaWdodC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90cmltID0gcmVxdWlyZSgnLi4vdXRpbC90cmltJyk7XG5cbnZhciBfdHJpbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmltKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHdzID0gL1xccysvOyAvKipcbiAgICAgICAgICAgICAgICAgKiAjIFJlbW92ZSBDbGFzc1xuICAgICAgICAgICAgICAgICAqIFJlbW92ZSBhIGNsYXNzIG9uIGFuIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXl9IGVsIEFuIGVsZW1lbnQgb3IgYXJyYXkgb2YgZWxlbWVudHMgdG8gdXBkYXRlLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgaGVscGVycy9kb20vcmVtb3ZlLWNsYXNzLmpzXG4gICAgICAgICAgICAgICAgICovXG5cbnZhciBjbGVhbnVwID0gL1xcc3syLH0vZztcblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIG5hbWUpIHtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gKDAsIF90cmltMi5kZWZhdWx0KShuYW1lKS5zcGxpdCh3cyk7XG4gIH0gZWxzZSB7XG4gICAgbmFtZSA9IG5hbWUgaW5zdGFuY2VvZiBBcnJheSA/IG5hbWUgOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB9XG5cbiAgLy8gb3B0aW1pemUgZm9yIGJlc3QsIG1vc3QgY29tbW9uIGNhc2VcbiAgaWYgKG5hbWUubGVuZ3RoID09PSAxICYmIGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChuYW1lWzBdKSBlbC5jbGFzc0xpc3QucmVtb3ZlKG5hbWVbMF0pO1xuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIC8vIHN0b3JlIHR3byBjb3BpZXNcbiAgdmFyIGNsc05hbWUgPSAnICcgKyAodHlwZW9mIGVsLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycgPyBlbC5jbGFzc05hbWUgOiBlbC5nZXRBdHRyaWJ1dGUgPyBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgOiAnJykgKyAnICc7XG4gIHZhciByZXN1bHQgPSBjbHNOYW1lO1xuICB2YXIgY3VycmVudCA9IHZvaWQgMDtcbiAgdmFyIHN0YXJ0ID0gdm9pZCAwO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IG5hbWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY3VycmVudCA9IG5hbWVbaV07XG4gICAgc3RhcnQgPSBjdXJyZW50ID8gcmVzdWx0LmluZGV4T2YoJyAnICsgY3VycmVudCArICcgJykgOiAtMTtcbiAgICBpZiAoc3RhcnQgIT09IC0xKSB7XG4gICAgICBzdGFydCArPSAxO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIHN0YXJ0KSArIHJlc3VsdC5zbGljZShzdGFydCArIGN1cnJlbnQubGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICAvLyBvbmx5IHdyaXRlIGlmIG1vZGlmaWVkXG4gIGlmIChjbHNOYW1lICE9PSByZXN1bHQpIHtcbiAgICBpZiAodHlwZW9mIGVsLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVsLmNsYXNzTmFtZSA9ICgwLCBfdHJpbTIuZGVmYXVsdCkocmVzdWx0LnJlcGxhY2UoY2xlYW51cCwgJyAnKSk7XG4gICAgfSBlbHNlIGlmIChlbC5zZXRBdHRyaWJ1dGUpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoMCwgX3RyaW0yLmRlZmF1bHQpKHJlc3VsdC5yZXBsYWNlKGNsZWFudXAsICcgJykpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWw7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHJlbW92ZUNsYXNzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmUtY2xhc3MuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfaGFzQ2xhc3MgPSByZXF1aXJlKCcuL2hhcy1jbGFzcycpO1xuXG52YXIgX2hhc0NsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhc0NsYXNzKTtcblxudmFyIF9hZGRDbGFzcyA9IHJlcXVpcmUoJy4vYWRkLWNsYXNzJyk7XG5cbnZhciBfYWRkQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWRkQ2xhc3MpO1xuXG52YXIgX3JlbW92ZUNsYXNzID0gcmVxdWlyZSgnLi9yZW1vdmUtY2xhc3MnKTtcblxudmFyIF9yZW1vdmVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZW1vdmVDbGFzcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsLCBuYW1lLCBlbmFibGUpIHtcblxuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgd2UncmUgcGFzc2VkIGFuIGFycmF5LCB0b2dnbGUgdGhlIGNsYXNzIG9uIGVhY2guXG4gIGlmIChlbCBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IGVsIGluc3RhbmNlb2YgQXJyYXkpIHtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdG9nZ2xlQ2xhc3MoZWxbaV0sIG5hbWUsIGVuYWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGFjdGlvbiA9IHZvaWQgMDtcbiAgaWYgKGVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5hYmxlID0gdHlwZW9mIGVuYWJsZSA9PT0gJ2Z1bmN0aW9uJyA/IGVuYWJsZS5jYWxsKG51bGwsIGVsKSA6IGVuYWJsZTtcbiAgICBhY3Rpb24gPSBlbmFibGUgPyAnYWRkJyA6ICdyZW1vdmUnO1xuICB9IGVsc2Uge1xuICAgIGFjdGlvbiA9ICgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKGVsLCBuYW1lKSA/ICdyZW1vdmUnIDogJ2FkZCc7XG4gIH1cblxuICByZXR1cm4gKGFjdGlvbiA9PT0gJ2FkZCcgPyBfYWRkQ2xhc3MyLmRlZmF1bHQgOiBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKGVsLCBuYW1lKTtcbn0gLyoqXG4gICAqICMgVG9nZ2xlIENsYXNzXG4gICAqIFRvZ2dsZSBhIGNsYXNzIG9uIGFuIGVsZW1lbnQgZ2l2ZW4gYSBjb25kaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxBcnJheX0gZWwgQW4gZWxlbWVudCBvciBhcnJheSBvZiBlbGVtZW50cyB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqXG4gICAqIEBtb2R1bGUgIGhlbHBlcnMvZG9tL3RvZ2dsZS1jbGFzcy5qc1xuICAgKi9cblxuZXhwb3J0cy5kZWZhdWx0ID0gdG9nZ2xlQ2xhc3M7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvZ2dsZS1jbGFzcy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIEdldCBJbmRleFxuICogR2V0IHRoZSBpbmRleCBvZiBhbiBlbGVtZW50IGluIGEgbm9kZWxpc3QuXG4gKlxuICogQHBhcmFtIHtOb2RlTGlzdH0gZWxzXG4gKiBAcGFyYW0ge05vZGV9IGVsXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL3RyYXZlcnNhbC9nZXQtaW5kZXguanNcbiAqL1xuZnVuY3Rpb24gZ2V0SW5kZXgoZWxzLCBlbCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChlbHMsIGVsKTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0SW5kZXg7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWluZGV4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIEVhY2hcbiAqIEFwcGx5IGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYSBsaXN0IG9mIGFueSBraW5kOiBBcnJheSwgTm9kZUxpc3QsIEhUTUxDb2xsZWN0aW9uIG9yIE9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fE5vZGVMaXN0fEhUTUxDb2xsZWN0aW9ufE9iamVjdH0gbGlzdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqXG4gKiBAZXhhbXBsZVxuICogZWFjaChbXSwgY2FsbGJhY2spO1xuICogZWFjaChlbC5jaGlsZHJlbiwgY2FsbGJhY2spO1xuICogZWFjaChlbC5jaGlsZE5vZGVzLCBjYWxsYmFjayk7XG4gKiBlYWNoKHt9LCBjYWxsYmFjayk7XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL3V0aWwvZWFjaC5qc1xuICovXG5mdW5jdGlvbiBlYWNoKGxpc3QsIGNiKSB7XG5cbiAgaWYgKCFsaXN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludm9rZSBgZWFjaGAgd2l0aG91dCBhIGNhbGxiYWNrIScpO1xuICB9XG5cbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG5cbiAgLy8gT2JqZWN0XG4gIGlmIChsZW4gPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAoaSBpbiBsaXN0KSB7XG4gICAgICBpZiAoaSAhPT0gJ3Byb3RvdHlwZScgJiYgbGlzdC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICBjYihpLCBsaXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gQXJyYXktbGlrZVxuICBlbHNlIHtcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY2IobGlzdFtpXSk7XG4gICAgICB9XG4gICAgfVxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBlYWNoO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lYWNoLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAocHJvdG8pIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1peGlucyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBtaXhpbnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgKDAsIF9lYWNoMi5kZWZhdWx0KShtaXhpbnMsIGZ1bmN0aW9uIChtaXhpbikge1xuICAgIGZvciAodmFyIGkgaW4gbWl4aW4pIHtcbiAgICAgIGlmIChtaXhpbi5oYXNPd25Qcm9wZXJ0eShpKSAmJiAhcHJvdG9baV0pIHByb3RvW2ldID0gbWl4aW5baV07XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBfZWFjaCA9IHJlcXVpcmUoJy4vZWFjaCcpO1xuXG52YXIgX2VhY2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFjaCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogIyBNaXhpblxuICogQXBwbHkgYSBtaXhpbiwgb3IgbWl4aW5zLCB0byBhbiBPYmplY3RcbiAqXG4gKiBAZXhhbXBsZVxuICogbWl4aW4ocHJvdG8sIG1peCwgbWl4MilcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdXRpbC9taXhpbi5qc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1peGluLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIFRyaW1cbiAqIFRyaW0gd2hpdGVzcGFjZSBvbiBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL3V0aWwvdHJpbS5qc1xuICovXG5cbnZhciB0cmltUkUgPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSh0cmltUkUsICcnKTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHJpbTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJpbS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9oZWlnaHQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2FuaW1hdGlvbi9oZWlnaHQnKTtcblxudmFyIF9oZWlnaHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGVpZ2h0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGVycm9yIHN0YXRlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBPcHRpb25hbFxuICAgKi9cbiAgc2V0RXJyb3I6IGZ1bmN0aW9uIHNldEVycm9yKG1lc3NhZ2UpIHtcblxuICAgIC8vIEFuaW1hdGUgZG93blxuICAgIGlmICghdGhpcy5faXNNZXNzYWdlVmlzaWJsZSgpKSB7XG4gICAgICB0aGlzLl9zaG93TWVzc2FnZSgpO1xuICAgIH1cblxuICAgIHRoaXMuY2xlYXJXYXJuaW5nKCk7XG4gICAgdGhpcy5jbGVhclN1Y2Nlc3MoKTtcblxuICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdkYXRhLWVycm9yJywgdHJ1ZSk7XG5cbiAgICBpZiAobWVzc2FnZSkge1xuICAgICAgdGhpcy5zZXRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZXJyb3Igc3RhdGUuXG4gICAqL1xuICBjbGVhckVycm9yOiBmdW5jdGlvbiBjbGVhckVycm9yKCkge1xuICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWVycm9yJywgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cblxuICAvKipcbiAgICogU2V0IHRoZSB3YXJuaW5nIHN0YXRlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBPcHRpb25hbFxuICAgKi9cbiAgc2V0V2FybmluZzogZnVuY3Rpb24gc2V0V2FybmluZyhtZXNzYWdlKSB7XG5cbiAgICAvLyBBbmltYXRlIGRvd25cbiAgICBpZiAoIXRoaXMuX2lzTWVzc2FnZVZpc2libGUoKSkge1xuICAgICAgdGhpcy5fc2hvd01lc3NhZ2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyRXJyb3IoKTtcbiAgICB0aGlzLmNsZWFyU3VjY2VzcygpO1xuXG4gICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtd2FybmluZycsIHRydWUpO1xuXG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMuc2V0TWVzc2FnZShtZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGVycm9yIHN0YXRlLlxuICAgKi9cbiAgY2xlYXJXYXJuaW5nOiBmdW5jdGlvbiBjbGVhcldhcm5pbmcoKSB7XG4gICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtd2FybmluZycsIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3VjY2VzcyBzdGF0ZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgT3B0aW9uYWxcbiAgICovXG4gIHNldFN1Y2Nlc3M6IGZ1bmN0aW9uIHNldFN1Y2Nlc3MobWVzc2FnZSkge1xuXG4gICAgLy8gQW5pbWF0ZSBkb3duXG4gICAgaWYgKCF0aGlzLl9pc01lc3NhZ2VWaXNpYmxlKCkpIHtcbiAgICAgIHRoaXMuX3Nob3dNZXNzYWdlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhckVycm9yKCk7XG4gICAgdGhpcy5jbGVhcldhcm5pbmcoKTtcblxuICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdkYXRhLXN1Y2Nlc3MnLCB0cnVlKTtcblxuICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICB0aGlzLnNldE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cblxuICAvKipcbiAgICogU2V0IHRoZSBzdWNjZXNzIHN0YXRlLlxuICAgKi9cbiAgY2xlYXJTdWNjZXNzOiBmdW5jdGlvbiBjbGVhclN1Y2Nlc3MoKSB7XG4gICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtc3VjY2VzcycsIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBtZXNzYWdlcy5cbiAgICovXG4gIGNsZWFyTWVzc2FnZXM6IGZ1bmN0aW9uIGNsZWFyTWVzc2FnZXMoKSB7XG4gICAgdGhpcy5faGlkZU1lc3NhZ2UoZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jbGVhckVycm9yKCk7XG4gICAgICB0aGlzLmNsZWFyV2FybmluZygpO1xuICAgICAgdGhpcy5jbGVhclN1Y2Nlc3MoKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWVzc2FnZSB0ZXh0LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKi9cbiAgc2V0TWVzc2FnZTogZnVuY3Rpb24gc2V0TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlRWwuaW5uZXJIVE1MID0gbWVzc2FnZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBtZXNzYWdlXG4gICAqL1xuICBfc2hvd01lc3NhZ2U6IGZ1bmN0aW9uIF9zaG93TWVzc2FnZSgpIHtcblxuICAgIGlmICghdGhpcy5tZXNzYWdlRWwucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLm1lc3NhZ2VFbCk7XG4gICAgfVxuXG4gICAgKDAsIF9oZWlnaHQyLmRlZmF1bHQpKHtcbiAgICAgIGVsOiB0aGlzLmVsLFxuICAgICAgdG9nZ2xlRWw6IHRoaXMubWVzc2FnZUVsXG4gICAgfSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogSGlkZSB0aGUgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIF9oaWRlTWVzc2FnZTogZnVuY3Rpb24gX2hpZGVNZXNzYWdlKGNhbGxiYWNrKSB7XG5cbiAgICAoMCwgX2hlaWdodDIuZGVmYXVsdCkoe1xuICAgICAgZWw6IHRoaXMuZWwsXG4gICAgICB0b2dnbGVFbDogdGhpcy5tZXNzYWdlRWwsXG4gICAgICB0b2dnbGVWYWx1ZTogJ25vbmUnLFxuICAgICAgYWN0aW9uOiAnY29sbGFwc2UnLFxuICAgICAgb25Db21wbGV0ZTogY2FsbGJhY2tcbiAgICB9KTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBJcyB0aGUgbWVzc2FnZSBjdXJyZW50bHkgdmlzaWJsZT9cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIF9pc01lc3NhZ2VWaXNpYmxlOiBmdW5jdGlvbiBfaXNNZXNzYWdlVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZXJyb3InKSB8fCB0aGlzLmVsLmdldEF0dHJpYnV0ZSgnZGF0YS13YXJuaW5nJykgfHwgdGhpcy5lbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3VjY2VzcycpO1xuICB9XG59OyAvKipcbiAgICAqICMgTWVzc2FnaW5nIE1peGluXG4gICAgKiBBZGQgZnVuY3Rpb25hbGl0eSBmb3Igc2hvd2luZyBtZXNzYWdlcyByZWxhdGVkIHRvIGEgZm9ybSBmaWVsZC5cbiAgICAqXG4gICAgKiBAZXhhbXBsZVxuICAgICogbWl4aW4oQ29tcG9uZW50LCBtZXNzYWdpbmcpO1xuICAgICpcbiAgICAqIEBtb2R1bGUgbWl4aW4vbWVzc2FnaW5nLmpzXG4gICAgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdpbmcuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBWYWxpZGF0aW9uIE1peGluXG4gKiBBZGQgZnVuY3Rpb25hbGl0eSBmb3IgdmFsaWRhdGluZyBhIGZvcm0gZmllbGQncyB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogbWl4aW4oQ29tcG9uZW50LCB2YWxpZGF0aW9uKTtcbiAqXG4gKiBAbW9kdWxlIG1peGluL3ZhbGlkYXRpb24uanNcbiAqL1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsaWRhdGUgZnVuY3Rpb24uIFRoaXMgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZyBhXG4gICAqIGN1c3RvbSB2YWxpZGF0ZSBtZXRob2QgYXMgYSBwYXJhbWV0ZXIuIFRoaXMgcmVhbGx5IG9ubHkgaGVscHMgb3V0XG4gICAqIG9mIHRoZSBib3ggZm9yIHRleHQgaW5wdXRzLlxuICAgKi9cbiAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuXG4gICAgdmFyIHZhbGlkYXRlID0gdGhpcy52YWxpZGF0ZVBhdHRlcm47XG5cbiAgICAvLyBOb3RoaW5nIHRvIHZhbGlkYXRlLlxuICAgIGlmICghdGhpcy5vblZhbGlkYXRlIHx8ICF2YWxpZGF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cCh2YWxpZGF0ZSk7XG5cbiAgICB0aGlzLm9uVmFsaWRhdGUocmUudGVzdCh0aGlzLmdldFZhbHVlKCkpLCB0aGlzLmdldFZhbHVlKCksIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGlvbi5qcy5tYXBcbiJdfQ=="}