{"version":3,"sources":["js/dist/components/node_modules/browser-pack/_prelude.js","js/dist/components/js/dist/components/base.js","js/dist/components/js/dist/components/popover.js","js/dist/components/js/dist/helpers/dom/add-class.js","js/dist/components/js/dist/helpers/dom/has-class.js","js/dist/components/js/dist/helpers/dom/offset.js","js/dist/components/js/dist/helpers/dom/parse-attribute.js","js/dist/components/js/dist/helpers/dom/remove-class.js","js/dist/components/js/dist/helpers/dom/toggle-class.js","js/dist/components/js/dist/helpers/manipulation/append-children.js","js/dist/components/js/dist/helpers/position/affix.js","js/dist/components/js/dist/helpers/position/box-position.js","js/dist/components/js/dist/helpers/traversal/get-parent.js","js/dist/components/js/dist/helpers/traversal/has-parent.js","js/dist/components/js/dist/helpers/traversal/matches.js","js/dist/components/js/dist/helpers/util/debounce.js","js/dist/components/js/dist/helpers/util/each.js","js/dist/components/js/dist/helpers/util/trim.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1kBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"popover.js","sourcesContent":["(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _each = require('../helpers/util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * # Base Component\n                                                                                                                                                           * The base class for Spark JS components. This class should never be\n                                                                                                                                                           * instantiated directly.\n                                                                                                                                                           *\n                                                                                                                                                           * @param {Element} el\n                                                                                                                                                           * @param {Object} params\n                                                                                                                                                           *\n                                                                                                                                                           * @module components/base.js\n                                                                                                                                                           */\n\nvar noop = function noop() {};\n\nvar Base = function () {\n\n  /**\n   * Set parameters and cache elements.\n   */\n  function Base(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Base);\n\n    if (params.elRequired && !el) {\n      return;\n    }\n\n    this.setParams(this.defaults || {}, true);\n    this.setParams(params);\n    (this._cacheElements || noop).call(this, el, params);\n    (this._parseParams || noop).call(this);\n  }\n\n  /**\n   * Remove the component from the DOM and prepare for garbage collection by dereferencing values.\n   * @param {Boolean} leaveElement Leave the element intact.\n   */\n\n\n  Base.prototype.remove = function remove(leaveElement) {\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    if (!leaveElement && this.el && this.el.parentNode) {\n      this.el.parentNode.removeChild(this.el);\n    }\n\n    this.unsetParams(this.defaults);\n\n    return this;\n  };\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   * @param {Object} params Optional\n   */\n\n\n  Base.prototype.update = function update(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    (this._cacheElements || noop).call(this, el || this.el, params);\n    (this._parseParams || noop).call(this);\n\n    if (this._addEventListeners) {\n      this._addEventListeners();\n    }\n\n    return this;\n  };\n\n  /**\n   * Set a hash of parameters if they're whitelisted or we're told to force the set.\n   * This is used to set initial values as well as set passed parameters.\n   * @param {Object} params\n   * @param {Boolean} force Force setting even if the param is not whitelisted.\n   */\n\n\n  Base.prototype.setParams = function setParams(params, force) {\n    var _this = this;\n\n    (0, _each2.default)(params, function (k, v) {\n      if (_this._whitelistedParams.indexOf(k) !== -1 || force) {\n        _this[k] = v;\n      }\n    });\n\n    return this;\n  };\n\n  /**\n   * Unset all parameters.\n   * @param {Array|Object} keys\n   * @param {Object} scope The object to unset the params from. Defaults to `this`.\n   */\n\n\n  Base.prototype.unsetParams = function unsetParams(keys, scope) {\n\n    keys = keys instanceof Array ? keys : Object.keys(keys);\n    scope = scope || this;\n    (0, _each2.default)(keys, function (k) {\n      delete scope[k];\n    });\n\n    return this;\n  };\n\n  return Base;\n}();\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nBase.prototype._whitelistedParams = [];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nBase.prototype.defaults = {};\n\nexports.default = Base;\nmodule.exports = exports['default'];\n//# sourceMappingURL=base.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _base = require('./base');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _addClass = require('../helpers/dom/add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _hasClass = require('../helpers/dom/has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _toggleClass = require('../helpers/dom/toggle-class');\n\nvar _toggleClass2 = _interopRequireDefault(_toggleClass);\n\nvar _appendChildren = require('../helpers/manipulation/append-children');\n\nvar _appendChildren2 = _interopRequireDefault(_appendChildren);\n\nvar _hasParent = require('../helpers/traversal/has-parent');\n\nvar _hasParent2 = _interopRequireDefault(_hasParent);\n\nvar _getParent = require('../helpers/traversal/get-parent');\n\nvar _getParent2 = _interopRequireDefault(_getParent);\n\nvar _parseAttribute = require('../helpers/dom/parse-attribute');\n\nvar _affix = require('../helpers/position/affix');\n\nvar _affix2 = _interopRequireDefault(_affix);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * # Popover\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Show and hide a popover. Should do some sanity checks on positioning as well.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @example\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * new Popover(el, {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   // Optional. Default anchoring of the content's x and y-axis relative to the button.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   defaultAnchorX: 'center', // 'left', 'center', 'right'\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   defaultAnchorY: 'center' // 'left', 'center', 'right'\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * });\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module components/popover.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\nvar noop = function noop() {};\n\nvar Popover = function (_BaseComponent) {\n  _inherits(Popover, _BaseComponent);\n\n  function Popover(el) {\n    var _ret;\n\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Popover);\n\n    var _this = _possibleConstructorReturn(this, _BaseComponent.call(this, el, params));\n\n    if (!el) return _ret = _this, _possibleConstructorReturn(_this, _ret);\n    _this._bindEventListenerCallbacks();\n    _this._addEventListeners();\n    return _this;\n  }\n\n  /**\n   * Open.\n   * @param {Object} params Optional\n   */\n\n\n  Popover.prototype.open = function open() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n    // If there is a timer running for the close event, clear it so it\n    // doesn't close stuff during open.\n    if (this.closeTimer) {\n      clearTimeout(this.closeTimer);\n      this.closeTimer = null;\n    }\n\n    // If the element we anchor the popover to is fixed, we need to know\n    // so that the affixed content can also be fixed.\n    this._checkFixedPosition();\n\n    // Update an existing affixed instance.\n    if (this.affix) {\n      this.affix.targetEl = params.affixTo || this.affix.targetEl;\n      this.affix.update();\n    }\n    // Affix the content to the toggle\n    else {\n        this.affix = new _affix2.default({\n          el: this.contentEl,\n          targetEl: params.affixTo || this.el,\n          caretEl: this.caretEl,\n          anchorX: this.anchorX,\n          anchorY: this.anchorY,\n          isFixed: this.isFixed\n        });\n      }\n\n    // Find all focusable elements in the Popover for navigation\n    var popoverFocusableEls = this.contentEl.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex=\"0\"]');\n\n    if (popoverFocusableEls.length > 0) {\n      this.popoverFocusableEls = Array.prototype.slice.call(popoverFocusableEls);\n      this.firstPopoverFocusableEl = this.popoverFocusableEls[0];\n      this.lastPopoverFocusableEl = this.popoverFocusableEls[this.popoverFocusableEls.length - 1];\n    }\n\n    // Listen for clicks on the window\n    this._addWindowEventListeners();\n\n    this.isActive = true;\n\n    // Dispatch a custom event so content inside the popover can respond\n    var e = document.createEvent('Event');\n    e.initEvent('spark.visible-children', true, true);\n    this.contentEl.dispatchEvent(e);\n\n    // Update bindings\n    this._updateAttributes();\n\n    // Set focus to first focusable element once Popover has been opened\n    if (popoverFocusableEls.length > 0) {\n      this.firstPopoverFocusableEl.focus();\n    }\n\n    // Callbacks\n    (params.complete || noop)();\n    (this.onOpen || noop)();\n\n    return this;\n  };\n\n  /**\n   * Close.\n   * @param {Object} params Optional\n   */\n\n\n  Popover.prototype.close = function close() {\n    var _this2 = this;\n\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n    // Not open, so don't close.\n    if (!this.affix) return this;\n\n    // If there is a timer running for the close event, clear it so we don't run close stuff twice.\n    if (this.closeTimer) {\n      clearTimeout(this.closeTimer);\n      this.closeTimer = null;\n    }\n\n    // Stop listening to window clicks.\n    this._removeWindowEventListeners();\n\n    this.isActive = false;\n\n    // Update bindings\n    this._updateAttributes();\n\n    // Close after the animation has completed\n    this.closeTimer = setTimeout(function () {\n      _this2._finishClose(params);\n    }, 250);\n\n    return this;\n  };\n\n  /**\n   * Toggle the open state.\n   */\n\n\n  Popover.prototype.toggle = function toggle() {\n    return this[this.isActive ? 'close' : 'open']();\n  };\n\n  /**\n   * Set the content. Optionally append instead of replacing.\n   * @param {Element|Array|NodeList} content\n   * @param {Object} params Optional\n   */\n\n\n  Popover.prototype.setContent = function setContent(content, params) {\n    params = params || {};\n    (0, _appendChildren2.default)(this.contentEl, content.length ? content : [content], !(params.append || false));\n    return this;\n  };\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   */\n\n\n  Popover.prototype.update = function update(el) {\n\n    this._removeEventListeners();\n    this._cacheElements(el || this.el);\n    this._addEventListeners();\n\n    if (this.affix) this.affix.update();\n\n    return this;\n  };\n\n  /**\n   * Store a reference to the tabs list, each tab and each panel.\n   * Set which tab is active, or use the first.\n   * @param {Element} el\n   */\n\n\n  Popover.prototype._cacheElements = function _cacheElements(el) {\n\n    // If a content element was already passed, make sure it has a popover content class\n    if (this.contentEl) {\n      (0, _addClass2.default)(this.contentEl, 'spark-popover__content');\n    }\n\n    this.el = el;\n    this.toggleEl = this.el.querySelector('.spark-popover__toggle, [data-role=\"toggle\"]') || this.el;\n    this.contentEl = this.contentEl || this.el.querySelector('.spark-popover__content, [class*=\"spark-popover__content--\"]') || this._createContentEl();\n    this.caretEl = this.contentEl.querySelector('.spark-popover__caret') || this._createCaretEl();\n    this.isActive = (0, _hasClass2.default)(this.toggleEl, 'popover-active');\n  };\n\n  /**\n   * Parse config values from the element.\n   */\n\n\n  Popover.prototype._parseParams = function _parseParams() {\n\n    this.anchorY = this.anchorY !== null ? this.anchorY : (0, _parseAttribute.string)(this.contentEl, 'data-anchor-y', null);\n    this.anchorX = this.anchorX !== null ? this.anchorX : (0, _parseAttribute.string)(this.contentEl, 'data-anchor-x', null);\n\n    // No anchors defined\n    if (!this.anchorY && !this.anchorX) {\n\n      // Left\n      if ((0, _hasClass2.default)(this.contentEl, 'spark-popover__content--left')) {\n        this.anchorY = 'middle';\n        this.anchorX = 'left';\n      }\n      // Right\n      else if ((0, _hasClass2.default)(this.contentEl, 'spark-popover__content--right')) {\n          this.anchorY = 'middle';\n          this.anchorX = 'right';\n        }\n        // Top\n        else if ((0, _hasClass2.default)(this.contentEl, 'spark-popover__content--top')) {\n            this.anchorY = 'top';\n            this.anchorX = 'center';\n          }\n          // Bottom\n          else {\n              this.anchorY = 'bottom';\n              this.anchorX = 'center';\n            }\n    }\n  };\n\n  /**\n   * Check to see if the button triggering the popover is fixed.\n   * If so, then popover needs to be fixed as well.\n   */\n\n\n  Popover.prototype._checkFixedPosition = function _checkFixedPosition() {\n\n    var parent = this.el;\n\n    while (parent && parent !== document) {\n      var style = getComputedStyle(parent);\n      if (style.position === 'fixed') {\n        return this.isFixed = true;\n      }\n      parent = parent.parentNode;\n    }\n\n    return this.isFixed = false;\n  };\n\n  /**\n   * Update classes for the open or close state.\n   */\n\n\n  Popover.prototype._updateAttributes = function _updateAttributes() {\n    (0, _toggleClass2.default)(this.el, 'popover-active', this.isActive);\n    (0, _toggleClass2.default)(this.contentEl, 'active', this.isActive);\n    (0, _toggleClass2.default)(this.toggleEl, 'active', this.isActive);\n  };\n\n  /**\n   * Create bound versions of event listener callbacks and store them.\n   * Otherwise we can't unbind from these events later because the\n   * function signatures won't match.\n   */\n\n\n  Popover.prototype._bindEventListenerCallbacks = function _bindEventListenerCallbacks() {\n    this._onClickBound = this._onClick.bind(this);\n    this._onContentClickBound = this._onContentClick.bind(this);\n    this._onWindowClickBound = this._onWindowClick.bind(this);\n    this._onKeyupBound = this._onKeyup.bind(this);\n    this._onKeydownBound = this._onKeydown.bind(this);\n  };\n\n  /**\n   * Add event listeners for DOM events.\n   */\n\n\n  Popover.prototype._addEventListeners = function _addEventListeners() {\n    this.el.addEventListener('click', this._onClickBound);\n    this.contentEl.addEventListener('click', this._onContentClickBound);\n  };\n\n  /**\n   * Remove event listeners for DOM events..\n   */\n\n\n  Popover.prototype._removeEventListeners = function _removeEventListeners() {\n    this.el.removeEventListener('click', this._onClickBound);\n    this.contentEl.removeEventListener('click', this._onContentClickBound);\n  };\n\n  /**\n   * Add event listeners to the window.\n   */\n\n\n  Popover.prototype._addWindowEventListeners = function _addWindowEventListeners() {\n    this._removeWindowEventListeners();\n    window.addEventListener('click', this._onWindowClickBound);\n    window.addEventListener('keyup', this._onKeyupBound);\n    window.addEventListener('keydown', this._onKeydownBound);\n  };\n\n  /**\n   * Remove window event listeners.\n   */\n\n\n  Popover.prototype._removeWindowEventListeners = function _removeWindowEventListeners() {\n    window.removeEventListener('click', this._onWindowClickBound);\n    window.removeEventListener('keyup', this._onKeyupBound);\n    window.removeEventListener('keydown', this._onKeydownBound);\n  };\n\n  /**\n   * Create a content element.\n   * @return {Element}\n   */\n\n\n  Popover.prototype._createContentEl = function _createContentEl() {\n    var el = document.createElement('div');\n    (0, _addClass2.default)(el, 'spark-popover__content');\n    el.setAttribute('role', 'tooltip');\n    return el;\n  };\n\n  /**\n   * Create the caret element.\n   * @return {Element}\n   */\n\n\n  Popover.prototype._createCaretEl = function _createCaretEl() {\n    var el = document.createElement('div');\n    el.className = 'spark-popover__caret';\n    this.contentEl.appendChild(el);\n    return el;\n  };\n\n  /**\n   * Complete the close event by moving the element back and destroying the affix.\n   * @param  {Object} params\n   */\n\n\n  Popover.prototype._finishClose = function _finishClose() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n    this.closeTimer = null;\n\n    // Move the content back to the parent\n    this.el.appendChild(this.contentEl);\n\n    this.affix.remove({ keepEl: true });\n    this.affix = null;\n\n    (params.complete || noop)();\n    (this.onClose || noop)();\n  };\n\n  /**\n   * When we are clicked, toggle the popover-active state.\n   * @param {Object} e\n   */\n\n\n  Popover.prototype._onClick = function _onClick(e) {\n\n    // If this is the toggle element, toggle.\n    if (e.target === this.toggleEl || (0, _hasParent2.default)(e.target, this.toggleEl)) {\n      e.preventDefault();\n      this.toggle();\n      return;\n    }\n  };\n\n  /**\n   * When a key is pressed on the window and it's an ESC, close the popover.\n   * @param {Object} e\n   */\n\n\n  Popover.prototype._onKeyup = function _onKeyup(e) {\n    if (e.keyCode === 27) {\n      this.close();\n\n      // Set focus back to toggle\n      this.toggleEl.focus();\n    }\n  };\n\n  /**\n   * When a key is pressed in an active Popover and it is a Tab key, or Shift+Tab, navigate the popover\n   * If it the Enter key, and focus is on the close button, close the Popover\n   *\n   * @param {Object} e\n   */\n\n\n  Popover.prototype._onKeydown = function _onKeydown(e) {\n    if (e.keyCode === 9) {\n      if (this.popoverFocusableEls.length === 1) {\n        e.preventDefault();\n      }\n\n      if (e.shiftKey) {\n        this._onBackwardTab(e);\n      } else {\n        this._onForwardTab(e);\n      }\n    }\n\n    // Enter Key\n    if (e.keyCode === 13) {\n      if (e.target === document.querySelector('.spark-popover__close') || (0, _getParent2.default)(e.target, '.spark-popover__close', this.contentEl)) {\n        e.preventDefault();\n        this.close();\n\n        // Set focus back to toggle\n        this.toggleEl.focus();\n      }\n    }\n  };\n\n  /**\n   * When tabbing backwards, localize traversal to Popover elements only\n   * @param {Object} e\n   */\n\n\n  Popover.prototype._onBackwardTab = function _onBackwardTab(e) {\n    if (document.activeElement === this.firstPopoverFocusableEl) {\n      e.preventDefault();\n      this.lastPopoverFocusableEl.focus();\n    }\n  };\n\n  /**\n   * When tabbing forwards, localize traversal to Popover elements only\n   * @param {Object} e\n   */\n\n\n  Popover.prototype._onForwardTab = function _onForwardTab(e) {\n    if (document.activeElement === this.lastPopoverFocusableEl) {\n      e.preventDefault();\n      this.firstPopoverFocusableEl.focus();\n    }\n  };\n\n  /**\n   * When the toggle is clicked, close if it's a link. If it's content, don't do anything but stop\n   * the event from bubbling.\n   * @param {Object} e\n   */\n\n\n  Popover.prototype._onContentClick = function _onContentClick(e) {\n\n    // If this is a link, close.\n    if ((0, _getParent2.default)(e.target, '.spark-popover__list-link', this.contentEl) || (0, _getParent2.default)(e.target, '.spark-popover__close', this.contentEl)) {\n      this.close();\n      return;\n    }\n  };\n\n  /**\n   * When the window is clicked and it's not part of the popover, close the popover.\n   * @param {Objec} e\n   */\n\n\n  Popover.prototype._onWindowClick = function _onWindowClick(e) {\n    if (e.target !== this.el && e.target !== this.contentEl && !(0, _hasParent2.default)(e.target, this.el) && !(0, _hasParent2.default)(e.target, this.contentEl)) {\n      this.close();\n    }\n  };\n\n  return Popover;\n}(_base2.default);\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nPopover.prototype._whitelistedParams = ['anchorX', 'anchorY', 'toggleEl', 'contentEl', 'onOpen', 'onClose'];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nPopover.prototype.defaults = {\n  el: null,\n  toggleEl: null,\n  contentEl: null,\n  caretEl: null,\n  affix: null,\n  isActive: false,\n  isPaused: false,\n  isFixed: false,\n  anchorX: null,\n  anchorY: null,\n  closeTimer: null,\n  onOpen: null,\n  onClose: null,\n  _onClickBound: null,\n  _onKeyupBound: null,\n  _onKeydownBound: null,\n  _onContentClickBound: null,\n  _onWindowClickBound: null,\n  _onWindowResizeBound: null,\n  _onWindowScrollBound: null\n};\n\nexports.default = Popover;\nmodule.exports = exports['default'];\n//# sourceMappingURL=popover.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * # Add Class\n * Add a class on an element.\n *\n * @param {Element|Array} el An element or array of elements to update.\n * @param {String} name\n * @return {Element}\n *\n * @module helpers/dom/add-class.js\n */\n\nvar ws = /\\s+/;\nvar cleanup = /\\s{2,}/g;\n\nfunction addClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) {\n      el.classList.add(name[0]);\n    }\n    return el;\n  }\n\n  var toAdd = [];\n  var i = 0;\n  var l = name.length;\n  var item = void 0;\n  var clsName = typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '';\n\n  // see if we have anything to add\n  for (; i < l; i++) {\n    item = name[i];\n    if (item && !(0, _hasClass2.default)(clsName, item)) {\n      toAdd.push(item);\n    }\n  }\n\n  if (toAdd.length) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = addClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=add-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * # Has Class\n * See if an element has a class.\n *\n * @param {Element|String} el\n * @param {String} name\n * @return {Boolean}\n *\n * @module helpers/dom/has-class.js\n */\nfunction hasClass(el, name) {\n  var cName = ((typeof el === 'undefined' ? 'undefined' : _typeof(el)) === 'object' ? el.className || el.getAttribute && el.getAttribute('class') || '' : el || '').replace(/[\\t\\r\\n\\f]/g, ' ');\n  return (' ' + cName + ' ').indexOf(' ' + name + ' ') !== -1;\n}\n\nexports.default = hasClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=has-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Offset Position\n * Get the offset position of the element.\n *\n * @param {Element} el\n * @param {Boolean} viewPortOffset The offset relative to the viewport, not page.\n * @return {Object}\n *\n * @module helpers/dom/offset.js\n */\nfunction offset(el, viewPortOffset) {\n\n  var rect = {\n    top: 0,\n    left: 0\n  };\n\n  // Native implementation\n  if (el.getBoundingClientRect) {\n\n    var bounding = el.getBoundingClientRect();\n    rect.left = bounding.left;\n    rect.top = bounding.top;\n\n    if (!viewPortOffset) {\n      rect.left += typeof window.scrollX !== 'undefined' ? window.scrollX : window.pageXOffset;\n      rect.top += typeof window.scrollY !== 'undefined' ? window.scrollY : window.pageYOffset;\n    }\n  } else {\n    var x = 0,\n        y = 0;\n    do {\n      x += el.offsetLeft - (!viewPortOffset ? el.scrollLeft : 0);\n      y += el.offsetTop - (!viewPortOffset ? el.scrollTop : 0);\n    } while (el = el.offsetParent);\n\n    rect.left = x;\n    rect.top = y;\n  }\n\n  return rect;\n}\n\nexports.default = offset;\nmodule.exports = exports['default'];\n//# sourceMappingURL=offset.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Parse DOM attributes\n * Given an element and an attribute name, parse that attribute\n * if it exists or return a default.\n *\n * @module helpers/dom/parse-attribute.js\n */\n\n/**\n * Get the boolean value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction boolean(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return val === 'true' || val === '' ? true : false;\n}\n\n/**\n * Get the numeric value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction number(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return parseInt(val, 10);\n}\n\n/**\n * Get the boolean value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction string(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return val;\n}\n\nexports.boolean = boolean;\nexports.number = number;\nexports.string = string;\n//# sourceMappingURL=parse-attribute.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ws = /\\s+/; /**\n                 * # Remove Class\n                 * Remove a class on an element.\n                 *\n                 * @param {Element|Array} el An element or array of elements to update.\n                 * @param {String} name\n                 * @return {Element}\n                 *\n                 * @module helpers/dom/remove-class.js\n                 */\n\nvar cleanup = /\\s{2,}/g;\n\nfunction removeClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) el.classList.remove(name[0]);\n    return el;\n  }\n\n  // store two copies\n  var clsName = ' ' + (typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '') + ' ';\n  var result = clsName;\n  var current = void 0;\n  var start = void 0;\n  for (var i = 0, l = name.length; i < l; i++) {\n    current = name[i];\n    start = current ? result.indexOf(' ' + current + ' ') : -1;\n    if (start !== -1) {\n      start += 1;\n      result = result.slice(0, start) + result.slice(start + current.length);\n    }\n  }\n\n  // only write if modified\n  if (clsName !== result) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)(result.replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)(result.replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = removeClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=remove-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _addClass = require('./add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _removeClass = require('./remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toggleClass(el, name, enable) {\n\n  if (!el) {\n    return;\n  }\n\n  // If we're passed an array, toggle the class on each.\n  if (el instanceof NodeList || el instanceof Array) {\n\n    for (var i = 0, len = el.length; i < len; i++) {\n      toggleClass(el[i], name, enable);\n    }\n\n    return;\n  }\n\n  var action = void 0;\n  if (enable !== undefined) {\n    enable = typeof enable === 'function' ? enable.call(null, el) : enable;\n    action = enable ? 'add' : 'remove';\n  } else {\n    action = (0, _hasClass2.default)(el, name) ? 'remove' : 'add';\n  }\n\n  return (action === 'add' ? _addClass2.default : _removeClass2.default)(el, name);\n} /**\n   * # Toggle Class\n   * Toggle a class on an element given a condition.\n   *\n   * @param {Element|Array} el An element or array of elements to update.\n   * @param {String} name\n   * @param {Boolean} enable\n   * @return {Element}\n   *\n   * @module  helpers/dom/toggle-class.js\n   */\n\nexports.default = toggleClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=toggle-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _each = require('../util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction appendChildren(el, children, empty) {\n\n  empty = empty === undefined ? false : empty;\n\n  if (empty) {\n    el.textContent = '';\n  }\n\n  var domList = children instanceof window.HTMLCollection;\n\n  if (domList) {\n    while (children.length) {\n      el.appendChild(children[0]);\n    }\n  } else {\n    (0, _each2.default)(children, function (c) {\n      if (c) {\n        el.appendChild(c);\n      }\n    });\n  }\n} /**\n   * # Append Children\n   * Append an array of children to a node.\n   *\n   * @param {Element} el\n   * @param {Array} children\n   * @param {Boolean} empty Empty the node before adding children?\n   *\n   * @module helpers/manipulation/append-children.js\n   */\n\nexports.default = appendChildren;\nmodule.exports = exports['default'];\n//# sourceMappingURL=append-children.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _offset2 = require('../dom/offset');\n\nvar _offset3 = _interopRequireDefault(_offset2);\n\nvar _boxPosition = require('./box-position');\n\nvar _boxPosition2 = _interopRequireDefault(_boxPosition);\n\nvar _debounce = require('../util/debounce');\n\nvar _debounce2 = _interopRequireDefault(_debounce);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * # Affix\n                                                                                                                                                           * Affix one element to another.\n                                                                                                                                                           *\n                                                                                                                                                           * @example\n                                                                                                                                                           * new Affix({\n                                                                                                                                                           *   el: el,\n                                                                                                                                                           *   targetEl: el2,\n                                                                                                                                                           *   caretEl: el3,\n                                                                                                                                                           *   anchorY: 'top', // 'middle', 'bottom'\n                                                                                                                                                           *   anchorX: 'left', // 'center', 'right'\n                                                                                                                                                           * })\n                                                                                                                                                           *\n                                                                                                                                                           * @module helpers/position/affix.js\n                                                                                                                                                           */\n\nvar Affix = function () {\n\n  /**\n   * Store the reference elements and position.\n   * @param  {Object} params\n   */\n  function Affix() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Affix);\n\n    this.el = params.el;\n    this.targetEl = params.targetEl;\n    this.caretEl = params.caretEl;\n    this.anchorY = params.anchorY || 'top';\n    this.anchorX = params.anchorX || 'center';\n    this.isFixed = params.isFixed || false;\n\n    this._addEventListeners();\n    this._insertEl();\n    this._setPosition();\n    this._updateDebounced = (0, _debounce2.default)(this.update.bind(this), 500);\n  }\n\n  /**\n   * Stop listening and clean up event listeners\n   * @param {Object} params Optional\n   * @return {Object} this\n   */\n\n\n  Affix.prototype.remove = function remove() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!params.keepEl) this._removeEl();\n    this._removeEventListeners();\n    return this;\n  };\n\n  /**\n   * Update the position.\n   * @return {Object} this\n   */\n\n\n  Affix.prototype.update = function update() {\n    this._setPosition();\n    return this;\n  };\n\n  /**\n   * Listen for window resizes to update the position.\n   */\n\n\n  Affix.prototype._addEventListeners = function _addEventListeners() {\n    this._onResizeBound = this._onResize.bind(this);\n    this._onScrollBound = this._onScroll.bind(this);\n    window.addEventListener('resize', this._onResizeBound);\n    window.addEventListener('scroll', this._onScrollBound);\n  };\n\n  /**\n   * Remove event listeners\n   */\n\n\n  Affix.prototype._removeEventListeners = function _removeEventListeners() {\n    window.removeEventListener('resize', this._onResizeBound);\n    window.removeEventListener('scroll', this._onScrollBound);\n  };\n\n  /**\n   * Insert the element into the DOM.\n   */\n\n\n  Affix.prototype._insertEl = function _insertEl() {\n    this.el.setAttribute('data-affixed', '');\n    this._getRootEl().appendChild(this.el);\n  };\n\n  /**\n   * Remove the element from the DOM.\n   */\n\n\n  Affix.prototype._removeEl = function _removeEl() {\n    this.el.parentNode.removeChild(this.el);\n    this.el.removeAttribute('data-affixed');\n  };\n\n  /**\n   * Set the position of the target element.\n   */\n\n\n  Affix.prototype._setPosition = function _setPosition() {\n\n    // Fixed position\n    this.el.style.setProperty('position', this.isFixed ? 'fixed' : 'absolute', 'important');\n\n    // Target element properties\n\n    var _offset = (0, _offset3.default)(this.targetEl, this.isFixed),\n        targetTop = _offset.top,\n        targetLeft = _offset.left;\n\n    var targetWidth = this.targetEl.offsetWidth;\n    var targetHeight = this.targetEl.offsetHeight;\n\n    // Element to affix properties\n    var elWidth = this.el.offsetWidth;\n    var elHeight = this.el.offsetHeight;\n\n    // Maxes\n    var docHeight = document.documentElement.offsetHeight;\n    var docWidth = document.documentElement.offsetWidth;\n\n    // Get the values\n\n    var _calculatePosition2 = this._calculatePosition({\n      anchorX: this.anchorX,\n      anchorY: this.anchorY,\n      targetTop: targetTop,\n      targetLeft: targetLeft,\n      elHeight: elHeight,\n      elWidth: elWidth,\n      targetHeight: targetHeight,\n      targetWidth: targetWidth,\n      minX: 0,\n      minY: 0,\n      maxX: docWidth - elWidth,\n      maxY: Math.max(docHeight - elHeight, 0)\n    }),\n        elTop = _calculatePosition2.elTop,\n        elLeft = _calculatePosition2.elLeft;\n\n    // Position the caret\n\n\n    var _positionCaret2 = this._positionCaret({\n      elLeft: elLeft,\n      elTop: elTop,\n      elWidth: elWidth,\n      elHeight: elHeight,\n      targetHeight: targetHeight,\n      targetWidth: targetWidth,\n      targetLeft: targetLeft,\n      targetTop: targetTop\n    }),\n        extraLeft = _positionCaret2.extraLeft,\n        extraTop = _positionCaret2.extraTop;\n\n    // Set the position\n\n\n    this.el.style.left = elLeft + extraLeft + 'px';\n    this.el.style.top = elTop + extraTop + 'px';\n  };\n\n  /**\n   * Get the proper top position for an anchor direction.\n   * @param  {Object} p\n   * @return {Object}\n   */\n\n\n  Affix.prototype._calculatePosition = function _calculatePosition(p) {\n\n    // Keep track of what we're trying to do here, so on subsequent, nested calls to this\n    // method we can see what has already been tried.\n    p.previousAttempts = (p.previousAttempts || 0) + 1;\n    p.previousChecks = p.previousChecks || [];\n\n    var finalCheck = p.previousAttempts > 3;\n    var top = void 0;\n    var left = void 0;\n\n    // Y-axis check\n    switch (p.anchorY) {\n      case 'bottom':\n        top = p.targetTop + p.targetHeight;\n        break;\n      case 'middle':\n        top = p.targetTop - (p.elHeight - p.targetHeight) / 2;\n        break;\n      default:\n        top = p.targetTop - p.elHeight;\n        break;\n    }\n\n    // Under min\n    if (top < p.minY) {\n\n      if (!finalCheck && p.previousChecks.indexOf('overY') === -1) {\n        p.previousChecks.push('underY');\n        p.anchorY = this._getNewAnchorY(true, p.anchorY, p.anchorX);\n        return this._calculatePosition(p);\n      } else {\n        top = p.minY;\n      }\n    }\n\n    // Don't check for being too tall because causing a vertical scroll\n    // bar down is okay and this saves us from some real positioning hell.\n    /*if (top > p.maxY) {\n       if (!finalCheck && p.previousChecks.indexOf('underY') === -1) {\n        p.previousChecks.push('overY');\n        p.anchorY = this._getNewAnchorY(false, p.anchorY, p.anchorX);\n        return this._calculatePosition(p);\n      }\n      // On a final check, bottom wins because at least we can scroll\n      else if (!(finalCheck && p.anchorY === 'bottom')) {\n        top = p.maxY;\n      }\n    }*/\n\n    // X-axis check\n    switch (p.anchorX) {\n      case 'right':\n        left = p.targetLeft + (p.anchorY !== 'middle' && !p.isOverlapping ? 0 : p.targetWidth);\n        break;\n      case 'center':\n        left = p.targetLeft - (p.elWidth - p.targetWidth) / 2;\n        break;\n      default:\n        left = p.targetLeft - p.elWidth + (p.anchorY !== 'middle' ? p.targetWidth : 0);\n        break;\n    }\n\n    // Under min\n    if (left < p.minX) {\n\n      if (!finalCheck && p.previousChecks.indexOf('overX') === -1) {\n        p.previousChecks.push('underX');\n        p.anchorX = this._getNewAnchorX(true, p.anchorX, p.anchorY);\n        return this._calculatePosition(p);\n      } else {\n        left = p.minX;\n      }\n    }\n\n    // Over max\n    if (left > p.maxX) {\n\n      if (!finalCheck && p.previousChecks.indexOf('underX') === -1) {\n        p.previousChecks.push('overX');\n        p.anchorX = this._getNewAnchorX(false, p.anchorX, p.anchorY);\n        return this._calculatePosition(p);\n      } else {\n        left = p.maxX;\n      }\n    }\n\n    // One element is covering another. Try to fix that, but bail out after four tries.\n    if ((0, _boxPosition2.default)({ width: p.elWidth, height: p.elHeight, left: left, top: top }, { width: p.targetWidth, height: p.targetHeight, left: p.targetLeft, top: p.targetTop }) === 'overlap') {\n\n      p.isOverlapping = true;\n\n      // Try Y\n      if (p.repositionY !== false) {\n\n        // Will start undefined, then true, then false. This limits us to entering\n        // this loop twice, once to try moving in each direction.\n        p.repositionY = !p.repositionY;\n\n        // First try to put above, then try to put below.\n        p.anchorY = this._getNewAnchorY(p.repositionY, 'middle', p.anchorX);\n\n        // Give us one more shot at positioning\n        p.previousAttempts--;\n\n        return this._calculatePosition(p);\n      }\n      // Try X\n      else if (p.repositionX !== false) {\n\n          // Will start undefined, then true, then false. This limits us to entering\n          // this loop twice, once to try moving in each direction.\n          p.repositionX = !p.repositionX;\n\n          // First try to put above, then try to put below.\n          p.anchorX = this._getNewAnchorX(p.repositionX, 'center', p.anchorY);\n\n          // Give us one more shot at positioning\n          p.previousAttempts--;\n\n          return this._calculatePosition(p);\n        }\n    }\n\n    return { elTop: top, elLeft: left, anchorX: p.anchorX, anchorY: p.anchorY };\n  };\n\n  /**\n   * Determine the new y-axis anchor\n   * @param  {Boolean} underMin Under the min?\n   * @param  {String} anchorY\n   * @param  {String} anchorX\n   * @return {String}\n   */\n\n\n  Affix.prototype._getNewAnchorY = function _getNewAnchorY(underMin, anchorY, anchorX) {\n\n    // If the x-axis is anchored in the center, skip\n    // trying to anchor to the middle because then we'd\n    // be overlaying the button.\n    if (anchorX === 'center' || anchorY === 'middle') {\n      return underMin ? 'bottom' : 'top';\n    } else {\n      return 'middle';\n    }\n  };\n\n  /**\n   * Determine the new y-axis anchor\n   * @param  {Boolean} underMin Under the min?\n   * @param  {String} anchorY\n   * @param  {String} anchorX\n   * @return {String}\n   */\n\n\n  Affix.prototype._getNewAnchorX = function _getNewAnchorX(underMin, anchorX, anchorY) {\n\n    // If the y-axis is anchored in the center, skip\n    // trying to anchor to the middle because then we'd\n    // be overlaying the button.\n    if (anchorY === 'middle' || anchorX === 'center') {\n      return underMin ? 'left' : 'right';\n    } else {\n      return 'center';\n    }\n  };\n\n  /**\n   * Set the position of the caret.\n   * @param {Object} p\n   * @return {Object}\n   */\n\n\n  Affix.prototype._positionCaret = function _positionCaret() {\n    var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n    if (!this.caretEl) return;\n\n    var caretPosition = (0, _boxPosition2.default)({ width: p.elWidth, height: p.elHeight, left: p.elLeft, top: p.elTop }, { width: p.targetWidth, height: p.targetHeight, left: p.targetLeft, top: p.targetTop });\n\n    var caretDimensions = this.caretEl.getBoundingClientRect();\n    var caretWidth = caretDimensions.width;\n    var caretHeight = caretDimensions.height;\n    var left = Math.min(p.elWidth, Math.max(0, p.targetLeft - p.elLeft + p.targetWidth / 2));\n    var top = Math.min(p.elHeight, Math.max(0, p.targetTop - p.elTop + p.targetHeight / 2));\n\n    this.caretEl.style.left = Math.round(left) + 'px';\n    this.caretEl.style.top = Math.round(top) + 'px';\n\n    var extraLeft = 0;\n    var extraTop = 0;\n\n    this.caretEl.setAttribute('data-position', caretPosition);\n\n    switch (caretPosition) {\n      case 'above':\n        extraTop = -caretWidth / 2;\n        break;\n      case 'below':\n        extraTop = caretWidth / 2;\n        break;\n      case 'left':\n        extraLeft = -caretHeight / 2;\n        break;\n      default:\n        extraLeft = caretHeight / 2;\n        break;\n    }\n\n    return {\n      extraLeft: extraLeft,\n      extraTop: extraTop\n    };\n  };\n\n  /**\n   * Get the root element. Want to check if there's a top-level form for working\n   * with ASP .NET pages.\n   */\n\n\n  Affix.prototype._getRootEl = function _getRootEl() {\n    var form = document.querySelector('body > form');\n    return form && form.getAttribute('data-affixed') === null ? form : document.body;\n  };\n\n  /**\n   * On resize, update the position.\n   */\n\n\n  Affix.prototype._onResize = function _onResize() {\n    this.update();\n  };\n\n  /**\n   * When the window scrolls, ensure the proper position of the popover.\n   */\n\n\n  Affix.prototype._onScroll = function _onScroll() {\n    this._updateDebounced();\n  };\n\n  return Affix;\n}();\n\nexports.default = Affix;\nmodule.exports = exports['default'];\n//# sourceMappingURL=affix.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (a, b) {\n\n  var aXSpan = a.left + a.width;\n  var aYSpan = a.top + a.height;\n  var bXSpan = b.left + b.width;\n  var bYSpan = b.top + b.height;\n\n  if (aXSpan <= b.left) return 'left'; // a is fully left of b\n  if (a.left >= bXSpan) return 'right'; // a is fully right of b\n  if (aYSpan <= b.top) return 'above'; // a is fully above b\n  if (a.top >= bYSpan) return 'below'; // a is fully below b\n\n  return 'overlap'; // boxes overlap\n};\n\nmodule.exports = exports['default']; /**\n                                      * # Box Position\n                                      * How is one element positioned relative to another?\n                                      *\n                                      * @example\n                                      * boxPosition(\n                                      * {width: 100, height: 300, left: 0, top: 0},\n                                      * {width: 200, height: 50, left: 100, top: 40}\n                                      * )\n                                      *\n                                      * @module helpers/position/box-position.js\n                                      *\n                                      * @param {Object} a\n                                      * @param {Object} b\n                                      * @return {String}\n                                      */\n//# sourceMappingURL=box-position.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _matches = require('./matches');\n\nvar _matches2 = _interopRequireDefault(_matches);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getParent(parent, query, limitEl) {\n\n  limitEl = limitEl instanceof Array ? limitEl : [limitEl || document.body];\n\n  while (parent) {\n\n    if ((0, _matches2.default)(parent, query)) {\n      return parent;\n    }\n\n    if (limitEl.indexOf(parent) !== -1) {\n      return false;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return false;\n} /**\n   * # Get Parent\n   * See if an element has another element for a parent.\n   *\n   * @param {Element} parent\n   * @param {String} query\n   * @param {Array|Element} limitEl The last element we should check.\n   * @return {Boolean|Element}\n   *\n   * @module helpers/traversal/get-parent.js\n   */\n\nexports.default = getParent;\nmodule.exports = exports['default'];\n//# sourceMappingURL=get-parent.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Has Parent\n * See if an element has another element for a parent.\n *\n * @param {Element} child\n * @param {Element} possibleParent\n * @return {Boolean}\n *\n * @module helpers/traversal/has-parent.js\n */\nfunction hasParent(child, possibleParent) {\n\n  var parent = child.parentNode;\n\n  while (parent) {\n\n    if (parent === possibleParent) {\n      return true;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return false;\n}\n\nexports.default = hasParent;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=has-parent.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Matches\n * See if an element matches a query selector.\n *\n * @param {Element} el\n * @param {String} query\n * @return {Boolean}\n *\n * @module helpers/traversal/matches.js\n */\nvar vendorMatch = typeof Element !== 'undefined' && (Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector);\n\nfunction matches(el, query) {\n\n  if (vendorMatch) return vendorMatch.call(el, query);\n\n  var nodes = el.parentNode ? el.parentNode.querySelectorAll(query) : [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i] === el) return true;\n  }\n\n  return false;\n}\n\nexports.default = matches;\nmodule.exports = exports['default'];\n//# sourceMappingURL=matches.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Debounce\n * Debounce a function call\n *\n * @param {Function} func\n * @param {Integer} delay\n *\n * @module helpers/util/debounce.js\n */\nfunction debounce(func, delay) {\n\n  var timer = void 0;\n\n  return function () {\n    var args = arguments;\n    if (timer) window.clearTimeout(timer);\n    timer = window.setTimeout(function () {\n      func.apply(this, args);\n    }, delay);\n  };\n}\n\nexports.default = debounce;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=debounce.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Each\n * Apply a callback function to a list of any kind: Array, NodeList, HTMLCollection or Object.\n *\n * @param {Array|NodeList|HTMLCollection|Object} list\n * @param {Function} cb\n *\n * @example\n * each([], callback);\n * each(el.children, callback);\n * each(el.childNodes, callback);\n * each({}, callback);\n *\n * @module helpers/util/each.js\n */\nfunction each(list, cb) {\n\n  if (!list) {\n    return;\n  }\n\n  if (typeof cb !== 'function') {\n    throw new Error('Cannot invoke `each` without a callback!');\n  }\n\n  var i = 0;\n  var len = list.length;\n\n  // Object\n  if (len === undefined) {\n    for (i in list) {\n      if (i !== 'prototype' && list.hasOwnProperty(i)) {\n        cb(i, list[i]);\n      }\n    }\n  }\n  // Array-like\n  else {\n      for (; i < len; i++) {\n        cb(list[i]);\n      }\n    }\n}\n\nexports.default = each;\nmodule.exports = exports['default'];\n//# sourceMappingURL=each.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Trim\n * Trim whitespace on a string.\n *\n * @param {String} str\n *\n * @module helpers/util/trim.js\n */\n\nvar trimRE = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\nfunction trim(str) {\n  return str.replace(trimRE, '');\n}\n\nexports.default = trim;\nmodule.exports = exports['default'];\n//# sourceMappingURL=trim.js.map\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9kaXN0L2NvbXBvbmVudHMvYmFzZS5qcyIsImpzL2Rpc3QvY29tcG9uZW50cy9wb3BvdmVyLmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS9hZGQtY2xhc3MuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL2hhcy1jbGFzcy5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vb2Zmc2V0LmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS9wYXJzZS1hdHRyaWJ1dGUuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL3JlbW92ZS1jbGFzcy5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vdG9nZ2xlLWNsYXNzLmpzIiwianMvZGlzdC9oZWxwZXJzL21hbmlwdWxhdGlvbi9hcHBlbmQtY2hpbGRyZW4uanMiLCJqcy9kaXN0L2hlbHBlcnMvcG9zaXRpb24vYWZmaXguanMiLCJqcy9kaXN0L2hlbHBlcnMvcG9zaXRpb24vYm94LXBvc2l0aW9uLmpzIiwianMvZGlzdC9oZWxwZXJzL3RyYXZlcnNhbC9nZXQtcGFyZW50LmpzIiwianMvZGlzdC9oZWxwZXJzL3RyYXZlcnNhbC9oYXMtcGFyZW50LmpzIiwianMvZGlzdC9oZWxwZXJzL3RyYXZlcnNhbC9tYXRjaGVzLmpzIiwianMvZGlzdC9oZWxwZXJzL3V0aWwvZGVib3VuY2UuanMiLCJqcy9kaXN0L2hlbHBlcnMvdXRpbC9lYWNoLmpzIiwianMvZGlzdC9oZWxwZXJzL3V0aWwvdHJpbS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfXJldHVybiBlfSkoKSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9lYWNoID0gcmVxdWlyZSgnLi4vaGVscGVycy91dGlsL2VhY2gnKTtcblxudmFyIF9lYWNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfSAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAjIEJhc2UgQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGhlIGJhc2UgY2xhc3MgZm9yIFNwYXJrIEpTIGNvbXBvbmVudHMuIFRoaXMgY2xhc3Mgc2hvdWxkIG5ldmVyIGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgY29tcG9uZW50cy9iYXNlLmpzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG52YXIgQmFzZSA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogU2V0IHBhcmFtZXRlcnMgYW5kIGNhY2hlIGVsZW1lbnRzLlxuICAgKi9cbiAgZnVuY3Rpb24gQmFzZShlbCkge1xuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2UpO1xuXG4gICAgaWYgKHBhcmFtcy5lbFJlcXVpcmVkICYmICFlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2V0UGFyYW1zKHRoaXMuZGVmYXVsdHMgfHwge30sIHRydWUpO1xuICAgIHRoaXMuc2V0UGFyYW1zKHBhcmFtcyk7XG4gICAgKHRoaXMuX2NhY2hlRWxlbWVudHMgfHwgbm9vcCkuY2FsbCh0aGlzLCBlbCwgcGFyYW1zKTtcbiAgICAodGhpcy5fcGFyc2VQYXJhbXMgfHwgbm9vcCkuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGNvbXBvbmVudCBmcm9tIHRoZSBET00gYW5kIHByZXBhcmUgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiBieSBkZXJlZmVyZW5jaW5nIHZhbHVlcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBsZWF2ZUVsZW1lbnQgTGVhdmUgdGhlIGVsZW1lbnQgaW50YWN0LlxuICAgKi9cblxuXG4gIEJhc2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShsZWF2ZUVsZW1lbnQpIHtcblxuICAgIGlmICh0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycykge1xuICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBpZiAoIWxlYXZlRWxlbWVudCAmJiB0aGlzLmVsICYmIHRoaXMuZWwucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgIH1cblxuICAgIHRoaXMudW5zZXRQYXJhbXModGhpcy5kZWZhdWx0cyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjb21wb25lbnQgdG8gdXNlIGEgbmV3IGVsZW1lbnQgb3IgcmVwYXJzZSBmcm9tXG4gICAqIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIE9wdGlvbmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgT3B0aW9uYWxcbiAgICovXG5cblxuICBCYXNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZWwpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuXG4gICAgaWYgKHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgICh0aGlzLl9jYWNoZUVsZW1lbnRzIHx8IG5vb3ApLmNhbGwodGhpcywgZWwgfHwgdGhpcy5lbCwgcGFyYW1zKTtcbiAgICAodGhpcy5fcGFyc2VQYXJhbXMgfHwgbm9vcCkuY2FsbCh0aGlzKTtcblxuICAgIGlmICh0aGlzLl9hZGRFdmVudExpc3RlbmVycykge1xuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgaGFzaCBvZiBwYXJhbWV0ZXJzIGlmIHRoZXkncmUgd2hpdGVsaXN0ZWQgb3Igd2UncmUgdG9sZCB0byBmb3JjZSB0aGUgc2V0LlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gc2V0IGluaXRpYWwgdmFsdWVzIGFzIHdlbGwgYXMgc2V0IHBhc3NlZCBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2UgRm9yY2Ugc2V0dGluZyBldmVuIGlmIHRoZSBwYXJhbSBpcyBub3Qgd2hpdGVsaXN0ZWQuXG4gICAqL1xuXG5cbiAgQmFzZS5wcm90b3R5cGUuc2V0UGFyYW1zID0gZnVuY3Rpb24gc2V0UGFyYW1zKHBhcmFtcywgZm9yY2UpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgKDAsIF9lYWNoMi5kZWZhdWx0KShwYXJhbXMsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICBpZiAoX3RoaXMuX3doaXRlbGlzdGVkUGFyYW1zLmluZGV4T2YoaykgIT09IC0xIHx8IGZvcmNlKSB7XG4gICAgICAgIF90aGlzW2tdID0gdjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbnNldCBhbGwgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGtleXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFRoZSBvYmplY3QgdG8gdW5zZXQgdGhlIHBhcmFtcyBmcm9tLiBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAqL1xuXG5cbiAgQmFzZS5wcm90b3R5cGUudW5zZXRQYXJhbXMgPSBmdW5jdGlvbiB1bnNldFBhcmFtcyhrZXlzLCBzY29wZSkge1xuXG4gICAga2V5cyA9IGtleXMgaW5zdGFuY2VvZiBBcnJheSA/IGtleXMgOiBPYmplY3Qua2V5cyhrZXlzKTtcbiAgICBzY29wZSA9IHNjb3BlIHx8IHRoaXM7XG4gICAgKDAsIF9lYWNoMi5kZWZhdWx0KShrZXlzLCBmdW5jdGlvbiAoaykge1xuICAgICAgZGVsZXRlIHNjb3BlW2tdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIEJhc2U7XG59KCk7XG5cbi8qKlxuICogV2hpdGVsaXN0ZWQgcGFyYW1ldGVycyB3aGljaCBjYW4gYmUgc2V0IG9uIGNvbnN0cnVjdGlvbi5cbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuXG5cbkJhc2UucHJvdG90eXBlLl93aGl0ZWxpc3RlZFBhcmFtcyA9IFtdO1xuXG4vKipcbiAqIERlZmF1bHQgdmFsdWVzIGZvciBpbnRlcm5hbCBwcm9wZXJ0aWVzIHdlIHdpbGwgYmUgc2V0dGluZy5cbiAqIFRoZXNlIGFyZSBzZXQgb24gZWFjaCBjb25zdHJ1Y3Rpb24gc28gd2UgZG9uJ3QgbGVhayBwcm9wZXJ0aWVzXG4gKiBpbnRvIHRoZSBwcm90b3R5cGUgY2hhaW4uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5CYXNlLnByb3RvdHlwZS5kZWZhdWx0cyA9IHt9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2Jhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcblxudmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xuXG52YXIgX2FkZENsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vYWRkLWNsYXNzJyk7XG5cbnZhciBfYWRkQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWRkQ2xhc3MpO1xuXG52YXIgX2hhc0NsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vaGFzLWNsYXNzJyk7XG5cbnZhciBfaGFzQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzQ2xhc3MpO1xuXG52YXIgX3RvZ2dsZUNsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vdG9nZ2xlLWNsYXNzJyk7XG5cbnZhciBfdG9nZ2xlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9nZ2xlQ2xhc3MpO1xuXG52YXIgX2FwcGVuZENoaWxkcmVuID0gcmVxdWlyZSgnLi4vaGVscGVycy9tYW5pcHVsYXRpb24vYXBwZW5kLWNoaWxkcmVuJyk7XG5cbnZhciBfYXBwZW5kQ2hpbGRyZW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXBwZW5kQ2hpbGRyZW4pO1xuXG52YXIgX2hhc1BhcmVudCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdHJhdmVyc2FsL2hhcy1wYXJlbnQnKTtcblxudmFyIF9oYXNQYXJlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzUGFyZW50KTtcblxudmFyIF9nZXRQYXJlbnQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RyYXZlcnNhbC9nZXQtcGFyZW50Jyk7XG5cbnZhciBfZ2V0UGFyZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFBhcmVudCk7XG5cbnZhciBfcGFyc2VBdHRyaWJ1dGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbS9wYXJzZS1hdHRyaWJ1dGUnKTtcblxudmFyIF9hZmZpeCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcG9zaXRpb24vYWZmaXgnKTtcblxudmFyIF9hZmZpeDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hZmZpeCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAjIFBvcG92ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNob3cgYW5kIGhpZGUgYSBwb3BvdmVyLiBTaG91bGQgZG8gc29tZSBzYW5pdHkgY2hlY2tzIG9uIHBvc2l0aW9uaW5nIGFzIHdlbGwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG5ldyBQb3BvdmVyKGVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIC8vIE9wdGlvbmFsLiBEZWZhdWx0IGFuY2hvcmluZyBvZiB0aGUgY29udGVudCdzIHggYW5kIHktYXhpcyByZWxhdGl2ZSB0byB0aGUgYnV0dG9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICBkZWZhdWx0QW5jaG9yWDogJ2NlbnRlcicsIC8vICdsZWZ0JywgJ2NlbnRlcicsICdyaWdodCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgZGVmYXVsdEFuY2hvclk6ICdjZW50ZXInIC8vICdsZWZ0JywgJ2NlbnRlcicsICdyaWdodCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgY29tcG9uZW50cy9wb3BvdmVyLmpzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIFBvcG92ZXIgPSBmdW5jdGlvbiAoX0Jhc2VDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFBvcG92ZXIsIF9CYXNlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBQb3BvdmVyKGVsKSB7XG4gICAgdmFyIF9yZXQ7XG5cbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb3BvdmVyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CYXNlQ29tcG9uZW50LmNhbGwodGhpcywgZWwsIHBhcmFtcykpO1xuXG4gICAgaWYgKCFlbCkgcmV0dXJuIF9yZXQgPSBfdGhpcywgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICAgIF90aGlzLl9iaW5kRXZlbnRMaXN0ZW5lckNhbGxiYWNrcygpO1xuICAgIF90aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVuLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIE9wdGlvbmFsXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgdGltZXIgcnVubmluZyBmb3IgdGhlIGNsb3NlIGV2ZW50LCBjbGVhciBpdCBzbyBpdFxuICAgIC8vIGRvZXNuJ3QgY2xvc2Ugc3R1ZmYgZHVyaW5nIG9wZW4uXG4gICAgaWYgKHRoaXMuY2xvc2VUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2xvc2VUaW1lcik7XG4gICAgICB0aGlzLmNsb3NlVGltZXIgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBlbGVtZW50IHdlIGFuY2hvciB0aGUgcG9wb3ZlciB0byBpcyBmaXhlZCwgd2UgbmVlZCB0byBrbm93XG4gICAgLy8gc28gdGhhdCB0aGUgYWZmaXhlZCBjb250ZW50IGNhbiBhbHNvIGJlIGZpeGVkLlxuICAgIHRoaXMuX2NoZWNrRml4ZWRQb3NpdGlvbigpO1xuXG4gICAgLy8gVXBkYXRlIGFuIGV4aXN0aW5nIGFmZml4ZWQgaW5zdGFuY2UuXG4gICAgaWYgKHRoaXMuYWZmaXgpIHtcbiAgICAgIHRoaXMuYWZmaXgudGFyZ2V0RWwgPSBwYXJhbXMuYWZmaXhUbyB8fCB0aGlzLmFmZml4LnRhcmdldEVsO1xuICAgICAgdGhpcy5hZmZpeC51cGRhdGUoKTtcbiAgICB9XG4gICAgLy8gQWZmaXggdGhlIGNvbnRlbnQgdG8gdGhlIHRvZ2dsZVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmFmZml4ID0gbmV3IF9hZmZpeDIuZGVmYXVsdCh7XG4gICAgICAgICAgZWw6IHRoaXMuY29udGVudEVsLFxuICAgICAgICAgIHRhcmdldEVsOiBwYXJhbXMuYWZmaXhUbyB8fCB0aGlzLmVsLFxuICAgICAgICAgIGNhcmV0RWw6IHRoaXMuY2FyZXRFbCxcbiAgICAgICAgICBhbmNob3JYOiB0aGlzLmFuY2hvclgsXG4gICAgICAgICAgYW5jaG9yWTogdGhpcy5hbmNob3JZLFxuICAgICAgICAgIGlzRml4ZWQ6IHRoaXMuaXNGaXhlZFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgIC8vIEZpbmQgYWxsIGZvY3VzYWJsZSBlbGVtZW50cyBpbiB0aGUgUG9wb3ZlciBmb3IgbmF2aWdhdGlvblxuICAgIHZhciBwb3BvdmVyRm9jdXNhYmxlRWxzID0gdGhpcy5jb250ZW50RWwucXVlcnlTZWxlY3RvckFsbCgnYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLCBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLCB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSksIFt0YWJpbmRleD1cIjBcIl0nKTtcblxuICAgIGlmIChwb3BvdmVyRm9jdXNhYmxlRWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucG9wb3ZlckZvY3VzYWJsZUVscyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHBvcG92ZXJGb2N1c2FibGVFbHMpO1xuICAgICAgdGhpcy5maXJzdFBvcG92ZXJGb2N1c2FibGVFbCA9IHRoaXMucG9wb3ZlckZvY3VzYWJsZUVsc1swXTtcbiAgICAgIHRoaXMubGFzdFBvcG92ZXJGb2N1c2FibGVFbCA9IHRoaXMucG9wb3ZlckZvY3VzYWJsZUVsc1t0aGlzLnBvcG92ZXJGb2N1c2FibGVFbHMubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgLy8gTGlzdGVuIGZvciBjbGlja3Mgb24gdGhlIHdpbmRvd1xuICAgIHRoaXMuX2FkZFdpbmRvd0V2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcblxuICAgIC8vIERpc3BhdGNoIGEgY3VzdG9tIGV2ZW50IHNvIGNvbnRlbnQgaW5zaWRlIHRoZSBwb3BvdmVyIGNhbiByZXNwb25kXG4gICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBlLmluaXRFdmVudCgnc3BhcmsudmlzaWJsZS1jaGlsZHJlbicsIHRydWUsIHRydWUpO1xuICAgIHRoaXMuY29udGVudEVsLmRpc3BhdGNoRXZlbnQoZSk7XG5cbiAgICAvLyBVcGRhdGUgYmluZGluZ3NcbiAgICB0aGlzLl91cGRhdGVBdHRyaWJ1dGVzKCk7XG5cbiAgICAvLyBTZXQgZm9jdXMgdG8gZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgb25jZSBQb3BvdmVyIGhhcyBiZWVuIG9wZW5lZFxuICAgIGlmIChwb3BvdmVyRm9jdXNhYmxlRWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZmlyc3RQb3BvdmVyRm9jdXNhYmxlRWwuZm9jdXMoKTtcbiAgICB9XG5cbiAgICAvLyBDYWxsYmFja3NcbiAgICAocGFyYW1zLmNvbXBsZXRlIHx8IG5vb3ApKCk7XG4gICAgKHRoaXMub25PcGVuIHx8IG5vb3ApKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQ2xvc2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgT3B0aW9uYWxcbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cblxuICAgIC8vIE5vdCBvcGVuLCBzbyBkb24ndCBjbG9zZS5cbiAgICBpZiAoIXRoaXMuYWZmaXgpIHJldHVybiB0aGlzO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSB0aW1lciBydW5uaW5nIGZvciB0aGUgY2xvc2UgZXZlbnQsIGNsZWFyIGl0IHNvIHdlIGRvbid0IHJ1biBjbG9zZSBzdHVmZiB0d2ljZS5cbiAgICBpZiAodGhpcy5jbG9zZVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jbG9zZVRpbWVyKTtcbiAgICAgIHRoaXMuY2xvc2VUaW1lciA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU3RvcCBsaXN0ZW5pbmcgdG8gd2luZG93IGNsaWNrcy5cbiAgICB0aGlzLl9yZW1vdmVXaW5kb3dFdmVudExpc3RlbmVycygpO1xuXG4gICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgLy8gVXBkYXRlIGJpbmRpbmdzXG4gICAgdGhpcy5fdXBkYXRlQXR0cmlidXRlcygpO1xuXG4gICAgLy8gQ2xvc2UgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgY29tcGxldGVkXG4gICAgdGhpcy5jbG9zZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczIuX2ZpbmlzaENsb3NlKHBhcmFtcyk7XG4gICAgfSwgMjUwKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUb2dnbGUgdGhlIG9wZW4gc3RhdGUuXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgIHJldHVybiB0aGlzW3RoaXMuaXNBY3RpdmUgPyAnY2xvc2UnIDogJ29wZW4nXSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvbnRlbnQuIE9wdGlvbmFsbHkgYXBwZW5kIGluc3RlYWQgb2YgcmVwbGFjaW5nLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXl8Tm9kZUxpc3R9IGNvbnRlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBPcHRpb25hbFxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiBzZXRDb250ZW50KGNvbnRlbnQsIHBhcmFtcykge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAoMCwgX2FwcGVuZENoaWxkcmVuMi5kZWZhdWx0KSh0aGlzLmNvbnRlbnRFbCwgY29udGVudC5sZW5ndGggPyBjb250ZW50IDogW2NvbnRlbnRdLCAhKHBhcmFtcy5hcHBlbmQgfHwgZmFsc2UpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjb21wb25lbnQgdG8gdXNlIGEgbmV3IGVsZW1lbnQgb3IgcmVwYXJzZSBmcm9tXG4gICAqIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIE9wdGlvbmFsXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGVsKSB7XG5cbiAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuX2NhY2hlRWxlbWVudHMoZWwgfHwgdGhpcy5lbCk7XG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgIGlmICh0aGlzLmFmZml4KSB0aGlzLmFmZml4LnVwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSB0YWJzIGxpc3QsIGVhY2ggdGFiIGFuZCBlYWNoIHBhbmVsLlxuICAgKiBTZXQgd2hpY2ggdGFiIGlzIGFjdGl2ZSwgb3IgdXNlIHRoZSBmaXJzdC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl9jYWNoZUVsZW1lbnRzID0gZnVuY3Rpb24gX2NhY2hlRWxlbWVudHMoZWwpIHtcblxuICAgIC8vIElmIGEgY29udGVudCBlbGVtZW50IHdhcyBhbHJlYWR5IHBhc3NlZCwgbWFrZSBzdXJlIGl0IGhhcyBhIHBvcG92ZXIgY29udGVudCBjbGFzc1xuICAgIGlmICh0aGlzLmNvbnRlbnRFbCkge1xuICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5jb250ZW50RWwsICdzcGFyay1wb3BvdmVyX19jb250ZW50Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMudG9nZ2xlRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1wb3BvdmVyX190b2dnbGUsIFtkYXRhLXJvbGU9XCJ0b2dnbGVcIl0nKSB8fCB0aGlzLmVsO1xuICAgIHRoaXMuY29udGVudEVsID0gdGhpcy5jb250ZW50RWwgfHwgdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuc3BhcmstcG9wb3Zlcl9fY29udGVudCwgW2NsYXNzKj1cInNwYXJrLXBvcG92ZXJfX2NvbnRlbnQtLVwiXScpIHx8IHRoaXMuX2NyZWF0ZUNvbnRlbnRFbCgpO1xuICAgIHRoaXMuY2FyZXRFbCA9IHRoaXMuY29udGVudEVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1wb3BvdmVyX19jYXJldCcpIHx8IHRoaXMuX2NyZWF0ZUNhcmV0RWwoKTtcbiAgICB0aGlzLmlzQWN0aXZlID0gKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkodGhpcy50b2dnbGVFbCwgJ3BvcG92ZXItYWN0aXZlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIGNvbmZpZyB2YWx1ZXMgZnJvbSB0aGUgZWxlbWVudC5cbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fcGFyc2VQYXJhbXMgPSBmdW5jdGlvbiBfcGFyc2VQYXJhbXMoKSB7XG5cbiAgICB0aGlzLmFuY2hvclkgPSB0aGlzLmFuY2hvclkgIT09IG51bGwgPyB0aGlzLmFuY2hvclkgOiAoMCwgX3BhcnNlQXR0cmlidXRlLnN0cmluZykodGhpcy5jb250ZW50RWwsICdkYXRhLWFuY2hvci15JywgbnVsbCk7XG4gICAgdGhpcy5hbmNob3JYID0gdGhpcy5hbmNob3JYICE9PSBudWxsID8gdGhpcy5hbmNob3JYIDogKDAsIF9wYXJzZUF0dHJpYnV0ZS5zdHJpbmcpKHRoaXMuY29udGVudEVsLCAnZGF0YS1hbmNob3IteCcsIG51bGwpO1xuXG4gICAgLy8gTm8gYW5jaG9ycyBkZWZpbmVkXG4gICAgaWYgKCF0aGlzLmFuY2hvclkgJiYgIXRoaXMuYW5jaG9yWCkge1xuXG4gICAgICAvLyBMZWZ0XG4gICAgICBpZiAoKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkodGhpcy5jb250ZW50RWwsICdzcGFyay1wb3BvdmVyX19jb250ZW50LS1sZWZ0JykpIHtcbiAgICAgICAgdGhpcy5hbmNob3JZID0gJ21pZGRsZSc7XG4gICAgICAgIHRoaXMuYW5jaG9yWCA9ICdsZWZ0JztcbiAgICAgIH1cbiAgICAgIC8vIFJpZ2h0XG4gICAgICBlbHNlIGlmICgoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KSh0aGlzLmNvbnRlbnRFbCwgJ3NwYXJrLXBvcG92ZXJfX2NvbnRlbnQtLXJpZ2h0JykpIHtcbiAgICAgICAgICB0aGlzLmFuY2hvclkgPSAnbWlkZGxlJztcbiAgICAgICAgICB0aGlzLmFuY2hvclggPSAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRvcFxuICAgICAgICBlbHNlIGlmICgoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KSh0aGlzLmNvbnRlbnRFbCwgJ3NwYXJrLXBvcG92ZXJfX2NvbnRlbnQtLXRvcCcpKSB7XG4gICAgICAgICAgICB0aGlzLmFuY2hvclkgPSAndG9wJztcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yWCA9ICdjZW50ZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBCb3R0b21cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5hbmNob3JZID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgIHRoaXMuYW5jaG9yWCA9ICdjZW50ZXInO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBidXR0b24gdHJpZ2dlcmluZyB0aGUgcG9wb3ZlciBpcyBmaXhlZC5cbiAgICogSWYgc28sIHRoZW4gcG9wb3ZlciBuZWVkcyB0byBiZSBmaXhlZCBhcyB3ZWxsLlxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl9jaGVja0ZpeGVkUG9zaXRpb24gPSBmdW5jdGlvbiBfY2hlY2tGaXhlZFBvc2l0aW9uKCkge1xuXG4gICAgdmFyIHBhcmVudCA9IHRoaXMuZWw7XG5cbiAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUocGFyZW50KTtcbiAgICAgIGlmIChzdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0ZpeGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmlzRml4ZWQgPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGNsYXNzZXMgZm9yIHRoZSBvcGVuIG9yIGNsb3NlIHN0YXRlLlxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl91cGRhdGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gX3VwZGF0ZUF0dHJpYnV0ZXMoKSB7XG4gICAgKDAsIF90b2dnbGVDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ3BvcG92ZXItYWN0aXZlJywgdGhpcy5pc0FjdGl2ZSk7XG4gICAgKDAsIF90b2dnbGVDbGFzczIuZGVmYXVsdCkodGhpcy5jb250ZW50RWwsICdhY3RpdmUnLCB0aGlzLmlzQWN0aXZlKTtcbiAgICAoMCwgX3RvZ2dsZUNsYXNzMi5kZWZhdWx0KSh0aGlzLnRvZ2dsZUVsLCAnYWN0aXZlJywgdGhpcy5pc0FjdGl2ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBib3VuZCB2ZXJzaW9ucyBvZiBldmVudCBsaXN0ZW5lciBjYWxsYmFja3MgYW5kIHN0b3JlIHRoZW0uXG4gICAqIE90aGVyd2lzZSB3ZSBjYW4ndCB1bmJpbmQgZnJvbSB0aGVzZSBldmVudHMgbGF0ZXIgYmVjYXVzZSB0aGVcbiAgICogZnVuY3Rpb24gc2lnbmF0dXJlcyB3b24ndCBtYXRjaC5cbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fYmluZEV2ZW50TGlzdGVuZXJDYWxsYmFja3MgPSBmdW5jdGlvbiBfYmluZEV2ZW50TGlzdGVuZXJDYWxsYmFja3MoKSB7XG4gICAgdGhpcy5fb25DbGlja0JvdW5kID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQ29udGVudENsaWNrQm91bmQgPSB0aGlzLl9vbkNvbnRlbnRDbGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uV2luZG93Q2xpY2tCb3VuZCA9IHRoaXMuX29uV2luZG93Q2xpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbktleXVwQm91bmQgPSB0aGlzLl9vbktleXVwLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25LZXlkb3duQm91bmQgPSB0aGlzLl9vbktleWRvd24uYmluZCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGV2ZW50IGxpc3RlbmVycyBmb3IgRE9NIGV2ZW50cy5cbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2tCb3VuZCk7XG4gICAgdGhpcy5jb250ZW50RWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNvbnRlbnRDbGlja0JvdW5kKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBmb3IgRE9NIGV2ZW50cy4uXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuX3JlbW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrQm91bmQpO1xuICAgIHRoaXMuY29udGVudEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25Db250ZW50Q2xpY2tCb3VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHdpbmRvdy5cbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fYWRkV2luZG93RXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfYWRkV2luZG93RXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fcmVtb3ZlV2luZG93RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbldpbmRvd0NsaWNrQm91bmQpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuX29uS2V5dXBCb3VuZCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleWRvd25Cb3VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB3aW5kb3cgZXZlbnQgbGlzdGVuZXJzLlxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl9yZW1vdmVXaW5kb3dFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZW1vdmVXaW5kb3dFdmVudExpc3RlbmVycygpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbldpbmRvd0NsaWNrQm91bmQpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuX29uS2V5dXBCb3VuZCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleWRvd25Cb3VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNvbnRlbnQgZWxlbWVudC5cbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fY3JlYXRlQ29udGVudEVsID0gZnVuY3Rpb24gX2NyZWF0ZUNvbnRlbnRFbCgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KShlbCwgJ3NwYXJrLXBvcG92ZXJfX2NvbnRlbnQnKTtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndG9vbHRpcCcpO1xuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBjYXJldCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl9jcmVhdGVDYXJldEVsID0gZnVuY3Rpb24gX2NyZWF0ZUNhcmV0RWwoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuY2xhc3NOYW1lID0gJ3NwYXJrLXBvcG92ZXJfX2NhcmV0JztcbiAgICB0aGlzLmNvbnRlbnRFbC5hcHBlbmRDaGlsZChlbCk7XG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb21wbGV0ZSB0aGUgY2xvc2UgZXZlbnQgYnkgbW92aW5nIHRoZSBlbGVtZW50IGJhY2sgYW5kIGRlc3Ryb3lpbmcgdGhlIGFmZml4LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHBhcmFtc1xuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl9maW5pc2hDbG9zZSA9IGZ1bmN0aW9uIF9maW5pc2hDbG9zZSgpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuXG4gICAgdGhpcy5jbG9zZVRpbWVyID0gbnVsbDtcblxuICAgIC8vIE1vdmUgdGhlIGNvbnRlbnQgYmFjayB0byB0aGUgcGFyZW50XG4gICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbCk7XG5cbiAgICB0aGlzLmFmZml4LnJlbW92ZSh7IGtlZXBFbDogdHJ1ZSB9KTtcbiAgICB0aGlzLmFmZml4ID0gbnVsbDtcblxuICAgIChwYXJhbXMuY29tcGxldGUgfHwgbm9vcCkoKTtcbiAgICAodGhpcy5vbkNsb3NlIHx8IG5vb3ApKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gd2UgYXJlIGNsaWNrZWQsIHRvZ2dsZSB0aGUgcG9wb3Zlci1hY3RpdmUgc3RhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuX29uQ2xpY2sgPSBmdW5jdGlvbiBfb25DbGljayhlKSB7XG5cbiAgICAvLyBJZiB0aGlzIGlzIHRoZSB0b2dnbGUgZWxlbWVudCwgdG9nZ2xlLlxuICAgIGlmIChlLnRhcmdldCA9PT0gdGhpcy50b2dnbGVFbCB8fCAoMCwgX2hhc1BhcmVudDIuZGVmYXVsdCkoZS50YXJnZXQsIHRoaXMudG9nZ2xlRWwpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2hlbiBhIGtleSBpcyBwcmVzc2VkIG9uIHRoZSB3aW5kb3cgYW5kIGl0J3MgYW4gRVNDLCBjbG9zZSB0aGUgcG9wb3Zlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fb25LZXl1cCA9IGZ1bmN0aW9uIF9vbktleXVwKGUpIHtcbiAgICBpZiAoZS5rZXlDb2RlID09PSAyNykge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuXG4gICAgICAvLyBTZXQgZm9jdXMgYmFjayB0byB0b2dnbGVcbiAgICAgIHRoaXMudG9nZ2xlRWwuZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gYSBrZXkgaXMgcHJlc3NlZCBpbiBhbiBhY3RpdmUgUG9wb3ZlciBhbmQgaXQgaXMgYSBUYWIga2V5LCBvciBTaGlmdCtUYWIsIG5hdmlnYXRlIHRoZSBwb3BvdmVyXG4gICAqIElmIGl0IHRoZSBFbnRlciBrZXksIGFuZCBmb2N1cyBpcyBvbiB0aGUgY2xvc2UgYnV0dG9uLCBjbG9zZSB0aGUgUG9wb3ZlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl9vbktleWRvd24gPSBmdW5jdGlvbiBfb25LZXlkb3duKGUpIHtcbiAgICBpZiAoZS5rZXlDb2RlID09PSA5KSB7XG4gICAgICBpZiAodGhpcy5wb3BvdmVyRm9jdXNhYmxlRWxzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgIHRoaXMuX29uQmFja3dhcmRUYWIoZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vbkZvcndhcmRUYWIoZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW50ZXIgS2V5XG4gICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGlmIChlLnRhcmdldCA9PT0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNwYXJrLXBvcG92ZXJfX2Nsb3NlJykgfHwgKDAsIF9nZXRQYXJlbnQyLmRlZmF1bHQpKGUudGFyZ2V0LCAnLnNwYXJrLXBvcG92ZXJfX2Nsb3NlJywgdGhpcy5jb250ZW50RWwpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuXG4gICAgICAgIC8vIFNldCBmb2N1cyBiYWNrIHRvIHRvZ2dsZVxuICAgICAgICB0aGlzLnRvZ2dsZUVsLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRhYmJpbmcgYmFja3dhcmRzLCBsb2NhbGl6ZSB0cmF2ZXJzYWwgdG8gUG9wb3ZlciBlbGVtZW50cyBvbmx5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuX29uQmFja3dhcmRUYWIgPSBmdW5jdGlvbiBfb25CYWNrd2FyZFRhYihlKSB7XG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuZmlyc3RQb3BvdmVyRm9jdXNhYmxlRWwpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMubGFzdFBvcG92ZXJGb2N1c2FibGVFbC5mb2N1cygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0YWJiaW5nIGZvcndhcmRzLCBsb2NhbGl6ZSB0cmF2ZXJzYWwgdG8gUG9wb3ZlciBlbGVtZW50cyBvbmx5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuX29uRm9yd2FyZFRhYiA9IGZ1bmN0aW9uIF9vbkZvcndhcmRUYWIoZSkge1xuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLmxhc3RQb3BvdmVyRm9jdXNhYmxlRWwpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuZmlyc3RQb3BvdmVyRm9jdXNhYmxlRWwuZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHRvZ2dsZSBpcyBjbGlja2VkLCBjbG9zZSBpZiBpdCdzIGEgbGluay4gSWYgaXQncyBjb250ZW50LCBkb24ndCBkbyBhbnl0aGluZyBidXQgc3RvcFxuICAgKiB0aGUgZXZlbnQgZnJvbSBidWJibGluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fb25Db250ZW50Q2xpY2sgPSBmdW5jdGlvbiBfb25Db250ZW50Q2xpY2soZSkge1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhIGxpbmssIGNsb3NlLlxuICAgIGlmICgoMCwgX2dldFBhcmVudDIuZGVmYXVsdCkoZS50YXJnZXQsICcuc3BhcmstcG9wb3Zlcl9fbGlzdC1saW5rJywgdGhpcy5jb250ZW50RWwpIHx8ICgwLCBfZ2V0UGFyZW50Mi5kZWZhdWx0KShlLnRhcmdldCwgJy5zcGFyay1wb3BvdmVyX19jbG9zZScsIHRoaXMuY29udGVudEVsKSkge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgd2luZG93IGlzIGNsaWNrZWQgYW5kIGl0J3Mgbm90IHBhcnQgb2YgdGhlIHBvcG92ZXIsIGNsb3NlIHRoZSBwb3BvdmVyLlxuICAgKiBAcGFyYW0ge09iamVjfSBlXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuX29uV2luZG93Q2xpY2sgPSBmdW5jdGlvbiBfb25XaW5kb3dDbGljayhlKSB7XG4gICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzLmVsICYmIGUudGFyZ2V0ICE9PSB0aGlzLmNvbnRlbnRFbCAmJiAhKDAsIF9oYXNQYXJlbnQyLmRlZmF1bHQpKGUudGFyZ2V0LCB0aGlzLmVsKSAmJiAhKDAsIF9oYXNQYXJlbnQyLmRlZmF1bHQpKGUudGFyZ2V0LCB0aGlzLmNvbnRlbnRFbCkpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFBvcG92ZXI7XG59KF9iYXNlMi5kZWZhdWx0KTtcblxuLyoqXG4gKiBXaGl0ZWxpc3RlZCBwYXJhbWV0ZXJzIHdoaWNoIGNhbiBiZSBzZXQgb24gY29uc3RydWN0aW9uLlxuICogQHR5cGUge0FycmF5fVxuICovXG5cblxuUG9wb3Zlci5wcm90b3R5cGUuX3doaXRlbGlzdGVkUGFyYW1zID0gWydhbmNob3JYJywgJ2FuY2hvclknLCAndG9nZ2xlRWwnLCAnY29udGVudEVsJywgJ29uT3BlbicsICdvbkNsb3NlJ107XG5cbi8qKlxuICogRGVmYXVsdCB2YWx1ZXMgZm9yIGludGVybmFsIHByb3BlcnRpZXMgd2Ugd2lsbCBiZSBzZXR0aW5nLlxuICogVGhlc2UgYXJlIHNldCBvbiBlYWNoIGNvbnN0cnVjdGlvbiBzbyB3ZSBkb24ndCBsZWFrIHByb3BlcnRpZXNcbiAqIGludG8gdGhlIHByb3RvdHlwZSBjaGFpbi5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblBvcG92ZXIucHJvdG90eXBlLmRlZmF1bHRzID0ge1xuICBlbDogbnVsbCxcbiAgdG9nZ2xlRWw6IG51bGwsXG4gIGNvbnRlbnRFbDogbnVsbCxcbiAgY2FyZXRFbDogbnVsbCxcbiAgYWZmaXg6IG51bGwsXG4gIGlzQWN0aXZlOiBmYWxzZSxcbiAgaXNQYXVzZWQ6IGZhbHNlLFxuICBpc0ZpeGVkOiBmYWxzZSxcbiAgYW5jaG9yWDogbnVsbCxcbiAgYW5jaG9yWTogbnVsbCxcbiAgY2xvc2VUaW1lcjogbnVsbCxcbiAgb25PcGVuOiBudWxsLFxuICBvbkNsb3NlOiBudWxsLFxuICBfb25DbGlja0JvdW5kOiBudWxsLFxuICBfb25LZXl1cEJvdW5kOiBudWxsLFxuICBfb25LZXlkb3duQm91bmQ6IG51bGwsXG4gIF9vbkNvbnRlbnRDbGlja0JvdW5kOiBudWxsLFxuICBfb25XaW5kb3dDbGlja0JvdW5kOiBudWxsLFxuICBfb25XaW5kb3dSZXNpemVCb3VuZDogbnVsbCxcbiAgX29uV2luZG93U2Nyb2xsQm91bmQ6IG51bGxcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFBvcG92ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcG92ZXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHJpbSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJpbScpO1xuXG52YXIgX3RyaW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJpbSk7XG5cbnZhciBfaGFzQ2xhc3MgPSByZXF1aXJlKCcuL2hhcy1jbGFzcycpO1xuXG52YXIgX2hhc0NsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhc0NsYXNzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiAjIEFkZCBDbGFzc1xuICogQWRkIGEgY2xhc3Mgb24gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXl9IGVsIEFuIGVsZW1lbnQgb3IgYXJyYXkgb2YgZWxlbWVudHMgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL2RvbS9hZGQtY2xhc3MuanNcbiAqL1xuXG52YXIgd3MgPSAvXFxzKy87XG52YXIgY2xlYW51cCA9IC9cXHN7Mix9L2c7XG5cbmZ1bmN0aW9uIGFkZENsYXNzKGVsLCBuYW1lKSB7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgbmFtZSA9ICgwLCBfdHJpbTIuZGVmYXVsdCkobmFtZSkuc3BsaXQod3MpO1xuICB9IGVsc2Uge1xuICAgIG5hbWUgPSBuYW1lIGluc3RhbmNlb2YgQXJyYXkgPyBuYW1lIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgfVxuXG4gIC8vIG9wdGltaXplIGZvciBiZXN0LCBtb3N0IGNvbW1vbiBjYXNlXG4gIGlmIChuYW1lLmxlbmd0aCA9PT0gMSAmJiBlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAobmFtZVswXSkge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChuYW1lWzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgdmFyIHRvQWRkID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBuYW1lLmxlbmd0aDtcbiAgdmFyIGl0ZW0gPSB2b2lkIDA7XG4gIHZhciBjbHNOYW1lID0gdHlwZW9mIGVsLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycgPyBlbC5jbGFzc05hbWUgOiBlbC5nZXRBdHRyaWJ1dGUgPyBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgOiAnJztcblxuICAvLyBzZWUgaWYgd2UgaGF2ZSBhbnl0aGluZyB0byBhZGRcbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBpdGVtID0gbmFtZVtpXTtcbiAgICBpZiAoaXRlbSAmJiAhKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkoY2xzTmFtZSwgaXRlbSkpIHtcbiAgICAgIHRvQWRkLnB1c2goaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRvQWRkLmxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgZWwuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZWwuY2xhc3NOYW1lID0gKDAsIF90cmltMi5kZWZhdWx0KSgoY2xzTmFtZSArICcgJyArIHRvQWRkLmpvaW4oJyAnKSkucmVwbGFjZShjbGVhbnVwLCAnICcpKTtcbiAgICB9IGVsc2UgaWYgKGVsLnNldEF0dHJpYnV0ZSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsICgwLCBfdHJpbTIuZGVmYXVsdCkoKGNsc05hbWUgKyAnICcgKyB0b0FkZC5qb2luKCcgJykpLnJlcGxhY2UoY2xlYW51cCwgJyAnKSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbDtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gYWRkQ2xhc3M7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZC1jbGFzcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4vKipcbiAqICMgSGFzIENsYXNzXG4gKiBTZWUgaWYgYW4gZWxlbWVudCBoYXMgYSBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL2RvbS9oYXMtY2xhc3MuanNcbiAqL1xuZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIG5hbWUpIHtcbiAgdmFyIGNOYW1lID0gKCh0eXBlb2YgZWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGVsKSkgPT09ICdvYmplY3QnID8gZWwuY2xhc3NOYW1lIHx8IGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycgOiBlbCB8fCAnJykucmVwbGFjZSgvW1xcdFxcclxcblxcZl0vZywgJyAnKTtcbiAgcmV0dXJuICgnICcgKyBjTmFtZSArICcgJykuaW5kZXhPZignICcgKyBuYW1lICsgJyAnKSAhPT0gLTE7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGhhc0NsYXNzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXMtY2xhc3MuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgT2Zmc2V0IFBvc2l0aW9uXG4gKiBHZXQgdGhlIG9mZnNldCBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHZpZXdQb3J0T2Zmc2V0IFRoZSBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LCBub3QgcGFnZS5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZG9tL29mZnNldC5qc1xuICovXG5mdW5jdGlvbiBvZmZzZXQoZWwsIHZpZXdQb3J0T2Zmc2V0KSB7XG5cbiAgdmFyIHJlY3QgPSB7XG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcblxuICAvLyBOYXRpdmUgaW1wbGVtZW50YXRpb25cbiAgaWYgKGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xuXG4gICAgdmFyIGJvdW5kaW5nID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmVjdC5sZWZ0ID0gYm91bmRpbmcubGVmdDtcbiAgICByZWN0LnRvcCA9IGJvdW5kaW5nLnRvcDtcblxuICAgIGlmICghdmlld1BvcnRPZmZzZXQpIHtcbiAgICAgIHJlY3QubGVmdCArPSB0eXBlb2Ygd2luZG93LnNjcm9sbFggIT09ICd1bmRlZmluZWQnID8gd2luZG93LnNjcm9sbFggOiB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgICByZWN0LnRvcCArPSB0eXBlb2Ygd2luZG93LnNjcm9sbFkgIT09ICd1bmRlZmluZWQnID8gd2luZG93LnNjcm9sbFkgOiB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB4ID0gMCxcbiAgICAgICAgeSA9IDA7XG4gICAgZG8ge1xuICAgICAgeCArPSBlbC5vZmZzZXRMZWZ0IC0gKCF2aWV3UG9ydE9mZnNldCA/IGVsLnNjcm9sbExlZnQgOiAwKTtcbiAgICAgIHkgKz0gZWwub2Zmc2V0VG9wIC0gKCF2aWV3UG9ydE9mZnNldCA/IGVsLnNjcm9sbFRvcCA6IDApO1xuICAgIH0gd2hpbGUgKGVsID0gZWwub2Zmc2V0UGFyZW50KTtcblxuICAgIHJlY3QubGVmdCA9IHg7XG4gICAgcmVjdC50b3AgPSB5O1xuICB9XG5cbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG9mZnNldDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2Zmc2V0LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIFBhcnNlIERPTSBhdHRyaWJ1dGVzXG4gKiBHaXZlbiBhbiBlbGVtZW50IGFuZCBhbiBhdHRyaWJ1dGUgbmFtZSwgcGFyc2UgdGhhdCBhdHRyaWJ1dGVcbiAqIGlmIGl0IGV4aXN0cyBvciByZXR1cm4gYSBkZWZhdWx0LlxuICpcbiAqIEBtb2R1bGUgaGVscGVycy9kb20vcGFyc2UtYXR0cmlidXRlLmpzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIGJvb2xlYW4gdmFsdWUgb2YgYW4gYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQsXG4gKiBmYWxsaW5nIGJhY2sgdG8gdGhlIGRlZmF1bHQgdmFsdWUuXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbFxuICogQHBhcmFtICB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0gIHtCb29sZWFufSBkZWZcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGJvb2xlYW4oZWwsIG5hbWUsIGRlZikge1xuICB2YXIgdmFsID0gZWwuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gZGVmO1xuICByZXR1cm4gdmFsID09PSAndHJ1ZScgfHwgdmFsID09PSAnJyA/IHRydWUgOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG51bWVyaWMgdmFsdWUgb2YgYW4gYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQsXG4gKiBmYWxsaW5nIGJhY2sgdG8gdGhlIGRlZmF1bHQgdmFsdWUuXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbFxuICogQHBhcmFtICB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0gIHtCb29sZWFufSBkZWZcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIG51bWJlcihlbCwgbmFtZSwgZGVmKSB7XG4gIHZhciB2YWwgPSBlbC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiBkZWY7XG4gIHJldHVybiBwYXJzZUludCh2YWwsIDEwKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGJvb2xlYW4gdmFsdWUgb2YgYW4gYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQsXG4gKiBmYWxsaW5nIGJhY2sgdG8gdGhlIGRlZmF1bHQgdmFsdWUuXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbFxuICogQHBhcmFtICB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0gIHtCb29sZWFufSBkZWZcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHN0cmluZyhlbCwgbmFtZSwgZGVmKSB7XG4gIHZhciB2YWwgPSBlbC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiBkZWY7XG4gIHJldHVybiB2YWw7XG59XG5cbmV4cG9ydHMuYm9vbGVhbiA9IGJvb2xlYW47XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UtYXR0cmlidXRlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3RyaW0gPSByZXF1aXJlKCcuLi91dGlsL3RyaW0nKTtcblxudmFyIF90cmltMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RyaW0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgd3MgPSAvXFxzKy87IC8qKlxuICAgICAgICAgICAgICAgICAqICMgUmVtb3ZlIENsYXNzXG4gICAgICAgICAgICAgICAgICogUmVtb3ZlIGEgY2xhc3Mgb24gYW4gZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxBcnJheX0gZWwgQW4gZWxlbWVudCBvciBhcnJheSBvZiBlbGVtZW50cyB0byB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQG1vZHVsZSBoZWxwZXJzL2RvbS9yZW1vdmUtY2xhc3MuanNcbiAgICAgICAgICAgICAgICAgKi9cblxudmFyIGNsZWFudXAgPSAvXFxzezIsfS9nO1xuXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgbmFtZSkge1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgIG5hbWUgPSAoMCwgX3RyaW0yLmRlZmF1bHQpKG5hbWUpLnNwbGl0KHdzKTtcbiAgfSBlbHNlIHtcbiAgICBuYW1lID0gbmFtZSBpbnN0YW5jZW9mIEFycmF5ID8gbmFtZSA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIH1cblxuICAvLyBvcHRpbWl6ZSBmb3IgYmVzdCwgbW9zdCBjb21tb24gY2FzZVxuICBpZiAobmFtZS5sZW5ndGggPT09IDEgJiYgZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKG5hbWVbMF0pIGVsLmNsYXNzTGlzdC5yZW1vdmUobmFtZVswXSk7XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgLy8gc3RvcmUgdHdvIGNvcGllc1xuICB2YXIgY2xzTmFtZSA9ICcgJyArICh0eXBlb2YgZWwuY2xhc3NOYW1lID09PSAnc3RyaW5nJyA/IGVsLmNsYXNzTmFtZSA6IGVsLmdldEF0dHJpYnV0ZSA/IGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSA6ICcnKSArICcgJztcbiAgdmFyIHJlc3VsdCA9IGNsc05hbWU7XG4gIHZhciBjdXJyZW50ID0gdm9pZCAwO1xuICB2YXIgc3RhcnQgPSB2b2lkIDA7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gbmFtZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjdXJyZW50ID0gbmFtZVtpXTtcbiAgICBzdGFydCA9IGN1cnJlbnQgPyByZXN1bHQuaW5kZXhPZignICcgKyBjdXJyZW50ICsgJyAnKSA6IC0xO1xuICAgIGlmIChzdGFydCAhPT0gLTEpIHtcbiAgICAgIHN0YXJ0ICs9IDE7XG4gICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgc3RhcnQpICsgcmVzdWx0LnNsaWNlKHN0YXJ0ICsgY3VycmVudC5sZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIG9ubHkgd3JpdGUgaWYgbW9kaWZpZWRcbiAgaWYgKGNsc05hbWUgIT09IHJlc3VsdCkge1xuICAgIGlmICh0eXBlb2YgZWwuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZWwuY2xhc3NOYW1lID0gKDAsIF90cmltMi5kZWZhdWx0KShyZXN1bHQucmVwbGFjZShjbGVhbnVwLCAnICcpKTtcbiAgICB9IGVsc2UgaWYgKGVsLnNldEF0dHJpYnV0ZSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsICgwLCBfdHJpbTIuZGVmYXVsdCkocmVzdWx0LnJlcGxhY2UoY2xlYW51cCwgJyAnKSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbDtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gcmVtb3ZlQ2xhc3M7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92ZS1jbGFzcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9oYXNDbGFzcyA9IHJlcXVpcmUoJy4vaGFzLWNsYXNzJyk7XG5cbnZhciBfaGFzQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzQ2xhc3MpO1xuXG52YXIgX2FkZENsYXNzID0gcmVxdWlyZSgnLi9hZGQtY2xhc3MnKTtcblxudmFyIF9hZGRDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hZGRDbGFzcyk7XG5cbnZhciBfcmVtb3ZlQ2xhc3MgPSByZXF1aXJlKCcuL3JlbW92ZS1jbGFzcycpO1xuXG52YXIgX3JlbW92ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlbW92ZUNsYXNzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWwsIG5hbWUsIGVuYWJsZSkge1xuXG4gIGlmICghZWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBwYXNzZWQgYW4gYXJyYXksIHRvZ2dsZSB0aGUgY2xhc3Mgb24gZWFjaC5cbiAgaWYgKGVsIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgZWwgaW5zdGFuY2VvZiBBcnJheSkge1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0b2dnbGVDbGFzcyhlbFtpXSwgbmFtZSwgZW5hYmxlKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYWN0aW9uID0gdm9pZCAwO1xuICBpZiAoZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmFibGUgPSB0eXBlb2YgZW5hYmxlID09PSAnZnVuY3Rpb24nID8gZW5hYmxlLmNhbGwobnVsbCwgZWwpIDogZW5hYmxlO1xuICAgIGFjdGlvbiA9IGVuYWJsZSA/ICdhZGQnIDogJ3JlbW92ZSc7XG4gIH0gZWxzZSB7XG4gICAgYWN0aW9uID0gKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkoZWwsIG5hbWUpID8gJ3JlbW92ZScgOiAnYWRkJztcbiAgfVxuXG4gIHJldHVybiAoYWN0aW9uID09PSAnYWRkJyA/IF9hZGRDbGFzczIuZGVmYXVsdCA6IF9yZW1vdmVDbGFzczIuZGVmYXVsdCkoZWwsIG5hbWUpO1xufSAvKipcbiAgICogIyBUb2dnbGUgQ2xhc3NcbiAgICogVG9nZ2xlIGEgY2xhc3Mgb24gYW4gZWxlbWVudCBnaXZlbiBhIGNvbmRpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fEFycmF5fSBlbCBBbiBlbGVtZW50IG9yIGFycmF5IG9mIGVsZW1lbnRzIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICpcbiAgICogQG1vZHVsZSAgaGVscGVycy9kb20vdG9nZ2xlLWNsYXNzLmpzXG4gICAqL1xuXG5leHBvcnRzLmRlZmF1bHQgPSB0b2dnbGVDbGFzcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9nZ2xlLWNsYXNzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2VhY2ggPSByZXF1aXJlKCcuLi91dGlsL2VhY2gnKTtcblxudmFyIF9lYWNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZHJlbihlbCwgY2hpbGRyZW4sIGVtcHR5KSB7XG5cbiAgZW1wdHkgPSBlbXB0eSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBlbXB0eTtcblxuICBpZiAoZW1wdHkpIHtcbiAgICBlbC50ZXh0Q29udGVudCA9ICcnO1xuICB9XG5cbiAgdmFyIGRvbUxpc3QgPSBjaGlsZHJlbiBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MQ29sbGVjdGlvbjtcblxuICBpZiAoZG9tTGlzdCkge1xuICAgIHdoaWxlIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGVsLmFwcGVuZENoaWxkKGNoaWxkcmVuWzBdKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgKDAsIF9lYWNoMi5kZWZhdWx0KShjaGlsZHJlbiwgZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjKSB7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKGMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59IC8qKlxuICAgKiAjIEFwcGVuZCBDaGlsZHJlblxuICAgKiBBcHBlbmQgYW4gYXJyYXkgb2YgY2hpbGRyZW4gdG8gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNoaWxkcmVuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW1wdHkgRW1wdHkgdGhlIG5vZGUgYmVmb3JlIGFkZGluZyBjaGlsZHJlbj9cbiAgICpcbiAgICogQG1vZHVsZSBoZWxwZXJzL21hbmlwdWxhdGlvbi9hcHBlbmQtY2hpbGRyZW4uanNcbiAgICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGFwcGVuZENoaWxkcmVuO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHBlbmQtY2hpbGRyZW4uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfb2Zmc2V0MiA9IHJlcXVpcmUoJy4uL2RvbS9vZmZzZXQnKTtcblxudmFyIF9vZmZzZXQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2Zmc2V0Mik7XG5cbnZhciBfYm94UG9zaXRpb24gPSByZXF1aXJlKCcuL2JveC1wb3NpdGlvbicpO1xuXG52YXIgX2JveFBvc2l0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JveFBvc2l0aW9uKTtcblxudmFyIF9kZWJvdW5jZSA9IHJlcXVpcmUoJy4uL3V0aWwvZGVib3VuY2UnKTtcblxudmFyIF9kZWJvdW5jZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWJvdW5jZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICMgQWZmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBBZmZpeCBvbmUgZWxlbWVudCB0byBhbm90aGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBuZXcgQWZmaXgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgZWw6IGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgdGFyZ2V0RWw6IGVsMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIGNhcmV0RWw6IGVsMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIGFuY2hvclk6ICd0b3AnLCAvLyAnbWlkZGxlJywgJ2JvdHRvbSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIGFuY2hvclg6ICdsZWZ0JywgLy8gJ2NlbnRlcicsICdyaWdodCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBoZWxwZXJzL3Bvc2l0aW9uL2FmZml4LmpzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBBZmZpeCA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogU3RvcmUgdGhlIHJlZmVyZW5jZSBlbGVtZW50cyBhbmQgcG9zaXRpb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gcGFyYW1zXG4gICAqL1xuICBmdW5jdGlvbiBBZmZpeCgpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBZmZpeCk7XG5cbiAgICB0aGlzLmVsID0gcGFyYW1zLmVsO1xuICAgIHRoaXMudGFyZ2V0RWwgPSBwYXJhbXMudGFyZ2V0RWw7XG4gICAgdGhpcy5jYXJldEVsID0gcGFyYW1zLmNhcmV0RWw7XG4gICAgdGhpcy5hbmNob3JZID0gcGFyYW1zLmFuY2hvclkgfHwgJ3RvcCc7XG4gICAgdGhpcy5hbmNob3JYID0gcGFyYW1zLmFuY2hvclggfHwgJ2NlbnRlcic7XG4gICAgdGhpcy5pc0ZpeGVkID0gcGFyYW1zLmlzRml4ZWQgfHwgZmFsc2U7XG5cbiAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuX2luc2VydEVsKCk7XG4gICAgdGhpcy5fc2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLl91cGRhdGVEZWJvdW5jZWQgPSAoMCwgX2RlYm91bmNlMi5kZWZhdWx0KSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpLCA1MDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgbGlzdGVuaW5nIGFuZCBjbGVhbiB1cCBldmVudCBsaXN0ZW5lcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBPcHRpb25hbFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNcbiAgICovXG5cblxuICBBZmZpeC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgaWYgKCFwYXJhbXMua2VlcEVsKSB0aGlzLl9yZW1vdmVFbCgpO1xuICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcG9zaXRpb24uXG4gICAqIEByZXR1cm4ge09iamVjdH0gdGhpc1xuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdGhpcy5fc2V0UG9zaXRpb24oKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogTGlzdGVuIGZvciB3aW5kb3cgcmVzaXplcyB0byB1cGRhdGUgdGhlIHBvc2l0aW9uLlxuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fb25SZXNpemVCb3VuZCA9IHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25TY3JvbGxCb3VuZCA9IHRoaXMuX29uU2Nyb2xsLmJpbmQodGhpcyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplQm91bmQpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbEJvdW5kKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplQm91bmQpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbEJvdW5kKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5zZXJ0IHRoZSBlbGVtZW50IGludG8gdGhlIERPTS5cbiAgICovXG5cblxuICBBZmZpeC5wcm90b3R5cGUuX2luc2VydEVsID0gZnVuY3Rpb24gX2luc2VydEVsKCkge1xuICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdkYXRhLWFmZml4ZWQnLCAnJyk7XG4gICAgdGhpcy5fZ2V0Um9vdEVsKCkuYXBwZW5kQ2hpbGQodGhpcy5lbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIHRoZSBET00uXG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9yZW1vdmVFbCA9IGZ1bmN0aW9uIF9yZW1vdmVFbCgpIHtcbiAgICB0aGlzLmVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbCk7XG4gICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtYWZmaXhlZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICovXG5cblxuICBBZmZpeC5wcm90b3R5cGUuX3NldFBvc2l0aW9uID0gZnVuY3Rpb24gX3NldFBvc2l0aW9uKCkge1xuXG4gICAgLy8gRml4ZWQgcG9zaXRpb25cbiAgICB0aGlzLmVsLnN0eWxlLnNldFByb3BlcnR5KCdwb3NpdGlvbicsIHRoaXMuaXNGaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnLCAnaW1wb3J0YW50Jyk7XG5cbiAgICAvLyBUYXJnZXQgZWxlbWVudCBwcm9wZXJ0aWVzXG5cbiAgICB2YXIgX29mZnNldCA9ICgwLCBfb2Zmc2V0My5kZWZhdWx0KSh0aGlzLnRhcmdldEVsLCB0aGlzLmlzRml4ZWQpLFxuICAgICAgICB0YXJnZXRUb3AgPSBfb2Zmc2V0LnRvcCxcbiAgICAgICAgdGFyZ2V0TGVmdCA9IF9vZmZzZXQubGVmdDtcblxuICAgIHZhciB0YXJnZXRXaWR0aCA9IHRoaXMudGFyZ2V0RWwub2Zmc2V0V2lkdGg7XG4gICAgdmFyIHRhcmdldEhlaWdodCA9IHRoaXMudGFyZ2V0RWwub2Zmc2V0SGVpZ2h0O1xuXG4gICAgLy8gRWxlbWVudCB0byBhZmZpeCBwcm9wZXJ0aWVzXG4gICAgdmFyIGVsV2lkdGggPSB0aGlzLmVsLm9mZnNldFdpZHRoO1xuICAgIHZhciBlbEhlaWdodCA9IHRoaXMuZWwub2Zmc2V0SGVpZ2h0O1xuXG4gICAgLy8gTWF4ZXNcbiAgICB2YXIgZG9jSGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICB2YXIgZG9jV2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0V2lkdGg7XG5cbiAgICAvLyBHZXQgdGhlIHZhbHVlc1xuXG4gICAgdmFyIF9jYWxjdWxhdGVQb3NpdGlvbjIgPSB0aGlzLl9jYWxjdWxhdGVQb3NpdGlvbih7XG4gICAgICBhbmNob3JYOiB0aGlzLmFuY2hvclgsXG4gICAgICBhbmNob3JZOiB0aGlzLmFuY2hvclksXG4gICAgICB0YXJnZXRUb3A6IHRhcmdldFRvcCxcbiAgICAgIHRhcmdldExlZnQ6IHRhcmdldExlZnQsXG4gICAgICBlbEhlaWdodDogZWxIZWlnaHQsXG4gICAgICBlbFdpZHRoOiBlbFdpZHRoLFxuICAgICAgdGFyZ2V0SGVpZ2h0OiB0YXJnZXRIZWlnaHQsXG4gICAgICB0YXJnZXRXaWR0aDogdGFyZ2V0V2lkdGgsXG4gICAgICBtaW5YOiAwLFxuICAgICAgbWluWTogMCxcbiAgICAgIG1heFg6IGRvY1dpZHRoIC0gZWxXaWR0aCxcbiAgICAgIG1heFk6IE1hdGgubWF4KGRvY0hlaWdodCAtIGVsSGVpZ2h0LCAwKVxuICAgIH0pLFxuICAgICAgICBlbFRvcCA9IF9jYWxjdWxhdGVQb3NpdGlvbjIuZWxUb3AsXG4gICAgICAgIGVsTGVmdCA9IF9jYWxjdWxhdGVQb3NpdGlvbjIuZWxMZWZ0O1xuXG4gICAgLy8gUG9zaXRpb24gdGhlIGNhcmV0XG5cblxuICAgIHZhciBfcG9zaXRpb25DYXJldDIgPSB0aGlzLl9wb3NpdGlvbkNhcmV0KHtcbiAgICAgIGVsTGVmdDogZWxMZWZ0LFxuICAgICAgZWxUb3A6IGVsVG9wLFxuICAgICAgZWxXaWR0aDogZWxXaWR0aCxcbiAgICAgIGVsSGVpZ2h0OiBlbEhlaWdodCxcbiAgICAgIHRhcmdldEhlaWdodDogdGFyZ2V0SGVpZ2h0LFxuICAgICAgdGFyZ2V0V2lkdGg6IHRhcmdldFdpZHRoLFxuICAgICAgdGFyZ2V0TGVmdDogdGFyZ2V0TGVmdCxcbiAgICAgIHRhcmdldFRvcDogdGFyZ2V0VG9wXG4gICAgfSksXG4gICAgICAgIGV4dHJhTGVmdCA9IF9wb3NpdGlvbkNhcmV0Mi5leHRyYUxlZnQsXG4gICAgICAgIGV4dHJhVG9wID0gX3Bvc2l0aW9uQ2FyZXQyLmV4dHJhVG9wO1xuXG4gICAgLy8gU2V0IHRoZSBwb3NpdGlvblxuXG5cbiAgICB0aGlzLmVsLnN0eWxlLmxlZnQgPSBlbExlZnQgKyBleHRyYUxlZnQgKyAncHgnO1xuICAgIHRoaXMuZWwuc3R5bGUudG9wID0gZWxUb3AgKyBleHRyYVRvcCArICdweCc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJvcGVyIHRvcCBwb3NpdGlvbiBmb3IgYW4gYW5jaG9yIGRpcmVjdGlvbi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBwXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cblxuICBBZmZpeC5wcm90b3R5cGUuX2NhbGN1bGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gX2NhbGN1bGF0ZVBvc2l0aW9uKHApIHtcblxuICAgIC8vIEtlZXAgdHJhY2sgb2Ygd2hhdCB3ZSdyZSB0cnlpbmcgdG8gZG8gaGVyZSwgc28gb24gc3Vic2VxdWVudCwgbmVzdGVkIGNhbGxzIHRvIHRoaXNcbiAgICAvLyBtZXRob2Qgd2UgY2FuIHNlZSB3aGF0IGhhcyBhbHJlYWR5IGJlZW4gdHJpZWQuXG4gICAgcC5wcmV2aW91c0F0dGVtcHRzID0gKHAucHJldmlvdXNBdHRlbXB0cyB8fCAwKSArIDE7XG4gICAgcC5wcmV2aW91c0NoZWNrcyA9IHAucHJldmlvdXNDaGVja3MgfHwgW107XG5cbiAgICB2YXIgZmluYWxDaGVjayA9IHAucHJldmlvdXNBdHRlbXB0cyA+IDM7XG4gICAgdmFyIHRvcCA9IHZvaWQgMDtcbiAgICB2YXIgbGVmdCA9IHZvaWQgMDtcblxuICAgIC8vIFktYXhpcyBjaGVja1xuICAgIHN3aXRjaCAocC5hbmNob3JZKSB7XG4gICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICB0b3AgPSBwLnRhcmdldFRvcCArIHAudGFyZ2V0SGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgIHRvcCA9IHAudGFyZ2V0VG9wIC0gKHAuZWxIZWlnaHQgLSBwLnRhcmdldEhlaWdodCkgLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRvcCA9IHAudGFyZ2V0VG9wIC0gcC5lbEhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gVW5kZXIgbWluXG4gICAgaWYgKHRvcCA8IHAubWluWSkge1xuXG4gICAgICBpZiAoIWZpbmFsQ2hlY2sgJiYgcC5wcmV2aW91c0NoZWNrcy5pbmRleE9mKCdvdmVyWScpID09PSAtMSkge1xuICAgICAgICBwLnByZXZpb3VzQ2hlY2tzLnB1c2goJ3VuZGVyWScpO1xuICAgICAgICBwLmFuY2hvclkgPSB0aGlzLl9nZXROZXdBbmNob3JZKHRydWUsIHAuYW5jaG9yWSwgcC5hbmNob3JYKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZVBvc2l0aW9uKHApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9wID0gcC5taW5ZO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERvbid0IGNoZWNrIGZvciBiZWluZyB0b28gdGFsbCBiZWNhdXNlIGNhdXNpbmcgYSB2ZXJ0aWNhbCBzY3JvbGxcbiAgICAvLyBiYXIgZG93biBpcyBva2F5IGFuZCB0aGlzIHNhdmVzIHVzIGZyb20gc29tZSByZWFsIHBvc2l0aW9uaW5nIGhlbGwuXG4gICAgLyppZiAodG9wID4gcC5tYXhZKSB7XG4gICAgICAgaWYgKCFmaW5hbENoZWNrICYmIHAucHJldmlvdXNDaGVja3MuaW5kZXhPZigndW5kZXJZJykgPT09IC0xKSB7XG4gICAgICAgIHAucHJldmlvdXNDaGVja3MucHVzaCgnb3ZlclknKTtcbiAgICAgICAgcC5hbmNob3JZID0gdGhpcy5fZ2V0TmV3QW5jaG9yWShmYWxzZSwgcC5hbmNob3JZLCBwLmFuY2hvclgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlUG9zaXRpb24ocCk7XG4gICAgICB9XG4gICAgICAvLyBPbiBhIGZpbmFsIGNoZWNrLCBib3R0b20gd2lucyBiZWNhdXNlIGF0IGxlYXN0IHdlIGNhbiBzY3JvbGxcbiAgICAgIGVsc2UgaWYgKCEoZmluYWxDaGVjayAmJiBwLmFuY2hvclkgPT09ICdib3R0b20nKSkge1xuICAgICAgICB0b3AgPSBwLm1heFk7XG4gICAgICB9XG4gICAgfSovXG5cbiAgICAvLyBYLWF4aXMgY2hlY2tcbiAgICBzd2l0Y2ggKHAuYW5jaG9yWCkge1xuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBsZWZ0ID0gcC50YXJnZXRMZWZ0ICsgKHAuYW5jaG9yWSAhPT0gJ21pZGRsZScgJiYgIXAuaXNPdmVybGFwcGluZyA/IDAgOiBwLnRhcmdldFdpZHRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICBsZWZ0ID0gcC50YXJnZXRMZWZ0IC0gKHAuZWxXaWR0aCAtIHAudGFyZ2V0V2lkdGgpIC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZWZ0ID0gcC50YXJnZXRMZWZ0IC0gcC5lbFdpZHRoICsgKHAuYW5jaG9yWSAhPT0gJ21pZGRsZScgPyBwLnRhcmdldFdpZHRoIDogMCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFVuZGVyIG1pblxuICAgIGlmIChsZWZ0IDwgcC5taW5YKSB7XG5cbiAgICAgIGlmICghZmluYWxDaGVjayAmJiBwLnByZXZpb3VzQ2hlY2tzLmluZGV4T2YoJ292ZXJYJykgPT09IC0xKSB7XG4gICAgICAgIHAucHJldmlvdXNDaGVja3MucHVzaCgndW5kZXJYJyk7XG4gICAgICAgIHAuYW5jaG9yWCA9IHRoaXMuX2dldE5ld0FuY2hvclgodHJ1ZSwgcC5hbmNob3JYLCBwLmFuY2hvclkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlUG9zaXRpb24ocCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0ID0gcC5taW5YO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE92ZXIgbWF4XG4gICAgaWYgKGxlZnQgPiBwLm1heFgpIHtcblxuICAgICAgaWYgKCFmaW5hbENoZWNrICYmIHAucHJldmlvdXNDaGVja3MuaW5kZXhPZigndW5kZXJYJykgPT09IC0xKSB7XG4gICAgICAgIHAucHJldmlvdXNDaGVja3MucHVzaCgnb3ZlclgnKTtcbiAgICAgICAgcC5hbmNob3JYID0gdGhpcy5fZ2V0TmV3QW5jaG9yWChmYWxzZSwgcC5hbmNob3JYLCBwLmFuY2hvclkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlUG9zaXRpb24ocCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0ID0gcC5tYXhYO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9uZSBlbGVtZW50IGlzIGNvdmVyaW5nIGFub3RoZXIuIFRyeSB0byBmaXggdGhhdCwgYnV0IGJhaWwgb3V0IGFmdGVyIGZvdXIgdHJpZXMuXG4gICAgaWYgKCgwLCBfYm94UG9zaXRpb24yLmRlZmF1bHQpKHsgd2lkdGg6IHAuZWxXaWR0aCwgaGVpZ2h0OiBwLmVsSGVpZ2h0LCBsZWZ0OiBsZWZ0LCB0b3A6IHRvcCB9LCB7IHdpZHRoOiBwLnRhcmdldFdpZHRoLCBoZWlnaHQ6IHAudGFyZ2V0SGVpZ2h0LCBsZWZ0OiBwLnRhcmdldExlZnQsIHRvcDogcC50YXJnZXRUb3AgfSkgPT09ICdvdmVybGFwJykge1xuXG4gICAgICBwLmlzT3ZlcmxhcHBpbmcgPSB0cnVlO1xuXG4gICAgICAvLyBUcnkgWVxuICAgICAgaWYgKHAucmVwb3NpdGlvblkgIT09IGZhbHNlKSB7XG5cbiAgICAgICAgLy8gV2lsbCBzdGFydCB1bmRlZmluZWQsIHRoZW4gdHJ1ZSwgdGhlbiBmYWxzZS4gVGhpcyBsaW1pdHMgdXMgdG8gZW50ZXJpbmdcbiAgICAgICAgLy8gdGhpcyBsb29wIHR3aWNlLCBvbmNlIHRvIHRyeSBtb3ZpbmcgaW4gZWFjaCBkaXJlY3Rpb24uXG4gICAgICAgIHAucmVwb3NpdGlvblkgPSAhcC5yZXBvc2l0aW9uWTtcblxuICAgICAgICAvLyBGaXJzdCB0cnkgdG8gcHV0IGFib3ZlLCB0aGVuIHRyeSB0byBwdXQgYmVsb3cuXG4gICAgICAgIHAuYW5jaG9yWSA9IHRoaXMuX2dldE5ld0FuY2hvclkocC5yZXBvc2l0aW9uWSwgJ21pZGRsZScsIHAuYW5jaG9yWCk7XG5cbiAgICAgICAgLy8gR2l2ZSB1cyBvbmUgbW9yZSBzaG90IGF0IHBvc2l0aW9uaW5nXG4gICAgICAgIHAucHJldmlvdXNBdHRlbXB0cy0tO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVQb3NpdGlvbihwKTtcbiAgICAgIH1cbiAgICAgIC8vIFRyeSBYXG4gICAgICBlbHNlIGlmIChwLnJlcG9zaXRpb25YICE9PSBmYWxzZSkge1xuXG4gICAgICAgICAgLy8gV2lsbCBzdGFydCB1bmRlZmluZWQsIHRoZW4gdHJ1ZSwgdGhlbiBmYWxzZS4gVGhpcyBsaW1pdHMgdXMgdG8gZW50ZXJpbmdcbiAgICAgICAgICAvLyB0aGlzIGxvb3AgdHdpY2UsIG9uY2UgdG8gdHJ5IG1vdmluZyBpbiBlYWNoIGRpcmVjdGlvbi5cbiAgICAgICAgICBwLnJlcG9zaXRpb25YID0gIXAucmVwb3NpdGlvblg7XG5cbiAgICAgICAgICAvLyBGaXJzdCB0cnkgdG8gcHV0IGFib3ZlLCB0aGVuIHRyeSB0byBwdXQgYmVsb3cuXG4gICAgICAgICAgcC5hbmNob3JYID0gdGhpcy5fZ2V0TmV3QW5jaG9yWChwLnJlcG9zaXRpb25YLCAnY2VudGVyJywgcC5hbmNob3JZKTtcblxuICAgICAgICAgIC8vIEdpdmUgdXMgb25lIG1vcmUgc2hvdCBhdCBwb3NpdGlvbmluZ1xuICAgICAgICAgIHAucHJldmlvdXNBdHRlbXB0cy0tO1xuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZVBvc2l0aW9uKHApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZWxUb3A6IHRvcCwgZWxMZWZ0OiBsZWZ0LCBhbmNob3JYOiBwLmFuY2hvclgsIGFuY2hvclk6IHAuYW5jaG9yWSB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIG5ldyB5LWF4aXMgYW5jaG9yXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IHVuZGVyTWluIFVuZGVyIHRoZSBtaW4/XG4gICAqIEBwYXJhbSAge1N0cmluZ30gYW5jaG9yWVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGFuY2hvclhcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5fZ2V0TmV3QW5jaG9yWSA9IGZ1bmN0aW9uIF9nZXROZXdBbmNob3JZKHVuZGVyTWluLCBhbmNob3JZLCBhbmNob3JYKSB7XG5cbiAgICAvLyBJZiB0aGUgeC1heGlzIGlzIGFuY2hvcmVkIGluIHRoZSBjZW50ZXIsIHNraXBcbiAgICAvLyB0cnlpbmcgdG8gYW5jaG9yIHRvIHRoZSBtaWRkbGUgYmVjYXVzZSB0aGVuIHdlJ2RcbiAgICAvLyBiZSBvdmVybGF5aW5nIHRoZSBidXR0b24uXG4gICAgaWYgKGFuY2hvclggPT09ICdjZW50ZXInIHx8IGFuY2hvclkgPT09ICdtaWRkbGUnKSB7XG4gICAgICByZXR1cm4gdW5kZXJNaW4gPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ21pZGRsZSc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIG5ldyB5LWF4aXMgYW5jaG9yXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IHVuZGVyTWluIFVuZGVyIHRoZSBtaW4/XG4gICAqIEBwYXJhbSAge1N0cmluZ30gYW5jaG9yWVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGFuY2hvclhcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5fZ2V0TmV3QW5jaG9yWCA9IGZ1bmN0aW9uIF9nZXROZXdBbmNob3JYKHVuZGVyTWluLCBhbmNob3JYLCBhbmNob3JZKSB7XG5cbiAgICAvLyBJZiB0aGUgeS1heGlzIGlzIGFuY2hvcmVkIGluIHRoZSBjZW50ZXIsIHNraXBcbiAgICAvLyB0cnlpbmcgdG8gYW5jaG9yIHRvIHRoZSBtaWRkbGUgYmVjYXVzZSB0aGVuIHdlJ2RcbiAgICAvLyBiZSBvdmVybGF5aW5nIHRoZSBidXR0b24uXG4gICAgaWYgKGFuY2hvclkgPT09ICdtaWRkbGUnIHx8IGFuY2hvclggPT09ICdjZW50ZXInKSB7XG4gICAgICByZXR1cm4gdW5kZXJNaW4gPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ2NlbnRlcic7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBjYXJldC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5fcG9zaXRpb25DYXJldCA9IGZ1bmN0aW9uIF9wb3NpdGlvbkNhcmV0KCkge1xuICAgIHZhciBwID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuXG4gICAgaWYgKCF0aGlzLmNhcmV0RWwpIHJldHVybjtcblxuICAgIHZhciBjYXJldFBvc2l0aW9uID0gKDAsIF9ib3hQb3NpdGlvbjIuZGVmYXVsdCkoeyB3aWR0aDogcC5lbFdpZHRoLCBoZWlnaHQ6IHAuZWxIZWlnaHQsIGxlZnQ6IHAuZWxMZWZ0LCB0b3A6IHAuZWxUb3AgfSwgeyB3aWR0aDogcC50YXJnZXRXaWR0aCwgaGVpZ2h0OiBwLnRhcmdldEhlaWdodCwgbGVmdDogcC50YXJnZXRMZWZ0LCB0b3A6IHAudGFyZ2V0VG9wIH0pO1xuXG4gICAgdmFyIGNhcmV0RGltZW5zaW9ucyA9IHRoaXMuY2FyZXRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgY2FyZXRXaWR0aCA9IGNhcmV0RGltZW5zaW9ucy53aWR0aDtcbiAgICB2YXIgY2FyZXRIZWlnaHQgPSBjYXJldERpbWVuc2lvbnMuaGVpZ2h0O1xuICAgIHZhciBsZWZ0ID0gTWF0aC5taW4ocC5lbFdpZHRoLCBNYXRoLm1heCgwLCBwLnRhcmdldExlZnQgLSBwLmVsTGVmdCArIHAudGFyZ2V0V2lkdGggLyAyKSk7XG4gICAgdmFyIHRvcCA9IE1hdGgubWluKHAuZWxIZWlnaHQsIE1hdGgubWF4KDAsIHAudGFyZ2V0VG9wIC0gcC5lbFRvcCArIHAudGFyZ2V0SGVpZ2h0IC8gMikpO1xuXG4gICAgdGhpcy5jYXJldEVsLnN0eWxlLmxlZnQgPSBNYXRoLnJvdW5kKGxlZnQpICsgJ3B4JztcbiAgICB0aGlzLmNhcmV0RWwuc3R5bGUudG9wID0gTWF0aC5yb3VuZCh0b3ApICsgJ3B4JztcblxuICAgIHZhciBleHRyYUxlZnQgPSAwO1xuICAgIHZhciBleHRyYVRvcCA9IDA7XG5cbiAgICB0aGlzLmNhcmV0RWwuc2V0QXR0cmlidXRlKCdkYXRhLXBvc2l0aW9uJywgY2FyZXRQb3NpdGlvbik7XG5cbiAgICBzd2l0Y2ggKGNhcmV0UG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ2Fib3ZlJzpcbiAgICAgICAgZXh0cmFUb3AgPSAtY2FyZXRXaWR0aCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYmVsb3cnOlxuICAgICAgICBleHRyYVRvcCA9IGNhcmV0V2lkdGggLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBleHRyYUxlZnQgPSAtY2FyZXRIZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGV4dHJhTGVmdCA9IGNhcmV0SGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGV4dHJhTGVmdDogZXh0cmFMZWZ0LFxuICAgICAgZXh0cmFUb3A6IGV4dHJhVG9wXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSByb290IGVsZW1lbnQuIFdhbnQgdG8gY2hlY2sgaWYgdGhlcmUncyBhIHRvcC1sZXZlbCBmb3JtIGZvciB3b3JraW5nXG4gICAqIHdpdGggQVNQIC5ORVQgcGFnZXMuXG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9nZXRSb290RWwgPSBmdW5jdGlvbiBfZ2V0Um9vdEVsKCkge1xuICAgIHZhciBmb3JtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keSA+IGZvcm0nKTtcbiAgICByZXR1cm4gZm9ybSAmJiBmb3JtLmdldEF0dHJpYnV0ZSgnZGF0YS1hZmZpeGVkJykgPT09IG51bGwgPyBmb3JtIDogZG9jdW1lbnQuYm9keTtcbiAgfTtcblxuICAvKipcbiAgICogT24gcmVzaXplLCB1cGRhdGUgdGhlIHBvc2l0aW9uLlxuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5fb25SZXNpemUgPSBmdW5jdGlvbiBfb25SZXNpemUoKSB7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgd2luZG93IHNjcm9sbHMsIGVuc3VyZSB0aGUgcHJvcGVyIHBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyLlxuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5fb25TY3JvbGwgPSBmdW5jdGlvbiBfb25TY3JvbGwoKSB7XG4gICAgdGhpcy5fdXBkYXRlRGVib3VuY2VkKCk7XG4gIH07XG5cbiAgcmV0dXJuIEFmZml4O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBBZmZpeDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWZmaXguanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgdmFyIGFYU3BhbiA9IGEubGVmdCArIGEud2lkdGg7XG4gIHZhciBhWVNwYW4gPSBhLnRvcCArIGEuaGVpZ2h0O1xuICB2YXIgYlhTcGFuID0gYi5sZWZ0ICsgYi53aWR0aDtcbiAgdmFyIGJZU3BhbiA9IGIudG9wICsgYi5oZWlnaHQ7XG5cbiAgaWYgKGFYU3BhbiA8PSBiLmxlZnQpIHJldHVybiAnbGVmdCc7IC8vIGEgaXMgZnVsbHkgbGVmdCBvZiBiXG4gIGlmIChhLmxlZnQgPj0gYlhTcGFuKSByZXR1cm4gJ3JpZ2h0JzsgLy8gYSBpcyBmdWxseSByaWdodCBvZiBiXG4gIGlmIChhWVNwYW4gPD0gYi50b3ApIHJldHVybiAnYWJvdmUnOyAvLyBhIGlzIGZ1bGx5IGFib3ZlIGJcbiAgaWYgKGEudG9wID49IGJZU3BhbikgcmV0dXJuICdiZWxvdyc7IC8vIGEgaXMgZnVsbHkgYmVsb3cgYlxuXG4gIHJldHVybiAnb3ZlcmxhcCc7IC8vIGJveGVzIG92ZXJsYXBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAjIEJveCBQb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEhvdyBpcyBvbmUgZWxlbWVudCBwb3NpdGlvbmVkIHJlbGF0aXZlIHRvIGFub3RoZXI/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGJveFBvc2l0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHt3aWR0aDogMTAwLCBoZWlnaHQ6IDMwMCwgbGVmdDogMCwgdG9wOiAwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB7d2lkdGg6IDIwMCwgaGVpZ2h0OiA1MCwgbGVmdDogMTAwLCB0b3A6IDQwfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgaGVscGVycy9wb3NpdGlvbi9ib3gtcG9zaXRpb24uanNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib3gtcG9zaXRpb24uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWF0Y2hlcyA9IHJlcXVpcmUoJy4vbWF0Y2hlcycpO1xuXG52YXIgX21hdGNoZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0Y2hlcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldFBhcmVudChwYXJlbnQsIHF1ZXJ5LCBsaW1pdEVsKSB7XG5cbiAgbGltaXRFbCA9IGxpbWl0RWwgaW5zdGFuY2VvZiBBcnJheSA/IGxpbWl0RWwgOiBbbGltaXRFbCB8fCBkb2N1bWVudC5ib2R5XTtcblxuICB3aGlsZSAocGFyZW50KSB7XG5cbiAgICBpZiAoKDAsIF9tYXRjaGVzMi5kZWZhdWx0KShwYXJlbnQsIHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG5cbiAgICBpZiAobGltaXRFbC5pbmRleE9mKHBhcmVudCkgIT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IC8qKlxuICAgKiAjIEdldCBQYXJlbnRcbiAgICogU2VlIGlmIGFuIGVsZW1lbnQgaGFzIGFub3RoZXIgZWxlbWVudCBmb3IgYSBwYXJlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeVxuICAgKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGxpbWl0RWwgVGhlIGxhc3QgZWxlbWVudCB3ZSBzaG91bGQgY2hlY2suXG4gICAqIEByZXR1cm4ge0Jvb2xlYW58RWxlbWVudH1cbiAgICpcbiAgICogQG1vZHVsZSBoZWxwZXJzL3RyYXZlcnNhbC9nZXQtcGFyZW50LmpzXG4gICAqL1xuXG5leHBvcnRzLmRlZmF1bHQgPSBnZXRQYXJlbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1wYXJlbnQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBIYXMgUGFyZW50XG4gKiBTZWUgaWYgYW4gZWxlbWVudCBoYXMgYW5vdGhlciBlbGVtZW50IGZvciBhIHBhcmVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNoaWxkXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBvc3NpYmxlUGFyZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICpcbiAqIEBtb2R1bGUgaGVscGVycy90cmF2ZXJzYWwvaGFzLXBhcmVudC5qc1xuICovXG5mdW5jdGlvbiBoYXNQYXJlbnQoY2hpbGQsIHBvc3NpYmxlUGFyZW50KSB7XG5cbiAgdmFyIHBhcmVudCA9IGNoaWxkLnBhcmVudE5vZGU7XG5cbiAgd2hpbGUgKHBhcmVudCkge1xuXG4gICAgaWYgKHBhcmVudCA9PT0gcG9zc2libGVQYXJlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBoYXNQYXJlbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzLXBhcmVudC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBNYXRjaGVzXG4gKiBTZWUgaWYgYW4gZWxlbWVudCBtYXRjaGVzIGEgcXVlcnkgc2VsZWN0b3IuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICpcbiAqIEBtb2R1bGUgaGVscGVycy90cmF2ZXJzYWwvbWF0Y2hlcy5qc1xuICovXG52YXIgdmVuZG9yTWF0Y2ggPSB0eXBlb2YgRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgKEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUub01hdGNoZXNTZWxlY3Rvcik7XG5cbmZ1bmN0aW9uIG1hdGNoZXMoZWwsIHF1ZXJ5KSB7XG5cbiAgaWYgKHZlbmRvck1hdGNoKSByZXR1cm4gdmVuZG9yTWF0Y2guY2FsbChlbCwgcXVlcnkpO1xuXG4gIHZhciBub2RlcyA9IGVsLnBhcmVudE5vZGUgPyBlbC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpIDogW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2Rlc1tpXSA9PT0gZWwpIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBtYXRjaGVzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRjaGVzLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgRGVib3VuY2VcbiAqIERlYm91bmNlIGEgZnVuY3Rpb24gY2FsbFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAqIEBwYXJhbSB7SW50ZWdlcn0gZGVsYXlcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdXRpbC9kZWJvdW5jZS5qc1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCBkZWxheSkge1xuXG4gIHZhciB0aW1lciA9IHZvaWQgMDtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIGlmICh0aW1lcikgd2luZG93LmNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgdGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0sIGRlbGF5KTtcbiAgfTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZGVib3VuY2U7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVib3VuY2UuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgRWFjaFxuICogQXBwbHkgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBhIGxpc3Qgb2YgYW55IGtpbmQ6IEFycmF5LCBOb2RlTGlzdCwgSFRNTENvbGxlY3Rpb24gb3IgT2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8Tm9kZUxpc3R8SFRNTENvbGxlY3Rpb258T2JqZWN0fSBsaXN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICpcbiAqIEBleGFtcGxlXG4gKiBlYWNoKFtdLCBjYWxsYmFjayk7XG4gKiBlYWNoKGVsLmNoaWxkcmVuLCBjYWxsYmFjayk7XG4gKiBlYWNoKGVsLmNoaWxkTm9kZXMsIGNhbGxiYWNrKTtcbiAqIGVhY2goe30sIGNhbGxiYWNrKTtcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdXRpbC9lYWNoLmpzXG4gKi9cbmZ1bmN0aW9uIGVhY2gobGlzdCwgY2IpIHtcblxuICBpZiAoIWxpc3QpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52b2tlIGBlYWNoYCB3aXRob3V0IGEgY2FsbGJhY2shJyk7XG4gIH1cblxuICB2YXIgaSA9IDA7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcblxuICAvLyBPYmplY3RcbiAgaWYgKGxlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChpIGluIGxpc3QpIHtcbiAgICAgIGlmIChpICE9PSAncHJvdG90eXBlJyAmJiBsaXN0Lmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGNiKGksIGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBBcnJheS1saWtlXG4gIGVsc2Uge1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjYihsaXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGVhY2g7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVhY2guanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgVHJpbVxuICogVHJpbSB3aGl0ZXNwYWNlIG9uIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdXRpbC90cmltLmpzXG4gKi9cblxudmFyIHRyaW1SRSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHRyaW1SRSwgJycpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0cmltO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmltLmpzLm1hcFxuIl19"}