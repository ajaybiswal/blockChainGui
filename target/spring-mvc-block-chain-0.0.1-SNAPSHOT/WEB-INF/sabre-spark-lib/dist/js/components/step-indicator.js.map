{"version":3,"sources":["js/dist/components/node_modules/browser-pack/_prelude.js","js/dist/components/js/dist/components/base.js","js/dist/components/js/dist/components/step-indicator.js","js/dist/components/js/dist/helpers/dom/add-class.js","js/dist/components/js/dist/helpers/dom/has-class.js","js/dist/components/js/dist/helpers/dom/remove-class.js","js/dist/components/js/dist/helpers/traversal/get-parent.js","js/dist/components/js/dist/helpers/traversal/matches.js","js/dist/components/js/dist/helpers/util/debounce.js","js/dist/components/js/dist/helpers/util/each.js","js/dist/components/js/dist/helpers/util/trim.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"step-indicator.js","sourcesContent":["(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _each = require('../helpers/util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * # Base Component\n                                                                                                                                                           * The base class for Spark JS components. This class should never be\n                                                                                                                                                           * instantiated directly.\n                                                                                                                                                           *\n                                                                                                                                                           * @param {Element} el\n                                                                                                                                                           * @param {Object} params\n                                                                                                                                                           *\n                                                                                                                                                           * @module components/base.js\n                                                                                                                                                           */\n\nvar noop = function noop() {};\n\nvar Base = function () {\n\n  /**\n   * Set parameters and cache elements.\n   */\n  function Base(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Base);\n\n    if (params.elRequired && !el) {\n      return;\n    }\n\n    this.setParams(this.defaults || {}, true);\n    this.setParams(params);\n    (this._cacheElements || noop).call(this, el, params);\n    (this._parseParams || noop).call(this);\n  }\n\n  /**\n   * Remove the component from the DOM and prepare for garbage collection by dereferencing values.\n   * @param {Boolean} leaveElement Leave the element intact.\n   */\n\n\n  Base.prototype.remove = function remove(leaveElement) {\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    if (!leaveElement && this.el && this.el.parentNode) {\n      this.el.parentNode.removeChild(this.el);\n    }\n\n    this.unsetParams(this.defaults);\n\n    return this;\n  };\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   * @param {Object} params Optional\n   */\n\n\n  Base.prototype.update = function update(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    (this._cacheElements || noop).call(this, el || this.el, params);\n    (this._parseParams || noop).call(this);\n\n    if (this._addEventListeners) {\n      this._addEventListeners();\n    }\n\n    return this;\n  };\n\n  /**\n   * Set a hash of parameters if they're whitelisted or we're told to force the set.\n   * This is used to set initial values as well as set passed parameters.\n   * @param {Object} params\n   * @param {Boolean} force Force setting even if the param is not whitelisted.\n   */\n\n\n  Base.prototype.setParams = function setParams(params, force) {\n    var _this = this;\n\n    (0, _each2.default)(params, function (k, v) {\n      if (_this._whitelistedParams.indexOf(k) !== -1 || force) {\n        _this[k] = v;\n      }\n    });\n\n    return this;\n  };\n\n  /**\n   * Unset all parameters.\n   * @param {Array|Object} keys\n   * @param {Object} scope The object to unset the params from. Defaults to `this`.\n   */\n\n\n  Base.prototype.unsetParams = function unsetParams(keys, scope) {\n\n    keys = keys instanceof Array ? keys : Object.keys(keys);\n    scope = scope || this;\n    (0, _each2.default)(keys, function (k) {\n      delete scope[k];\n    });\n\n    return this;\n  };\n\n  return Base;\n}();\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nBase.prototype._whitelistedParams = [];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nBase.prototype.defaults = {};\n\nexports.default = Base;\nmodule.exports = exports['default'];\n//# sourceMappingURL=base.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _base = require('./base');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _addClass = require('../helpers/dom/add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _removeClass = require('../helpers/dom/remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nvar _hasClass = require('../helpers/dom/has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _getParent = require('../helpers/traversal/get-parent');\n\nvar _getParent2 = _interopRequireDefault(_getParent);\n\nvar _debounce = require('../helpers/util/debounce');\n\nvar _debounce2 = _interopRequireDefault(_debounce);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * # Step Indicator\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Set of indicators represent different steps\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @example\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * new StepIndicator(el, params);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module components/step-indicator.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\nvar noop = function noop() {};\n\nvar StepIndicator = function (_BaseComponent) {\n  _inherits(StepIndicator, _BaseComponent);\n\n  /**\n   * StepIndicator constructor.\n   * @param {Element} el\n   * @param {Object} params\n   */\n  function StepIndicator(el) {\n    var _this;\n\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, StepIndicator);\n\n    if (!(_this = _possibleConstructorReturn(this, _BaseComponent.call(this, el, params)), _this)) {\n      return _possibleConstructorReturn(_this);\n    }\n\n    _this._bindEventListenerCallbacks();\n    _this._addEventListeners();\n    _this._calculateStyle();\n    return _possibleConstructorReturn(_this);\n  }\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   */\n\n\n  StepIndicator.prototype.update = function update(el) {\n\n    this._removeEventListeners();\n    this._cacheElements(el || this.el);\n    this._parseParams();\n    this._addEventListeners();\n    this._calculateStyle();\n\n    return this;\n  };\n\n  /**\n   * Store a reference to the element.\n   * @param {Element} el\n   */\n\n\n  StepIndicator.prototype._cacheElements = function _cacheElements(el) {\n    this.el = el;\n    this.containerEl = this.containerEl || el.parentNode;\n    this._body = this.el.querySelector('.spark-step-indicator__body');\n    this._list = this.el.querySelector('.spark-step-indicator__list');\n    this._items = this.el.querySelectorAll('.spark-step-indicator__item');\n  };\n\n  /**\n   * Parse parameters from the element.\n   */\n\n\n  StepIndicator.prototype._parseParams = function _parseParams() {\n    this.type = this.type !== null ? this.type : this.el.attributes['data-type'] && this.el.attributes['data-type'].value;\n    this.header = this.header !== null ? this.header : this.el.attributes['data-header'] && true;\n    this.subtitle = this.subtitle !== null ? this.subtitle : this.el.attributes['data-subtitle'] && true;\n    this.dropdownLabel = this.dropdownLabel !== null ? this.dropdownLabel : this.el.attributes['data-dropdownLabel'] && this.el.attributes['data-dropdownLabel'].value;\n\n    if (!this.dropdownLabel) {\n      this.dropdownLabel = 'Select a Step';\n    }\n  };\n\n  /**\n   * Create bound versions of event listener callbacks and store them.\n   * Otherwise we can't unbind from these events later because the\n   * function signatures won't match.\n   */\n\n\n  StepIndicator.prototype._bindEventListenerCallbacks = function _bindEventListenerCallbacks() {\n    this._onResizeBound = this._onResize.bind(this);\n    this._onLoadBound = this._onLoad.bind(this);\n    this._onVisibleBound = this._onVisible.bind(this);\n    this._toggleDropdownBound = this._toggleDropdown.bind(this);\n    this._onKeydownBound = (0, _debounce2.default)(this._onKeydown.bind(this), 100);\n  };\n\n  /**\n   * Add event listeners for DOM events.\n   */\n\n\n  StepIndicator.prototype._addEventListeners = function _addEventListeners() {\n    window.addEventListener('resize', this._onResizeBound);\n    document.addEventListener('spark.visible-children', this._onVisibleBound, true);\n    window.addEventListener('load', this._onLoadBound);\n    this.el.addEventListener('keydown', this._onKeydownBound);\n    document.addEventListener('spark.step-indicator', this._toggleDropdownBound, true);\n  };\n\n  /**\n   * Remove event listeners for DOM events..\n   */\n\n\n  StepIndicator.prototype._removeEventListeners = function _removeEventListeners() {\n    window.removeEventListener('resize', this._onResizeBound);\n    document.removeEventListener('spark.visible-children', this._onVisibleBound, true);\n    document.removeEventListener('click', this._toggleDropdownBound);\n    window.removeEventListener('load', this._onLoadBound);\n    this.el.removeEventListener('keydown', this._onKeydownBound);\n    document.removeEventListener('spark.step-indicator', this._toggleDropdownBound, true);\n  };\n\n  /**\n   * Change selected step state into incomplete\n   * @param {Int} index of selected step\n   */\n\n\n  StepIndicator.prototype._resetStepState = function _resetStepState(stepIndex) {\n    if (stepIndex < 0 || stepIndex >= this._items.length) {\n      return;\n    }\n\n    (0, _removeClass2.default)(this._items[stepIndex], ['spark-step-indicator__item--completed', 'spark-step-indicator__item--current', 'spark-step-indicator__item--disabled']);\n    this._items[stepIndex].removeAttribute('tabindex');\n  };\n\n  /**\n   * Set selected step state: completed/current/disabled/incomplete\n   * For current step, will remove current step from other steps\n   * @param {Int} index of selected step\n   * @param {String} state to be set\n   */\n\n\n  StepIndicator.prototype.setStepState = function setStepState(stepIndex, state) {\n    if (stepIndex < 0 || stepIndex >= this._items.length) {\n      return this;\n    }\n    switch (state) {\n      case 'completed':\n        this._resetStepState(stepIndex);\n        (0, _addClass2.default)(this._items[stepIndex], 'spark-step-indicator__item--completed');\n        break;\n      case 'current':\n        var currentStep = this._list.querySelector('.spark-step-indicator__item--current');\n        (0, _removeClass2.default)(currentStep, 'spark-step-indicator__item--current');\n        (0, _addClass2.default)(this._items[stepIndex], 'spark-step-indicator__item--current');\n        break;\n      case 'disabled':\n        this._resetStepState(stepIndex);\n        (0, _addClass2.default)(this._items[stepIndex], 'spark-step-indicator__item--disabled');\n        this._items[stepIndex].setAttribute('tabindex', '-1');\n        break;\n      case 'incomplete':\n        this._resetStepState(stepIndex);\n        break;\n    }\n    this._calculateStyle();\n    return this;\n  };\n\n  /**\n   * When the Enter key is pressed toggle the dropdown or update the selection if in dropdown mode\n   * When the Tab key is pressed, navigate to the next element by default otherwise collapse the dropdown\n   * @param {Object} Reference of DOM obj\n   * @param {Object} Event of click\n   */\n\n\n  StepIndicator.prototype._onKeydown = function _onKeydown(e) {\n    if (!(0, _getParent2.default)(e.target, '.spark-step-indicator__list', this.el) && !(0, _getParent2.default)(e.target, '.spark-step-indicator__body--dropdown', this.el)) {\n      return;\n    }\n\n    var code = e.keyCode || e.which;\n\n    // Enter Key\n    if (code === 13) {\n      if ((0, _hasClass2.default)(e.target, 'spark-step-indicator__item--dropdown__header')) {\n        e.preventDefault();\n        this._toggleDropdown(e);\n      }\n    }\n\n    // Tab Key - Check if focus has now shifted outside of the Step Indicator Dropdown\n    if (code === 9) {\n      (0, _hasClass2.default)(document.activeElement, 'spark-step-indicator__item') === false && this._dropdownExpand === true ? this._toggleDropdown(e) : null;\n    }\n  };\n\n  /**\n   * Provide a method to bind click callback function to certain step.\n   * @param {Array} a set of step indices represent the target of callback\n   * @param {Function} callback function\n   */\n\n\n  StepIndicator.prototype.bindStepClickCallback = function bindStepClickCallback(indexArr, callback) {\n    callback = callback || noop;\n    for (var i = 0; i < indexArr.length; i++) {\n      this._items[indexArr[i]].addEventListener('click', callback);\n    }\n    return this;\n  };\n\n  /**\n   * Remove click callback from steps\n   * @param {Array} a set of step indices represent the target of callback\n   * @param {Function} callback function\n   *\n   */\n\n\n  StepIndicator.prototype.removeStepClickCallback = function removeStepClickCallback(indexArr, callback) {\n    callback = callback || noop;\n    for (var i = 0; i < indexArr.length; i++) {\n      this._items[indexArr[i]].removeEventListener('click', callback);\n    }\n    return this;\n  };\n\n  /**\n   * Work for _calculateStyle.\n   * Comparing the width of list and total items, including padding\n   * @return {Boolean}\n   */\n\n\n  StepIndicator.prototype._isOverWidth = function _isOverWidth() {\n    var listWidth = this._list.offsetWidth;\n    var itemTotalWidth = this._listPaddingTotal;\n    for (var i = 0; i < this._items.length; i++) {\n      itemTotalWidth += this._items[i].offsetWidth;\n    }\n    if (listWidth < itemTotalWidth) {\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * Calcuate different style based settings\n   */\n\n\n  StepIndicator.prototype._calculateStyle = function _calculateStyle() {\n    if (!this.header) {\n      var titleEl = this.el.querySelector('.spark-step-indicator__title');\n      titleEl.style.display = 'none';\n      (0, _addClass2.default)(this._body, 'spark-step-indicator__body--no-border');\n    }\n    if (!this.subtitle) {\n      var subtitleEl = this.el.querySelector('.spark-step-indicator__subtitle');\n      subtitleEl.style.display = 'none';\n    }\n    // Remove special DOM and Class of dropdown variation\n    this._switchFromDropdown();\n    switch (this.type) {\n      case 'standard-dropdown':\n        this._calculateRespStyle();\n        break;\n      case 'large':\n        this._calculateLargeStyle();\n        break;\n      case 'condensed':\n        this._calculateCondensedStyle();\n        break;\n      case 'dropdown':\n        this._calculateDropdownStyle();\n        break;\n      default:\n        this._calculateStandardStyle();\n    }\n    // Work for IE11, detect IE11 via userAgent\n    // userAgent: Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv 11.0) like Gecko\n    var isIE11 = !!(navigator.userAgent.match(/Trident/) && navigator.userAgent.match(/rv[ :]11/));\n    if (isIE11) {\n      this._addItemWidth();\n    }\n  };\n\n  /**\n   * For IE11 ONLY, Add width: 100% to work around IE11 bug\n   * IE11 will have incorrect position with flex-grow max-width and justify-content when items hit max-width\n   * Sometimes after calculating, even itemTotalWidth is less 1px than listWidth,\n   * it also means items are fit in the list, not hit the max-width\n   * So add 2px to list width when comparing to avoid this.\n   */\n\n\n  StepIndicator.prototype._addItemWidth = function _addItemWidth() {\n    if (!(0, _hasClass2.default)(this._list, 'spark-step-indicator__list--condensed') && !(0, _hasClass2.default)(this._body, 'spark-step-indicator__body--dropdown')) {\n      var listWidth = this._list.offsetWidth;\n      var itemTotalWidth = this._listPaddingTotal;\n      for (var i = 0; i < this._items.length; i++) {\n        itemTotalWidth += this._items[i].offsetWidth;\n      }\n      if (listWidth - itemTotalWidth > 2) {\n        this._switchWidthForIe11(0, true);\n      } else {\n        this._switchWidthForIe11(0, false);\n      }\n    } else {\n      this._switchWidthForIe11(0, false);\n    }\n  };\n\n  /**\n   * Switch spark-step-indicator__item style width: 100% to work around IE11 bug\n   * @param {Number} start index of step\n   * @param {Boolean} whether add width: 100%\n   */\n\n\n  StepIndicator.prototype._switchWidthForIe11 = function _switchWidthForIe11(index, val) {\n    for (var i = index; i < this._items.length; i++) {\n      this._items[i].style.width = val ? '100%' : '';\n    }\n  };\n\n  /**\n   * Fix on large variation\n   * Calculate node and list length remove connect line of each end\n   * Sometimes after calculating, even itemTotalWidth is bigger 1px than listWidth,\n   * it also means items are fit in the list, not over width.\n   * So add 2px to list width when comparing to avoid this.\n   * Dependency of _calculateCondensedStyle() and _calculateStandardStyle()\n   *\n   */\n\n\n  StepIndicator.prototype._calculateLargeStyle = function _calculateLargeStyle() {\n    this._list.style['flex-wrap'] = 'wrap';\n    var listWidth = this._list.offsetWidth;\n    var itemTotalWidth = this._listPaddingTotal;\n    for (var i = 0; i < this._items.length; i++) {\n      (0, _removeClass2.default)(this._items[i], 'noline');\n      itemTotalWidth += this._items[i].offsetWidth;\n\n      if (listWidth < itemTotalWidth && i > 0) {\n        (0, _addClass2.default)(this._items[i - 1], 'noline');\n        itemTotalWidth = this._items[i].offsetWidth + this._listPaddingTotal;\n      }\n    }\n  };\n\n  /**\n   * Fix on condensed variation\n   * Same as fix large variation except CSS class\n   */\n\n\n  StepIndicator.prototype._calculateCondensedStyle = function _calculateCondensedStyle() {\n    (0, _addClass2.default)(this._list, 'spark-step-indicator__list--condensed');\n    this._calculateLargeStyle();\n  };\n\n  /**\n   * Fix on dropdown variation\n   */\n\n\n  StepIndicator.prototype._calculateDropdownStyle = function _calculateDropdownStyle() {\n    this._switchToDropdown();\n  };\n\n  /**\n   * Change only between large and condensed variation\n   * no dropdown variation\n   */\n\n\n  StepIndicator.prototype._calculateStandardStyle = function _calculateStandardStyle() {\n    this._list.style.visibility = 'hidden';\n    for (var i = 0; i < this._items.length; i++) {\n      (0, _removeClass2.default)(this._items[i], 'noline');\n    }\n    (0, _removeClass2.default)(this._list, 'spark-step-indicator__list--condensed');\n    if (this._isOverWidth()) {\n      (0, _addClass2.default)(this._list, 'spark-step-indicator__list--condensed');\n      this._calculateLargeStyle();\n    }\n    this._list.style.visibility = 'visible';\n  };\n\n  /**\n   * Make list invisible and change it into large variation at first.\n   * Switch variation from top to bottom to find the fit one\n   */\n\n\n  StepIndicator.prototype._calculateRespStyle = function _calculateRespStyle() {\n    this._list.style.visibility = 'hidden';\n    (0, _removeClass2.default)(this._list, 'spark-step-indicator__list--condensed');\n    if (this._isOverWidth()) {\n      (0, _addClass2.default)(this._list, 'spark-step-indicator__list--condensed');\n      if (this._isOverWidth()) {\n        (0, _removeClass2.default)(this._list, 'spark-step-indicator__list--condensed');\n        this._switchToDropdown();\n      }\n    }\n    this._list.style.visibility = 'visible';\n  };\n\n  /**\n   * Create header element for dropdown variation\n   * Try to find the current step of indicator and show it on the header\n   * if not found, show the first step\n   * @return {Object} header element of dropdown variation\n   */\n\n\n  StepIndicator.prototype._createDropdownHeader = function _createDropdownHeader() {\n    var el = document.createElement('a');\n    var currentStep = this._list.querySelector('.spark-step-indicator__item--current');\n    // Can not find current step\n    if (!currentStep) {\n      currentStep = this._items[0];\n    }\n\n    // Set ARIA roles and attributes\n    el.setAttribute('role', 'button');\n    el.setAttribute('aria-expanded', 'false');\n    var listID = this._list.getAttribute('id') !== null && this._list.getAttribute('id') !== '' ? this._list.getAttribute('id') : '';\n    el.setAttribute('aria-controls', listID);\n\n    el.innerHTML = currentStep.innerHTML;\n    el.innerHTML += '<span class=\"spark-step-indicator__notice\">' + this.dropdownLabel + '</span>';\n\n    // Create label element like '2 of 7'\n    var stepNotice = document.createElement('span');\n    var currentIndex = Array.prototype.indexOf.call(this._items, currentStep);\n    stepNotice.innerHTML = currentIndex + 1 + ' of ' + this._items.length;\n    stepNotice.className = 'spark-step-indicator__label--dropdown';\n\n    el.appendChild(stepNotice);\n    el.className = currentStep.className;\n    el.setAttribute('tabindex', '0');\n\n    (0, _addClass2.default)(el, 'spark-step-indicator__item--dropdown__header');\n    this._dropdownHeader = el;\n  };\n\n  /**\n   * Some extra event binder and DOM of dropdown variation need to be set\n   */\n\n\n  StepIndicator.prototype._switchToDropdown = function _switchToDropdown() {\n    (0, _addClass2.default)(this._body, 'spark-step-indicator__body--dropdown');\n    this._createDropdownHeader();\n    this._list.parentNode.insertBefore(this._dropdownHeader, this._list);\n    document.removeEventListener('click', this._toggleDropdownBound);\n    document.addEventListener('click', this._toggleDropdownBound);\n    (0, _addClass2.default)(this._list, 'collapse');\n\n    for (var i = 0; i < this._items.length; i++) {\n      if (!(0, _hasClass2.default)(this._items[i], 'spark-step-indicator__item--disabled')) {\n        this._items[i].setAttribute('tabindex', '-1');\n      }\n    }\n  };\n\n  /**\n   * Remove extra event and DOM when switch variation from dropdown\n   */\n\n\n  StepIndicator.prototype._switchFromDropdown = function _switchFromDropdown() {\n    (0, _removeClass2.default)(this._body, 'spark-step-indicator__body--dropdown');\n    var header = this._list.parentNode.querySelector('.spark-step-indicator__item--dropdown__header');\n    document.removeEventListener('click', this._toggleDropdownBound);\n    if (header) {\n      this._list.parentNode.removeChild(header);\n    }\n    (0, _removeClass2.default)(this._list, 'collapse');\n\n    for (var i = 0; i < this._items.length; i++) {\n      if (!(0, _hasClass2.default)(this._items[i], 'spark-step-indicator__item--disabled')) {\n        this._items[i].removeAttribute('tabindex');\n      }\n    }\n  };\n\n  /**\n   * Allow programmatic toggling of Dropdown version of Step Indicator.\n   * This becomes desirable particularly in the case of single page applications\n   */\n\n\n  StepIndicator.prototype.toggle = function toggle() {\n    if (this._dropdownHeader) {\n      var e = document.createEvent('Event');\n      e.initEvent('spark.step-indicator', true, true);\n      this._dropdownHeader.dispatchEvent(e);\n    }\n  };\n\n  /**\n   * Toggle collapse/expand state of step list in dropdown variation\n   * If there is a scroll in dropdown variation, scroll to 'current' node\n   * @param {Object} Reference of DOM obj\n   * @param {Object} Event of click\n   */\n\n\n  StepIndicator.prototype._toggleDropdown = function _toggleDropdown(e) {\n    var target = e.target || e.srcElement;\n    if (this._dropdownHeader.contains(target)) {\n      if (!this._dropdownExpand) {\n        (0, _removeClass2.default)(this._list, 'collapse');\n        (0, _addClass2.default)(this._dropdownHeader, 'expand');\n        this._dropdownExpand = true;\n        this._dropdownHeader.setAttribute('aria-expanded', 'true');\n\n        for (var i = 0; i < this._items.length; i++) {\n          if (!(0, _hasClass2.default)(this._items[i], 'spark-step-indicator__item--disabled')) {\n            this._items[i].removeAttribute('tabindex');\n          }\n        }\n      } else {\n        (0, _addClass2.default)(this._list, 'collapse');\n        (0, _removeClass2.default)(this._dropdownHeader, 'expand');\n        this._dropdownExpand = false;\n        this._dropdownHeader.setAttribute('aria-expanded', 'false');\n\n        for (var _i = 0; _i < this._items.length; _i++) {\n          if (!(0, _hasClass2.default)(this._items[_i], 'spark-step-indicator__item--disabled')) {\n            this._items[_i].setAttribute('tabindex', '-1');\n          }\n        }\n      }\n    } else {\n      (0, _addClass2.default)(this._list, 'collapse');\n      (0, _removeClass2.default)(this._dropdownHeader, 'expand');\n      this._dropdownExpand = false;\n      this._dropdownHeader.setAttribute('aria-expanded', 'false');\n\n      for (var _i2 = 0; _i2 < this._items.length; _i2++) {\n        if (!(0, _hasClass2.default)(this._items[_i2], 'spark-step-indicator__item--disabled')) {\n          this._items[_i2].setAttribute('tabindex', '-1');\n        }\n      }\n    }\n    if (this._list.offsetHeight > 0) {\n      var scrollMove = 0;\n      for (var _i3 = 0; _i3 < this._items.length; _i3++) {\n        if ((0, _hasClass2.default)(this._items[_i3], 'spark-step-indicator__item--current')) {\n          this._list.scrollTop = scrollMove;\n          break;\n        }\n        scrollMove += this._items[_i3].offsetHeight;\n      }\n    }\n  };\n\n  /**\n   * When the window finish loading\n   */\n\n\n  StepIndicator.prototype._onLoad = function _onLoad() {\n    this._checkPadding();\n    this._calculateStyle();\n  };\n\n  /**\n   * When the window is resized, base on params make some reponsive change.\n   */\n\n\n  StepIndicator.prototype._onResize = function _onResize() {\n    this._checkPadding();\n    this._calculateStyle();\n  };\n\n  /**\n   * Padding is applied to condensed step indicators but not large step indicators.\n   * Therefore as large indicators transition to condensed ones and vice versa, verify\n   * the padding values in order to properly calculate positioning of divider line classes\n   */\n\n\n  StepIndicator.prototype._checkPadding = function _checkPadding() {\n    // Cache list left + right padding for width calculating\n    var listStyles = getComputedStyle(this._list);\n    var listPaddingLeft = parseInt(listStyles.getPropertyValue('padding-left'), 10);\n    var listPaddingRight = parseInt(listStyles.getPropertyValue('padding-right'), 10);\n    this._listPaddingTotal = listPaddingLeft + listPaddingRight;\n  };\n\n  /**\n   * When a parent container shows its children and our element\n   * is inside of it, resize\n   * @param  {Object} e\n   */\n\n\n  StepIndicator.prototype._onVisible = function _onVisible(e) {\n    if (e.target.contains(this.el)) {\n      window.setTimeout(function () {\n        this._calculateStyle();\n      }.bind(this), 0);\n    }\n  };\n\n  return StepIndicator;\n}(_base2.default);\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nStepIndicator.prototype._whitelistedParams = ['type', 'header', 'subtitle', 'dropdownLabel'];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nStepIndicator.prototype.defaults = {\n  el: null,\n  containerEl: null,\n  header: null,\n  subtitle: null,\n  dropdownLabel: null,\n  type: null,\n  _body: null,\n  _list: null,\n  _listPaddingTotal: 0,\n  _dropdownExpand: false,\n  _dropdownHeader: null,\n  _items: null,\n  _onResizeBound: null,\n  _onVisibleBound: null\n};\n\nexports.default = StepIndicator;\nmodule.exports = exports['default'];\n//# sourceMappingURL=step-indicator.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * # Add Class\n * Add a class on an element.\n *\n * @param {Element|Array} el An element or array of elements to update.\n * @param {String} name\n * @return {Element}\n *\n * @module helpers/dom/add-class.js\n */\n\nvar ws = /\\s+/;\nvar cleanup = /\\s{2,}/g;\n\nfunction addClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) {\n      el.classList.add(name[0]);\n    }\n    return el;\n  }\n\n  var toAdd = [];\n  var i = 0;\n  var l = name.length;\n  var item = void 0;\n  var clsName = typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '';\n\n  // see if we have anything to add\n  for (; i < l; i++) {\n    item = name[i];\n    if (item && !(0, _hasClass2.default)(clsName, item)) {\n      toAdd.push(item);\n    }\n  }\n\n  if (toAdd.length) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = addClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=add-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * # Has Class\n * See if an element has a class.\n *\n * @param {Element|String} el\n * @param {String} name\n * @return {Boolean}\n *\n * @module helpers/dom/has-class.js\n */\nfunction hasClass(el, name) {\n  var cName = ((typeof el === 'undefined' ? 'undefined' : _typeof(el)) === 'object' ? el.className || el.getAttribute && el.getAttribute('class') || '' : el || '').replace(/[\\t\\r\\n\\f]/g, ' ');\n  return (' ' + cName + ' ').indexOf(' ' + name + ' ') !== -1;\n}\n\nexports.default = hasClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=has-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ws = /\\s+/; /**\n                 * # Remove Class\n                 * Remove a class on an element.\n                 *\n                 * @param {Element|Array} el An element or array of elements to update.\n                 * @param {String} name\n                 * @return {Element}\n                 *\n                 * @module helpers/dom/remove-class.js\n                 */\n\nvar cleanup = /\\s{2,}/g;\n\nfunction removeClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) el.classList.remove(name[0]);\n    return el;\n  }\n\n  // store two copies\n  var clsName = ' ' + (typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '') + ' ';\n  var result = clsName;\n  var current = void 0;\n  var start = void 0;\n  for (var i = 0, l = name.length; i < l; i++) {\n    current = name[i];\n    start = current ? result.indexOf(' ' + current + ' ') : -1;\n    if (start !== -1) {\n      start += 1;\n      result = result.slice(0, start) + result.slice(start + current.length);\n    }\n  }\n\n  // only write if modified\n  if (clsName !== result) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)(result.replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)(result.replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = removeClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=remove-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _matches = require('./matches');\n\nvar _matches2 = _interopRequireDefault(_matches);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getParent(parent, query, limitEl) {\n\n  limitEl = limitEl instanceof Array ? limitEl : [limitEl || document.body];\n\n  while (parent) {\n\n    if ((0, _matches2.default)(parent, query)) {\n      return parent;\n    }\n\n    if (limitEl.indexOf(parent) !== -1) {\n      return false;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return false;\n} /**\n   * # Get Parent\n   * See if an element has another element for a parent.\n   *\n   * @param {Element} parent\n   * @param {String} query\n   * @param {Array|Element} limitEl The last element we should check.\n   * @return {Boolean|Element}\n   *\n   * @module helpers/traversal/get-parent.js\n   */\n\nexports.default = getParent;\nmodule.exports = exports['default'];\n//# sourceMappingURL=get-parent.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Matches\n * See if an element matches a query selector.\n *\n * @param {Element} el\n * @param {String} query\n * @return {Boolean}\n *\n * @module helpers/traversal/matches.js\n */\nvar vendorMatch = typeof Element !== 'undefined' && (Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector);\n\nfunction matches(el, query) {\n\n  if (vendorMatch) return vendorMatch.call(el, query);\n\n  var nodes = el.parentNode ? el.parentNode.querySelectorAll(query) : [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i] === el) return true;\n  }\n\n  return false;\n}\n\nexports.default = matches;\nmodule.exports = exports['default'];\n//# sourceMappingURL=matches.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Debounce\n * Debounce a function call\n *\n * @param {Function} func\n * @param {Integer} delay\n *\n * @module helpers/util/debounce.js\n */\nfunction debounce(func, delay) {\n\n  var timer = void 0;\n\n  return function () {\n    var args = arguments;\n    if (timer) window.clearTimeout(timer);\n    timer = window.setTimeout(function () {\n      func.apply(this, args);\n    }, delay);\n  };\n}\n\nexports.default = debounce;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=debounce.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Each\n * Apply a callback function to a list of any kind: Array, NodeList, HTMLCollection or Object.\n *\n * @param {Array|NodeList|HTMLCollection|Object} list\n * @param {Function} cb\n *\n * @example\n * each([], callback);\n * each(el.children, callback);\n * each(el.childNodes, callback);\n * each({}, callback);\n *\n * @module helpers/util/each.js\n */\nfunction each(list, cb) {\n\n  if (!list) {\n    return;\n  }\n\n  if (typeof cb !== 'function') {\n    throw new Error('Cannot invoke `each` without a callback!');\n  }\n\n  var i = 0;\n  var len = list.length;\n\n  // Object\n  if (len === undefined) {\n    for (i in list) {\n      if (i !== 'prototype' && list.hasOwnProperty(i)) {\n        cb(i, list[i]);\n      }\n    }\n  }\n  // Array-like\n  else {\n      for (; i < len; i++) {\n        cb(list[i]);\n      }\n    }\n}\n\nexports.default = each;\nmodule.exports = exports['default'];\n//# sourceMappingURL=each.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Trim\n * Trim whitespace on a string.\n *\n * @param {String} str\n *\n * @module helpers/util/trim.js\n */\n\nvar trimRE = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\nfunction trim(str) {\n  return str.replace(trimRE, '');\n}\n\nexports.default = trim;\nmodule.exports = exports['default'];\n//# sourceMappingURL=trim.js.map\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9kaXN0L2NvbXBvbmVudHMvYmFzZS5qcyIsImpzL2Rpc3QvY29tcG9uZW50cy9zdGVwLWluZGljYXRvci5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vYWRkLWNsYXNzLmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS9oYXMtY2xhc3MuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL3JlbW92ZS1jbGFzcy5qcyIsImpzL2Rpc3QvaGVscGVycy90cmF2ZXJzYWwvZ2V0LXBhcmVudC5qcyIsImpzL2Rpc3QvaGVscGVycy90cmF2ZXJzYWwvbWF0Y2hlcy5qcyIsImpzL2Rpc3QvaGVscGVycy91dGlsL2RlYm91bmNlLmpzIiwianMvZGlzdC9oZWxwZXJzL3V0aWwvZWFjaC5qcyIsImpzL2Rpc3QvaGVscGVycy91dGlsL3RyaW0uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc31yZXR1cm4gZX0pKCkiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZWFjaCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdXRpbC9lYWNoJyk7XG5cbnZhciBfZWFjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIyBCYXNlIENvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoZSBiYXNlIGNsYXNzIGZvciBTcGFyayBKUyBjb21wb25lbnRzLiBUaGlzIGNsYXNzIHNob3VsZCBuZXZlciBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGluc3RhbnRpYXRlZCBkaXJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIGNvbXBvbmVudHMvYmFzZS5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIEJhc2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIFNldCBwYXJhbWV0ZXJzIGFuZCBjYWNoZSBlbGVtZW50cy5cbiAgICovXG4gIGZ1bmN0aW9uIEJhc2UoZWwpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlKTtcblxuICAgIGlmIChwYXJhbXMuZWxSZXF1aXJlZCAmJiAhZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldFBhcmFtcyh0aGlzLmRlZmF1bHRzIHx8IHt9LCB0cnVlKTtcbiAgICB0aGlzLnNldFBhcmFtcyhwYXJhbXMpO1xuICAgICh0aGlzLl9jYWNoZUVsZW1lbnRzIHx8IG5vb3ApLmNhbGwodGhpcywgZWwsIHBhcmFtcyk7XG4gICAgKHRoaXMuX3BhcnNlUGFyYW1zIHx8IG5vb3ApLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBjb21wb25lbnQgZnJvbSB0aGUgRE9NIGFuZCBwcmVwYXJlIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24gYnkgZGVyZWZlcmVuY2luZyB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbGVhdmVFbGVtZW50IExlYXZlIHRoZSBlbGVtZW50IGludGFjdC5cbiAgICovXG5cblxuICBCYXNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUobGVhdmVFbGVtZW50KSB7XG5cbiAgICBpZiAodGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgaWYgKCFsZWF2ZUVsZW1lbnQgJiYgdGhpcy5lbCAmJiB0aGlzLmVsLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgICB9XG5cbiAgICB0aGlzLnVuc2V0UGFyYW1zKHRoaXMuZGVmYXVsdHMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY29tcG9uZW50IHRvIHVzZSBhIG5ldyBlbGVtZW50IG9yIHJlcGFyc2UgZnJvbVxuICAgKiB0aGUgZXhpc3RpbmcgZWxlbWVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBPcHRpb25hbFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIE9wdGlvbmFsXG4gICAqL1xuXG5cbiAgQmFzZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGVsKSB7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cblxuICAgIGlmICh0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycykge1xuICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICAodGhpcy5fY2FjaGVFbGVtZW50cyB8fCBub29wKS5jYWxsKHRoaXMsIGVsIHx8IHRoaXMuZWwsIHBhcmFtcyk7XG4gICAgKHRoaXMuX3BhcnNlUGFyYW1zIHx8IG5vb3ApLmNhbGwodGhpcyk7XG5cbiAgICBpZiAodGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIGhhc2ggb2YgcGFyYW1ldGVycyBpZiB0aGV5J3JlIHdoaXRlbGlzdGVkIG9yIHdlJ3JlIHRvbGQgdG8gZm9yY2UgdGhlIHNldC5cbiAgICogVGhpcyBpcyB1c2VkIHRvIHNldCBpbml0aWFsIHZhbHVlcyBhcyB3ZWxsIGFzIHNldCBwYXNzZWQgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlIEZvcmNlIHNldHRpbmcgZXZlbiBpZiB0aGUgcGFyYW0gaXMgbm90IHdoaXRlbGlzdGVkLlxuICAgKi9cblxuXG4gIEJhc2UucHJvdG90eXBlLnNldFBhcmFtcyA9IGZ1bmN0aW9uIHNldFBhcmFtcyhwYXJhbXMsIGZvcmNlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICgwLCBfZWFjaDIuZGVmYXVsdCkocGFyYW1zLCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgaWYgKF90aGlzLl93aGl0ZWxpc3RlZFBhcmFtcy5pbmRleE9mKGspICE9PSAtMSB8fCBmb3JjZSkge1xuICAgICAgICBfdGhpc1trXSA9IHY7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVW5zZXQgYWxsIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSBUaGUgb2JqZWN0IHRvIHVuc2V0IHRoZSBwYXJhbXMgZnJvbS4gRGVmYXVsdHMgdG8gYHRoaXNgLlxuICAgKi9cblxuXG4gIEJhc2UucHJvdG90eXBlLnVuc2V0UGFyYW1zID0gZnVuY3Rpb24gdW5zZXRQYXJhbXMoa2V5cywgc2NvcGUpIHtcblxuICAgIGtleXMgPSBrZXlzIGluc3RhbmNlb2YgQXJyYXkgPyBrZXlzIDogT2JqZWN0LmtleXMoa2V5cyk7XG4gICAgc2NvcGUgPSBzY29wZSB8fCB0aGlzO1xuICAgICgwLCBfZWFjaDIuZGVmYXVsdCkoa2V5cywgZnVuY3Rpb24gKGspIHtcbiAgICAgIGRlbGV0ZSBzY29wZVtrXTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBCYXNlO1xufSgpO1xuXG4vKipcbiAqIFdoaXRlbGlzdGVkIHBhcmFtZXRlcnMgd2hpY2ggY2FuIGJlIHNldCBvbiBjb25zdHJ1Y3Rpb24uXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cblxuXG5CYXNlLnByb3RvdHlwZS5fd2hpdGVsaXN0ZWRQYXJhbXMgPSBbXTtcblxuLyoqXG4gKiBEZWZhdWx0IHZhbHVlcyBmb3IgaW50ZXJuYWwgcHJvcGVydGllcyB3ZSB3aWxsIGJlIHNldHRpbmcuXG4gKiBUaGVzZSBhcmUgc2V0IG9uIGVhY2ggY29uc3RydWN0aW9uIHNvIHdlIGRvbid0IGxlYWsgcHJvcGVydGllc1xuICogaW50byB0aGUgcHJvdG90eXBlIGNoYWluLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuQmFzZS5wcm90b3R5cGUuZGVmYXVsdHMgPSB7fTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQmFzZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9iYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5cbnZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcblxudmFyIF9hZGRDbGFzcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL2FkZC1jbGFzcycpO1xuXG52YXIgX2FkZENsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FkZENsYXNzKTtcblxudmFyIF9yZW1vdmVDbGFzcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL3JlbW92ZS1jbGFzcycpO1xuXG52YXIgX3JlbW92ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlbW92ZUNsYXNzKTtcblxudmFyIF9oYXNDbGFzcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL2hhcy1jbGFzcycpO1xuXG52YXIgX2hhc0NsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhc0NsYXNzKTtcblxudmFyIF9nZXRQYXJlbnQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RyYXZlcnNhbC9nZXQtcGFyZW50Jyk7XG5cbnZhciBfZ2V0UGFyZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFBhcmVudCk7XG5cbnZhciBfZGVib3VuY2UgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3V0aWwvZGVib3VuY2UnKTtcblxudmFyIF9kZWJvdW5jZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWJvdW5jZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAjIFN0ZXAgSW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTZXQgb2YgaW5kaWNhdG9ycyByZXByZXNlbnQgZGlmZmVyZW50IHN0ZXBzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG5ldyBTdGVwSW5kaWNhdG9yKGVsLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgY29tcG9uZW50cy9zdGVwLWluZGljYXRvci5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbnZhciBTdGVwSW5kaWNhdG9yID0gZnVuY3Rpb24gKF9CYXNlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTdGVwSW5kaWNhdG9yLCBfQmFzZUNvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIFN0ZXBJbmRpY2F0b3IgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgKi9cbiAgZnVuY3Rpb24gU3RlcEluZGljYXRvcihlbCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0ZXBJbmRpY2F0b3IpO1xuXG4gICAgaWYgKCEoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQmFzZUNvbXBvbmVudC5jYWxsKHRoaXMsIGVsLCBwYXJhbXMpKSwgX3RoaXMpKSB7XG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMpO1xuICAgIH1cblxuICAgIF90aGlzLl9iaW5kRXZlbnRMaXN0ZW5lckNhbGxiYWNrcygpO1xuICAgIF90aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIF90aGlzLl9jYWxjdWxhdGVTdHlsZSgpO1xuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjb21wb25lbnQgdG8gdXNlIGEgbmV3IGVsZW1lbnQgb3IgcmVwYXJzZSBmcm9tXG4gICAqIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIE9wdGlvbmFsXG4gICAqL1xuXG5cbiAgU3RlcEluZGljYXRvci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGVsKSB7XG5cbiAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuX2NhY2hlRWxlbWVudHMoZWwgfHwgdGhpcy5lbCk7XG4gICAgdGhpcy5fcGFyc2VQYXJhbXMoKTtcbiAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuX2NhbGN1bGF0ZVN0eWxlKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICovXG5cblxuICBTdGVwSW5kaWNhdG9yLnByb3RvdHlwZS5fY2FjaGVFbGVtZW50cyA9IGZ1bmN0aW9uIF9jYWNoZUVsZW1lbnRzKGVsKSB7XG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMuY29udGFpbmVyRWwgPSB0aGlzLmNvbnRhaW5lckVsIHx8IGVsLnBhcmVudE5vZGU7XG4gICAgdGhpcy5fYm9keSA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnNwYXJrLXN0ZXAtaW5kaWNhdG9yX19ib2R5Jyk7XG4gICAgdGhpcy5fbGlzdCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnNwYXJrLXN0ZXAtaW5kaWNhdG9yX19saXN0Jyk7XG4gICAgdGhpcy5faXRlbXMgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zcGFyay1zdGVwLWluZGljYXRvcl9faXRlbScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBwYXJhbWV0ZXJzIGZyb20gdGhlIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgU3RlcEluZGljYXRvci5wcm90b3R5cGUuX3BhcnNlUGFyYW1zID0gZnVuY3Rpb24gX3BhcnNlUGFyYW1zKCkge1xuICAgIHRoaXMudHlwZSA9IHRoaXMudHlwZSAhPT0gbnVsbCA/IHRoaXMudHlwZSA6IHRoaXMuZWwuYXR0cmlidXRlc1snZGF0YS10eXBlJ10gJiYgdGhpcy5lbC5hdHRyaWJ1dGVzWydkYXRhLXR5cGUnXS52YWx1ZTtcbiAgICB0aGlzLmhlYWRlciA9IHRoaXMuaGVhZGVyICE9PSBudWxsID8gdGhpcy5oZWFkZXIgOiB0aGlzLmVsLmF0dHJpYnV0ZXNbJ2RhdGEtaGVhZGVyJ10gJiYgdHJ1ZTtcbiAgICB0aGlzLnN1YnRpdGxlID0gdGhpcy5zdWJ0aXRsZSAhPT0gbnVsbCA/IHRoaXMuc3VidGl0bGUgOiB0aGlzLmVsLmF0dHJpYnV0ZXNbJ2RhdGEtc3VidGl0bGUnXSAmJiB0cnVlO1xuICAgIHRoaXMuZHJvcGRvd25MYWJlbCA9IHRoaXMuZHJvcGRvd25MYWJlbCAhPT0gbnVsbCA/IHRoaXMuZHJvcGRvd25MYWJlbCA6IHRoaXMuZWwuYXR0cmlidXRlc1snZGF0YS1kcm9wZG93bkxhYmVsJ10gJiYgdGhpcy5lbC5hdHRyaWJ1dGVzWydkYXRhLWRyb3Bkb3duTGFiZWwnXS52YWx1ZTtcblxuICAgIGlmICghdGhpcy5kcm9wZG93bkxhYmVsKSB7XG4gICAgICB0aGlzLmRyb3Bkb3duTGFiZWwgPSAnU2VsZWN0IGEgU3RlcCc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYm91bmQgdmVyc2lvbnMgb2YgZXZlbnQgbGlzdGVuZXIgY2FsbGJhY2tzIGFuZCBzdG9yZSB0aGVtLlxuICAgKiBPdGhlcndpc2Ugd2UgY2FuJ3QgdW5iaW5kIGZyb20gdGhlc2UgZXZlbnRzIGxhdGVyIGJlY2F1c2UgdGhlXG4gICAqIGZ1bmN0aW9uIHNpZ25hdHVyZXMgd29uJ3QgbWF0Y2guXG4gICAqL1xuXG5cbiAgU3RlcEluZGljYXRvci5wcm90b3R5cGUuX2JpbmRFdmVudExpc3RlbmVyQ2FsbGJhY2tzID0gZnVuY3Rpb24gX2JpbmRFdmVudExpc3RlbmVyQ2FsbGJhY2tzKCkge1xuICAgIHRoaXMuX29uUmVzaXplQm91bmQgPSB0aGlzLl9vblJlc2l6ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uTG9hZEJvdW5kID0gdGhpcy5fb25Mb2FkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25WaXNpYmxlQm91bmQgPSB0aGlzLl9vblZpc2libGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl90b2dnbGVEcm9wZG93bkJvdW5kID0gdGhpcy5fdG9nZ2xlRHJvcGRvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbktleWRvd25Cb3VuZCA9ICgwLCBfZGVib3VuY2UyLmRlZmF1bHQpKHRoaXMuX29uS2V5ZG93bi5iaW5kKHRoaXMpLCAxMDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgZXZlbnQgbGlzdGVuZXJzIGZvciBET00gZXZlbnRzLlxuICAgKi9cblxuXG4gIFN0ZXBJbmRpY2F0b3IucHJvdG90eXBlLl9hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemVCb3VuZCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc3BhcmsudmlzaWJsZS1jaGlsZHJlbicsIHRoaXMuX29uVmlzaWJsZUJvdW5kLCB0cnVlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX29uTG9hZEJvdW5kKTtcbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleWRvd25Cb3VuZCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc3Bhcmsuc3RlcC1pbmRpY2F0b3InLCB0aGlzLl90b2dnbGVEcm9wZG93bkJvdW5kLCB0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBmb3IgRE9NIGV2ZW50cy4uXG4gICAqL1xuXG5cbiAgU3RlcEluZGljYXRvci5wcm90b3R5cGUuX3JlbW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZUJvdW5kKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzcGFyay52aXNpYmxlLWNoaWxkcmVuJywgdGhpcy5fb25WaXNpYmxlQm91bmQsIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fdG9nZ2xlRHJvcGRvd25Cb3VuZCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLl9vbkxvYWRCb3VuZCk7XG4gICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlkb3duQm91bmQpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NwYXJrLnN0ZXAtaW5kaWNhdG9yJywgdGhpcy5fdG9nZ2xlRHJvcGRvd25Cb3VuZCwgdHJ1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoYW5nZSBzZWxlY3RlZCBzdGVwIHN0YXRlIGludG8gaW5jb21wbGV0ZVxuICAgKiBAcGFyYW0ge0ludH0gaW5kZXggb2Ygc2VsZWN0ZWQgc3RlcFxuICAgKi9cblxuXG4gIFN0ZXBJbmRpY2F0b3IucHJvdG90eXBlLl9yZXNldFN0ZXBTdGF0ZSA9IGZ1bmN0aW9uIF9yZXNldFN0ZXBTdGF0ZShzdGVwSW5kZXgpIHtcbiAgICBpZiAoc3RlcEluZGV4IDwgMCB8fCBzdGVwSW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkodGhpcy5faXRlbXNbc3RlcEluZGV4XSwgWydzcGFyay1zdGVwLWluZGljYXRvcl9faXRlbS0tY29tcGxldGVkJywgJ3NwYXJrLXN0ZXAtaW5kaWNhdG9yX19pdGVtLS1jdXJyZW50JywgJ3NwYXJrLXN0ZXAtaW5kaWNhdG9yX19pdGVtLS1kaXNhYmxlZCddKTtcbiAgICB0aGlzLl9pdGVtc1tzdGVwSW5kZXhdLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHNlbGVjdGVkIHN0ZXAgc3RhdGU6IGNvbXBsZXRlZC9jdXJyZW50L2Rpc2FibGVkL2luY29tcGxldGVcbiAgICogRm9yIGN1cnJlbnQgc3RlcCwgd2lsbCByZW1vdmUgY3VycmVudCBzdGVwIGZyb20gb3RoZXIgc3RlcHNcbiAgICogQHBhcmFtIHtJbnR9IGluZGV4IG9mIHNlbGVjdGVkIHN0ZXBcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0YXRlIHRvIGJlIHNldFxuICAgKi9cblxuXG4gIFN0ZXBJbmRpY2F0b3IucHJvdG90eXBlLnNldFN0ZXBTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0ZXBTdGF0ZShzdGVwSW5kZXgsIHN0YXRlKSB7XG4gICAgaWYgKHN0ZXBJbmRleCA8IDAgfHwgc3RlcEluZGV4ID49IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6XG4gICAgICAgIHRoaXMuX3Jlc2V0U3RlcFN0YXRlKHN0ZXBJbmRleCk7XG4gICAgICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKHRoaXMuX2l0ZW1zW3N0ZXBJbmRleF0sICdzcGFyay1zdGVwLWluZGljYXRvcl9faXRlbS0tY29tcGxldGVkJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY3VycmVudCc6XG4gICAgICAgIHZhciBjdXJyZW50U3RlcCA9IHRoaXMuX2xpc3QucXVlcnlTZWxlY3RvcignLnNwYXJrLXN0ZXAtaW5kaWNhdG9yX19pdGVtLS1jdXJyZW50Jyk7XG4gICAgICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKGN1cnJlbnRTdGVwLCAnc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2l0ZW0tLWN1cnJlbnQnKTtcbiAgICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5faXRlbXNbc3RlcEluZGV4XSwgJ3NwYXJrLXN0ZXAtaW5kaWNhdG9yX19pdGVtLS1jdXJyZW50Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGlzYWJsZWQnOlxuICAgICAgICB0aGlzLl9yZXNldFN0ZXBTdGF0ZShzdGVwSW5kZXgpO1xuICAgICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLl9pdGVtc1tzdGVwSW5kZXhdLCAnc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2l0ZW0tLWRpc2FibGVkJyk7XG4gICAgICAgIHRoaXMuX2l0ZW1zW3N0ZXBJbmRleF0uc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2luY29tcGxldGUnOlxuICAgICAgICB0aGlzLl9yZXNldFN0ZXBTdGF0ZShzdGVwSW5kZXgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5fY2FsY3VsYXRlU3R5bGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgRW50ZXIga2V5IGlzIHByZXNzZWQgdG9nZ2xlIHRoZSBkcm9wZG93biBvciB1cGRhdGUgdGhlIHNlbGVjdGlvbiBpZiBpbiBkcm9wZG93biBtb2RlXG4gICAqIFdoZW4gdGhlIFRhYiBrZXkgaXMgcHJlc3NlZCwgbmF2aWdhdGUgdG8gdGhlIG5leHQgZWxlbWVudCBieSBkZWZhdWx0IG90aGVyd2lzZSBjb2xsYXBzZSB0aGUgZHJvcGRvd25cbiAgICogQHBhcmFtIHtPYmplY3R9IFJlZmVyZW5jZSBvZiBET00gb2JqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBFdmVudCBvZiBjbGlja1xuICAgKi9cblxuXG4gIFN0ZXBJbmRpY2F0b3IucHJvdG90eXBlLl9vbktleWRvd24gPSBmdW5jdGlvbiBfb25LZXlkb3duKGUpIHtcbiAgICBpZiAoISgwLCBfZ2V0UGFyZW50Mi5kZWZhdWx0KShlLnRhcmdldCwgJy5zcGFyay1zdGVwLWluZGljYXRvcl9fbGlzdCcsIHRoaXMuZWwpICYmICEoMCwgX2dldFBhcmVudDIuZGVmYXVsdCkoZS50YXJnZXQsICcuc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2JvZHktLWRyb3Bkb3duJywgdGhpcy5lbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29kZSA9IGUua2V5Q29kZSB8fCBlLndoaWNoO1xuXG4gICAgLy8gRW50ZXIgS2V5XG4gICAgaWYgKGNvZGUgPT09IDEzKSB7XG4gICAgICBpZiAoKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkoZS50YXJnZXQsICdzcGFyay1zdGVwLWluZGljYXRvcl9faXRlbS0tZHJvcGRvd25fX2hlYWRlcicpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5fdG9nZ2xlRHJvcGRvd24oZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGFiIEtleSAtIENoZWNrIGlmIGZvY3VzIGhhcyBub3cgc2hpZnRlZCBvdXRzaWRlIG9mIHRoZSBTdGVwIEluZGljYXRvciBEcm9wZG93blxuICAgIGlmIChjb2RlID09PSA5KSB7XG4gICAgICAoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KShkb2N1bWVudC5hY3RpdmVFbGVtZW50LCAnc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2l0ZW0nKSA9PT0gZmFsc2UgJiYgdGhpcy5fZHJvcGRvd25FeHBhbmQgPT09IHRydWUgPyB0aGlzLl90b2dnbGVEcm9wZG93bihlKSA6IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgbWV0aG9kIHRvIGJpbmQgY2xpY2sgY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2VydGFpbiBzdGVwLlxuICAgKiBAcGFyYW0ge0FycmF5fSBhIHNldCBvZiBzdGVwIGluZGljZXMgcmVwcmVzZW50IHRoZSB0YXJnZXQgb2YgY2FsbGJhY2tcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICovXG5cblxuICBTdGVwSW5kaWNhdG9yLnByb3RvdHlwZS5iaW5kU3RlcENsaWNrQ2FsbGJhY2sgPSBmdW5jdGlvbiBiaW5kU3RlcENsaWNrQ2FsbGJhY2soaW5kZXhBcnIsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXhBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2l0ZW1zW2luZGV4QXJyW2ldXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBjbGljayBjYWxsYmFjayBmcm9tIHN0ZXBzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGEgc2V0IG9mIHN0ZXAgaW5kaWNlcyByZXByZXNlbnQgdGhlIHRhcmdldCBvZiBjYWxsYmFja1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvblxuICAgKlxuICAgKi9cblxuXG4gIFN0ZXBJbmRpY2F0b3IucHJvdG90eXBlLnJlbW92ZVN0ZXBDbGlja0NhbGxiYWNrID0gZnVuY3Rpb24gcmVtb3ZlU3RlcENsaWNrQ2FsbGJhY2soaW5kZXhBcnIsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXhBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2l0ZW1zW2luZGV4QXJyW2ldXS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdvcmsgZm9yIF9jYWxjdWxhdGVTdHlsZS5cbiAgICogQ29tcGFyaW5nIHRoZSB3aWR0aCBvZiBsaXN0IGFuZCB0b3RhbCBpdGVtcywgaW5jbHVkaW5nIHBhZGRpbmdcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cblxuICBTdGVwSW5kaWNhdG9yLnByb3RvdHlwZS5faXNPdmVyV2lkdGggPSBmdW5jdGlvbiBfaXNPdmVyV2lkdGgoKSB7XG4gICAgdmFyIGxpc3RXaWR0aCA9IHRoaXMuX2xpc3Qub2Zmc2V0V2lkdGg7XG4gICAgdmFyIGl0ZW1Ub3RhbFdpZHRoID0gdGhpcy5fbGlzdFBhZGRpbmdUb3RhbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpdGVtVG90YWxXaWR0aCArPSB0aGlzLl9pdGVtc1tpXS5vZmZzZXRXaWR0aDtcbiAgICB9XG4gICAgaWYgKGxpc3RXaWR0aCA8IGl0ZW1Ub3RhbFdpZHRoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWF0ZSBkaWZmZXJlbnQgc3R5bGUgYmFzZWQgc2V0dGluZ3NcbiAgICovXG5cblxuICBTdGVwSW5kaWNhdG9yLnByb3RvdHlwZS5fY2FsY3VsYXRlU3R5bGUgPSBmdW5jdGlvbiBfY2FsY3VsYXRlU3R5bGUoKSB7XG4gICAgaWYgKCF0aGlzLmhlYWRlcikge1xuICAgICAgdmFyIHRpdGxlRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1zdGVwLWluZGljYXRvcl9fdGl0bGUnKTtcbiAgICAgIHRpdGxlRWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKHRoaXMuX2JvZHksICdzcGFyay1zdGVwLWluZGljYXRvcl9fYm9keS0tbm8tYm9yZGVyJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5zdWJ0aXRsZSkge1xuICAgICAgdmFyIHN1YnRpdGxlRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1zdGVwLWluZGljYXRvcl9fc3VidGl0bGUnKTtcbiAgICAgIHN1YnRpdGxlRWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHNwZWNpYWwgRE9NIGFuZCBDbGFzcyBvZiBkcm9wZG93biB2YXJpYXRpb25cbiAgICB0aGlzLl9zd2l0Y2hGcm9tRHJvcGRvd24oKTtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSAnc3RhbmRhcmQtZHJvcGRvd24nOlxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVSZXNwU3R5bGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsYXJnZSc6XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZUxhcmdlU3R5bGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjb25kZW5zZWQnOlxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVDb25kZW5zZWRTdHlsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Ryb3Bkb3duJzpcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlRHJvcGRvd25TdHlsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVN0YW5kYXJkU3R5bGUoKTtcbiAgICB9XG4gICAgLy8gV29yayBmb3IgSUUxMSwgZGV0ZWN0IElFMTEgdmlhIHVzZXJBZ2VudFxuICAgIC8vIHVzZXJBZ2VudDogTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgNi4zOyBUcmlkZW50LzcuMDsgcnYgMTEuMCkgbGlrZSBHZWNrb1xuICAgIHZhciBpc0lFMTEgPSAhIShuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9UcmlkZW50LykgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvcnZbIDpdMTEvKSk7XG4gICAgaWYgKGlzSUUxMSkge1xuICAgICAgdGhpcy5fYWRkSXRlbVdpZHRoKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGb3IgSUUxMSBPTkxZLCBBZGQgd2lkdGg6IDEwMCUgdG8gd29yayBhcm91bmQgSUUxMSBidWdcbiAgICogSUUxMSB3aWxsIGhhdmUgaW5jb3JyZWN0IHBvc2l0aW9uIHdpdGggZmxleC1ncm93IG1heC13aWR0aCBhbmQganVzdGlmeS1jb250ZW50IHdoZW4gaXRlbXMgaGl0IG1heC13aWR0aFxuICAgKiBTb21ldGltZXMgYWZ0ZXIgY2FsY3VsYXRpbmcsIGV2ZW4gaXRlbVRvdGFsV2lkdGggaXMgbGVzcyAxcHggdGhhbiBsaXN0V2lkdGgsXG4gICAqIGl0IGFsc28gbWVhbnMgaXRlbXMgYXJlIGZpdCBpbiB0aGUgbGlzdCwgbm90IGhpdCB0aGUgbWF4LXdpZHRoXG4gICAqIFNvIGFkZCAycHggdG8gbGlzdCB3aWR0aCB3aGVuIGNvbXBhcmluZyB0byBhdm9pZCB0aGlzLlxuICAgKi9cblxuXG4gIFN0ZXBJbmRpY2F0b3IucHJvdG90eXBlLl9hZGRJdGVtV2lkdGggPSBmdW5jdGlvbiBfYWRkSXRlbVdpZHRoKCkge1xuICAgIGlmICghKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkodGhpcy5fbGlzdCwgJ3NwYXJrLXN0ZXAtaW5kaWNhdG9yX19saXN0LS1jb25kZW5zZWQnKSAmJiAhKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkodGhpcy5fYm9keSwgJ3NwYXJrLXN0ZXAtaW5kaWNhdG9yX19ib2R5LS1kcm9wZG93bicpKSB7XG4gICAgICB2YXIgbGlzdFdpZHRoID0gdGhpcy5fbGlzdC5vZmZzZXRXaWR0aDtcbiAgICAgIHZhciBpdGVtVG90YWxXaWR0aCA9IHRoaXMuX2xpc3RQYWRkaW5nVG90YWw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW1Ub3RhbFdpZHRoICs9IHRoaXMuX2l0ZW1zW2ldLm9mZnNldFdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3RXaWR0aCAtIGl0ZW1Ub3RhbFdpZHRoID4gMikge1xuICAgICAgICB0aGlzLl9zd2l0Y2hXaWR0aEZvckllMTEoMCwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zd2l0Y2hXaWR0aEZvckllMTEoMCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zd2l0Y2hXaWR0aEZvckllMTEoMCwgZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3dpdGNoIHNwYXJrLXN0ZXAtaW5kaWNhdG9yX19pdGVtIHN0eWxlIHdpZHRoOiAxMDAlIHRvIHdvcmsgYXJvdW5kIElFMTEgYnVnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBpbmRleCBvZiBzdGVwXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciBhZGQgd2lkdGg6IDEwMCVcbiAgICovXG5cblxuICBTdGVwSW5kaWNhdG9yLnByb3RvdHlwZS5fc3dpdGNoV2lkdGhGb3JJZTExID0gZnVuY3Rpb24gX3N3aXRjaFdpZHRoRm9ySWUxMShpbmRleCwgdmFsKSB7XG4gICAgZm9yICh2YXIgaSA9IGluZGV4OyBpIDwgdGhpcy5faXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2l0ZW1zW2ldLnN0eWxlLndpZHRoID0gdmFsID8gJzEwMCUnIDogJyc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGaXggb24gbGFyZ2UgdmFyaWF0aW9uXG4gICAqIENhbGN1bGF0ZSBub2RlIGFuZCBsaXN0IGxlbmd0aCByZW1vdmUgY29ubmVjdCBsaW5lIG9mIGVhY2ggZW5kXG4gICAqIFNvbWV0aW1lcyBhZnRlciBjYWxjdWxhdGluZywgZXZlbiBpdGVtVG90YWxXaWR0aCBpcyBiaWdnZXIgMXB4IHRoYW4gbGlzdFdpZHRoLFxuICAgKiBpdCBhbHNvIG1lYW5zIGl0ZW1zIGFyZSBmaXQgaW4gdGhlIGxpc3QsIG5vdCBvdmVyIHdpZHRoLlxuICAgKiBTbyBhZGQgMnB4IHRvIGxpc3Qgd2lkdGggd2hlbiBjb21wYXJpbmcgdG8gYXZvaWQgdGhpcy5cbiAgICogRGVwZW5kZW5jeSBvZiBfY2FsY3VsYXRlQ29uZGVuc2VkU3R5bGUoKSBhbmQgX2NhbGN1bGF0ZVN0YW5kYXJkU3R5bGUoKVxuICAgKlxuICAgKi9cblxuXG4gIFN0ZXBJbmRpY2F0b3IucHJvdG90eXBlLl9jYWxjdWxhdGVMYXJnZVN0eWxlID0gZnVuY3Rpb24gX2NhbGN1bGF0ZUxhcmdlU3R5bGUoKSB7XG4gICAgdGhpcy5fbGlzdC5zdHlsZVsnZmxleC13cmFwJ10gPSAnd3JhcCc7XG4gICAgdmFyIGxpc3RXaWR0aCA9IHRoaXMuX2xpc3Qub2Zmc2V0V2lkdGg7XG4gICAgdmFyIGl0ZW1Ub3RhbFdpZHRoID0gdGhpcy5fbGlzdFBhZGRpbmdUb3RhbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KSh0aGlzLl9pdGVtc1tpXSwgJ25vbGluZScpO1xuICAgICAgaXRlbVRvdGFsV2lkdGggKz0gdGhpcy5faXRlbXNbaV0ub2Zmc2V0V2lkdGg7XG5cbiAgICAgIGlmIChsaXN0V2lkdGggPCBpdGVtVG90YWxXaWR0aCAmJiBpID4gMCkge1xuICAgICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLl9pdGVtc1tpIC0gMV0sICdub2xpbmUnKTtcbiAgICAgICAgaXRlbVRvdGFsV2lkdGggPSB0aGlzLl9pdGVtc1tpXS5vZmZzZXRXaWR0aCArIHRoaXMuX2xpc3RQYWRkaW5nVG90YWw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGaXggb24gY29uZGVuc2VkIHZhcmlhdGlvblxuICAgKiBTYW1lIGFzIGZpeCBsYXJnZSB2YXJpYXRpb24gZXhjZXB0IENTUyBjbGFzc1xuICAgKi9cblxuXG4gIFN0ZXBJbmRpY2F0b3IucHJvdG90eXBlLl9jYWxjdWxhdGVDb25kZW5zZWRTdHlsZSA9IGZ1bmN0aW9uIF9jYWxjdWxhdGVDb25kZW5zZWRTdHlsZSgpIHtcbiAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLl9saXN0LCAnc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2xpc3QtLWNvbmRlbnNlZCcpO1xuICAgIHRoaXMuX2NhbGN1bGF0ZUxhcmdlU3R5bGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogRml4IG9uIGRyb3Bkb3duIHZhcmlhdGlvblxuICAgKi9cblxuXG4gIFN0ZXBJbmRpY2F0b3IucHJvdG90eXBlLl9jYWxjdWxhdGVEcm9wZG93blN0eWxlID0gZnVuY3Rpb24gX2NhbGN1bGF0ZURyb3Bkb3duU3R5bGUoKSB7XG4gICAgdGhpcy5fc3dpdGNoVG9Ecm9wZG93bigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGFuZ2Ugb25seSBiZXR3ZWVuIGxhcmdlIGFuZCBjb25kZW5zZWQgdmFyaWF0aW9uXG4gICAqIG5vIGRyb3Bkb3duIHZhcmlhdGlvblxuICAgKi9cblxuXG4gIFN0ZXBJbmRpY2F0b3IucHJvdG90eXBlLl9jYWxjdWxhdGVTdGFuZGFyZFN0eWxlID0gZnVuY3Rpb24gX2NhbGN1bGF0ZVN0YW5kYXJkU3R5bGUoKSB7XG4gICAgdGhpcy5fbGlzdC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkodGhpcy5faXRlbXNbaV0sICdub2xpbmUnKTtcbiAgICB9XG4gICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkodGhpcy5fbGlzdCwgJ3NwYXJrLXN0ZXAtaW5kaWNhdG9yX19saXN0LS1jb25kZW5zZWQnKTtcbiAgICBpZiAodGhpcy5faXNPdmVyV2lkdGgoKSkge1xuICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5fbGlzdCwgJ3NwYXJrLXN0ZXAtaW5kaWNhdG9yX19saXN0LS1jb25kZW5zZWQnKTtcbiAgICAgIHRoaXMuX2NhbGN1bGF0ZUxhcmdlU3R5bGUoKTtcbiAgICB9XG4gICAgdGhpcy5fbGlzdC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlIGxpc3QgaW52aXNpYmxlIGFuZCBjaGFuZ2UgaXQgaW50byBsYXJnZSB2YXJpYXRpb24gYXQgZmlyc3QuXG4gICAqIFN3aXRjaCB2YXJpYXRpb24gZnJvbSB0b3AgdG8gYm90dG9tIHRvIGZpbmQgdGhlIGZpdCBvbmVcbiAgICovXG5cblxuICBTdGVwSW5kaWNhdG9yLnByb3RvdHlwZS5fY2FsY3VsYXRlUmVzcFN0eWxlID0gZnVuY3Rpb24gX2NhbGN1bGF0ZVJlc3BTdHlsZSgpIHtcbiAgICB0aGlzLl9saXN0LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KSh0aGlzLl9saXN0LCAnc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2xpc3QtLWNvbmRlbnNlZCcpO1xuICAgIGlmICh0aGlzLl9pc092ZXJXaWR0aCgpKSB7XG4gICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLl9saXN0LCAnc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2xpc3QtLWNvbmRlbnNlZCcpO1xuICAgICAgaWYgKHRoaXMuX2lzT3ZlcldpZHRoKCkpIHtcbiAgICAgICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkodGhpcy5fbGlzdCwgJ3NwYXJrLXN0ZXAtaW5kaWNhdG9yX19saXN0LS1jb25kZW5zZWQnKTtcbiAgICAgICAgdGhpcy5fc3dpdGNoVG9Ecm9wZG93bigpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9saXN0LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBoZWFkZXIgZWxlbWVudCBmb3IgZHJvcGRvd24gdmFyaWF0aW9uXG4gICAqIFRyeSB0byBmaW5kIHRoZSBjdXJyZW50IHN0ZXAgb2YgaW5kaWNhdG9yIGFuZCBzaG93IGl0IG9uIHRoZSBoZWFkZXJcbiAgICogaWYgbm90IGZvdW5kLCBzaG93IHRoZSBmaXJzdCBzdGVwXG4gICAqIEByZXR1cm4ge09iamVjdH0gaGVhZGVyIGVsZW1lbnQgb2YgZHJvcGRvd24gdmFyaWF0aW9uXG4gICAqL1xuXG5cbiAgU3RlcEluZGljYXRvci5wcm90b3R5cGUuX2NyZWF0ZURyb3Bkb3duSGVhZGVyID0gZnVuY3Rpb24gX2NyZWF0ZURyb3Bkb3duSGVhZGVyKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICB2YXIgY3VycmVudFN0ZXAgPSB0aGlzLl9saXN0LnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1zdGVwLWluZGljYXRvcl9faXRlbS0tY3VycmVudCcpO1xuICAgIC8vIENhbiBub3QgZmluZCBjdXJyZW50IHN0ZXBcbiAgICBpZiAoIWN1cnJlbnRTdGVwKSB7XG4gICAgICBjdXJyZW50U3RlcCA9IHRoaXMuX2l0ZW1zWzBdO1xuICAgIH1cblxuICAgIC8vIFNldCBBUklBIHJvbGVzIGFuZCBhdHRyaWJ1dGVzXG4gICAgZWwuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgIHZhciBsaXN0SUQgPSB0aGlzLl9saXN0LmdldEF0dHJpYnV0ZSgnaWQnKSAhPT0gbnVsbCAmJiB0aGlzLl9saXN0LmdldEF0dHJpYnV0ZSgnaWQnKSAhPT0gJycgPyB0aGlzLl9saXN0LmdldEF0dHJpYnV0ZSgnaWQnKSA6ICcnO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycsIGxpc3RJRCk7XG5cbiAgICBlbC5pbm5lckhUTUwgPSBjdXJyZW50U3RlcC5pbm5lckhUTUw7XG4gICAgZWwuaW5uZXJIVE1MICs9ICc8c3BhbiBjbGFzcz1cInNwYXJrLXN0ZXAtaW5kaWNhdG9yX19ub3RpY2VcIj4nICsgdGhpcy5kcm9wZG93bkxhYmVsICsgJzwvc3Bhbj4nO1xuXG4gICAgLy8gQ3JlYXRlIGxhYmVsIGVsZW1lbnQgbGlrZSAnMiBvZiA3J1xuICAgIHZhciBzdGVwTm90aWNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIHZhciBjdXJyZW50SW5kZXggPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMuX2l0ZW1zLCBjdXJyZW50U3RlcCk7XG4gICAgc3RlcE5vdGljZS5pbm5lckhUTUwgPSBjdXJyZW50SW5kZXggKyAxICsgJyBvZiAnICsgdGhpcy5faXRlbXMubGVuZ3RoO1xuICAgIHN0ZXBOb3RpY2UuY2xhc3NOYW1lID0gJ3NwYXJrLXN0ZXAtaW5kaWNhdG9yX19sYWJlbC0tZHJvcGRvd24nO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQoc3RlcE5vdGljZSk7XG4gICAgZWwuY2xhc3NOYW1lID0gY3VycmVudFN0ZXAuY2xhc3NOYW1lO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnMCcpO1xuXG4gICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkoZWwsICdzcGFyay1zdGVwLWluZGljYXRvcl9faXRlbS0tZHJvcGRvd25fX2hlYWRlcicpO1xuICAgIHRoaXMuX2Ryb3Bkb3duSGVhZGVyID0gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNvbWUgZXh0cmEgZXZlbnQgYmluZGVyIGFuZCBET00gb2YgZHJvcGRvd24gdmFyaWF0aW9uIG5lZWQgdG8gYmUgc2V0XG4gICAqL1xuXG5cbiAgU3RlcEluZGljYXRvci5wcm90b3R5cGUuX3N3aXRjaFRvRHJvcGRvd24gPSBmdW5jdGlvbiBfc3dpdGNoVG9Ecm9wZG93bigpIHtcbiAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLl9ib2R5LCAnc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2JvZHktLWRyb3Bkb3duJyk7XG4gICAgdGhpcy5fY3JlYXRlRHJvcGRvd25IZWFkZXIoKTtcbiAgICB0aGlzLl9saXN0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuX2Ryb3Bkb3duSGVhZGVyLCB0aGlzLl9saXN0KTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX3RvZ2dsZURyb3Bkb3duQm91bmQpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fdG9nZ2xlRHJvcGRvd25Cb3VuZCk7XG4gICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5fbGlzdCwgJ2NvbGxhcHNlJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoISgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKHRoaXMuX2l0ZW1zW2ldLCAnc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2l0ZW0tLWRpc2FibGVkJykpIHtcbiAgICAgICAgdGhpcy5faXRlbXNbaV0uc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGV4dHJhIGV2ZW50IGFuZCBET00gd2hlbiBzd2l0Y2ggdmFyaWF0aW9uIGZyb20gZHJvcGRvd25cbiAgICovXG5cblxuICBTdGVwSW5kaWNhdG9yLnByb3RvdHlwZS5fc3dpdGNoRnJvbURyb3Bkb3duID0gZnVuY3Rpb24gX3N3aXRjaEZyb21Ecm9wZG93bigpIHtcbiAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KSh0aGlzLl9ib2R5LCAnc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2JvZHktLWRyb3Bkb3duJyk7XG4gICAgdmFyIGhlYWRlciA9IHRoaXMuX2xpc3QucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yKCcuc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2l0ZW0tLWRyb3Bkb3duX19oZWFkZXInKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX3RvZ2dsZURyb3Bkb3duQm91bmQpO1xuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIHRoaXMuX2xpc3QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoZWFkZXIpO1xuICAgIH1cbiAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KSh0aGlzLl9saXN0LCAnY29sbGFwc2UnKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkodGhpcy5faXRlbXNbaV0sICdzcGFyay1zdGVwLWluZGljYXRvcl9faXRlbS0tZGlzYWJsZWQnKSkge1xuICAgICAgICB0aGlzLl9pdGVtc1tpXS5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBbGxvdyBwcm9ncmFtbWF0aWMgdG9nZ2xpbmcgb2YgRHJvcGRvd24gdmVyc2lvbiBvZiBTdGVwIEluZGljYXRvci5cbiAgICogVGhpcyBiZWNvbWVzIGRlc2lyYWJsZSBwYXJ0aWN1bGFybHkgaW4gdGhlIGNhc2Ugb2Ygc2luZ2xlIHBhZ2UgYXBwbGljYXRpb25zXG4gICAqL1xuXG5cbiAgU3RlcEluZGljYXRvci5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLl9kcm9wZG93bkhlYWRlcikge1xuICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGUuaW5pdEV2ZW50KCdzcGFyay5zdGVwLWluZGljYXRvcicsIHRydWUsIHRydWUpO1xuICAgICAgdGhpcy5fZHJvcGRvd25IZWFkZXIuZGlzcGF0Y2hFdmVudChlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSBjb2xsYXBzZS9leHBhbmQgc3RhdGUgb2Ygc3RlcCBsaXN0IGluIGRyb3Bkb3duIHZhcmlhdGlvblxuICAgKiBJZiB0aGVyZSBpcyBhIHNjcm9sbCBpbiBkcm9wZG93biB2YXJpYXRpb24sIHNjcm9sbCB0byAnY3VycmVudCcgbm9kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gUmVmZXJlbmNlIG9mIERPTSBvYmpcbiAgICogQHBhcmFtIHtPYmplY3R9IEV2ZW50IG9mIGNsaWNrXG4gICAqL1xuXG5cbiAgU3RlcEluZGljYXRvci5wcm90b3R5cGUuX3RvZ2dsZURyb3Bkb3duID0gZnVuY3Rpb24gX3RvZ2dsZURyb3Bkb3duKGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgIGlmICh0aGlzLl9kcm9wZG93bkhlYWRlci5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICBpZiAoIXRoaXMuX2Ryb3Bkb3duRXhwYW5kKSB7XG4gICAgICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKHRoaXMuX2xpc3QsICdjb2xsYXBzZScpO1xuICAgICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLl9kcm9wZG93bkhlYWRlciwgJ2V4cGFuZCcpO1xuICAgICAgICB0aGlzLl9kcm9wZG93bkV4cGFuZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2Ryb3Bkb3duSGVhZGVyLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICghKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkodGhpcy5faXRlbXNbaV0sICdzcGFyay1zdGVwLWluZGljYXRvcl9faXRlbS0tZGlzYWJsZWQnKSkge1xuICAgICAgICAgICAgdGhpcy5faXRlbXNbaV0ucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5fbGlzdCwgJ2NvbGxhcHNlJyk7XG4gICAgICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKHRoaXMuX2Ryb3Bkb3duSGVhZGVyLCAnZXhwYW5kJyk7XG4gICAgICAgIHRoaXMuX2Ryb3Bkb3duRXhwYW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Ryb3Bkb3duSGVhZGVyLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLl9pdGVtcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBpZiAoISgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKHRoaXMuX2l0ZW1zW19pXSwgJ3NwYXJrLXN0ZXAtaW5kaWNhdG9yX19pdGVtLS1kaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtc1tfaV0uc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLl9saXN0LCAnY29sbGFwc2UnKTtcbiAgICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKHRoaXMuX2Ryb3Bkb3duSGVhZGVyLCAnZXhwYW5kJyk7XG4gICAgICB0aGlzLl9kcm9wZG93bkV4cGFuZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fZHJvcGRvd25IZWFkZXIuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgaWYgKCEoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KSh0aGlzLl9pdGVtc1tfaTJdLCAnc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2l0ZW0tLWRpc2FibGVkJykpIHtcbiAgICAgICAgICB0aGlzLl9pdGVtc1tfaTJdLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fbGlzdC5vZmZzZXRIZWlnaHQgPiAwKSB7XG4gICAgICB2YXIgc2Nyb2xsTW92ZSA9IDA7XG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCB0aGlzLl9pdGVtcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgIGlmICgoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KSh0aGlzLl9pdGVtc1tfaTNdLCAnc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2l0ZW0tLWN1cnJlbnQnKSkge1xuICAgICAgICAgIHRoaXMuX2xpc3Quc2Nyb2xsVG9wID0gc2Nyb2xsTW92ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzY3JvbGxNb3ZlICs9IHRoaXMuX2l0ZW1zW19pM10ub2Zmc2V0SGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgd2luZG93IGZpbmlzaCBsb2FkaW5nXG4gICAqL1xuXG5cbiAgU3RlcEluZGljYXRvci5wcm90b3R5cGUuX29uTG9hZCA9IGZ1bmN0aW9uIF9vbkxvYWQoKSB7XG4gICAgdGhpcy5fY2hlY2tQYWRkaW5nKCk7XG4gICAgdGhpcy5fY2FsY3VsYXRlU3R5bGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgd2luZG93IGlzIHJlc2l6ZWQsIGJhc2Ugb24gcGFyYW1zIG1ha2Ugc29tZSByZXBvbnNpdmUgY2hhbmdlLlxuICAgKi9cblxuXG4gIFN0ZXBJbmRpY2F0b3IucHJvdG90eXBlLl9vblJlc2l6ZSA9IGZ1bmN0aW9uIF9vblJlc2l6ZSgpIHtcbiAgICB0aGlzLl9jaGVja1BhZGRpbmcoKTtcbiAgICB0aGlzLl9jYWxjdWxhdGVTdHlsZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYWRkaW5nIGlzIGFwcGxpZWQgdG8gY29uZGVuc2VkIHN0ZXAgaW5kaWNhdG9ycyBidXQgbm90IGxhcmdlIHN0ZXAgaW5kaWNhdG9ycy5cbiAgICogVGhlcmVmb3JlIGFzIGxhcmdlIGluZGljYXRvcnMgdHJhbnNpdGlvbiB0byBjb25kZW5zZWQgb25lcyBhbmQgdmljZSB2ZXJzYSwgdmVyaWZ5XG4gICAqIHRoZSBwYWRkaW5nIHZhbHVlcyBpbiBvcmRlciB0byBwcm9wZXJseSBjYWxjdWxhdGUgcG9zaXRpb25pbmcgb2YgZGl2aWRlciBsaW5lIGNsYXNzZXNcbiAgICovXG5cblxuICBTdGVwSW5kaWNhdG9yLnByb3RvdHlwZS5fY2hlY2tQYWRkaW5nID0gZnVuY3Rpb24gX2NoZWNrUGFkZGluZygpIHtcbiAgICAvLyBDYWNoZSBsaXN0IGxlZnQgKyByaWdodCBwYWRkaW5nIGZvciB3aWR0aCBjYWxjdWxhdGluZ1xuICAgIHZhciBsaXN0U3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9saXN0KTtcbiAgICB2YXIgbGlzdFBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQobGlzdFN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdwYWRkaW5nLWxlZnQnKSwgMTApO1xuICAgIHZhciBsaXN0UGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQobGlzdFN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdwYWRkaW5nLXJpZ2h0JyksIDEwKTtcbiAgICB0aGlzLl9saXN0UGFkZGluZ1RvdGFsID0gbGlzdFBhZGRpbmdMZWZ0ICsgbGlzdFBhZGRpbmdSaWdodDtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiBhIHBhcmVudCBjb250YWluZXIgc2hvd3MgaXRzIGNoaWxkcmVuIGFuZCBvdXIgZWxlbWVudFxuICAgKiBpcyBpbnNpZGUgb2YgaXQsIHJlc2l6ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGVcbiAgICovXG5cblxuICBTdGVwSW5kaWNhdG9yLnByb3RvdHlwZS5fb25WaXNpYmxlID0gZnVuY3Rpb24gX29uVmlzaWJsZShlKSB7XG4gICAgaWYgKGUudGFyZ2V0LmNvbnRhaW5zKHRoaXMuZWwpKSB7XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVN0eWxlKCk7XG4gICAgICB9LmJpbmQodGhpcyksIDApO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU3RlcEluZGljYXRvcjtcbn0oX2Jhc2UyLmRlZmF1bHQpO1xuXG4vKipcbiAqIFdoaXRlbGlzdGVkIHBhcmFtZXRlcnMgd2hpY2ggY2FuIGJlIHNldCBvbiBjb25zdHJ1Y3Rpb24uXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cblxuXG5TdGVwSW5kaWNhdG9yLnByb3RvdHlwZS5fd2hpdGVsaXN0ZWRQYXJhbXMgPSBbJ3R5cGUnLCAnaGVhZGVyJywgJ3N1YnRpdGxlJywgJ2Ryb3Bkb3duTGFiZWwnXTtcblxuLyoqXG4gKiBEZWZhdWx0IHZhbHVlcyBmb3IgaW50ZXJuYWwgcHJvcGVydGllcyB3ZSB3aWxsIGJlIHNldHRpbmcuXG4gKiBUaGVzZSBhcmUgc2V0IG9uIGVhY2ggY29uc3RydWN0aW9uIHNvIHdlIGRvbid0IGxlYWsgcHJvcGVydGllc1xuICogaW50byB0aGUgcHJvdG90eXBlIGNoYWluLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuU3RlcEluZGljYXRvci5wcm90b3R5cGUuZGVmYXVsdHMgPSB7XG4gIGVsOiBudWxsLFxuICBjb250YWluZXJFbDogbnVsbCxcbiAgaGVhZGVyOiBudWxsLFxuICBzdWJ0aXRsZTogbnVsbCxcbiAgZHJvcGRvd25MYWJlbDogbnVsbCxcbiAgdHlwZTogbnVsbCxcbiAgX2JvZHk6IG51bGwsXG4gIF9saXN0OiBudWxsLFxuICBfbGlzdFBhZGRpbmdUb3RhbDogMCxcbiAgX2Ryb3Bkb3duRXhwYW5kOiBmYWxzZSxcbiAgX2Ryb3Bkb3duSGVhZGVyOiBudWxsLFxuICBfaXRlbXM6IG51bGwsXG4gIF9vblJlc2l6ZUJvdW5kOiBudWxsLFxuICBfb25WaXNpYmxlQm91bmQ6IG51bGxcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFN0ZXBJbmRpY2F0b3I7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0ZXAtaW5kaWNhdG9yLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3RyaW0gPSByZXF1aXJlKCcuLi91dGlsL3RyaW0nKTtcblxudmFyIF90cmltMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RyaW0pO1xuXG52YXIgX2hhc0NsYXNzID0gcmVxdWlyZSgnLi9oYXMtY2xhc3MnKTtcblxudmFyIF9oYXNDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYXNDbGFzcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogIyBBZGQgQ2xhc3NcbiAqIEFkZCBhIGNsYXNzIG9uIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fEFycmF5fSBlbCBBbiBlbGVtZW50IG9yIGFycmF5IG9mIGVsZW1lbnRzIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICpcbiAqIEBtb2R1bGUgaGVscGVycy9kb20vYWRkLWNsYXNzLmpzXG4gKi9cblxudmFyIHdzID0gL1xccysvO1xudmFyIGNsZWFudXAgPSAvXFxzezIsfS9nO1xuXG5mdW5jdGlvbiBhZGRDbGFzcyhlbCwgbmFtZSkge1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgIG5hbWUgPSAoMCwgX3RyaW0yLmRlZmF1bHQpKG5hbWUpLnNwbGl0KHdzKTtcbiAgfSBlbHNlIHtcbiAgICBuYW1lID0gbmFtZSBpbnN0YW5jZW9mIEFycmF5ID8gbmFtZSA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIH1cblxuICAvLyBvcHRpbWl6ZSBmb3IgYmVzdCwgbW9zdCBjb21tb24gY2FzZVxuICBpZiAobmFtZS5sZW5ndGggPT09IDEgJiYgZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKG5hbWVbMF0pIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQobmFtZVswXSk7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIHZhciB0b0FkZCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0gbmFtZS5sZW5ndGg7XG4gIHZhciBpdGVtID0gdm9pZCAwO1xuICB2YXIgY2xzTmFtZSA9IHR5cGVvZiBlbC5jbGFzc05hbWUgPT09ICdzdHJpbmcnID8gZWwuY2xhc3NOYW1lIDogZWwuZ2V0QXR0cmlidXRlID8gZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIDogJyc7XG5cbiAgLy8gc2VlIGlmIHdlIGhhdmUgYW55dGhpbmcgdG8gYWRkXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgaXRlbSA9IG5hbWVbaV07XG4gICAgaWYgKGl0ZW0gJiYgISgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKGNsc05hbWUsIGl0ZW0pKSB7XG4gICAgICB0b0FkZC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0b0FkZC5sZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIGVsLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVsLmNsYXNzTmFtZSA9ICgwLCBfdHJpbTIuZGVmYXVsdCkoKGNsc05hbWUgKyAnICcgKyB0b0FkZC5qb2luKCcgJykpLnJlcGxhY2UoY2xlYW51cCwgJyAnKSk7XG4gICAgfSBlbHNlIGlmIChlbC5zZXRBdHRyaWJ1dGUpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoMCwgX3RyaW0yLmRlZmF1bHQpKChjbHNOYW1lICsgJyAnICsgdG9BZGQuam9pbignICcpKS5yZXBsYWNlKGNsZWFudXAsICcgJykpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWw7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGFkZENsYXNzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGQtY2xhc3MuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuLyoqXG4gKiAjIEhhcyBDbGFzc1xuICogU2VlIGlmIGFuIGVsZW1lbnQgaGFzIGEgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICpcbiAqIEBtb2R1bGUgaGVscGVycy9kb20vaGFzLWNsYXNzLmpzXG4gKi9cbmZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBuYW1lKSB7XG4gIHZhciBjTmFtZSA9ICgodHlwZW9mIGVsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihlbCkpID09PSAnb2JqZWN0JyA/IGVsLmNsYXNzTmFtZSB8fCBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnIDogZWwgfHwgJycpLnJlcGxhY2UoL1tcXHRcXHJcXG5cXGZdL2csICcgJyk7XG4gIHJldHVybiAoJyAnICsgY05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgbmFtZSArICcgJykgIT09IC0xO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBoYXNDbGFzcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzLWNsYXNzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3RyaW0gPSByZXF1aXJlKCcuLi91dGlsL3RyaW0nKTtcblxudmFyIF90cmltMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RyaW0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgd3MgPSAvXFxzKy87IC8qKlxuICAgICAgICAgICAgICAgICAqICMgUmVtb3ZlIENsYXNzXG4gICAgICAgICAgICAgICAgICogUmVtb3ZlIGEgY2xhc3Mgb24gYW4gZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxBcnJheX0gZWwgQW4gZWxlbWVudCBvciBhcnJheSBvZiBlbGVtZW50cyB0byB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQG1vZHVsZSBoZWxwZXJzL2RvbS9yZW1vdmUtY2xhc3MuanNcbiAgICAgICAgICAgICAgICAgKi9cblxudmFyIGNsZWFudXAgPSAvXFxzezIsfS9nO1xuXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgbmFtZSkge1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgIG5hbWUgPSAoMCwgX3RyaW0yLmRlZmF1bHQpKG5hbWUpLnNwbGl0KHdzKTtcbiAgfSBlbHNlIHtcbiAgICBuYW1lID0gbmFtZSBpbnN0YW5jZW9mIEFycmF5ID8gbmFtZSA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIH1cblxuICAvLyBvcHRpbWl6ZSBmb3IgYmVzdCwgbW9zdCBjb21tb24gY2FzZVxuICBpZiAobmFtZS5sZW5ndGggPT09IDEgJiYgZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKG5hbWVbMF0pIGVsLmNsYXNzTGlzdC5yZW1vdmUobmFtZVswXSk7XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgLy8gc3RvcmUgdHdvIGNvcGllc1xuICB2YXIgY2xzTmFtZSA9ICcgJyArICh0eXBlb2YgZWwuY2xhc3NOYW1lID09PSAnc3RyaW5nJyA/IGVsLmNsYXNzTmFtZSA6IGVsLmdldEF0dHJpYnV0ZSA/IGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSA6ICcnKSArICcgJztcbiAgdmFyIHJlc3VsdCA9IGNsc05hbWU7XG4gIHZhciBjdXJyZW50ID0gdm9pZCAwO1xuICB2YXIgc3RhcnQgPSB2b2lkIDA7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gbmFtZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjdXJyZW50ID0gbmFtZVtpXTtcbiAgICBzdGFydCA9IGN1cnJlbnQgPyByZXN1bHQuaW5kZXhPZignICcgKyBjdXJyZW50ICsgJyAnKSA6IC0xO1xuICAgIGlmIChzdGFydCAhPT0gLTEpIHtcbiAgICAgIHN0YXJ0ICs9IDE7XG4gICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgc3RhcnQpICsgcmVzdWx0LnNsaWNlKHN0YXJ0ICsgY3VycmVudC5sZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIG9ubHkgd3JpdGUgaWYgbW9kaWZpZWRcbiAgaWYgKGNsc05hbWUgIT09IHJlc3VsdCkge1xuICAgIGlmICh0eXBlb2YgZWwuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZWwuY2xhc3NOYW1lID0gKDAsIF90cmltMi5kZWZhdWx0KShyZXN1bHQucmVwbGFjZShjbGVhbnVwLCAnICcpKTtcbiAgICB9IGVsc2UgaWYgKGVsLnNldEF0dHJpYnV0ZSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsICgwLCBfdHJpbTIuZGVmYXVsdCkocmVzdWx0LnJlcGxhY2UoY2xlYW51cCwgJyAnKSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbDtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gcmVtb3ZlQ2xhc3M7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92ZS1jbGFzcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tYXRjaGVzID0gcmVxdWlyZSgnLi9tYXRjaGVzJyk7XG5cbnZhciBfbWF0Y2hlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRjaGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0UGFyZW50KHBhcmVudCwgcXVlcnksIGxpbWl0RWwpIHtcblxuICBsaW1pdEVsID0gbGltaXRFbCBpbnN0YW5jZW9mIEFycmF5ID8gbGltaXRFbCA6IFtsaW1pdEVsIHx8IGRvY3VtZW50LmJvZHldO1xuXG4gIHdoaWxlIChwYXJlbnQpIHtcblxuICAgIGlmICgoMCwgX21hdGNoZXMyLmRlZmF1bHQpKHBhcmVudCwgcXVlcnkpKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIGlmIChsaW1pdEVsLmluZGV4T2YocGFyZW50KSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLyoqXG4gICAqICMgR2V0IFBhcmVudFxuICAgKiBTZWUgaWYgYW4gZWxlbWVudCBoYXMgYW5vdGhlciBlbGVtZW50IGZvciBhIHBhcmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5XG4gICAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gbGltaXRFbCBUaGUgbGFzdCBlbGVtZW50IHdlIHNob3VsZCBjaGVjay5cbiAgICogQHJldHVybiB7Qm9vbGVhbnxFbGVtZW50fVxuICAgKlxuICAgKiBAbW9kdWxlIGhlbHBlcnMvdHJhdmVyc2FsL2dldC1wYXJlbnQuanNcbiAgICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGdldFBhcmVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXBhcmVudC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBNYXRjaGVzXG4gKiBTZWUgaWYgYW4gZWxlbWVudCBtYXRjaGVzIGEgcXVlcnkgc2VsZWN0b3IuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICpcbiAqIEBtb2R1bGUgaGVscGVycy90cmF2ZXJzYWwvbWF0Y2hlcy5qc1xuICovXG52YXIgdmVuZG9yTWF0Y2ggPSB0eXBlb2YgRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgKEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUub01hdGNoZXNTZWxlY3Rvcik7XG5cbmZ1bmN0aW9uIG1hdGNoZXMoZWwsIHF1ZXJ5KSB7XG5cbiAgaWYgKHZlbmRvck1hdGNoKSByZXR1cm4gdmVuZG9yTWF0Y2guY2FsbChlbCwgcXVlcnkpO1xuXG4gIHZhciBub2RlcyA9IGVsLnBhcmVudE5vZGUgPyBlbC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpIDogW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2Rlc1tpXSA9PT0gZWwpIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBtYXRjaGVzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRjaGVzLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgRGVib3VuY2VcbiAqIERlYm91bmNlIGEgZnVuY3Rpb24gY2FsbFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAqIEBwYXJhbSB7SW50ZWdlcn0gZGVsYXlcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdXRpbC9kZWJvdW5jZS5qc1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCBkZWxheSkge1xuXG4gIHZhciB0aW1lciA9IHZvaWQgMDtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIGlmICh0aW1lcikgd2luZG93LmNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgdGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0sIGRlbGF5KTtcbiAgfTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZGVib3VuY2U7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVib3VuY2UuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgRWFjaFxuICogQXBwbHkgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBhIGxpc3Qgb2YgYW55IGtpbmQ6IEFycmF5LCBOb2RlTGlzdCwgSFRNTENvbGxlY3Rpb24gb3IgT2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8Tm9kZUxpc3R8SFRNTENvbGxlY3Rpb258T2JqZWN0fSBsaXN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICpcbiAqIEBleGFtcGxlXG4gKiBlYWNoKFtdLCBjYWxsYmFjayk7XG4gKiBlYWNoKGVsLmNoaWxkcmVuLCBjYWxsYmFjayk7XG4gKiBlYWNoKGVsLmNoaWxkTm9kZXMsIGNhbGxiYWNrKTtcbiAqIGVhY2goe30sIGNhbGxiYWNrKTtcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdXRpbC9lYWNoLmpzXG4gKi9cbmZ1bmN0aW9uIGVhY2gobGlzdCwgY2IpIHtcblxuICBpZiAoIWxpc3QpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52b2tlIGBlYWNoYCB3aXRob3V0IGEgY2FsbGJhY2shJyk7XG4gIH1cblxuICB2YXIgaSA9IDA7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcblxuICAvLyBPYmplY3RcbiAgaWYgKGxlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChpIGluIGxpc3QpIHtcbiAgICAgIGlmIChpICE9PSAncHJvdG90eXBlJyAmJiBsaXN0Lmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGNiKGksIGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBBcnJheS1saWtlXG4gIGVsc2Uge1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjYihsaXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGVhY2g7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVhY2guanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgVHJpbVxuICogVHJpbSB3aGl0ZXNwYWNlIG9uIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdXRpbC90cmltLmpzXG4gKi9cblxudmFyIHRyaW1SRSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHRyaW1SRSwgJycpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0cmltO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmltLmpzLm1hcFxuIl19"}